<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Sklearn 导入随机逻辑回归函数 RLR 失败原因及解决</title>
      <link href="/posts/5fd458f7.html"/>
      <url>/posts/5fd458f7.html</url>
      
        <content type="html"><![CDATA[<h1>一、问题描述</h1><ol><li><p>描述：在进行分类任务时，导入随机逻辑回归模型 RandomizedLogisticRegression 时会提示无法找到该模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> RandomizedLogisticRegression <span class="keyword">as</span> RLR</span><br></pre></td></tr></table></figure></li><li><p>分析：自 sklearn 0.19.2 版本后，随机逻辑回归模型已经被移除</p></li><li><p>当前软件版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn</span><br><span class="line">sklearn.show_versions()</span><br></pre></td></tr></table></figure><blockquote><p>System:<br>python: 3.9.16</p><p>Python dependencies:</p><p>​sklearn: 1.3.2</p><p>​numpy: 1.26.2</p><p>​scipy: 1.10.1</p><p>​pandas: 2.1.3</p><p>​matplotlib: 3.7.1</p><p>​joblib: 1.3.2</p></blockquote></li></ol><h1>二、解决办法</h1><h2 id="（一）手动安装随机逻辑回归模型">（一）手动安装随机逻辑回归模型</h2><ol><li><p>模型仓库：<a href="https://github.com/scikit-learn-contrib/stability-selection">https://github.com/scikit-learn-contrib/stability-selection</a></p></li><li><p>安装参考：<a href="https://github.com/scikit-learn-contrib/stability-selection/issues/38">https://github.com/scikit-learn-contrib/stability-selection/issues/38</a></p><blockquote><p>注：</p><p>​安装随机逻辑回归模型后，能够解决模型导入时的报错问题，并能够正确拟合训练模型。</p><p>​但是在后续查看特征筛选结果和 Score 分数时，会无法调用 rlr.get_support() 和 rlr.scores_ 方法，可能是因为高版本在移除随机逻辑回归模型时，也对 sklearn_base 中的方法做了修改，无法再按旧版本方法调用。</p></blockquote></li></ol><h2 id="（二）采用低版本-Scikit-Learn">（二）采用低版本 Scikit-Learn</h2><ol><li><p>低版本 Scikit-Learn 所需的环境</p><blockquote><p>Python 3.8 及以下（建议 Python 3.6）</p><p>Numpy 1.23.5 及以下（建议 Numpy 1.20.0）</p><p>Scikit-Learn 0.19.2</p><p>注：</p><ol><li>所建议版本是较为久远的版本，可能会出现无法找到对应源、无法安装的情况，需根据自己的电脑情况调整；</li><li>M 系列 Mac 由于架构不同，不支持 3.8 版本以下的 Python，请使用 Python 3.8；</li><li>Scikit-Learn 最好使用 0.19.2 版本。</li></ol></blockquote></li><li><p>安装过程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">conda 创建虚拟环境 Python 3.8</span></span><br><span class="line">conda create -n py38 python=3.8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">激活 py38 环境</span></span><br><span class="line">conda activate py38</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装相关库</span></span><br><span class="line">pip install numpy==1.23.5</span><br><span class="line">pip install scipy</span><br><span class="line">pip install pandas</span><br><span class="line">pip install xlrd</span><br><span class="line">pip install scikit-learn==0.19.2</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><ol><li>以上过程均在终端 shell 中安装；</li><li>或者选用 Anaconda 图形化界面安装。</li></ol></blockquote></li><li><p>安装完毕后，在 Pycharm 右下角添加并使用新的 Python 解释器即可。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
          <category> Sklearn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> Sklearn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CIFAR100 多模型训练结果及分析</title>
      <link href="/posts/2fb8888f.html"/>
      <url>/posts/2fb8888f.html</url>
      
        <content type="html"><![CDATA[<h1>一、自建网络</h1><h2 id="两层-CNN-网络">两层 CNN 网络</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: Adam</li></ul></blockquote></li><li><p>思路</p><blockquote><p>CNN：Conv2d -&gt; BatchNorm2d -&gt; ReLu -&gt; MaxPool2d</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-2CNN.png" alt="Arch_2CNN"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-2CNN.png" alt="Loss_2CNN"></p><blockquote><ul><li>Time: 0:01:11.308311</li><li>Min Loss: 1.4500</li><li>Final Loss: 1.9618</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：39.75 %</li></ul></blockquote></li></ol><h2 id="三层-CNN-网络">三层 CNN 网络</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: Adam</li></ul></blockquote></li><li><p>思路</p><blockquote><p>CNN：Conv2d -&gt; BatchNorm2d -&gt; ReLu -&gt; MaxPool2d</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-3CNN.png" alt="Arch_3CNN"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-3CNN.png" alt="Loss_3CNN"></p><blockquote><ul><li>Time: 0:01:10.645922</li><li>Min Loss: 1.5404</li><li>Final Loss: 1.9817</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：44.14 %</li></ul></blockquote></li></ol><h2 id="五层-CNN-网络">五层 CNN 网络</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: Adam</li></ul></blockquote></li><li><p>思路</p><blockquote><p>CNN：Conv2d -&gt; BatchNorm2d -&gt; ReLu -&gt; MaxPool2d</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-5CNN.png" alt="Arch_5CNN"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-5CNN.png" alt="Loss_5CNN"></p><blockquote><ul><li>Time: 0:02:12.387121</li><li>Min Loss: 1.3080</li><li>Final Loss: 1.5872</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：44.20 %</li></ul></blockquote></li></ol><h1>二、经典 CNN 网络</h1><h2 id="VGG-19">VGG 19</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: SGD</li></ul></blockquote></li><li><p>思路</p><blockquote><p>VGG 19 -&gt; Transforms ( Resize + ToTensor + Normalize) -&gt; Model Arch ( fc out 100 ) -&gt; Fine Tune</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-VGG.png" alt="Arch_VGG"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-VGG.png" alt="Loss_VGG"></p><blockquote><ul><li>Time: 0:24:17.983430</li><li>Min Loss: 0.3057</li><li>Final Loss: 0.7126</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：71.61 %</li></ul></blockquote></li></ol><h2 id="ResNet-101">ResNet 101</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: SGD</li></ul></blockquote></li><li><p>思路</p><blockquote><p>ResNet 101 -&gt; Transforms ( Resize + ToTensor + Normalize) -&gt; Model Arch ( fc out 100 ) -&gt; Fine Tune</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-ResNet.png" alt="Arch_ResNet"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-ResNet.png" alt="Loss_ResNet"></p><blockquote><ul><li>Time: 0:26:58.626524</li><li>Min Loss: 0.0667</li><li>Final Loss: 0.0942</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：83.92 %</li></ul></blockquote></li></ol><h1>三、 Vision Transformer 网络</h1><h2 id="ViT-b-32">ViT_b_32</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: SGD</li></ul></blockquote></li><li><p>思路</p><blockquote><p>ViT_b_32 -&gt; Transforms ( Resize + ToTensor + Normalize) -&gt; Model Arch ( fc out 100 ) -&gt; Fine Tune</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-ViT.png" alt="Arch_ViT"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-ViT.png" alt="Loss_ViT"></p><blockquote><ul><li>Time: 0:11:34.681656</li><li>Min Loss: 0.1308</li><li>Final Loss: 0.1308</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：84.34 %</li></ul></blockquote></li></ol><h2 id="Swin-b">Swin_b</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: SGD</li></ul></blockquote></li><li><p>思路</p><blockquote><p>Swim_b -&gt; Transforms ( Resize + ToTensor + Normalize) -&gt; Model Arch ( fc out 100 ) -&gt; Fine Tune</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-Swin.png" alt="Arch_Swin"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-Swin.png" alt="Loss_Swin"></p><blockquote><ul><li>Time: 0:40:31.978593</li><li>Min Loss: 0.2692</li><li>Final Loss: 0.5661</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：83.53 %</li></ul></blockquote></li></ol><h1>四、对比分析</h1><table><thead><tr><th>Model</th><th>Total Params</th><th>Total Size</th><th>Min loss</th><th>Final Loss</th><th>Accuracy</th></tr></thead><tbody><tr><td>CNN_2</td><td>219,044</td><td>40.63</td><td>1.4500</td><td>1.9618</td><td>39.75 %</td></tr><tr><td>CNN_3</td><td>168,036</td><td>46.94</td><td>1.5404</td><td>1.9817</td><td>44.14 %</td></tr><tr><td>CNN_5</td><td>1,116,388</td><td>55.43</td><td>1.3080</td><td>1.5872</td><td>44.20 %</td></tr><tr><td>VGG19</td><td>139,979,940</td><td>773.24</td><td>0.3057</td><td>0.7126</td><td>71.61 %</td></tr><tr><td>ResNet101</td><td>42,705,060</td><td>593.20</td><td>0.0667</td><td>0.0942</td><td>83.92 %</td></tr><tr><td>ViT_b_32</td><td>87,532,132</td><td>263.59</td><td>0.1308</td><td>0.1308</td><td>84.34 %</td></tr><tr><td>Swin_b</td><td>86,845,724</td><td>425.33</td><td>0.2692</td><td>0.5661</td><td>83.53 %</td></tr></tbody></table><ol><li>对比自建 CNN 网络<ul><li>从 2 层 CNN 到 3 层 CNN 模型的总参数量有所下降，主要原因是 FC 层 Linear 函数的输入参数减少，导致了总参数量的下降。</li><li>从 2 层 CNN 到 3 层 CNN 模型准确率提升了约 4.39%；从 3 层 CNN 到 5 层 CNN 模型准确率几乎没有提升。虽然从 3 层到 5 层模型的总参数量扩大了约 6.64 倍，但是模型的性能没有显著提升，推测是因为此时模型深度的增加已经无法帮助模型学到更多有用的特征，且深度的增加也可能会导致模型出现过拟合现象，致使准确率无法得到进一步提升。</li></ul></li><li>对比经典 CNN 网络<ul><li>VGG19 模型拥有近 1.4 亿的参数量，其规模也是本次测试中最大的模型。 VGG19 的测试结果（71.61%），也证明了使用更小的卷积核（3 * 3）并且增加卷积神经网络的深度，可以有效地提升模型的性能。</li><li>ResNet101 通过引入残差块在网络内部跳跃连接，缓解了深度增加所导致的梯度消失的问题。从模型结果来看（83.92%），在增加模型深度，缓解梯度消失问题的同时也减少了参数量，相比于 VGG19 模型取得了更好的效果。</li></ul></li><li>对比 Transformer 网络<ul><li>本次所选用的 Transformer 网络都是该系列下的基础模型。ViT_b_32 模型 和 Swin_b 模型参数量相当，最后测试结果也较为接近，都具有较好的性能。</li><li>值得一提的是，在实际训练和测试时，Swin_b 模型对显存的占用非常高，训练时大约需要 15G 左右的显存空间，而测试时大概需要 30G 左右的显存空间，对硬件设备的要求很高。</li></ul></li></ol><h1>五、总结与优化</h1><h2 id="总结">总结</h2><ul><li>从自建 CNN 网络到 VGG 模型，可以看出增加网络的宽度和深度可以很好的提高模型的性能；但如果一直简单地增加深度，可能会遇到梯度爆炸或梯度消失的问题，对于前者可以尝试使用正则化的方式解决，但对于梯度消失的问题，就需要引入残差网络，在不增加额外参数的情况下，尽可能让深层次的模型得到充分训练，进而继续提升模型的性能，上述过程也在本次实验中得到了充分的验证。</li><li>转向 Transformer 架构，在 ViT 模型的思路下，用自注意力机制来捕捉全局图像信息，从而得到全连接的网络结构，能够很好的捕捉数据的特征；Swin 模型进一步采用分层的窗口化注意力机制和分层的网络结构，在降低计算复杂度的同时，也通过层级嵌套捕捉了多尺度的特征，使得模型在处理不同尺度的信息时更加灵活。</li><li>但是在本次实验中，ResNet 和 ViT 以及 Swin 的模型性能（测试集准确率）相近，没能很好的展现出 Transformer 架构在 CV 领域的巨大潜力。推测其中的原因，一是 ResNet 残差网络的性能确实很好，能够非常显著的降低梯度消失风险、提升 CNN 网络的性能；二是本次实验所选用的 CIFAR100 数据集相对原本的 ImageNet 而言更简单，用 ResNet 模型就足以捕捉其中的关键特征，能够较好的完成分类任务，ViT 和 Swin 的潜力没能得到充分发挥；三是模型的选用及训练策略的不足，本次实验选用的 ResNet 模型为 101 层，而 ViT 和 Swin 都只选用了 Base 模型，同时训练的 Epoch 较少，损失函数和优化器的选用没有做进一步的比对分析，学习率也没有做进一步的尝试。</li></ul><h2 id="优化">优化</h2><ul><li>宏观层面，下一步将继续尝试不同的模型，结合模型结构和实验结果分析每种模型的特点、改进点。</li><li>微观层面，下一步将尝试调整训练策略，增加 Epoch 的同时引入验证集，根据验证集准确率等指标提前停止训练防止模型过拟合现象的产生，同时将尝试不同的损失函数和优化器，以及综合使用 Warm up、余弦退火等技巧逐步改善学习率，进一步提升模型的性能。</li></ul>]]></content>
      
      
      <categories>
          
          <category> CV </category>
          
          <category> CNN </category>
          
          <category> ViT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DL </tag>
            
            <tag> CV </tag>
            
            <tag> CNN </tag>
            
            <tag> ViT </tag>
            
            <tag> Transformer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日LeetCode_230903</title>
      <link href="/posts/4d3cdec0.html"/>
      <url>/posts/4d3cdec0.html</url>
      
        <content type="html"><![CDATA[<h2 id="4-寻找两个正序数组的中位数">4.寻找两个正序数组的中位数</h2><h3 id="（1）题目">（1）题目</h3><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li></ul><h3 id="（2）题解">（2）题解</h3><blockquote><p>给定两个有序数组，要求找到两个有序数组的中位数，最直观的思路有以下两种：</p><ol><li>使用归并的方式，合并两个有序数组，得到一个大的有序数组。大的有序数组的中间位置的元素，即为中位数。第一种思路的时间复杂度是 O(m+n) ，空间复杂度是 O(m+n) ；</li><li>不需要合并两个有序数组，只要找到中位数的位置即可。由于两个数组的长度已知，因此中位数对应的两个数组的下标之和也是已知的。维护两个指针，初始时分别指向两个数组的下标 0 的位置，每次将指向较小值的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到到达中位数的位置。空间复杂度降到 O(1) ，时间复杂度仍是 O(m+n) ；</li></ol></blockquote><ul><li><p>不合并数组，依次取数，直至中位数位置</p><p>中位数的位置一定在 (m+n)/2 附近：</p><ul><li>如果是偶数，中位数就是最后取的两个数的平均数；</li><li>如果是奇数，中位数就是最后取的那个数。</li></ul><p>取数阶段，循环 (m + n) / 2.0 + 1 次即可；判断中位数时，关键是奇数情况，可能有指针溢出，需要判断一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 nums1 和 nums2 中每次取一个数，直到取出的数的个数 &lt;= (m+n)/2 + 1</span></span><br><span class="line"><span class="type">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>; <span class="comment">// x, y 分别是 nums1 和 nums2 的下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (m + n) / <span class="number">2.0</span> + <span class="number">1</span>; ++i)&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; m &amp;&amp; y &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1[x] &lt; nums2[y]) ++x;</span><br><span class="line">    <span class="keyword">else</span> ++y;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (x &lt; m) ++x;</span><br><span class="line">  <span class="keyword">else</span> ++y;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> (nums1[x - <span class="number">1</span>] + nums2[y - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt;= m)&#123;</span><br><span class="line">    <span class="keyword">return</span> nums1[x - <span class="number">1</span>];</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (y &gt;= n)&#123;</span><br><span class="line">    <span class="keyword">return</span> nums2[y - <span class="number">1</span>];</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(nums1[x - <span class="number">1</span>], nums2[y - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法测试用例可行，但 LeetCode 无法通过，可能是指针溢出形成空指针不被允许。</p></li><li><p>改进</p><p>我们首先计算出两个数组的长度，然后将它们的长度相加，得到总长度。接下来，我们使用一个循环来遍历这两个数组，直到到达中位数的位置。在循环中，我们维护两个指针 <code>aStart</code> 和 <code>bStart</code>，它们分别指向两个数组的下标 0 的位置。我们还维护两个变量 <code>left</code> 和 <code>right</code>，它们分别表示当前的中位数和前一个元素。在每次循环中，我们将 <code>left</code> 的值更新为 <code>right</code>，然后将指向较小值的指针后移一位。最后，如果总长度是偶数，则中位数是 <code>left</code> 和 <code>right</code> 的平均值，否则中位数是 <code>right</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> len = m + n;</span><br><span class="line"><span class="type">int</span> left = <span class="number">-1</span>, right = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> aStart = <span class="number">0</span>, bStart = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len / <span class="number">2</span>; i++)&#123;</span><br><span class="line">left = right;</span><br><span class="line">  <span class="keyword">if</span> (aStart &lt; m &amp;&amp; (bStart &gt;= n || nums1[aStart] &lt; nums2[bStart]))&#123;</span><br><span class="line">    right = nums1[aStart++];</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    right = nums2[bStart++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> (left + right) / <span class="number">2.0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二分查找</p><p>如果对时间复杂度的要求有 log⁡ ，通常都需要用到二分查找：</p><p>根据中位数的定义，当 m+n 是奇数时，中位数是两个有序数组中的第 (m+n)/2 个元素，当 m+n 是偶数时，中位数是两个有序数组中的第 (m+n)/2 个元素和第 (m+n)/2+1 个元素的平均值。因此，这道题可以转化成寻找两个有序数组中的第 k 小的数，其中 k 为 (m+n)/2 或 (m+n)/2+1 。</p><p>假设两个有序数组分别是 A 和 B。要找到第 k 个元素，我们可以比较 A[k/2−1] 和 B[k/2−1] ，其中 / 表示整数除法。由于 A 和 B 的前面分别有  k/2−1 个元素，对于 A[k/2−1] 和 B[k/2−1] 中的较小值，最多只会有 (k/2−1)+(k/2−1)≤k−2 个元素比它小，那么它就不能是第 k 小的数了。</p><p>因此我们可以归纳出三种情况：</p><ol><li>如果 A[k/2−1]&lt;B[k/2−1] ，则比 A[k/2−1] 小的数最多只有 A 的前 k/2−1 个数和 B 的前 k/2−1 个数，即比 A[k/2−1] 小的数最多只有 k−2 个，因此 A[k/2−1] 不可能是第 k 个数，A[0] 到 A[k/2−1] 也都不可能是第 k 个数，可以全部排除。</li><li>如果 A[k/2−1]&gt;B[k/2−1] ，则可以排除 B[0] 到 B[k/2−1] 。</li><li>如果 A[k/2−1]=B[k/2−1] ，则可以归入第一种情况处理。</li></ol><p><img src="https://assets.leetcode-cn.com/solution-static/4/4_fig1.png" alt=""></p><p>可以看到，比较 A[k/2−1] 和 B[k/2−1] 之后，可以排除 k/2 个不可能是第 k 小的数，查找范围缩小了一半。同时，我们将在排除后的新数组上继续进行二分查找，并且根据我们排除数的个数，减少 k 的值，这是因为我们排除的数都不大于第 k 小的数。</p><p>有以下三种情况需要特殊处理：</p><ol><li>如果 A[k/2−1] 或者 B[k/2−1] 越界，那么我们可以选取对应数组中的最后一个元素。在这种情况下，我们必须根据排除数的个数减少 k 的值，而不能直接将 k 减去 k/2。</li><li>如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第 k 小的元素。</li><li>如果 k=1 ，我们只要返回两个数组首元素的最小值即可。</li></ol><p>用一个例子说明上述算法。假设两个有序数组如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: 1 3 4 9</span><br><span class="line">B: 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>两个有序数组的长度分别是 4 和 9，长度之和是 13，中位数是两个有序数组中的第 7 个元素，因此需要找到第 k=7 个元素。</p><p>比较两个有序数组中下标为 k/2−1=2 的数，即 A[2]=4 和 B[2]=3 ，如下面所示：<br>由于 A[2]&gt;B[2] ，因此排除 B[0] 到 B[2] ，即数组 B 的下标偏移（offset）变为 3，同时更新 k 的值：k=k−k/2=4。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: 1 3 4 9</span><br><span class="line">B: [1 2 3] 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>下一步寻找，比较两个有序数组中下标为 k/2−1=1 的数，即 A[1]=3 和 B[4]=5 ，如下面所示，其中方括号部分表示已经被排除的数。<br>由于 A[1]&lt;B[4]，因此排除 A[0] 到 A[1]，即数组 A 的下标偏移变为 2，同时更新 k 的值：k=k−k/2=2。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: [1 3] 4 9</span><br><span class="line">B: [1 2 3] 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>下一步寻找，比较两个有序数组中下标为 k/2−1=0 的数，即比较 A[2]=4 和 B[3]=4 ，如下面所示，其中方括号部分表示已经被排除的数。<br>由于 A[2]=B[3]，根据之前的规则，排除 A 中的元素，因此排除 A[2] ，即数组 A 的下标偏移变为 3 ，同时更新 k 的值： k=k−k/2=1 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: [1 3 4] 9</span><br><span class="line">B: [1 2 3] 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>由于 k 的值变成 1，因此比较两个有序数组中的未排除下标范围内的第一个数，其中较小的数即为第 k 个数，由于 A[3]=9&gt;B[3]=4 ，因此第 k 个数是 B[3]=4。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthElement</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class="line"><span class="comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (index1 == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="type">int</span> newIndex1 = <span class="built_in">min</span>(index1 + k / <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> newIndex2 = <span class="built_in">min</span>(index2 + k / <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> pivot1 = nums1[newIndex1];</span><br><span class="line">            <span class="type">int</span> pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= newIndex1 - index1 + <span class="number">1</span>;</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= newIndex2 - index2 + <span class="number">1</span>;</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> totalLength = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKthElement</span>(nums1, nums2, (totalLength + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span>) + <span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="（3）知识点">（3）知识点</h3><ul><li><a href="https://suanfa8.com/binary-search">二分查找总结</a></li><li><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/39941/jiang-qi-zhuan-wei-zhao-liang-ge-you-xu-shu-zu-de-/">本题思路 1</a></li><li><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/6098/4-xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu/">本题思路 2</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日LeetCode_230902</title>
      <link href="/posts/3a3bee56.html"/>
      <url>/posts/3a3bee56.html</url>
      
        <content type="html"><![CDATA[<h2 id="3-无重复字符的最长子串">3. 无重复字符的最长子串</h2><h3 id="（1）题目">（1）题目</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 </span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h3 id="（2）题解">（2）题解</h3><ul><li><p>暴力循环</p><p>两层循环，外层循环从左侧开始，依次移动；内层循环从外层循环的下一个位置开始移动，每移动一次检测是否有重复，若有重复，则找到当前起始位置的最长子串，停止内层循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表，用于检测是否有重复字符</span></span><br><span class="line">unordered_set&lt;<span class="type">char</span>&gt; HashTable;</span><br><span class="line"><span class="comment">// 最长子串长度</span></span><br><span class="line"><span class="type">int</span> maxlength = <span class="number">0</span>;       </span><br><span class="line"><span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 外层循环从左向右遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">  HashTable.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">  <span class="comment">// 内层循环从 i + 1 开始向右遍历</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">    <span class="comment">// 如果 j 到达边界，或者出现重复字符</span></span><br><span class="line">    <span class="keyword">if</span>(j == n || HashTable.<span class="built_in">find</span>(s[j]) != HashTable.<span class="built_in">end</span>())&#123;</span><br><span class="line">      <span class="comment">// 更新最长子串长度</span></span><br><span class="line">      maxlength = <span class="built_in">max</span>(maxlength, j - i);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，将 s[j] 加入哈希表</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      HashTable.<span class="built_in">insert</span>(s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清空哈希表</span></span><br><span class="line">  HashTable.<span class="built_in">clear</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxlength;</span><br></pre></td></tr></table></figure><p>该方法在每次外层循环时都要重建哈希表，对于内存的占用过高；同时，因为有两层循环，且每次都是逐个字母检测，耗时过长，并不推荐使用。</p></li><li><p>滑动窗口</p><p>假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 rk 。 那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 rk 的字符显然是不重复的，并且由于少了原本的第 k 个字符，可以尝试继续增大 rk ，直到右侧出现了重复字符为止。</p><ul><li><p>使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表「枚举子串的起始位置」，右指针代表窗口的结束位置 rk ；</p></li><li><p>在每一步的操作中，将左指针向右移动一格，表示开始枚举下一个字符作为起始位置，然后不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着<em><strong>以左指针开始的，不包含重复字符的最长子串</strong></em>；</p></li><li><p>判断重复字符：哈希表（即 C++ 中的 std::unordered_set，Java 中的 HashSet，Python 中的 set, JavaScript 中的 Set）。在左指针向右移动的时候，从哈希集合中移除一个字符，在右指针向右移动的时候，往哈希集合中添加一个字符。</p><p><strong>注意：这里所使用的哈希表只是为了确认每次加入的新字母是否与已有序列重复，因此加入后，统计表中的新字母的个数即可。</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">      unordered_set&lt;<span class="type">char</span>&gt; occ;</span><br><span class="line">      <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">      <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">      <span class="type">int</span> rk = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 枚举左指针的位置，初始值隐性地表示为 -1</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">          occ.<span class="built_in">erase</span>(s[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.<span class="built_in">count</span>(s[rk + <span class="number">1</span>]))&#123;</span><br><span class="line">          <span class="comment">// 不断地移动右指针</span></span><br><span class="line">          occ.<span class="built_in">insert</span>(s[rk + <span class="number">1</span>]);</span><br><span class="line">          ++rk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>进一步改进，出现重复字符就缩小窗口</p><p>外层循环改进为 右指针到达字符串末尾就停止循环，这样可以减少一定的循环次数；</p><p>循环内，仅用了 c 和 d 两个临时变量用于存储窗口的边界字符，并利用此检测是否有重复字符以及增减出现次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 记录最长集合</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>; <span class="comment">// 窗口左指针</span></span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>; <span class="comment">// 窗口右指针</span></span><br><span class="line">        <span class="comment">// 哈希表，记录每个字符是否出现过</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line">        <span class="comment">// 外层循环，扩张窗口</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[right]; <span class="comment">// 记录右指针字符</span></span><br><span class="line">            right++;</span><br><span class="line">            window[c]++; <span class="comment">// 将 c 在哈希表中出现的次数+1</span></span><br><span class="line">            <span class="comment">// 如果出现重复字符，就缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span> (window[c] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">char</span> d = s[left]; <span class="comment">// 记录左指针字符</span></span><br><span class="line">                left++;</span><br><span class="line">                window[d]--; <span class="comment">// 减少 d 的出现次数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最长集合</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>window[c]++</code> 这一句代码的意思是将字符 <code>c</code> 在 <code>window</code> 映射中的出现次数加 1。如果 <code>c</code> 在 <code>window</code> 映射中不存在，则会自动插入一个键值对 <code>(c, 0)</code>，然后将出现次数加 1。这个操作可以用来维护当前窗口中每个字符的出现次数。</p></blockquote></li></ul><h3 id="（3）知识点">（3）知识点</h3><ol><li>滑动窗口算法：该算法是一种常用的解决字符串子串问题的方法。它通过维护一个窗口，来遍历字符串中的所有子串。在每次移动窗口时，可以通过一些技巧来避免重复计算，从而达到线性时间复杂度的目的。</li><li>哈希表：哈希表是一种常用的数据结构，可以用来快速地查找和插入元素。在本题中，我们可以使用哈希表来维护当前窗口中每个字符的出现次数。</li><li>双指针：双指针是一种常用的技巧，可以使用两个指针 <code>i</code> 和 <code>j</code> 来维护当前窗口的左右边界。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门</title>
      <link href="/posts/89826705.html"/>
      <url>/posts/89826705.html</url>
      
        <content type="html"><![CDATA[<h1>Docker 入门</h1><h2 id="一、-Docker-介绍">一、 Docker 介绍</h2><p>Docker 是一个用于 构建(build)、运行(run)、传送(share) 应用程序的平台。</p><p>通过 Docker 我们可以将应用程序及其运行时所依赖的环境、第三方软件库、配置文件等打包在一起，行成一个个“集装箱”，运送至其他平台，以便于在任何环境中正确地运行。</p><h2 id="二、-Docker-应用场景">二、 Docker 应用场景</h2><blockquote><p>应用隔离、环境配置、 安装部署、持续集成、持续发布、DevOps</p></blockquote><p>例如，我们利用目前较为主流的前后端分离架构写了一个网站，前端使用 Vue 来构建网站的界面，后端使用 Java 的 SpringBoot 微服务架构来提供各种服务和接口，使用 MySQL 数据库来存储数据。</p><p>如果不使用 Docker，我们需要先安装 NodeJs 环境、安装各种 npm 依赖包，配置 Java 运行环境，安装 SpringBoot 微服务的各种第三方依赖包，安装 MySQL 数据库，以及配置各种环境变量、启动服务等。与此同时，如果要把该网站部署在测试环境和生产环境上，还需要将上述步骤再重复一遍。</p><p>相反，如果我们使用 Docker，只要我们在开发环境中配置好了所有环境并将其打包成一个“集装箱”，那么就可以直接在其他环境中直接运行。</p><h2 id="三、容器和虚拟机的区别">三、容器和虚拟机的区别</h2><h3 id="（一）传统虚拟机">（一）传统虚拟机</h3><p>传统虚拟机软件包括：VMware 、 Virtalbox、 Parallels Desktop 、 WSL 、 Hyper-V 等</p><p>虚拟机是完整的操作系统，可以在该操作系统中运行各种支持的应用程序。虚拟机实际上是利用 虚拟化技术(Hypervisor) 将物理资源虚拟化为多个逻辑资源，它可以将一个物理服务器虚拟为多个逻辑服务器，每个逻辑服务器都有自己的操作系统、 CPU 、内存、硬盘和网络接口等。逻辑服务器之间是完全隔离的，可以独立运行。</p><p>虚拟机在一定程度上实现了资源的整合，可以将一台服务器的计算能力、存储能力、网络资源分配给多台虚拟服务器，实现多台服务器的功能。但虚拟机也存在一定的缺点，每台虚拟服务器都将占用非常多的资源，且启动速度慢。</p><p>实际上我们并不需要让每台服务器都运行多个虚拟机。通常情况下，每台物理服务器都有其特定的用途，如 Web 服务器只需提供收发数据包的功能即可，并不需要一个完整的操作系统，因此没有必要在该服务器上使用虚拟机来收发数据包。</p><h3 id="（二）容器">（二）容器</h3><p>容器是一个虚拟化技术，一定程度上类似虚拟机，是一个独立的环境。Docker 是容器的一种实现方式，是一个容器话的解决方案和平台。</p><p>与虚拟机不同的是，容器中并不需要运行一个完整的操作系统便可以运行应用程序，因此其占用的资源更少、启动速度更快。</p><h2 id="四、基本原理">四、基本原理</h2><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Docker%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.jpeg" alt="Docker基本概念"></p><h3 id="（一）镜像-images">（一）镜像 images</h3><p>镜像是一个只读模版，可以用来创建容器。（类）</p><h3 id="（二）容器-containers">（二）容器 containers</h3><p>容器是 Docker 的运行实例，提供了一个独立的可移植的环境，可以在该环境中运行应用程序。（对象）</p><h3 id="（三）仓库-registry">（三）仓库 registry</h3><p>用于存储 Docker 镜像。</p><h2 id="五、安装配置">五、安装配置</h2><h3 id="（一）安装">（一）安装</h3><ul><li><p>macOS 安装</p><p>下载安装即可。安装后运行 Docker，便可以在终端中使用 Docker 命令。</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Docker%E5%AE%89%E8%A3%85.png" alt="Docker安装"></p></li><li><p>Windows 安装</p><p>下载安装完毕后，需要在系统设置-Windows 功能中开启 Hyper-V 功能，才能正常启用 Docker 。</p></li></ul><h3 id="（二）容器化">（二）容器化</h3><ol><li>将应用程序打包成容器，然后在容器中运行应用程序的过程。</li><li>容器化步骤：<ol><li>创建一个 Dockerfile ；</li><li>使用 Dockerfile 构建镜像；</li><li>使用镜像创建和运行容器。</li></ol></li><li>Dockerfile：文本文件，包含了多条指令，用于指导 Docker 构建镜像。通常包括精简版的操作系统、应用程序的运行环境、应用程序本体、第三方依赖包或库、应用程序的配置文件、环境变量等。</li></ol><h2 id="六、常用命令">六、常用命令</h2><p><a href="https://www.runoob.com/docker/docker-command-manual.html">Docker 常用命令</a></p><h2 id="七、构建镜像并启动容器">七、构建镜像并启动容器</h2><h3 id="（一）创建-Dockerfile-文件">（一）创建 Dockerfile 文件</h3><ol><li><p>创建 HelloDocker 文件夹；</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/1-1%20%E5%88%9B%E5%BB%BA%20HelloDocker%20%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt=""></p></li><li><p>在项目文件夹中创建 index.js 文件并键入简单 JS 命令，使之在控制台输出语句；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在控制台输出语句</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/1-2%20%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F.png" alt=""></p><p>现在，在开发环境中已经可以输出语句了；</p><p>但是，如果我们需要在其他环境也运行该程序，就需要安装兼容的操作系统、JS 运行环境 NodeJS，并将该程序及其依赖包和配置文件一并复制到新的环境中，才能正常运行；</p><p>此时，就可以利用 Docker，将这些步骤打包起来，写入 Dockerfile 文件中。</p></li><li><p>在项目文件夹中创建 Dockerfile 文件并写入相关命令；</p><ol><li><p>设置镜像</p><p>镜像是按层次结构来构建的，每一层都是基于上一层的，因此需要先指定一个基础镜像；然后在该镜像的基础上添加应用程序。</p><p>这里使用到了 NodeJS ，因此需要添加其对应的基础镜像，本来应该从 Linux 的基础镜像（操作系统）开始，例如 alpine ，但 NodeJS 的镜像实际上已经是基于 Alpine 镜像构建的了，所以我们可以直接使用 NodeJS 的镜像作为我们的基础镜像。</p></li><li><p>将应用程序复制到 Docker 中</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> 源文件路径 目标路径</span></span><br></pre></td></tr></table></figure></li><li><p>在镜像中运行应用程序</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;可执行程序名&quot;</span>, <span class="string">&quot;可执行程序接受的参数&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/1-3%20%E7%BC%96%E5%86%99%20Dockerfile%20%E6%96%87%E4%BB%B6.png" alt=""></p></li></ol></li></ol><h3 id="（二）创建镜像">（二）创建镜像</h3><ol><li><p>在终端中创建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t 镜像名称[:版本号] 目录</span><br><span class="line">// 版本号可省略，不指定版本默认使用最新版本</span><br><span class="line">// . 表示当前目录</span><br></pre></td></tr></table></figure><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/2-1%20%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F.png" alt=""></p></li><li><p>查看镜像是否创建成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">// docker image ls</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/2-2%20%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F.png" alt=""></p><h3 id="（三）运行镜像">（三）运行镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run 镜像名称</span><br></pre></td></tr></table></figure><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/2-3%20%E8%BF%90%E8%A1%8C%E9%95%9C%E5%83%8F.png" alt=""></p><h3 id="（四）在其他环境中运行镜像">（四）在其他环境中运行镜像</h3><ul><li><p>将镜像复制到当前环境中，运行即可；</p></li><li><p>将镜像上传至 Dockerhub 中，在任意环境中 pull 拉取再运行即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 用户名/镜像名称</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 必备工具 </category>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必备工具 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日LeetCode_230831</title>
      <link href="/posts/89dd8618.html"/>
      <url>/posts/89dd8618.html</url>
      
        <content type="html"><![CDATA[<h2 id="2-两数相加">2. 两数相加</h2><h3 id="（1）题目">（1）题目</h3><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="题目示例"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h3 id="（2）题解">（2）题解</h3><ul><li><p>循环对位相加</p><p>对应位依次相加，利用额外变量追踪进位情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">//记录当前位的和</span></span><br><span class="line"><span class="type">int</span> carry = <span class="number">0</span>; <span class="comment">//记录下一位的进位情况</span></span><br><span class="line"></span><br><span class="line">ListNode* result =<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">ListNode* cur = result; <span class="comment">//result 固定在头结点，current 移动</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">//该循环用于计算 l1 和 l2 有相同的位数的部分</span></span><br><span class="line"><span class="keyword">while</span> (l1 != <span class="literal">NULL</span> <span class="keyword">and</span> l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">sum = l1-&gt;val + l2-&gt;val + carry;</span><br><span class="line">cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>); <span class="comment">//取余</span></span><br><span class="line">carry = sum / <span class="number">10</span>; <span class="comment">//取整，有进位是 1，否则是 0</span></span><br><span class="line"><span class="comment">//向后移动</span></span><br><span class="line">l1 = l1-&gt;next;</span><br><span class="line">l2 = l2-&gt;next;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环结束后，判断是否还有余下的位数</span></span><br><span class="line"><span class="keyword">while</span> (l1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">sum = l1-&gt;val + carry;</span><br><span class="line">cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">carry = sum / <span class="number">10</span>;</span><br><span class="line">l1 = l1-&gt;next;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">sum = l2-&gt;val + carry;</span><br><span class="line">cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">carry = sum / <span class="number">10</span>;</span><br><span class="line">l2 = l2-&gt;next;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述循环都结束后，所有位数均已遍历，最后检查是否还有进位</span></span><br><span class="line"><span class="keyword">if</span> (carry != <span class="number">0</span>)&#123;</span><br><span class="line">cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="keyword">return</span> result-&gt;next;</span><br></pre></td></tr></table></figure></li><li><p>改进</p><p>简化了循环的过程，一次循环即可遍历两个链表的所有位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ListNode* head=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);<span class="comment">//存放结果的链表</span></span><br><span class="line">ListNode* h=head;<span class="comment">//移动指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;<span class="comment">//每个位的加和结果</span></span><br><span class="line"><span class="type">bool</span> carry=<span class="literal">false</span>;<span class="comment">//进位标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该循环用于将 l1 和 l2 的每一位都遍历</span></span><br><span class="line"><span class="keyword">while</span>(l1!=<span class="literal">NULL</span>||l2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">  sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(l1!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    sum+=l1-&gt;val;</span><br><span class="line">    l1=l1-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(l2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    sum+=l2-&gt;val;</span><br><span class="line">    l2=l2-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(carry)</span><br><span class="line">    sum++;</span><br><span class="line">  h-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">  h=h-&gt;next;</span><br><span class="line">  carry=sum&gt;=<span class="number">10</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后判断是否有进位</span></span><br><span class="line"><span class="keyword">if</span>(carry)&#123;</span><br><span class="line">  h-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head-&gt;next;</span><br></pre></td></tr></table></figure></li><li><p>递归法</p><p>将两个链表从头开始相加，每次将两个链表的当前节点以及上一次相加的进位相加，得到一个新的节点，并将这个节点的 next 指针指向下一次递归的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">addTwoNumbersHelper</span>(l1, l2, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 递归函数 参数包括两个链表以及上一次相加的进位，返回值是相加后的链表</span></span><br><span class="line">  <span class="function">ListNode* <span class="title">addTwoNumbersHelper</span><span class="params">(ListNode* l1, ListNode* l2, <span class="type">int</span> carry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先判断递归结束的条件，即两个链表都为空且进位为 0</span></span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span> &amp;&amp; l2 == <span class="literal">nullptr</span> &amp;&amp; carry == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算当前节点的值</span></span><br><span class="line">    <span class="type">int</span> sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + carry;</span><br><span class="line">    <span class="comment">// 创建一个新的节点 并取余赋值</span></span><br><span class="line">    ListNode* node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 递归，将这个节点的 next 指针指向下一次递归的结果</span></span><br><span class="line">    node-&gt;next = <span class="built_in">addTwoNumbersHelper</span>(l1 ? l1-&gt;next : <span class="literal">nullptr</span>, l2 ? l2-&gt;next : <span class="literal">nullptr</span>, sum / <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 返回该节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="（3）知识点">（3）知识点</h3><ul><li><p>错误 1：示例 3 最高位没有进位 1</p><p>错误原因：最后检查 carry 是否为 0 时，应该是 <code>cur-&gt;next = new ListNode(carry);</code> 而不是 <code>cur-&gt;next = new ListNode(sum%10);</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>每日LeetCode_230830</title>
      <link href="/posts/fedab68e.html"/>
      <url>/posts/fedab68e.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-两数之和">1. 两数之和</h2><h3 id="（1）题目">（1）题目</h3><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p><strong>进阶：</strong> 你可以想出一个时间复杂度小于 <code>O(n²)</code> 的算法吗？</p><h3 id="（2）题解">（2）题解</h3><ul><li><p>暴力法  <strong>O(n²)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>哈希表 <strong>O(n)</strong></p><p>将每一个元素作为 key ，将其索引值作为 value 。每次查询一个元素，并与 target 做差（ target - key），如果差在表中可查，则找到并输出当前元素和查到的元素的 value ；否则检查下一个元素。</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/LeetCode-1-%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="LeetCode-1"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 构建哈希表</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">  map.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 逐一检查</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">  <span class="type">int</span> diff = target - nums[j];</span><br><span class="line">  <span class="keyword">if</span> (map.<span class="built_in">find</span>(diff) != map.<span class="built_in">end</span>() <span class="keyword">and</span> map[diff] != j)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;j, map[diff]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>哈希表进一步改进</p><p>先查询 target - nums[i] 值是否存在，如果不存在才将 nums[i] 插入哈希表，等待后面的数字做差后与之比较；如果存在，则说明找到了，不必再验证后续的值，直接输出即可。</p><p>该方法可以减少省去构建哈希表时的循环，时间复杂度相同，但可节省内存空间的占用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">  <span class="keyword">auto</span> it = hashtable.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">  <span class="keyword">if</span> (it != hashtable.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;it-&gt;second, i&#125;; <span class="comment">//有则输出</span></span><br><span class="line">  &#125;</span><br><span class="line">  hashtable[nums[i]] = i; <span class="comment">//无则插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="（3）知识点">（3）知识点</h3><ul><li><p>C++ 中 Hash 表的使用：unordered_map 容器</p><p><a href="https://blog.csdn.net/zou_albert/article/details/106983268">https://blog.csdn.net/zou_albert/article/details/106983268</a></p></li><li><p>unordered_map 的插入</p><p><a href="https://blog.csdn.net/YourClerk/article/details/123967991">https://blog.csdn.net/YourClerk/article/details/123967991</a></p></li><li><p>map 容器中的取值方式 -&gt; first / second</p><p><a href="https://blog.csdn.net/qq_38860340/article/details/121640219">https://blog.csdn.net/qq_38860340/article/details/121640219</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>M系列 Mac CLion 环境配置问题(一)</title>
      <link href="/posts/65843a24.html"/>
      <url>/posts/65843a24.html</url>
      
        <content type="html"><![CDATA[<h1>关于 M1 Mac 中 CLion 添加头文件情况下仍无法调用 __gcd 函数的解决办法</h1><h2 id="一、问题描述">一、问题描述</h2><p>近期在学习 C++ 的过程中发现，正常调用 __gcd 函数（最大公因数函数），CLion 报错无法调用。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; __gcd(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误如下：</p><blockquote><p>error: use of undeclared identifier ‘__gcd’</p></blockquote><h2 id="二、问题处理">二、问题处理</h2><p>尝试各种方式后，最终发现是编译器的问题，在此记录处理过程，有相同问题的同学可以参考。</p><h3 id="（一）系统及软件版本">（一）系统及软件版本</h3><p>系统：macOS Ventura 13.2</p><p>软件：CLion 2022.3.2</p><h3 id="（二）解决流程">（二）解决流程</h3><p>之前在安装 CLion 时我直接按照 CLion 的提示安装了 Command Line Tools ，并直接使用了 CLion 的默认编译器配置，这样就有可能导致编译过程中出现错误，需要重新配一下环境。</p><ol><li>打开终端，确认Command Line Tools是否安装成功。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Xcode-<span class="keyword">select</span> -install</span><br></pre></td></tr></table></figure><ol start="2"><li>利用 Homebrew 安装 gcc</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install gcc</span><br></pre></td></tr></table></figure><p>​注：安装 gcc 编译器时可能出现问题，解决方法可参照 <a href="https://blog.csdn.net/weixin_45571585/article/details/126977413?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-6-126977413-blog-116170561.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-6-126977413-blog-116170561.pc_relevant_aa&amp;utm_relevant_index=11">gcc 安装教程</a>。</p><ol start="3"><li>利用 Homebrew 安装 cmake</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install cmake</span><br></pre></td></tr></table></figure><ol start="4"><li>重新配置 CLion</li></ol><p>进入 CLion <code>设置 -- 构建、执行、部署 -- 工具链</code> 修改构建工具、 C 编译器以及 C++ 编译器，如下：</p><ul><li>原配置：</li></ul><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%80%20CLion%E5%8E%9F%E9%85%8D%E7%BD%AE.png" alt="CLion原配置"></p><ul><li>修改为：</li></ul><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%80%20CLion%E9%85%8D%E7%BD%AE%E4%BF%AE%E6%94%B9.png" alt="CLion配置修改"></p><p><strong>注1：可能版本有点区别，只要在文件中选取 ctest 、 gcc-xx 、 g+±xx 即可；</strong></p><p><strong>注2：如果点开文件后找不到文件夹，按下 <code>commond + shift + .</code> 即可显示隐藏文件夹，选好后再按一次即可隐藏</strong></p><ol start="5"><li>重启一下 CLion 即可调用 __gcc 函数</li></ol>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
          <category> CLion </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac环境配置 </tag>
            
            <tag> CLion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础</title>
      <link href="/posts/1a60696b.html"/>
      <url>/posts/1a60696b.html</url>
      
        <content type="html"><![CDATA[<h1>Git版本控制</h1><h2 id="一、版本控制">一、版本控制</h2><h3 id="（一）什么是版本控制？">（一）什么是版本控制？</h3><p>版本控制是一种记录和管理计算机文件或项目的变化历史的系统。它允许开发人员或团队跟踪文件的每次修改、查看更改内容、比较不同版本之间的差异，并在需要时还原到之前的特定状态。版本控制对于软件开发和其他类似项目的管理非常重要，因为它提供了许多优势和便利。</p><p>主要的版本控制系统有两种类型：集中式版本控制系统（Centralized Version Control System，CVCS）和分布式版本控制系统（Distributed Version Control System，DVCS）。</p><ol><li><p>集中式版本控制系统（CVCS）：<br>在CVCS中，所有文件的版本历史都保存在中央服务器上。开发人员通过连接到中央服务器来检出最新版本的文件，并将自己的更改提交到中央服务器。CVCS的缺点是，如果中央服务器出现故障或网络连接问题，那么开发人员将无法提交更改或获取最新的代码。此外，对于较大的团队，由于所有开发人员都使用中央服务器，可能会造成服务器性能瓶颈。</p></li><li><p>分布式版本控制系统（DVCS）：<br>在DVCS中，每个开发人员都有一个完整的代码仓库，包含完整的项目历史。开发人员可以在本地进行提交、回滚、创建分支等操作，而不需要实时连接到中央服务器。这使得团队成员可以在离线状态下工作，并且可以更加灵活地协作。当开发人员准备好时，他们可以将他们的更改推送（push）到中央服务器，或者从中央服务器拉取（pull）其他人的更改。</p></li></ol><p>版本控制系统的主要优势包括：</p><ul><li>更好的协作：团队成员可以同时在同一个项目上工作，不会干扰彼此的进度，也能更容易地合并不同人员的修改。</li><li>历史记录：每个版本都被记录下来，可以查看文件的完整修改历史，包括何时做了哪些更改。</li><li>版本回退：如果某次修改引入了问题，可以轻松回退到之前的稳定版本。</li><li>分支管理：可以创建多个分支，每个分支可用于不同的功能开发或问题修复，而不会相互干扰。</li><li>远程备份：中央服务器提供了对代码的远程备份，减少了数据丢失的风险。</li></ul><p>版本控制系统的使用不仅局限于软件开发，它还可以在各种其他场景中应用，如文档管理、项目管理、设计文件等。</p><h3 id="（二）为什么需要版本控制？">（二）为什么需要版本控制？</h3><p>以论文写作为例，在没有版本控制工具前，我们往往是通过每次修改版本都保留一个文件的方式来管理论文。通过多个文件来确定各个版本，不仅会占用更多的空间，而且也不利于我们对比版本间的差异。此外，我们也无法和他人协作。</p><p>使用版本控制工具，我们在论文写作中可以实现：</p><ol><li><p><strong>版本历史记录：</strong> 版本控制工具记录了每次对论文进行的修改和更新，包括添加、删除、编辑等。这使得作者可以随时查看论文的历史版本，了解每个修改的内容和时间，方便跟踪研究进展和撰写过程。</p></li><li><p><strong>版本回退和比较：</strong> 作者可以轻松地回退到之前的版本，如果当前的修改出现问题或需要恢复之前的内容，这在不丢失任何数据的情况下进行。此外，版本控制工具允许作者比较不同版本之间的差异，帮助他们了解具体修改的细节和影响。</p></li><li><p><strong>分支管理：</strong> 版本控制工具允许作者创建多个分支，每个分支可以用于不同的实验、讨论或章节撰写。这样可以在不影响主线论文的情况下进行尝试和修改，保持主线内容的稳定性。</p></li><li><p><strong>协作与审阅：</strong> 版本控制工具使得多位作者可以并行地对论文进行编辑和审阅。每位作者都可以在自己的本地副本上工作，然后将更改推送到共享的远程仓库。这样，团队成员可以实时了解其他人的修改，并且可以更好地合并和处理冲突。</p></li><li><p><strong>备份和安全性：</strong> 版本控制工具提供了对论文内容的远程备份，减少了数据丢失的风险。即使本地计算机出现故障，作者的论文仍然安全存储在远程服务器上。</p></li><li><p><strong>跨平台支持：</strong> 大多数版本控制工具都支持跨平台，这意味着作者可以在不同的操作系统上（如Windows、Mac、Linux）使用同一个版本控制系统，并轻松地共享和访问论文内容。</p></li><li><p><strong>注释和讨论：</strong> 版本控制工具通常支持注释和讨论功能，团队成员可以在特定的修改或提交上留下评论，以便进行讨论、提供反馈或交流想法。</p></li></ol><p>总体而言，版本控制工具为论文写作带来了更好的协作、追踪和管理的能力，提高了论文写作的效率，并保障了论文内容的安全性和稳定性。这对于研究团队、学生、教师以及其他合作写作项目的人员来说，都是非常有价值的工具。</p><h3 id="（三）常用版本控制工具？">（三）常用版本控制工具？</h3><p>常用的版本控制方法和工具主要有以下几种：</p><ol><li><p><strong>集中式版本控制系统（CVCS）：</strong></p><ul><li>CVS (Concurrent Versions System)：是最早流行的集中式版本控制系统之一，但目前已逐渐被更先进的版本控制系统所取代。</li><li>Subversion (SVN)：一种更现代和流行的集中式版本控制系统，提供了更多功能和改进，仍然在一些项目中广泛使用。</li></ul></li><li><p><strong>分布式版本控制系统（DVCS）：</strong></p><ul><li>Git：目前最流行和广泛使用的分布式版本控制系统。Git 是由 Linus Torvalds 创造的，它非常快速、强大，并得到了全球开发者社区的支持。</li><li>Mercurial：另一种流行的分布式版本控制系统，与 Git 类似，但在一些特定场景下可能具有不同的优势。</li></ul></li><li><p><strong>集成开发环境（IDE）内置版本控制：</strong></p><ul><li>一些集成开发环境（如Visual Studio、Eclipse、IntelliJ IDEA等）具有内置的版本控制集成，通常支持 Git 和 SVN 等常见的版本控制工具。</li></ul></li><li><p><strong>在线托管平台的版本控制：</strong></p><ul><li>GitHub：一个基于 Git 的在线代码托管平台，广泛用于开源项目、团队协作以及个人项目管理。</li><li>GitLab：类似于 GitHub 的另一个在线代码托管平台，提供类似的功能，并且可以自行搭建在私有服务器上。</li><li>Bitbucket：提供 Git 和 Mercurial 支持的在线代码托管平台，通常用于私有项目。</li></ul></li></ol><p>这些版本控制方法和工具在软件开发、文档管理、论文写作、项目协作等领域广泛使用。选择哪种版本控制方法和工具取决于项目的需求、团队的喜好和技术要求。Git 是目前最受欢迎和推荐的版本控制系统，它为开发者提供了强大的功能和灵活性，并在开源社区中得到广泛支持。</p><h2 id="二、-Git">二、 Git</h2><h3 id="（一）什么是-Git？">（一）什么是 Git？</h3><p>Git是一种分布式版本控制系统，它用于跟踪计算机文件的变化和协调多人在同一个项目上的协作。版本控制是在软件开发和其他类似项目中非常重要的概念，因为它允许开发人员或团队记录每个文件的更改历史并管理不同版本之间的差异。</p><p>Git由Linus Torvalds于2005年创造，最初是为了更好地管理Linux内核的开发而设计的。现在，Git已经成为世界上最流行和广泛使用的版本控制系统之一，被广泛应用于软件开发和其他项目管理中。</p><p>Git的主要特点包括：</p><ol><li><p>分布式：与传统的集中式版本控制系统不同，Git是一种分布式系统，每个开发人员都有一个完整的代码仓库，包含完整的历史记录。这使得团队成员可以在离线状态下工作，并可以更容易地进行协作。</p></li><li><p>分支管理：Git非常擅长管理分支，开发人员可以轻松地创建、合并和删除分支，这为同时处理多个功能或修复不同问题提供了便利。</p></li><li><p>快速和高效：Git被设计成非常快速和高效，使开发人员可以迅速完成各种操作，如提交、分支切换和合并等。</p></li><li><p>完整的历史记录：Git记录每个文件的完整历史记录，开发人员可以查看文件的每个版本、每次修改和对应的作者信息。</p></li><li><p>数据完整性：Git使用哈希值来保证数据的完整性，这意味着一旦数据被提交，就会被永久地记录和保留。</p></li><li><p>开放源代码：Git是开源软件，任何人都可以查看其源代码，并可以根据需要进行自定义修改。</p></li></ol><p>使用Git，开发人员可以更加灵活地协作，管理项目，并追踪代码变化，从而帮助团队更加高效地进行软件开发或其他类型的项目管理。</p><h3 id="（二）Git-工作原理">（二）Git 工作原理</h3><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F932856%2F202004%2F932856-20200423143251346-796113044.jpg&amp;refer=http%3A%2F%2Fimg2020.cnblogs.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1644374894&amp;t=7c2044128f7851ecd92de3c01f0187ca" alt="点击查看源网页"></p><p>Git 大致分为4个板块：</p><ul><li>工作目录：存放我们正在写的代码（当我们新版本开发完成之后，就可以进行新版本的提交）</li><li>暂存区：暂时保存待提交的内容（新版本提交后会存放到本地仓库）</li><li>本地仓库：位于我们电脑上的一个版本控制仓库（存放的就是当前项目各个版本代码的增删信息）</li><li>远程仓库：位于服务器上的版本控制仓库（服务器上的版本信息可以由本地仓库推送上去，也可以从服务器抓取到本地仓库）</li></ul><p>它是一个分布式的控制系统，因此一般情况下我们每个人的电脑上都有一个本地仓库，由大家共同向远程仓库去推送版本迭代信息。</p><p>通过这一系列操作，我们就可以实现每开发完一个版本或是一个功能，就提交一次新版本，这样，我们就可以很好地控制项目的版本迭代，想回退到之前的版本随时都可以回退，想查看新版本添加或是删除了什么代码，随时都可以查看。</p><h3 id="（三）安装-Git">（三）安装 Git</h3><p>首先请前往 Git 官网去下载最新的安装包：<a href="https://git-scm.com/">https://git-scm.com/</a></p><p>安装完成后，需要设定用户名和邮箱来区分不同的用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Ang Lee&quot;</span><br><span class="line">git config --global user.email &quot;18416841@qq.com&quot;</span><br></pre></td></tr></table></figure><h3 id="（四）基本命令介绍">（四）基本命令介绍</h3><ol><li>创建本地仓库</li></ol><p>我们可以将任意一个文件夹作为一个本地仓库，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>输入后，会自动生成一个<code>.git</code>目录，注意这个目录是一个隐藏目录，而当前目录就是我们的工作目录。</p><p>创建成功后，我们可以查看一下当前的一个状态，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>如果已经成功配置为Git本地仓库，那么输入后可以看到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br></pre></td></tr></table></figure><p>这表示我们还没有向仓库中提交任何内容，也就是一个空的状态。</p><ol start="2"><li>添加和提交</li></ol><p>接着我们来看看，如何使用git来管理我们文档的版本，我们创建一个文本文档，随便写入一点内容，接着输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>我们会得到如下提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">hello.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p>其中Untracked files是未追踪文件的意思，也就是说，如果一个文件处于未追踪状态，那么git不会记录它的变化，始终将其当做一个新创建的文件，这里我们将其添加到暂存区，那么它会自动变为被追踪状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add hello.txt #也可以 add . 一次性添加目录下所有的</span><br></pre></td></tr></table></figure><p>再次查看当前状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">new file:   hello.txt</span><br></pre></td></tr></table></figure><p>现在文件名称的颜色变成了绿色，并且是处于Changes to be committed下面，因此，我们的hello.txt现在已经被添加到暂存区了。</p><p>接着我们来尝试将其提交到Git本地仓库中，注意需要输入提交的描述以便后续查看，比如你这次提交修改了或是新增了哪些内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;Hello World&#x27;</span></span><br></pre></td></tr></table></figure><p>注：如果是修改了文件的内容（不是增删文件），可以用以下一行命令完成添加到暂存区以及提交到本地仓库中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m <span class="string">&#x27;Modify x&#x27;</span></span><br></pre></td></tr></table></figure><p>接着我们可以查看我们的提交记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line">git <span class="built_in">log</span> --graph</span><br><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure><p>我们还可以查看最近一次变更的详细内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show [也可以加上commit ID查看指定的提交记录]</span><br></pre></td></tr></table></figure><p>再次查看当前状态，已经是清空状态了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>接着我们可以尝试修改一下我们的文本文档，由于当前文件已经是被追踪状态，那么git会去跟踪它的变化，如果说文件发生了修改，那么我们再次查看状态会得到下面的结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">modified:   hello.txt</span><br></pre></td></tr></table></figure><p>也就是说现在此文件是处于已修改状态，我们如果修改好了，就可以提交我们的新版本到本地仓库中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;Modify Text&#x27;</span></span><br></pre></td></tr></table></figure><p>接着我们来查询一下提交记录，可以看到一共有两次提交记录。</p><p>我们可以创建一个<code>.gitignore</code>文件来确定一个文件忽略列表，如果忽略列表中的文件存在且不是被追踪状态，那么git不会对其进行任何检查：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这样就会匹配所有以txt结尾的文件</span></span><br><span class="line"><span class="string">*.txt</span></span><br><span class="line"><span class="comment"># 虽然上面排除了所有txt结尾的文件，但是这个不排除</span></span><br><span class="line"><span class="type">!666.txt</span></span><br><span class="line"><span class="comment"># 也可以直接指定一个文件夹，文件夹下的所有文件将全部忽略</span></span><br><span class="line"><span class="string">test/</span></span><br><span class="line"><span class="comment"># 目录中所有以txt结尾的文件，但不包括子目录</span></span><br><span class="line"><span class="string">xxx/*.txt</span></span><br><span class="line"><span class="comment"># 目录中所有以txt结尾的文件，包括子目录</span></span><br><span class="line"><span class="string">xxx/**/*.txt</span></span><br></pre></td></tr></table></figure><p>创建后，我们来看看是否还会检测到我们忽略的文件。</p><ol start="3"><li>回滚</li></ol><p>当我们想要回退到过去的版本时，就可以执行回滚操作，执行后，可以将工作空间的内容恢复到指定提交的状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commitID</span><br></pre></td></tr></table></figure><p>执行后，会直接重置为那个时候的状态。再次查看提交日志，我们发现之后的日志全部消失了。</p><p>那么要是现在我又想回去呢？我们可以通过查看所有分支的所有操作记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p>这样就能找到之前的commitID，再次重置即可。</p><ol start="4"><li>分支</li></ol><p>分支就像我们树上的一个树枝一样，它们可能一开始的时候是同一根树枝，但是长着长着就开始分道扬镳了，这就是分支。我们的代码也是这样，可能一开始写基础功能的时候使用的是单个分支，但是某一天我们希望基于这些基础的功能，把我们的项目做成两个不同方向的项目，比如一个方向做Web网站，另一个方向做游戏服务端。</p><p>因此，我们可以在一个主干上分出N个分支，分别对多个分支的代码进行维护。</p><ul><li>创建分支</li></ul><p>我们可以通过以下命令来查看当前仓库中存在的分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>我们发现，默认情况下是有一个master分支的，并且我们使用的也是master分支，一般情况下master分支都是正式版本的更新，而其他分支一般是开发中才频繁更新的。我们接着来基于当前分支创建一个新的分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 对应的删除分支是</span></span><br><span class="line">git branch -d <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>现在我们修改一下文件，提交，再查看一下提交日志：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m <span class="string">&#x27;branch master commit&#x27;</span></span><br></pre></td></tr></table></figure><p>通过添加-a来自动将未放入暂存区的已修改文件放入暂存区并执行提交操作。查看日志，我们发现现在我们的提交只生效于master分支，而新创建的分支并没有发生修改。</p><p>我们将分支切换到另一个分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>我们会发现，文件变成了此分支创建的时的状态，也就是说，在不同分支下我们的文件内容是相互隔离的。</p><p>我们现在再来提交一次变更，会发现它只生效在test分支上。我们可以看看当前的分支状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --all --graph</span><br></pre></td></tr></table></figure><ul><li>合并分支</li></ul><p>我们也可以将两个分支更新的内容最终合并到同一个分支上，我们先切换回主分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>接着使用分支合并命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>会得到如下提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Auto-merging hello.txt</span><br><span class="line">CONFLICT (content): Merge conflict in hello.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>在合并过程中产生了冲突，因为两个分支都对hello.txt文件进行了修改，那么现在要合并在一起，到底保留谁的hello文件呢？</p><p>我们可以查看一下是哪里发生了冲突：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>因此，现在我们将master分支的版本回退到修改hello.txt之前或是直接修改为最新版本的内容，这样就不会有冲突了，接着再执行一次合并操作，现在两个分支成功合并为同一个分支。</p><ul><li>变基分支</li></ul><p>除了直接合并分支以外，我们还可以进行变基操作，它跟合并不同，合并是分支回到主干的过程，而变基是直接修改分支开始的位置，比如我们希望将yyds变基到master上，那么yyds会将分支起点移动到master最后一次提交位置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase master</span><br></pre></td></tr></table></figure><p>变基后，yyds分支相当于同步了此前master分支的全部提交。</p><ul><li>优选</li></ul><p>我们还可以选择其将他分支上的提交作用于当前分支上，这种操作称为cherrypick：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;commit <span class="built_in">id</span>&gt;:单独合并一个提交</span><br></pre></td></tr></table></figure><p>这里我们在master分支上创建一个新的文件，提交此次更新，接着通过cherry-pick的方式将此次更新作用于test分支上。</p><h2 id="三、使用IDEA版本控制">三、使用IDEA版本控制</h2><p>虽然前面我们基本讲解了git的命令行使用方法，但是没有一个图形化界面，始终会感觉到很抽象，所以这里我们使用IDEA来演示，IDEA内部集成了git模块，它可以让我们的git版本管理图形化显示，当然除了IDEA也有一些独立的软件比如：SourceTree（挺好用）</p><p>打开IDEA后，找到版本控模块，我们直接点击创建本地仓库，它会自动将当前项目的根目录作为我们的本地仓库，而我们编写的所有代码和项目目录下其他的文件都可以进行版本控制。</p><p>我们发现所有项目中正在编写的类文件全部变红了，也就是处于未追踪状态，接着我们进行第一次初始化提交，提交之后我们可以在下方看到所有的本地仓库提交记录。</p><p>接着我们来整合一下Web环境，创建新的类之后，IDEA会提示我们是否将文件添加到Git，也就是是否放入暂存区并开启追踪，我们可以直接对比两次代码的相同和不同之处。</p><p>接着我们来演示一下分支创建和分支管理。</p><h2 id="四、远程仓库">四、远程仓库</h2><p>远程仓库实际上就是位于服务器上的仓库，它能在远端保存我们的版本历史，并且可以实现多人同时合作编写项目，每个人都能够同步他人的版本，能够看到他人的版本提交，相当于将我们的代码放在服务器上进行托管。</p><p>远程仓库有公有和私有的，公有的远程仓库有GitHub、码云、Coding等，他们都是对外开放的，我们注册账号之后就可以使用远程仓库进行版本控制，其中最大的就是GitHub，但是它服务器在国外，我们国内连接可能会有一点卡。私有的一般是GitLab这种自主搭建的远程仓库私服，在公司中比较常用，它只对公司内部开放，不对外开放。</p><p>这里我们以GitHub做讲解，官网：<a href="https://github.com">https://github.com</a>，首先完成用户注册。</p><p>接下来在 GitHub 中创建一个项目远程仓库(New Repository)，依次填写仓库名称、仓库介绍以及私有/公有仓库，创建后便可以得到远程仓库的地址(Https)。</p><h3 id="（一）远程账户认证和推送">（一）远程账户认证和推送</h3><p>创建仓库后，我们可以通过推送来将本地仓库中的内容推送到远程仓库。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add 名称 远程仓库地址</span><br><span class="line">git push 远程仓库名称 本地分支名称[:远端分支名称]</span><br></pre></td></tr></table></figure><p>注意<code>push</code>后面两个参数，一个是远端名称，还有一个就是本地分支名称，但是如果本地分支名称和远端分支名称一致，那么不用指定远端分支名称，但是如果我们希望推送的分支在远端没有同名的，那么需要额外指定。推送前需要登陆账户，GitHub现在不允许使用用户名密码验证，只允许使用个人AccessToken来验证身份，所以我们需要先去生成一个Token才可以。</p><p>注：创建Token时，勾选 repo、gist、user 选项。在终端中push时，账号为GitHub账号名称，密码为Token值。</p><p>推送后，我们发现远程仓库中的内容已经与我们本地仓库中的内容保持一致了，注意，远程仓库也可以有很多个分支。</p><hr><p>以下部分为SSH配置方式，目前GitHub已支持终端记住Token凭证，因此可忽略该方式。</p><p>但是这样比较麻烦，我们每次都需要去输入用户名和密码，有没有一劳永逸的方法呢？当然，我们也可以使用SSH来实现一次性校验，我们可以在本地生成一个rsa公钥：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/github.pub</span><br></pre></td></tr></table></figure><p>接着我们需要在GitHub上上传我们的公钥，当我们再次去访问GitHub时，会自动验证，就无需进行登录了，之后在Linux部分我们会详细讲解SSH的原理。</p><hr><p>接着我们修改一下工作区的内容，提交到本地仓库后，再推送到远程仓库，提交的过程中我们注意观察提交记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m <span class="string">&#x27;Modify files&#x27;</span></span><br><span class="line">git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">git push origin master </span><br><span class="line">git <span class="built_in">log</span> --all --oneline --graph</span><br></pre></td></tr></table></figure><p>我们可以将远端和本地的分支进行绑定，绑定后就不需要指定分支名称了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin master:master</span><br><span class="line">git push origin</span><br></pre></td></tr></table></figure><p>在一个本地仓库对应一个远程仓库的情况下，远程仓库基本上就是纯粹的代码托管了（云盘那种感觉，就纯粹是存你代码的）</p><h3 id="（二）克隆项目">（二）克隆项目</h3><p>如果我们已经存在一个远程仓库的情况下，我们需要在远程仓库的代码上继续编写代码，这个时候怎么办呢？</p><p>我们可以使用克隆操作来将远端仓库的内容全部复制到本地：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 远程仓库地址</span><br></pre></td></tr></table></figure><p>这样本地就能够直接与远程保持同步。</p><h3 id="（三）抓取、拉取和冲突解决">（三）抓取、拉取和冲突解决</h3><p>我们接着来看，如果这个时候，出现多个本地仓库对应一个远程仓库的情况下，比如一个团队里面，N个人都在使用同一个远程仓库，但是他们各自只负责编写和推送自己业务部分的代码，也就是我们常说的协同工作，那么这个时候，我们就需要协调。</p><p>比如程序员A完成了他的模块，那么他就可以提交代码并推送到远程仓库，这时程序员B也要开始写代码了，由于远程仓库有其他程序员的提交记录，因此程序员B的本地仓库和远程仓库不一致，这时就需要有先进行pull操作，获取远程仓库中最新的提交：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch 远程仓库 <span class="comment">#抓取：只获取但不合并远端分支，后面需要我们手动合并才能提交</span></span><br><span class="line">git pull 远程仓库 <span class="comment">#拉取：获取+合并</span></span><br></pre></td></tr></table></figure><p>在程序员B拉取了最新的版本后，再编写自己的代码然后提交就可以实现多人合作编写项目了，并且在拉取过程中就能将别人提交的内容同步到本地，开发效率大大提升。</p><p>如果工作中存在不协调的地方，比如现在我们本地有两个仓库，一个仓库去修改hello.txt并直接提交，另一个仓库也修改hello.txt并直接提交，会得到如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">To https://github.com/xx/xxx.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to &#x27;https://github.com/xx/xxx.git&#x27;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &#x27;git pull ...&#x27;) before pushing again.</span><br><span class="line">hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br></pre></td></tr></table></figure><p>一旦一个本地仓库推送了代码，那么另一个本地仓库的推送会被拒绝，原因是当前文件已经被其他的推送给修改了，我们这边相当于是另一个版本，和之前两个分支合并一样，产生了冲突，因此我们只能去解决冲突问题。</p><p>如果远程仓库中的提交和本地仓库中的提交没有去编写同一个文件，那么就可以直接拉取：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull 远程仓库</span><br></pre></td></tr></table></figure><p>拉取后会自动进行合并，合并完成之后我们再提交即可。</p><p>但是如果两次提交都修改了同一个文件，那么就会遇到和多分支合并一样的情况，在合并时会产生冲突，这时就需要我们自己去解决冲突了。</p>]]></content>
      
      
      <categories>
          
          <category> 必备工具 </category>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必备工具 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客搭建（一）</title>
      <link href="/posts/ad52d94.html"/>
      <url>/posts/ad52d94.html</url>
      
        <content type="html"><![CDATA[<h1>个人博客搭建（一）</h1><div class="note red icon-padding flat"><i class="note-icon fas fa-fan fa-spin"></i><p>本文是搭建个人博客系列的第一篇文章，主要包括本地环境搭建、远程仓库搭建两个部分。</p></div><h2 id="一、技术栈">一、技术栈</h2><ul><li>语言：HTML、CSS、JavaScript、MarkDown</li><li>框架：Hexo</li><li>主题：ButterFly</li><li>仓库：GitHub</li><li>第三方托管：Vercel</li><li>域名：阿里云</li></ul><h2 id="二、本地环境搭建">二、本地环境搭建</h2><h3 id="1-安装Node-js">1. 安装Node.js</h3><ul><li>下载地址：<a href="https://nodejs.org/zh-cn/download/">https://nodejs.org/zh-cn/download/</a></li><li>安装完成后，打开命令行，输入<code>node -v</code>和<code>npm -v</code>，查看是否安装成功</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 实战 </category>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客搭建 </tag>
            
            <tag> Hexo </tag>
            
            <tag> ButterFly </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title></title>
      <link href="/manifest.json"/>
      <url>/manifest.json</url>
      
        <content type="html"><![CDATA[{"name":"AngFff's Blog","short_name":"AngFff","theme_color":"#87CEEB","background_color":"#87CEEB","display":"standalone","scope":"/","start_url":"/","icons":[{"src":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/siteicon-drumstick-16.png","sizes":"16x16","type":"image/png"},{"src":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/siteicon-drumstick-32.png","sizes":"32x32","type":"image/png"},{"src":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/siteicon-drumstick-48.png","sizes":"48x48","type":"image/png"},{"src":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/siteicon-drumstick-64.png","sizes":"64x64","type":"image/png"},{"src":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/siteicon-drumstick-128.png","sizes":"128x128","type":"image/png"},{"src":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/siteicon-drumstick-144.png","sizes":"144x144","type":"image/png"},{"src":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/siteicon-drumstick-512.png","sizes":"512x512","type":"image/png"}],"splash_pages":null}]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>友链</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Music...</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-arrow-down-a-z"></i><p>Adele</p></div>    <div id="aplayer-jhgKhKyq" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="36841427" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86" data-loop="none"    ></div><details class="toggle" ><summary class="toggle-button" style="">Love In The Dark</summary><div class="toggle-content"><p>We’re not the only ones<br>我们不是彼此命中之人<br>I don’t regret a thing<br>我不会后悔我的决定<br>Every word I’ve said<br>我曾诉说的一言一语<br>You know I’ll always mean<br>而你知道我的言语从不虚假<br>It is the world to mean<br>世界证明我的心从不虚假<br>That you are in my life<br>你的确曾让我的生命灿烂如花<br>But I want to live，And not just survive<br>但此刻我只想活出自己，而不是傀儡般的生存着</p></div></details><hr>    <div id="aplayer-VcqMrTTl" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="1892652689" data-server="netease" data-type="song" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86" data-loop="none"    ></div><details class="toggle" ><summary class="toggle-button" style="">I Drink Wine</summary><div class="toggle-content"><p>I hope in time (Hope in time) we both will find (We’ll both find) peace of mind<br>我希望届时 我们都能 找到心灵的平静<br>Sometimes the road less traveled is the road best left behind (Ah, ah, ah, ah)<br>有时候，人迹罕至的道路才是最好的那一条道路</p><p>Well, so I hope I learn to get over myself<br>所以我只希望我能学会克服自己<br>Stop trying to be somebody else<br>不要再努力着成为别人</p><p>You better believe I’m trying (Trying, trying)<br>但你最好相信 我在尝试<br>To keep climbing (Climbing, climbing)<br>继续攀登<br>But the higher we climb feels like we’re both none the wiser<br>但是我们越到高处，越发感觉我们都并非智者</p></div></details>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Photos...</title>
      <link href="/photos/index.html"/>
      <url>/photos/index.html</url>
      
        <content type="html"><![CDATA[<div class="note blue icon-padding flat"><i class="note-icon fas fa-camera"></i><p>岁月的痕迹，时光的印记，都在这里。</p></div><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/wallpaper-ocean-1.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">壁纸</div>  <p>一些壁纸</p>  <a href='/photos/wallpaper'></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/film-YourNameEngravedHerein-1.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">电影</div>  <p>一些电影截图</p>  <a href='/photos/film'></a>  </figcaption>  </figure>  </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Films...</title>
      <link href="/photos/film/index.html"/>
      <url>/photos/film/index.html</url>
      
        <content type="html"><![CDATA[<div class="gallery">    <div class="fj-gallery  data" data-rowHeight="220" data-limit="10">    <span class="gallery-data">[{"url":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/film-YourNameEngravedHerein-1.jpg","alt":""},{"url":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/film-YourNameEngravedHerein-2.jpg","alt":""},{"url":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/film-YourNameEngravedHerein-3.jpg","alt":""},{"url":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/film-YourNameEngravedHerein-4.jpg","alt":""}]</span>    </div>    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>    </div>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Wallpapers...</title>
      <link href="/photos/wallpaper/index.html"/>
      <url>/photos/wallpaper/index.html</url>
      
        <content type="html"><![CDATA[<div class="gallery">    <div class="fj-gallery  data" data-rowHeight="220" data-limit="10">    <span class="gallery-data">[{"url":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/wallpaper-nature-1.jpg","alt":""},{"url":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/wallpaper-nature-2.jpg","alt":""},{"url":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/wallpaper-nature-3.jpg","alt":""},{"url":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/wallpaper-nature-4.jpg","alt":""},{"url":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/wallpaper-nature-5.jpg","alt":""},{"url":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/wallpaper-nature-6.jpg","alt":""},{"url":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/wallpaper-nature-7.jpg","alt":""},{"url":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/wallpaper-nature-8.jpg","alt":""},{"url":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/wallpaper-nature-9.jpg","alt":""},{"url":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/wallpaper-nature-10.jpg","alt":""},{"url":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/wallpaper-light-1.jpg","alt":""},{"url":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/wallpaper-light-2.jpg","alt":""},{"url":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/wallpaper-light-3.jpg","alt":""},{"url":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/wallpaper-ocean-1.jpg","alt":""},{"url":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/wallpaper-ocean-2.jpg","alt":""},{"url":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/wallpaper-cloud-1.jpg","alt":""},{"url":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/wallpaper-sky-1.jpg","alt":""},{"url":"https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/wallpaper-city-1.jpg","alt":""}]</span>    </div>    <button class="gallery-load-more"><span>加载更多</span><i class="fa-solid fa-arrow-down"></i></button>    </div>]]></content>
      
    </entry>
    
    
  
</search>
