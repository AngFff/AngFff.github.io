<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AngFff&#39;s Blog</title>
  
  
  <link href="https://www.angfff.top/atom.xml" rel="self"/>
  
  <link href="https://www.angfff.top/"/>
  <updated>2025-05-22T04:31:26.224Z</updated>
  <id>https://www.angfff.top/</id>
  
  <author>
    <name>AngFff</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>互联网产品分析笔记(五)</title>
    <link href="https://www.angfff.top/posts/c3379359.html"/>
    <id>https://www.angfff.top/posts/c3379359.html</id>
    <published>2025-05-22T04:22:35.000Z</published>
    <updated>2025-05-22T04:31:26.224Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Speech-Central（跨平台文本转语音阅读器）">Speech Central（跨平台文本转语音阅读器）</h2><h3 id="产品概述">产品概述</h3><p>Speech Central 是一款来自塞尔维亚的跨平台文本转语音（Text-to-Speech, TTS）应用，支持 Windows、macOS、iOS、Android、Web 等多个平台。它主要面向有信息过载问题、阅读障碍（如阅读障碍症）、或希望通过听力提升效率的用户，提供网页朗读、电子书朗读、文档阅读等多场景支持，是一款偏向实用主义的 TTS 工具型产品。</p><h3 id="核心功能">核心功能</h3><ol><li><strong>网页和RSS朗读</strong>：用户可将网页文章加入收听列表，按类别自动整理朗读。</li><li><strong>本地文件支持</strong>：支持PDF、Word、EPUB等多种格式的导入朗读。</li><li><strong>个性化发音设置</strong>：支持多种语音包选择（系统语音/第三方TTS引擎），可调整语速、语调、发音人等。</li><li><strong>多设备同步</strong>：用户内容库在云端同步，换设备继续听。</li><li><strong>阅读列表与播放管理</strong>：可建立播放队列、标记“已读”“稍后听”“最爱”等分类。</li></ol><h3 id="用户体验评估">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>全平台覆盖，真正做到了“任何设备都能听文章”；适合办公党与出行场景。</li><li>功能设置细致，语音参数可调控范围广，自定义程度高。</li><li>定价亲民，尤其在Windows端用户中性价比极高。</li></ul></li><li><strong>不足</strong>：<ul><li>UI 设计较为传统，缺少现代产品的美观与流畅感。</li><li>中文支持虽可用，但没有专属优化，断句和语调偶有不自然。</li><li>缺乏社交或分享机制，社区感为零，增长依赖搜索与推荐。</li></ul></li></ul><h3 id="商业模式解释">商业模式解释</h3><ol><li><strong>一次性付费或订阅制</strong>：不同平台采取不同策略，如Windows为买断，iOS为订阅制。</li><li><strong>语音包增值服务</strong>：引导用户购买更自然的高品质TTS语音引擎（如Neural Voices）。</li><li><strong>教育/无障碍用户方案</strong>：面向学习障碍或阅读障碍用户群提供定制优惠。</li><li><strong>捆绑服务销售</strong>：未来可探索与新闻源、知识库（如Pocket、Instapaper）集成进行内容推荐引流。</li></ol><h3 id="竞争分析">竞争分析</h3><ul><li><strong>直接竞争者</strong>：<ul><li><strong>Voice Dream Reader</strong>（iOS重度用户最爱）：朗读自然，设计优秀但定价较高。</li><li><strong>Speechify</strong>：AI配音逼真、社交传播强，但贵、平台不全。</li></ul></li><li><strong>间接竞争者</strong>：<ul><li><strong>Read Aloud 浏览器插件</strong>：功能轻但便捷，适合网页阅读快速使用。</li><li><strong>Audible &amp; Podcasts</strong>：虽然不是TTS，但占用了大量听力资源用户时间。</li></ul></li><li><strong>Speech Central 优势</strong>：<ul><li>平台覆盖全面，功能实用，目标用户对性价比敏感，因此用户粘性高。</li><li>对技术型用户、知识工作者更友好，适合构建“听力工作流”。</li></ul></li><li><strong>Speech Central 劣势</strong>：<ul><li>缺乏品牌声量与用户激励机制，难以破圈。</li><li>用户界面缺乏情感设计，远不如Speechify那种“用听力改变人生”的用户心智。</li></ul></li></ul><h3 id="运营策略建议">运营策略建议</h3><ol><li><strong>推出“沉浸阅读场景”套餐</strong>：结合蓝光护眼模式、环境音效播放等元素，增强专注感。</li><li><strong>与生产力工具如Notion、Obsidian集成</strong>：导入文档一键朗读，打通知识管理闭环。</li><li><strong>开设“每周阅读排行榜”栏目</strong>：引导用户订阅RSS源并分享喜好，提高留存与互动。</li><li><strong>布局亚洲市场，推出本地语音优化包</strong>：尤其是中文、日语用户的语音自然度提升需求巨大。</li></ol><h3 id="改进建议">改进建议</h3><ol><li><strong>优化移动端交互与UI</strong>：提升视觉体验感，适配暗黑模式、手势导航等现代交互范式。</li><li><strong>添加“听力笔记”功能</strong>：让用户可在听书过程中快速语音做笔记，提升知识沉淀感。</li><li><strong>打造“听力学习计划”系统</strong>：鼓励用户每天听10分钟，结合打卡、进度反馈，构建习惯。</li><li><strong>引入“AI精读”辅助功能</strong>：结合LLM模型，生成段落摘要、关键词提取，增强信息获取效率。</li></ol><h3 id="总结">总结</h3><p>Speech Central 是一款“朴素却强大”的工具，它不像Speechify那么网红，但在实用性上绝对是知识型用户的可靠伙伴。如果它能进一步打造AI听力体验闭环、改善交互与本地化内容生态，它就能从“工具”升级为“声音时代的知识助理”。<br>一句话总结：Speech Central，是一款你可能没听说，但一旦用上就戒不掉的听力阅读神器。🎧📖🧠</p><hr>]]></content>
    
    
    <summary type="html">互联网产品分析笔记(五)</summary>
    
    
    
    <category term="产品分析" scheme="https://www.angfff.top/categories/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="互联网产品" scheme="https://www.angfff.top/tags/%E4%BA%92%E8%81%94%E7%BD%91%E4%BA%A7%E5%93%81/"/>
    
    <category term="产品分析" scheme="https://www.angfff.top/tags/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"/>
    
    <category term="PM" scheme="https://www.angfff.top/tags/PM/"/>
    
  </entry>
  
  <entry>
    <title>Java SE 学习笔记 3️⃣</title>
    <link href="https://www.angfff.top/posts/65cda6bb.html"/>
    <id>https://www.angfff.top/posts/65cda6bb.html</id>
    <published>2025-05-18T14:45:59.000Z</published>
    <updated>2025-05-22T04:31:09.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型">泛型</h2><p>为了统计学生成绩，要求设计一个Score对象，包括课程名称、课程号、课程成绩，但是成绩分为两种，一种是以<code>优秀、良好、合格</code> 来作为结果，还有一种就是 <code>60.0、75.5、92.5</code> 这样的数字分数，可能高等数学这门课是以数字成绩进行结算，而计算机网络实验这门课是以等级进行结算，这两种分数类型都有可能出现，那么现在该如何去设计这样的一个Score类呢？</p><p>现在的问题就是，成绩可能是<code>String</code>类型，也可能是<code>Integer</code>类型，如何才能很好的去存可能出现的两种类型呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Score</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    String id;</span><br><span class="line">    Object value;  <span class="comment">//因为Object是所有类型的父类，因此既可以存放Integer也能存放String</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(String name, String id, Object value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.score = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的方法虽然很好地解决了多种类型存储问题，但是Object类型在编译阶段并不具有良好的类型判断能力，很容易出现以下的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Score</span> <span class="variable">score</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Score</span>(<span class="string">&quot;数据结构与算法基础&quot;</span>, <span class="string">&quot;EP074512&quot;</span>, <span class="string">&quot;优秀&quot;</span>);  <span class="comment">//是String类型的</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">Integer</span> <span class="variable">number</span> <span class="operator">=</span> (Integer) score.score;  <span class="comment">//获取成绩需要进行强制类型转换，虽然并不是一开始的类型，但是编译不会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Object类型作为引用，对于使用者来说，由于是Object类型，所以说并不能直接判断存储的类型到底是String还是Integer，取值只能进行强制类型转换，显然无法在编译期确定类型是否安全，项目中代码量非常之大，进行类型比较又会导致额外的开销和增加代码量，如果不经比较就很容易出现类型转换异常，代码的健壮性有所欠缺，所以说这种解决办法虽然可行，但并不是最好的方案。<br>为了解决以上问题，JDK 5新增了泛型，它能够在编译阶段就检查类型安全，大大提升开发效率。</p><h3 id="泛型类">泛型类</h3><p>泛型其实就一个待定类型，我们可以使用一个特殊的名字表示泛型，泛型在定义时并不明确是什么类型，而是需要到使用时才会确定对应的泛型类型。</p><p>我们可以将一个类定义为一个泛型类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Score</span>&lt;T&gt; &#123;   <span class="comment">//泛型类需要使用&lt;&gt;，我们需要在里面添加1 - N个类型变量</span></span><br><span class="line">    String name;</span><br><span class="line">    String id;</span><br><span class="line">    T value;   <span class="comment">//T会根据使用时提供的类型自动变成对应类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(String name, String id, T value)</span> &#123;   <span class="comment">//这里T可以是任何类型，但是一旦确定，那么就不能修改了</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看这是如何使用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Score&lt;String&gt; score = <span class="keyword">new</span> <span class="title class_">Score</span>&lt;String&gt;(<span class="string">&quot;计算机网络&quot;</span>, <span class="string">&quot;EP074512&quot;</span>, <span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">  <span class="comment">//因为现在有了类型变量，在使用时同样需要跟上&lt;&gt;并在其中填写明确要使用的类型</span></span><br><span class="line">  <span class="comment">//这样我们就可以根据不同的类型进行选择了</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> score.value;   <span class="comment">//一旦类型明确，那么泛型就变成对应的类型了</span></span><br><span class="line">    System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型将数据类型的确定控制在了编译阶段，在编写代码的时候就能明确泛型的类型，如果类型不符合，将无法通过编译！因为是具体使用对象时才会明确具体类型，所以说静态方法中是不能用的：</p><p><img src="https://s2.loli.net/2022/09/27/RCqAhvMGzNwfH7J.png" alt="image-20220927135128332"></p><p>只不过这里需要注意一下，我们在方法中使用待确定类型的变量时，因为此时并不明确具体是什么类型，那么默认会认为这个变量是一个Object类型的变量，因为无论具体类型是什么，一定是Object类的子类：</p><p><img src="https://s2.loli.net/2022/09/26/gkFs35US9rxo7f2.png" alt="image-20220926235642963"></p><p>我们可以对其进行强制类型转换，但是实际上没多大必要：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(T t)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) t;   <span class="comment">//都明确要用String了，那这里定义泛型不是多此一举吗</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为泛型本身就是对某些待定类型的简单处理，如果都明确要使用什么类型了，那大可不必使用泛型。还有，不能通过这个不确定的类型变量就去直接创建对象和对应的数组：</p><p><img src="https://s2.loli.net/2022/09/27/RlHYhPSUJ5ICswG.png" alt="image-20220927134825845"></p><p>注意，具体类型不同的泛型类变量，不能使用不同的变量进行接收：</p><p><img src="https://s2.loli.net/2022/09/25/jhekq9ZKHoiT2yI.png" alt="image-20220925170746329"></p><p>如果要让某个变量支持引用确定了任意类型的泛型，那么可以使用<code>?</code>通配符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Test&lt;?&gt; test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;Integer&gt;();</span><br><span class="line">    test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;String&gt;();</span><br><span class="line">  <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> test.value;    <span class="comment">//但是注意，如果使用通配符，那么由于类型不确定，所以说具体类型同样会变成Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，泛型变量不止可以只有一个，如果需要使用多个的话，我们也可以定义多个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&lt;A, B, C&gt; &#123;   <span class="comment">//多个类型变量使用逗号隔开</span></span><br><span class="line">    <span class="keyword">public</span> A a;</span><br><span class="line">    <span class="keyword">public</span> B b;</span><br><span class="line">    <span class="keyword">public</span> C c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么在使用时，就需要将这三种类型都进行明确指定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Test&lt;String, Integer, Character&gt; test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;&gt;();  <span class="comment">//使用钻石运算符可以省略其中的类型</span></span><br><span class="line">    test.a = <span class="string">&quot;lbwnb&quot;</span>;</span><br><span class="line">    test.b = <span class="number">10</span>;</span><br><span class="line">    test.c = <span class="string">&#x27;淦&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉好像还是挺简单的？只要是在类中，都可以使用类型变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt;&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过，泛型只能确定为一个引用类型，基本类型是不支持的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> T value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/26/TI6tWwj4vXFdenr.png" alt="image-20220926232135111"></p><p>如果要存放基本数据类型的值，我们只能使用对应的包装类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Test&lt;Integer&gt; test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果是基本类型的数组，因为数组本身是引用类型，所以说是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Test&lt;<span class="type">int</span>[]&gt; test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用泛型，我们就可以将某些不明确的类型在具体使用时再明确。</p><h3 id="泛型与多态">泛型与多态</h3><p>不只是类，包括接口、抽象类，都是可以支持泛型的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Study</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当子类实现此接口时，我们可以选择在实现类明确泛型类型，或是继续使用此泛型让具体创建的对象来确定类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">A</span>();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> a.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">Study</span>&lt;Integer&gt; &#123;   </span><br><span class="line">      <span class="comment">//在实现接口或是继承父类时，如果子类是一个普通类，那么可以直接明确对应类型</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Integer <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者是继续摆烂，依然使用泛型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        A&lt;String&gt; a = <span class="keyword">new</span> <span class="title class_">A</span>&lt;&gt;();</span><br><span class="line">        <span class="type">String</span> <span class="variable">i</span> <span class="operator">=</span> a.test();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Study</span>&lt;T&gt; &#123;   </span><br><span class="line">      <span class="comment">//让子类继续为一个泛型类，那么可以不用明确</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> T <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承也是同样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">A</span>&lt;T&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&lt;String&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法">泛型方法</h3><p>当然，类型变量并不是只能在泛型类中才可以使用，我们也可以定义泛型方法。</p><p>当某个方法（无论是是静态方法还是成员方法）需要接受的参数类型并不确定时，我们也可以使用泛型来表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> test(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">test</span><span class="params">(T t)</span>&#123;   <span class="comment">//在返回值类型前添加&lt;&gt;并填写泛型变量表示这个是一个泛型方法</span></span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>泛型方法会在使用时自动确定泛型类型，比如上我们定义的是类型T作为参数，同样的类型T作为返回值，实际传入的参数是一个字符串类型的值，那么T就会自动变成String类型，因此返回值也是String类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] strings = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">    main.add(strings, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    System.out.println(Arrays.toString(strings));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T[] arr, T t)</span>&#123;</span><br><span class="line">    arr[<span class="number">0</span>] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上泛型方法在很多工具类中也有，比如说Arrays的排序方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Integer[] arr = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line">Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;   </span><br><span class="line">  <span class="comment">//通过创建泛型接口的匿名内部类，来自定义排序规则，因为匿名内部类就是接口的实现类，所以说这里就明确了类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;   <span class="comment">//这个方法会在执行排序时被调用（别人来调用我们的实现）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>比如现在我们想要让数据从大到小排列，我们就可以自定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Integer[] arr = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    Arrays.sort(arr, <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span> &#123;   <span class="comment">//两个需要比较的数会在这里给出</span></span><br><span class="line">            <span class="keyword">return</span> o2 - o1;    </span><br><span class="line">          <span class="comment">//compare方法要求返回一个int来表示两个数的大小关系，大于0表示大于，小于0表示小于</span></span><br><span class="line">          <span class="comment">//这里直接o2-o1就行，如果o2比o1大，那么肯定应该排在前面，所以说返回正数表示大于</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为我们前面学习了Lambda表达式，像这种只有一个方法需要实现的接口，直接安排了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Integer[] arr = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    Arrays.sort(arr, (o1, o2) -&gt; o2 - o1);   <span class="comment">//瞬间变一行，效果跟上面是一样的</span></span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包括数组复制方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] arr = &#123;<span class="string">&quot;AAA&quot;</span>, <span class="string">&quot;BBB&quot;</span>, <span class="string">&quot;CCC&quot;</span>&#125;;</span><br><span class="line">    String[] newArr = Arrays.copyOf(arr, <span class="number">3</span>);   <span class="comment">//这里传入的类型是什么，返回的类型就是什么，也是用到了泛型</span></span><br><span class="line">    System.out.println(Arrays.toString(newArr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，泛型实际上在很多情况下都能够极大地方便我们对于程序的代码设计。</p><h3 id="泛型的界限">泛型的界限</h3><p>现在有一个新的需求，现在没有String类型的成绩了，但是成绩依然可能是整数，也可能是小数，这时我们不希望用户将泛型指定为除数字类型外的其他类型，我们就需要使用到泛型的上界定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Score</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; &#123;   <span class="comment">//设定类型参数上界，必须是Number或是Number的子类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Score</span><span class="params">(String name, String id, T value)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要在泛型变量的后面添加<code>extends</code>关键字即可指定上界，使用时，具体类型只能是我们指定的上界类型或是上界类型的子类，不得是其他类型。否则一律报错：</p><p><img src="https://s2.loli.net/2022/09/27/BAgmdCkDFL62V8H.png" alt="image-20220927000902574"></p><p>实际上就像这样：</p><p><img src="https://s2.loli.net/2022/09/27/rLnjHp73tdFSPUM.png" alt="img"></p><p>同样的，当我们在使用变量时，泛型通配符也支持泛型的界限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Score&lt;? <span class="keyword">extends</span> <span class="title class_">Integer</span>&gt; score = <span class="keyword">new</span> <span class="title class_">Score</span>&lt;&gt;(<span class="string">&quot;数据结构与算法&quot;</span>, <span class="string">&quot;EP074512&quot;</span>, <span class="number">60</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么既然泛型有上界，那么有没有下界呢？肯定的啊：</p><p><img src="https://s2.loli.net/2022/09/27/UJg7s41NC9Gn6fX.png" alt="image-20220927002611032"></p><p>只不过下界仅适用于通配符，对于类型变量来说是不支持的。下界限定就像这样：</p><p><img src="https://s2.loli.net/2022/09/27/QFZNSCpnAmKG7qr.png" alt="4aa52791-73f4-448f-bab3-9133ea85d850.jpg"></p><p>那么限定了上界后，我们再来使用这个对象的泛型成员，会变成什么类型呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Score&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; score = <span class="keyword">new</span> <span class="title class_">Score</span>&lt;&gt;(<span class="string">&quot;数据结构与算法基础&quot;</span>, <span class="string">&quot;EP074512&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">Number</span> <span class="variable">o</span> <span class="operator">=</span> score.getValue();   <span class="comment">//可以看到，此时虽然使用的是通配符，但是不再是Object类型，而是对应的上界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们限定下界的话，因为还是有可能是Object，所以说依然是跟之前一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Score&lt;? <span class="built_in">super</span> Number&gt; score = <span class="keyword">new</span> <span class="title class_">Score</span>&lt;&gt;(<span class="string">&quot;数据结构与算法基础&quot;</span>, <span class="string">&quot;EP074512&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> score.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过给设定泛型上限，我们就可以更加灵活地控制泛型的具体类型范围。</p><h3 id="类型擦除">类型擦除</h3><p>前面我们已经了解如何使用泛型，那么泛型到底是如何实现的呢，程序编译之后的样子是什么样的？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">abstract</span> T <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上在Java中并不是真的有泛型类型（为了兼容之前的Java版本）因为所有的对象都是属于一个普通的类型，一个泛型类型编译之后，实际上会直接使用默认的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> Object <span class="title function_">test</span><span class="params">(Object t)</span>;  <span class="comment">//默认就是Object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果我们给类型变量设定了上界，那么会从默认类型变成上界定义的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &lt;T <span class="keyword">extends</span> <span class="title class_">Number</span>&gt;&#123;   <span class="comment">//设定上界为Number</span></span><br><span class="line">    <span class="keyword">abstract</span> T <span class="title function_">test</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么编译之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">abstract</span> Number <span class="title function_">test</span><span class="params">(Number t)</span>;  <span class="comment">//上界Number，因为现在只可能出现Number的子类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，泛型其实仅仅是在编译阶段进行类型检查，当程序在运行时，并不会真的去检查对应类型，所以说哪怕是我们不去指定类型也可以直接使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();    <span class="comment">//对于泛型类Test，不指定具体类型也是可以的，默认就是原始类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过此时编译器会给出警告：</p><p><img src="https://s2.loli.net/2022/09/27/kVCIg3TilOuLFmj.png" alt="image-20220927131226728"></p><p>同样的，由于类型擦除，实际上我们在使用时，编译后的代码是进行了强制类型转换的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    A&lt;String&gt; a = <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    <span class="type">String</span>  <span class="variable">i</span> <span class="operator">=</span> a.test(<span class="string">&quot;10&quot;</span>);     <span class="comment">//因为类型A只有返回值为原始类型Object的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上编译之后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">B</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">i</span> <span class="operator">=</span> (String) a.test(<span class="string">&quot;10&quot;</span>);   <span class="comment">//依靠强制类型转换完成的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，我们思考一个问题，既然继承泛型类之后可以明确具体类型，那么为什么<code>@Override</code>不会出现错误呢？我们前面说了，重写的条件是需要和父类的返回值类型和形参一致，而泛型默认的原始类型是Object类型，子类明确后变为其他类型，这显然不满足重写的条件，但是为什么依然能编译通过呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span>&lt;String&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    String <span class="title function_">test</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看编译之后长啥样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compiled from &quot;B.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">com</span>.test.entity.B <span class="keyword">extends</span> <span class="title class_">com</span>.test.entity.A&lt;java.lang.String&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> com.test.entity.B();</span><br><span class="line">  java.lang.String <span class="title function_">test</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">  java.lang.Object <span class="title function_">test</span><span class="params">(java.lang.Object)</span>;   <span class="comment">//桥接方法，这才是真正重写的方法，但是使用时会调用上面的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过反编译进行观察，实际上是编译器帮助我们生成了一个桥接方法用于支持重写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">test</span><span class="params">(Object obj)</span> &#123;   <span class="comment">//这才是重写的桥接方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.test((Integer) obj);   <span class="comment">//桥接方法调用我们自己写的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">test</span><span class="params">(String str)</span> &#123;   <span class="comment">//我们自己写的方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型擦除机制其实就是为了方便使用后面集合类（不然每次都要强制类型转换）同时为了向下兼容采取的方案。因此，泛型的使用会有一些限制：</p><p>首先，在进行类型判断时，不允许使用泛型，只能使用原始类型：</p><p><img src="https://s2.loli.net/2022/09/27/q7DQ9lAweJLOFky.png" alt="image-20220927133232627"></p><p>只能判断是不是原始类型，里面的具体类型是不支持的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Test&lt;String&gt; test = <span class="keyword">new</span> <span class="title class_">Test</span>&lt;&gt;();</span><br><span class="line">System.out.println(test <span class="keyword">instanceof</span> Test);   <span class="comment">//在进行类型判断时，不允许使用泛型，只能使用原始类型</span></span><br></pre></td></tr></table></figure><p>还有，泛型类型是不支持创建参数化类型数组的：</p><p><img src="https://s2.loli.net/2022/09/27/7tK5APuSZovBLIc.png" alt="image-20220927133611288"></p><p>要用只能用原始类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Test[] test = <span class="keyword">new</span> <span class="title class_">Test</span>[<span class="number">10</span>];   <span class="comment">//同样是因为类型擦除导致的，运行时可不会去检查具体类型是什么</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过只是把它当做泛型类型的数组还是可以用的：</p><p><img src="https://s2.loli.net/2022/09/27/upjWbyq9XC5FLDv.png" alt="image-20220927134335255"></p><h3 id="函数式接口">函数式接口</h3><p>学习了泛型，我们来介绍一下再JDK 1.8中新增的函数式接口。</p><p>函数式接口就是JDK1.8专门为我们提供好的用于Lambda表达式的接口，这些接口都可以直接使用Lambda表达式，非常方便，这里我们主要介绍一下四个主要的函数式接口：</p><p><strong>Supplier供给型函数式接口：</strong> 这个接口是专门用于供给使用的，其中只有一个get方法用于获取需要的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span>   <span class="comment">//函数式接口都会打上这样一个注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Supplier</span>&lt;T&gt; &#123;</span><br><span class="line">    T <span class="title function_">get</span><span class="params">()</span>;   <span class="comment">//实现此方法，实现供给功能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们要实现一个专门供给Student对象Supplier，就可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是学生！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//专门供给Student对象的Supplier</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Supplier&lt;Student&gt; STUDENT_SUPPLIER = Student::<span class="keyword">new</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> STUDENT_SUPPLIER.get();</span><br><span class="line">    student.hello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Consumer消费型函数式接口：</strong> 这个接口专门用于消费某个对象的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(T t)</span>;    <span class="comment">//这个方法就是用于消费的，没有返回值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Consumer&lt;T&gt; <span class="title function_">andThen</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> T&gt; after)</span> &#123;   <span class="comment">//这个方法便于我们连续使用此消费接口</span></span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用起来也是很简单的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//专门消费Student对象的Consumer</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Consumer&lt;Student&gt; STUDENT_CONSUMER = student -&gt; System.out.println(student+<span class="string">&quot; 真好吃！&quot;</span>);</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    STUDENT_CONSUMER.accept(student);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们也可以使用<code>andThen</code>方法继续调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    STUDENT_CONSUMER   <span class="comment">//我们可以提前将消费之后的操作以同样的方式预定好</span></span><br><span class="line">            .andThen(stu -&gt; System.out.println(<span class="string">&quot;我是吃完之后的操作！&quot;</span>)) </span><br><span class="line">            .andThen(stu -&gt; System.out.println(<span class="string">&quot;好了好了，吃饱了！&quot;</span>))</span><br><span class="line">            .accept(student);   <span class="comment">//预定好之后，再执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，就可以在消费之后进行一些其他的处理了，使用很简洁的代码就可以实现：</p><p><img src="https://s2.loli.net/2022/09/27/Pu1jGzKNSvnV9YZ.png" alt="image-20220927181706365"></p><p><strong>Function函数型函数式接口：</strong> 这个接口消费一个对象，然后会向外供给一个对象（前两个的融合体）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Function</span>&lt;T, R&gt; &#123;</span><br><span class="line">    R <span class="title function_">apply</span><span class="params">(T t)</span>;   <span class="comment">//这里一共有两个类型参数，其中一个是接受的参数类型，还有一个是返回的结果类型</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; Function&lt;V, R&gt; <span class="title function_">compose</span><span class="params">(Function&lt;? <span class="built_in">super</span> V, ? extends T&gt; before)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; Function&lt;T, V&gt; <span class="title function_">andThen</span><span class="params">(Function&lt;? <span class="built_in">super</span> R, ? extends V&gt; after)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; Function&lt;T, T&gt; <span class="title function_">identity</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口方法有点多，我们一个一个来看，首先还是最基本的<code>apply</code>方法，这个是我们需要实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里实现了一个简单的功能，将传入的int参数转换为字符串的形式</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Function&lt;Integer, String&gt; INTEGER_STRING_FUNCTION = Object::toString;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> INTEGER_STRING_FUNCTION.apply(<span class="number">10</span>);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用<code>compose</code>将指定函数式的结果作为当前函数式的实参：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> INTEGER_STRING_FUNCTION</span><br><span class="line">            .compose((String s) -&gt; s.length())   <span class="comment">//将此函数式的返回值作为当前实现的实参</span></span><br><span class="line">            .apply(<span class="string">&quot;lbwnb&quot;</span>);   <span class="comment">//传入上面函数式需要的参数</span></span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相反的，<code>andThen</code>可以将当前实现的返回值进行进一步的处理，得到其他类型的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Boolean</span> <span class="variable">str</span> <span class="operator">=</span> INTEGER_STRING_FUNCTION</span><br><span class="line">            .andThen(String::isEmpty)   <span class="comment">//在执行完后，返回值作为参数执行andThen内的函数式，最后得到的结果就是最终的结果了</span></span><br><span class="line">            .apply(<span class="number">10</span>);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较有趣的是，Function中还提供了一个将传入参数原样返回的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Function&lt;String, String&gt; function = Function.identity();   <span class="comment">//原样返回</span></span><br><span class="line">    System.out.println(function.apply(<span class="string">&quot;不会吧不会吧，不会有人听到现在还是懵逼的吧&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Predicate断言型函数式接口：</strong> 接收一个参数，然后进行自定义判断并返回一个boolean结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Predicate</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">test</span><span class="params">(T t)</span>;    <span class="comment">//这个方法就是我们要实现的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">and</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">negate</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> Predicate&lt;T&gt; <span class="title function_">or</span><span class="params">(Predicate&lt;? <span class="built_in">super</span> T&gt; other)</span> &#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; Predicate&lt;T&gt; <span class="title function_">isEqual</span><span class="params">(Object targetRef)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以来编写一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> score;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Predicate&lt;Student&gt; STUDENT_PREDICATE = student -&gt; student.score &gt;= <span class="number">60</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    student.score = <span class="number">80</span>;</span><br><span class="line">    <span class="keyword">if</span>(STUDENT_PREDICATE.test(student)) &#123;  <span class="comment">//test方法的返回值是一个boolean结果</span></span><br><span class="line">        System.out.println(<span class="string">&quot;及格了，真不错，今晚奖励自己一次&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不是，Java都考不及格？隔壁初中生都在打ACM了&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以使用组合条件判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    student.score = <span class="number">80</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> STUDENT_PREDICATE</span><br><span class="line">            .and(stu -&gt; stu.score &gt; <span class="number">90</span>)   <span class="comment">//需要同时满足这里的条件，才能返回true</span></span><br><span class="line">            .test(student);</span><br><span class="line">    <span class="keyword">if</span>(!b) System.out.println(<span class="string">&quot;Java到现在都没考到90分？你的室友都拿国家奖学金了&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，这个类型提供了一个对应的实现，用于判断两个对象是否相等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Predicate&lt;String&gt; predicate = Predicate.isEqual(<span class="string">&quot;Hello World&quot;</span>);   <span class="comment">//这里传入的对象会和之后的进行比较</span></span><br><span class="line">    System.out.println(predicate.test(<span class="string">&quot;Hello World&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过使用这四个核心的函数式接口，我们就可以使得代码更加简洁，具体的使用场景会在后面讲解。</p><h3 id="判空包装">判空包装</h3><p>Java8还新增了一个非常重要的判空包装类Optional，这个类可以很有效的处理空指针问题。</p><p>比如对于下面这样一个很简单的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str)</span>&#123;   <span class="comment">//传入字符串，如果不是空串，那么就打印长度</span></span><br><span class="line">    <span class="keyword">if</span>(!str.isEmpty()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串长度为：&quot;</span>+str.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果我们在传入参数时，丢个null进去，直接原地爆炸：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str)</span>&#123; </span><br><span class="line">    <span class="keyword">if</span>(!str.isEmpty()) &#123;   <span class="comment">//此时传入的值为null，调用方法马上得到空指针异常</span></span><br><span class="line">        System.out.println(<span class="string">&quot;字符串长度为：&quot;</span>+str.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此我们还需要在使用之前进行判空操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(str == <span class="literal">null</span>) <span class="keyword">return</span>;   <span class="comment">//这样就可以防止null导致的异常了</span></span><br><span class="line">    <span class="keyword">if</span>(!str.isEmpty()) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;字符串长度为：&quot;</span>+str.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这种方式很好，但是在Java8之后，有了Optional类，它可以更加优雅地处理这种问题，我们来看看如何使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str)</span>&#123;</span><br><span class="line">    Optional</span><br><span class="line">            .ofNullable(str)   <span class="comment">//将传入的对象包装进Optional中</span></span><br><span class="line">            .ifPresent(s -&gt; System.out.println(<span class="string">&quot;字符串长度为：&quot;</span>+s.length()));  </span><br><span class="line">  <span class="comment">//如果不为空，则执行这里的Consumer实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优雅，真是太优雅了，同样的功能，现在我们只需要两行就搞定了，而且代码相当简洁。如果你学习过JavaScript或是Kotlin等语言，它的语法就像是：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str : String? = <span class="literal">null</span></span><br><span class="line">str?.upperCase()</span><br></pre></td></tr></table></figure><p>并且，包装之后，我们再获取时可以优雅地处理为空的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Optional.ofNullable(str).get();   <span class="comment">//get方法可以获取被包装的对象引用，但是如果为空的话，会抛出异常</span></span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以对于这种有可能为空的情况进行处理，如果为空，那么就返回另一个备选方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str)</span>&#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> Optional.ofNullable(str).orElse(<span class="string">&quot;我是为null的情况备选方案&quot;</span>);</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉很方便？我们还可以将包装的类型直接转换为另一种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String str)</span>&#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Optional</span><br><span class="line">            .ofNullable(str)</span><br><span class="line">            .map(String::length)   <span class="comment">//使用map来进行映射，将当前类型转换为其他类型，或者是进行处理</span></span><br><span class="line">            .orElse(-<span class="number">1</span>);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，Optional的方法比较多，这里就不一一介绍了。</p><hr><h2 id="数据结构基础">数据结构基础</h2><p><strong>注意：</strong> 本部分内容难度很大，推荐计算机专业课程《数据结构与算法》作为前置学习课程。本部分介绍数据结构只是为了为后面的集合类型做准备。</p><p>学习集合类之前，我们还有最关键的内容需要学习，同第二章一样，自底向上才是最佳的学习方向，比起直接带大家认识集合类，不如先了解一下数据结构，只有了解了数据结构基础，才能更好地学习集合类，同时，数据结构也是你以后深入学习JDK源码的必备条件（学习不要快餐式）当然，我们主要是讲解Java，数据结构作为铺垫作用，所以我们只会讲解关键的部分，其他部分可以在数据结构与算法篇视频教程中详细学习。</p><blockquote><p>在计算机科学中，数据结构是一种数据组织、管理和存储的格式,它可以帮助我们实现对数据高效的访问和修改。更准确地说,数据结构是数据值的集合，可以体现数据值之间的关系，以及可以对数据进行应用的函数或操作。</p></blockquote><p>通俗地说，我们需要去学习在计算机中如何去更好地管理我们的数据，才能让我们对我们的数据控制更加灵活！</p><p><img src="https://s2.loli.net/2022/07/10/9RwL7pxgyfoB3WT.png" alt="image-20220710103307583"></p><p>比如现在我们需要保存100个学生的数据，那么你首先想到的肯定是使用数组吧！没错，没有什么比数组更适合存放这100个学生的数据了，但是如果我们现在有了新的需求呢？我们不仅仅是存放这些数据，我们还希望能够将这些数据按顺序存放，支持在某个位置插入一条数据、删除一条数据、修改一条数据等，这时候，数组就显得有些乏力了。</p><p>数组无法做到这么高级的功能，那么我们就需要定义一种更加高级的数据结构来做到，我们可以使用线性表（Linear List）</p><blockquote><p>线性表是由同一类型的数据元素构成的有序序列的线性结构。线性表中元素的个数就是线性表的长度，表的起始位置称为表头，表的结束位置称为表尾，当一个线性表中没有元素时，称为空表。</p></blockquote><p>线性表一般需要包含以下功能：</p><ul><li><strong>获取指定位置上的元素：</strong> 直接获取线性表指定位置<code>i</code>上的元素。</li><li><strong>插入元素：</strong> 在指定位置<code>i</code>上插入一个元素。</li><li><strong>删除元素：</strong> 删除指定位置<code>i</code>上的一个元素。</li><li><strong>获取长度：</strong> 返回线性表的长度。</li></ul><p>也就是说，现在我们需要设计的是一种功能完善的表结构，它不像是数组那么低级，而是真正意义上的表：</p><p><img src="https://s2.loli.net/2022/07/23/Ve6dlqROzhumD5o.png" alt="image-20220723112639416"></p><p>简单来说它就是列表，比如我们的菜单，我们在点菜时就需要往菜单列表中添加菜品或是删除菜品，这时列表就很有用了，因为数组长度固定、操作简单，而我们添加菜品、删除菜品这些操作又要求长度动态变化、操作多样。</p><p>那么，如此高级的数据结构，我们该如何去实现呢？实现线性表的结构一般有两种，一种是顺序存储实现，还有一种是链式存储实现，我们先来看第一种，也是最简单的的一种。</p><h3 id="线性表：顺序表">线性表：顺序表</h3><p>前面我们说到，既然数组无法实现这样的高级表结构，那么我就基于数组，对其进行强化，也就是说，我们存放数据还是使用数组，但是我们可以为其编写一些额外的操作来强化为线性表，像这样底层依然采用顺序存储实现的线性表，我们称为顺序表。</p><p><img src="https://s2.loli.net/2022/07/24/elBvx4Zo1AJ2WqT.png" alt="image-20220724150015044"></p><p>这里我们可以先定义一个新的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;E&gt; &#123;   <span class="comment">//泛型E，因为表中要存的具体数据类型待定</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">capacity</span> <span class="operator">=</span> <span class="number">10</span>;   <span class="comment">//当前顺序表的容量</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//当前已经存放的元素数量</span></span><br><span class="line">    <span class="keyword">private</span> Object[] array = <span class="keyword">new</span> <span class="title class_">Object</span>[capacity];   <span class="comment">//底层存放数据的数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺序表的插入和删除操作，其实就是：</p><p><img src="https://s2.loli.net/2022/09/27/24Glc7UQjLt5Wny.jpg" alt="67813f22-3607-4351-934d-f8127e6ba15a"></p><p>当插入元素时，需要将插入位置给腾出来，也就是将后面的所有元素向后移，同样的，如果要删除元素，那么也需要将所有的元素向前移动，顺序表是紧凑的，不能出现空位。</p><p>所以说我们可以来尝试实现一下，首先是插入方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element, <span class="type">int</span> index)</span>&#123;   <span class="comment">//插入方法需要支持在指定下标位置插入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size; i &gt; index; i--)   <span class="comment">//从后往前，一个一个搬运元素</span></span><br><span class="line">        array[i] = array[i - <span class="number">1</span>];</span><br><span class="line">    array[index] = element;   <span class="comment">//腾出位置之后，直接插入元素放到对应位置上</span></span><br><span class="line">    size++;   <span class="comment">//插入完成之后，记得将size自增</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过这样并不完美，因为我们的插入操作并不是在任何位置都支持插入的，我们允许插入的位置只能是 [0, size] 这个范围内</p><p><img src="https://s2.loli.net/2022/07/23/H67F1crBhqQiXxg.png" alt="image-20220723153933279"></p><p>所以说我们需要在插入之前进行判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size)    <span class="comment">//插入之前先判断插入位置是否合法</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;插入位置非法，合法的插入位置为：0 ~ &quot;</span>+size);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size; i &gt; index; i--)</span><br><span class="line">        array[i] = array[i - <span class="number">1</span>];</span><br><span class="line">    array[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">10</span>, <span class="number">1</span>);    <span class="comment">//一上来只能在第一个位置插入，第二个位置肯定是非法的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是就成功得到异常：</p><p><img src="https://s2.loli.net/2022/09/27/rtkRMaWseE2Cm1z.png" alt="image-20220927211134905"></p><p>只不过依然不够完美，万一我们的顺序表装满了咋办？所以说，我们在插入元素之前，需要进行判断，如果已经装满了，那么我们需要先扩容之后才能继续插入新的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;插入位置非法，合法的插入位置为：0 ~ &quot;</span>+size);</span><br><span class="line">    <span class="keyword">if</span>(capacity == size) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> capacity + (capacity &gt;&gt; <span class="number">1</span>);   <span class="comment">//扩容规则就按照原本容量的1.5倍来吧</span></span><br><span class="line">        Object[] newArray = <span class="keyword">new</span> <span class="title class_">Object</span>[newCapacity];    <span class="comment">//创建一个新的数组来存放更多的元素</span></span><br><span class="line">        System.arraycopy(array, <span class="number">0</span>, newArray, <span class="number">0</span>, size);   <span class="comment">//使用arraycopy快速拷贝原数组内容到新的数组</span></span><br><span class="line">        array = newArray;   <span class="comment">//更换为新的数组</span></span><br><span class="line">      capacity = newCapacity;   <span class="comment">//容量变成扩容之后的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size; i &gt; index; i--)</span><br><span class="line">        array[i] = array[i - <span class="number">1</span>];</span><br><span class="line">    array[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来重写一下<code>toString</code>方法打印当前存放的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) builder.append(array[i]).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们的底层数组会自动扩容，便于我们使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">20</span>; i++)</span><br><span class="line">        list.add(i, i);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/27/6SMZxC5QI3cgXYk.png" alt="image-20220927212426959"></p><p>我们接着来看删除操作，其实操作差不多，只需要将后面的覆盖到前面就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span>   <span class="comment">//屏蔽未经检查警告</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>&#123;   <span class="comment">//删除对应位置上的元素，注意需要返回被删除的元素</span></span><br><span class="line">    <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) array[index];   <span class="comment">//因为存放的是Object类型，这里需要强制类型转换为E</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; size; i++)   <span class="comment">//从前往后，挨个往前搬一位</span></span><br><span class="line">        array[i] = array[i + <span class="number">1</span>];</span><br><span class="line">    size--;    <span class="comment">//删完记得将size--</span></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，我们需要对删除的合法范围进行判断：</p><p><img src="https://s2.loli.net/2022/07/23/uHBjUfKpd9ygScW.png" alt="image-20220723160901921"></p><p>所以说我们也来进行一下判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;删除位置非法，合法的插入位置为：0 ~ &quot;</span>+(size - <span class="number">1</span>));</span><br><span class="line">    <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> (E) array[index];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt; size; i++)</span><br><span class="line">        array[i] = array[i + <span class="number">1</span>];</span><br><span class="line">    size--;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为删除不需要考虑容量的问题，所以说这里的删除操作就编写完成了。</p><p>当然，我们还得支持获取指定下标位置上的元素，这个就简单了，直接从数组中那就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>)   <span class="comment">//在插入之前同样要进行范围检查</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;非法的位置，合法的位置为：0 ~ &quot;</span>+(size - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> (E) array[index];   <span class="comment">//直接返回就完事</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;   <span class="comment">//获取当前存放的元素数量</span></span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉顺便表其实还是挺简单的，也就是一个数组多了一些操作罢了。</p><h3 id="线性表：链表">线性表：链表</h3><p>前面我们介绍了如何使用数组实现线性表，我们接着来看第二种方式，我们可以使用链表来实现，那么什么是链表呢？</p><p><img src="https://s2.loli.net/2022/07/23/ruemiRQplVy7q9s.png" alt="image-20220723171648380"></p><p>链表不同于顺序表，顺序表底层采用数组作为存储容器，需要分配一块连续且完整的内存空间进行使用，而链表则不需要，它通过一个指针来连接各个分散的结点，形成了一个链状的结构，每个结点存放一个元素，以及一个指向下一个结点的指针，通过这样一个一个相连，最后形成了链表。它不需要申请连续的空间，只需要按照顺序连接即可，虽然物理上可能不相邻，但是在逻辑上依然是每个元素相邻存放的，这样的结构叫做链表（单链表）。</p><p>链表分为带头结点的链表和不带头结点的链表，戴头结点的链表就是会有一个头结点指向后续的整个链表，但是头结点不存放数据：</p><p><img src="https://s2.loli.net/2022/07/23/gRUEfOqbtrGN2JZ.png" alt="image-20220723180221112"></p><p>而不带头结点的链表就像上面那样，第一个节点就是存放数据的结点，一般设计链表都会采用带头结点的结构，因为操作更加方便。</p><p>我们来尝试定义一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedList</span>&lt;E&gt; &#123;</span><br><span class="line">  <span class="comment">//链表的头结点，用于连接之后的所有结点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;E&gt; head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//当前的元素数量还是要存一下，方便后面操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;  <span class="comment">//结点类，仅供内部使用</span></span><br><span class="line">        E element;   <span class="comment">//每个结点都存放元素</span></span><br><span class="line">        Node&lt;E&gt; next;   <span class="comment">//以及指向下一个结点的引用</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E element)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.element = element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来设计一下链表的插入和删除，我们前面实现了顺序表的插入，那么链表的插入该怎么做呢？</p><p><img src="https://s2.loli.net/2022/07/23/71dgFSWDfoELiXB.png" alt="image-20220723175548491"></p><p>我们可以先修改新插入的结点的后继结点（也就是下一个结点）指向，指向原本在这个位置的结点：</p><p><img src="https://s2.loli.net/2022/07/23/8MNURYiacWZqwu6.png" alt="image-20220723220552680"></p><p>接着我们可以将前驱结点（也就是上一个结点）的后继结点指向修改为我们新插入的结点：</p><p><img src="https://s2.loli.net/2022/07/23/ysETUJb6cgBz2Qx.png" alt="image-20220723175745472"></p><p>这样，我们就成功插入了一个新的结点，现在新插入的结点到达了原本的第二个位置上：</p><p><img src="https://s2.loli.net/2022/07/23/Kb7jCiWa3o4AN8D.png" alt="image-20220723175842075"></p><p>按照这个思路，我们来实现一下，首先设计一下方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    Node&lt;E&gt; prev = head;   <span class="comment">//先找到对应位置的前驱结点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++) </span><br><span class="line">        prev = prev.next;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(element);   <span class="comment">//创建新的结点</span></span><br><span class="line">    node.next = prev.next;   <span class="comment">//先让新的节点指向原本在这个位置上的结点</span></span><br><span class="line">    prev.next = node;   <span class="comment">//然后让前驱结点指向当前结点</span></span><br><span class="line">    size++;   <span class="comment">//完事之后一样的，更新size</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来重写一下toString方法看看能否正常插入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    Node&lt;E&gt; node = head.next;   <span class="comment">//从第一个结点开始，一个一个遍历，遍历一个就拼接到字符串上去</span></span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">        builder.append(node.element).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们的插入操作是可以正常工作的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    list.add(<span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    list.add(<span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line">    list.add(<span class="number">20</span>, <span class="number">1</span>);</span><br><span class="line">    System.out.println(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/27/Mpj9azwWciemAZY.png" alt="image-20220927235051844"></p><p>只不过还不够完美，跟之前一样，我们还得考虑插入位置是否合法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(E element, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;插入位置非法，合法的插入位置为：0 ~ &quot;</span>+size);</span><br><span class="line">    Node&lt;E&gt; prev = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(element);</span><br><span class="line">    node.next = prev.next;</span><br><span class="line">    prev.next = node;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入操作完成之后，我们接着来看删除操作，那么我们如何实现删除操作呢？实际上也会更简单一些，我们可以直接将待删除节点的前驱结点指向修改为待删除节点的下一个：</p><p><img src="https://s2.loli.net/2022/07/23/N5sZx9T2a8lOzoC.png" alt="image-20220723222922058"></p><p><img src="https://s2.loli.net/2022/07/23/tNYnBJe9pczUq1Z.png" alt="image-20220723223103306"></p><p>这样，在逻辑上来说，待删除结点其实已经不在链表中了，所以我们只需要释放掉待删除结点占用的内存空间就行了：</p><p><img src="https://s2.loli.net/2022/07/23/MFE2gZuS5eOysDW.png" alt="image-20220723223216420"></p><p>那么我们就按照这个思路来编写一下程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>)   <span class="comment">//同样的，先判断位置是否合法</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;删除位置非法，合法的删除位置为：0 ~ &quot;</span>+(size - <span class="number">1</span>));</span><br><span class="line">    Node&lt;E&gt; prev = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; index; i++)   <span class="comment">//同样需要先找到前驱结点</span></span><br><span class="line">        prev = prev.next;</span><br><span class="line">    <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> prev.next.element;   <span class="comment">//先把待删除结点存放的元素取出来</span></span><br><span class="line">    prev.next = prev.next.next;  <span class="comment">//可以删了</span></span><br><span class="line">    size--;   <span class="comment">//记得size--</span></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉还是挺简单的？这样，我们就成功完成了链表的删除操作。</p><p>我们接着来实现一下获取对应位置上的元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(index &lt; <span class="number">0</span> || index &gt; size - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;非法的位置，合法的位置为：0 ~ &quot;</span>+(size - <span class="number">1</span>));</span><br><span class="line">    Node&lt;E&gt; node = head;</span><br><span class="line">    <span class="keyword">while</span> (index-- &gt;= <span class="number">0</span>)   <span class="comment">//这里直接让index减到-1为止</span></span><br><span class="line">        node = node.next;</span><br><span class="line">    <span class="keyword">return</span> node.element;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们的链表就编写完成了，实际上只要理解了那种结构，其实还是挺简单的。</p><p><strong>问题</strong>：什么情况下使用顺序表，什么情况下使用链表呢？</p><ul><li>通过分析顺序表和链表的特性我们不难发现，链表在随机访问元素时，需要通过遍历来完成，而顺序表则利用数组的特性直接访问得到，所以，当我们读取数据多于插入或是删除数据的情况下时，使用顺序表会更好。</li><li>而顺序表在插入元素时就显得有些鸡肋了，因为需要移动后续元素，整个移动操作会浪费时间，而链表则不需要，只需要修改结点 指向即可完成插入，所以在频繁出现插入或删除的情况下，使用链表会更好。</li></ul><p>虽然单链表使用起来也比较方便，不过有一个问题就是，如果我们想要操作某一个结点，比如删除或是插入，那么由于单链表的性质，我们只能先去找到它的前驱结点，才能进行。为了解决这种查找前驱结点非常麻烦的问题，我们可以让结点不仅保存指向后续结点的指针，同时也保存指向前驱结点的指针：</p><p><img src="https://s2.loli.net/2022/07/24/oeXm6nyW7I9lPMf.png" alt="image-20220724123947104"></p><p>这样我们无论在哪个结点，都能够快速找到对应的前驱结点，就很方便了，这样的链表我们成为双向链表（双链表）</p><h3 id="线性表：栈">线性表：栈</h3><p>栈（也叫堆栈，Stack）是一种特殊的线性表，它只能在在表尾进行插入和删除操作，就像下面这样：</p><p><img src="https://s2.loli.net/2022/07/24/D3heysaM9EpAgS4.png" alt="image-20220724210955622"></p><p>也就是说，我们只能在一端进行插入和删除，当我们依次插入1、2、3、4这四个元素后，连续进行四次删除操作，删除的顺序刚好相反：4、3、2、1，我们一般将其竖着看：</p><p><img src="https://s2.loli.net/2022/07/24/2NxUpCIRLoZt9Ky.png" alt="image-20220724211442421"></p><p>底部称为栈底，顶部称为栈顶，所有的操作只能在栈顶进行，也就是说，被压在下方的元素，只能等待其上方的元素出栈之后才能取出，就像我们往箱子里里面放的书一样，因为只有一个口取出里面的物品，所以被压在下面的书只能等上面的书被拿出来之后才能取出，这就是栈的思想，它是一种先进后出的数据结构（FILO，First In, Last Out）</p><p>实现栈也是非常简单的，可以基于我们前面的顺序表或是链表，这里我们需要实现两个新的操作：</p><ul><li>pop：出栈操作，从栈顶取出一个元素。</li><li>push：入栈操作，向栈中压入一个新的元素。</li></ul><p>栈可以使用顺序表实现，也可以使用链表实现，这里我们就使用链表，实际上使用链表会更加的方便，我们可以直接将头结点指向栈顶结点，而栈顶结点连接后续的栈内结点：</p><p><img src="https://s2.loli.net/2022/07/24/outf2S7D3WzQK8c.png" alt="image-20220724222836333"></p><p>当有新的元素入栈，只需要在链表头部插入新的结点即可，我们来尝试编写一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedStack</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;E&gt; head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>);   <span class="comment">//大体内容跟链表类似</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E element;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E element)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.element = element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来编写一下入栈操作：</p><p><img src="https://s2.loli.net/2022/07/24/GdBj3g5YRFzSsVw.png" alt="image-20220724223550553"></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(E element)</span>&#123;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(element);   <span class="comment">//直接创建新结点</span></span><br><span class="line">    node.next = head.next;    <span class="comment">//新结点的下一个变成原本的栈顶结点</span></span><br><span class="line">    head.next = node;     <span class="comment">//头结点的下一个改成新的结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就可以轻松实现入栈操作了。其实出栈也是同理，所以我们只需要将第一个元素移除即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> E <span class="title function_">pop</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head.next == <span class="literal">null</span>)   <span class="comment">//如果栈已经没有元素了，那么肯定是没办法取的</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;栈为空&quot;</span>);</span><br><span class="line">    <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> head.next.element;   <span class="comment">//先把待出栈元素取出来</span></span><br><span class="line">    head.next = head.next.next;   <span class="comment">//直接让头结点的下一个指向下一个的下一个</span></span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    LinkedStack&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedStack</span>&lt;&gt;();</span><br><span class="line">    stack.push(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    stack.push(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">    stack.push(<span class="string">&quot;CCC&quot;</span>);</span><br><span class="line">    System.out.println(stack.pop());</span><br><span class="line">    System.out.println(stack.pop());</span><br><span class="line">    System.out.println(stack.pop());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，入栈顺序和出栈顺序是完全相反的：</p><p><img src="https://s2.loli.net/2022/09/28/yaWmfPDU63X8BQn.png" alt="image-20220928101152179"></p><p>其实还是挺简单的。</p><h3 id="线性表：队列">线性表：队列</h3><p>前面我们学习了栈，栈中元素只能栈顶出入，它是一种特殊的线性表，同样的，队列（Queue）也是一种特殊的线性表。</p><p>就像我们在超市、食堂需要排队一样，我们总是排成一列，先到的人就排在前面，后来的人就排在后面，越前面的人越先完成任务，这就是队列，队列有队头和队尾：</p><p><img src="https://s2.loli.net/2022/07/25/xBuZckTNtR54AEq.png" alt="image-20220725103600318"></p><p>秉承先来后到的原则，队列中的元素只能从队尾进入，只能从队首出去，也就是说，入队顺序为1、2、3、4，那么出队顺序也一定是1、2、3、4，所以队列是一种先进先出（FIFO，First In, First Out）的数据结构。</p><p>队列也可以使用链表和顺序表来实现，只不过使用链表的话就不需要关心容量之类的问题了，会更加灵活一些：</p><p><img src="https://s2.loli.net/2022/07/25/lwGgHXqAV5z2KNk.png" alt="image-20220725145214955"></p><p>注意我们需要同时保存队首和队尾两个指针，因为是单链表，所以队首需要存放指向头结点的指针，因为需要的是前驱结点，而队尾则直接是指向尾结点的指针即可，后面只需要直接在后面拼接就行。</p><p>当有新的元素入队时，只需要拼在队尾就行了，同时队尾指针也要后移一位：</p><p><img src="https://s2.loli.net/2022/07/25/ufmFEwrS9xVKoIZ.png" alt="image-20220725145608827"></p><p>出队时，只需要移除队首指向的下一个元素即可：</p><p><img src="https://s2.loli.net/2022/07/25/geJRFwHKhGT69XD.png" alt="image-20220725145707707"></p><p>那么我们就按照这个思路，来编写一下代码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedQueue</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;E&gt; head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(E element)</span>&#123;  <span class="comment">//入队操作</span></span><br><span class="line">        Node&lt;E&gt; last = head;</span><br><span class="line">        <span class="keyword">while</span> (last.next != <span class="literal">null</span>)   <span class="comment">//入队直接丢到最后一个结点的屁股后面就行了</span></span><br><span class="line">            last = last.next;</span><br><span class="line">        last.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span>&#123;   <span class="comment">//出队操作</span></span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>)   <span class="comment">//如果队列已经没有元素了，那么肯定是没办法取的</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> head.next.element;</span><br><span class="line">        head.next = head.next.next;   <span class="comment">//直接从队首取出</span></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E element;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E element)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.element = element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实使用起来还是挺简单的，我们来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    LinkedQueue&lt;String&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedQueue</span>&lt;&gt;();</span><br><span class="line">    stack.offer(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line">    stack.offer(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">    stack.offer(<span class="string">&quot;CCC&quot;</span>);</span><br><span class="line">    System.out.println(stack.poll());</span><br><span class="line">    System.out.println(stack.poll());</span><br><span class="line">    System.out.println(stack.poll());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/28/FUS1Rc8JuEMT6bq.png" alt="image-20220928154121872"></p><p>可以看到，队列遵从先进先出，入队顺序和出队顺序是一样的。</p><h3 id="树：二叉树">树：二叉树</h3><p>树是一种全新的数据结构，它就像一棵树的树枝一样，不断延伸。</p><p><img src="https://s2.loli.net/2022/08/08/NajFZzXHxUCDQBW.png" alt="树枝666"></p><p>在我们的程序中，想要表示出一棵树，就可以像下面这样连接：</p><p><img src="https://s2.loli.net/2022/08/01/aoBjrR5bPqWzCel.png" alt="image-20220801210920230"></p><p>可以看到，现在一个结点下面可能会连接多个节点，并不断延伸，就像树枝一样，每个结点都有可能是一个分支点，延伸出多个分支，从位于最上方的结点开始不断向下，而这种数据结构，我们就称为<strong>树</strong>（Tree）注意分支只能向后单独延伸，之后就分道扬镳了，<strong>不能与其他分支上的结点相交！</strong></p><ul><li>我们一般称位于最上方的结点为树的<strong>根结点</strong>（Root）因为整棵树正是从这里开始延伸出去的。</li><li>每个结点连接的子结点数目（分支的数目），我们称为结点的<strong>度</strong>（Degree），而各个结点度的最大值称为树的度。</li><li>每个结点延伸下去的下一个结点都可以称为一棵<strong>子树</strong>（SubTree）比如结点<code>B</code>及其之后延伸的所有分支合在一起，就是一棵<code>A</code>的子树。</li><li>每个<strong>结点的层次</strong>（Level）按照从上往下的顺序，树的根结点为<code>1</code>，每向下一层<code>+1</code>，比如<code>G</code>的层次就是<code>3</code>，整棵树中所有结点的最大层次，就是这颗<strong>树的深度</strong>（Depth），比如上面这棵树的深度为4，因为最大层次就是4。</li></ul><p>由于整棵树错综复杂，所以说我们需要先规定一下结点之间的称呼，就像族谱那样：</p><ul><li>与当前结点直接向下相连的结点，我们称为<strong>子结点</strong>（Child），比如<code>B、C、D</code>结点，都是<code>A</code>的子结点，就像族谱中的父子关系一样，下一代一定是子女，相反的，那么<code>A</code>就是<code>B、C、D</code>的<strong>父结点</strong>（Parent），也可以叫双亲结点。</li><li>如果某个节点没有任何的子结点（结点度为0时）那么我们称这个结点为<strong>叶子结点</strong>（因为已经到头了，后面没有分支了，这时就该树枝上长叶子了那样）比如<code>K、L、F、G、M、I、J</code>结点，都是叶子结点。</li><li>如果两个结点的父结点是同一个，那么称这两个节点为<strong>兄弟结点</strong>（Sibling）比如<code>B</code>和<code>C</code>就是兄弟结点，因为都是<code>A</code>的孩子。</li><li>从根结点开始一直到某个结点的整条路径的所有结点，都是这个结点的<strong>祖先结点</strong>（Ancestor）比如<code>L</code>的祖先结点就是<code>A、B、E</code></li></ul><p>那么在了解了树的相关称呼之后，相信各位就应该对树有了一定的了解，虽然概念比较多，但是还请各位一定记住，不然后面就容易听懵。</p><p>而我们本章需要着重讨论的是<strong>二叉树</strong>（Binary Tree）它是一种特殊的树，它的度最大只能为<code>2</code>，所以我们称其为二叉树，一棵二叉树大概长这样：</p><p><img src="https://s2.loli.net/2022/08/01/QGLfnYWFby37deP.png" alt="image-20220801224008266"></p><p>并且二叉树任何结点的子树是有左右之分的，不能颠倒顺序，比如A结点左边的子树，称为左子树，右边的子树称为右子树。</p><p>当然，对于某些二叉树我们有特别的称呼，比如，在一棵二叉树中，所有分支结点都存在左子树和右子树，且叶子结点都在同一层：</p><p><img src="https://s2.loli.net/2022/08/01/btfjlJhDuWrSXYi.png" alt="image-20220801231216578"></p><p>这样的二叉树我们称为<strong>满二叉树</strong>，可以看到整棵树都是很饱满的，没有出现任何度为1的结点，当然，还有一种特殊情况：</p><p><img src="https://s2.loli.net/2022/08/01/QGLfnYWFby37deP.png" alt="image-20220801224008266"></p><p>可以看到只有最后一层有空缺，并且所有的叶子结点是按照从左往右的顺序排列的，这样的二叉树我们一般称其为<strong>完全二叉树</strong>，所以，一棵满二叉树，一定是一棵完全二叉树。</p><p>我们接着来看看二叉树在程序中的表示形式，我们在前面使用链表的时候，每个结点不仅存放对应的数据，而且会存放一个指向下一个结点的引用：</p><p><img src="https://s2.loli.net/2022/07/23/ruemiRQplVy7q9s.png" alt="image-20220723171648380"></p><p>而二叉树也可以使用这样的链式存储形式，只不过现在一个结点需要存放一个指向左子树的引用和一个指向右子树的引用了：</p><p><img src="https://s2.loli.net/2022/08/06/H9MqkghmAjFJnuO.png" alt="image-20220806111610082"></p><p>通过这种方式，我们就可以通过连接不同的结点形成一颗二叉树了，这样也更便于我们去理解它，我们首先定义一个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> E element;</span><br><span class="line">    <span class="keyword">public</span> TreeNode&lt;E&gt; left, right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(E element)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.element = element;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们现在想要构建一颗像这样的二叉树：</p><p><img src="https://s2.loli.net/2022/08/05/uan6A3ZRLykt289.png" alt="image-20220805231744693"></p><p>首先我们需要创建好这几个结点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    TreeNode&lt;Character&gt; a = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; b = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; c = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; d = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; e = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们从最上面开始，挨着进行连接，首先是A这个结点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    a.left = b;</span><br><span class="line">    a.right = c;</span><br><span class="line">    b.left = d;</span><br><span class="line">    b.right = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，我们就成功构建好了这棵二叉树，比如现在我们想通过根结点访问到D：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(a.left.left.element);</span><br></pre></td></tr></table></figure><p>断点调试也可以看的很清楚：</p><p><img src="https://s2.loli.net/2022/09/30/XCkDxVBFz2bWph8.png" alt="image-20220930160452608"></p><p>这样，我们就通过使用链式结构，成功构建出了一棵二叉树，接着我们来看看如何遍历一棵二叉树，也就是说我们想要访问二叉树的每一个结点，由于树形结构特殊，遍历顺序并不唯一，所以一共有四种访问方式：**前序遍历、中序遍历、后序遍历、层序遍历。**不同的访问方式输出都结点顺序也不同。</p><p>首先我们来看最简单的前序遍历：</p><p><img src="https://s2.loli.net/2022/08/06/G6ujstSVZ2XWJLE.png" alt="image-20220806171459056"></p><p>前序遍历是一种勇往直前的态度，走到哪就遍历到那里，先走左边再走右边，比如上面的这个图，首先会从根节点开始：</p><p><img src="https://s2.loli.net/2022/08/06/qCFMosHtujEZ3U6.png" alt="image-20220806171431845"></p><p>从A开始，先左后右，那么下一个就是B，然后继续走左边，是D，现在ABD走完之后，B的左边结束了，那么就要开始B的右边了，所以下一个是E，E结束之后，现在A的左子树已经全部遍历完成了，然后就是右边，接着就是C，C没有左子树了，那么只能走右边了，最后输出F，所以上面这个二叉树的前序遍历结果为：ABDECF</p><ol><li>打印根节点</li><li>前序遍历左子树</li><li>前序遍历右子树</li></ol><p>我们不难发现规律，整棵二叉树（包括子树）的根节点一定是出现在最前面的，比如A在最前面，A的左子树根结点B也是在最前面的。我们现在就来尝试编写一下代码实现一下，先把二叉树构建出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    TreeNode&lt;Character&gt; a = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; b = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;B&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; c = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;C&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; d = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;D&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; e = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;E&#x27;</span>);</span><br><span class="line">    TreeNode&lt;Character&gt; f = <span class="keyword">new</span> <span class="title class_">TreeNode</span>&lt;&gt;(<span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">    a.left = b;</span><br><span class="line">    a.right = c;</span><br><span class="line">    b.left = d;</span><br><span class="line">    b.right = e;</span><br><span class="line">    c.right = f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组装好之后，我们来实现一下前序遍历的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode&lt;T&gt; root)</span>&#123;</span><br><span class="line">    System.out.print(root.element + <span class="string">&quot; &quot;</span>);   <span class="comment">//首先肯定要打印，这个是必须的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印完成之后，我们就按照先左后右的规则往后遍历下一个结点，这里我们就直接使用递归来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode&lt;T&gt; root)</span>&#123;</span><br><span class="line">    System.out.print(root.element + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    preOrder(root.left);    <span class="comment">//先走左边</span></span><br><span class="line">    preOrder(root.right);   <span class="comment">//再走右边</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过还没完，我们的递归肯定是需要一个终止条件的，不可能无限地进行下去，如果已经走到底了，那么就不能再往下走了，所以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">preOrder</span><span class="params">(TreeNode&lt;T&gt; root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    System.out.print(root.element);</span><br><span class="line">    preOrder(root.left);</span><br><span class="line">    preOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    preOrder(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到结果为：</p><p><img src="https://s2.loli.net/2022/08/06/hZ8qEfWaP5o6L2j.png" alt="image-20220806173227580"></p><p>这样我们就通过一个简单的递归操作完成了对一棵二叉树的前序遍历，如果不太好理解，建议结合调试进行观察。</p><p>那么前序遍历我们了解完了，接着就是中序遍历了，中序遍历在顺序上与前序遍历不同，前序遍历是走到哪就打印到哪，而中序遍历需要先完成整个左子树的遍历后再打印，然后再遍历其右子树。</p><p>我们还是以上面的二叉树为例：</p><p><img src="https://s2.loli.net/2022/08/06/W6Yb5M92gQApNJa.png" alt="image-20220806230603967"></p><p>首先需要先不断遍历左子树，走到最底部，但是沿途并不进行打印，而是到底之后，再打印，所以第一个打印的是D，接着由于没有右子树，所以我们回到B，此时再打印B，然后再去看B的右结点E，由于没有左子树和右子树了，所以直接打印E，左边遍历完成，接着回到A，打印A，然后对A的右子树重复上述操作。所以说遍历的基本规则还是一样的，只是打印值的时机发生了改变。</p><ol><li>中序遍历左子树</li><li>打印结点</li><li>中序遍历右子树</li></ol><p>所以这棵二叉树的中序遍历结果为：DBEACF，我们可以发现一个规律，就是在某个结点的左子树中所有结点，其中序遍历结果也是按照这样的规律排列的，比如A的左子树中所有结点，中序遍历结果中全部都在A的左边，右子树中所有的结点，全部都在A的右边（这个规律很关键，后面在做一些算法题时会用到）</p><p>那么怎么才能将打印调整到左子树全部遍历结束之后呢？其实很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode&lt;T&gt; root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    inOrder(root.left);    <span class="comment">//先完成全部左子树的遍历</span></span><br><span class="line">    System.out.print(root.element);    <span class="comment">//等待左子树遍历完成之后再打印</span></span><br><span class="line">    inOrder(root.right);    <span class="comment">//然后就是对右子树进行遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要将打印放到左子树遍历之后即可，这样打印出来的结果就是中序遍历的结果了：</p><p><img src="https://s2.loli.net/2022/08/06/V2KdMy3T5Beo8vx.png" alt="image-20220806231752418"></p><p>这样，我们就实现了二叉树的中序遍历，实际上还是很好理解的。</p><p>接着我们来看一下后序遍历，后序遍历继续将打印的时机延后，需要等待左右子树全部遍历完成，才会去进行打印。</p><p><img src="https://s2.loli.net/2022/08/06/YE2rODdqpCInUa9.png" alt="image-20220806233407910"></p><p>首先还是一路向左，到达结点D，此时结点D没有左子树了，接着看结点D还有没有右子树，发现也没有，左右子树全部遍历完成，那么此时再打印D，同样的，D完事之后就回到B了，此时接着看B的右子树，发现有结点E，重复上述操作，E也打印出来了，接着B的左右子树全部OK，那么再打印B，接着A的左子树就完事了，现在回到A，看到A的右子树，继续重复上述步骤，当A的右子树也遍历结束后，最后再打印A结点。</p><ol><li>后序遍历左子树</li><li>后序遍历右子树</li><li>打印结点</li></ol><p>所以最后的遍历顺序为：DEBFCA，不难发现，整棵二叉树（包括子树）根结点一定是在后面的，比如A在所有的结点的后面，B在其子节点D、E的后面，这一点恰恰和前序遍历相反（注意不是得到的结果相反，是规律相反）</p><p>所以，按照这个思路，我们来编写一下后序遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">postOrder</span><span class="params">(TreeNode&lt;T&gt; root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    postOrder(root.left);</span><br><span class="line">    postOrder(root.right);</span><br><span class="line">    System.out.print(root.element);  <span class="comment">//时机延迟到最后</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://s2.loli.net/2022/08/06/6Vx9fmSUcqw51Mp.png" alt="image-20220806234428922"></p><p>最后我们来看层序遍历，实际上这种遍历方式是我们人脑最容易理解的，它是按照每一层在进行遍历：</p><p><img src="https://s2.loli.net/2022/08/07/ywF6r9MU1JSPIge.png" alt="image-20220807205135936"></p><p>层序遍历实际上就是按照从上往下每一层，从左到右的顺序打印每个结点，比如上面的这棵二叉树，那么层序遍历的结果就是：ABCDEF，像这样一层一层的挨个输出。</p><p>虽然理解起来比较简单，但是如果让你编程写出来，该咋搞？是不是感觉有点无从下手？</p><p>我们可以利用队列来实现层序遍历，首先将根结点存入队列中，接着循环执行以下步骤：</p><ul><li>进行出队操作，得到一个结点，并打印结点的值。</li><li>将此结点的左右孩子结点依次入队。</li></ul><p>不断重复以上步骤，直到队列为空。</p><p>我们来分析一下，首先肯定一开始A在里面：</p><p><img src="https://s2.loli.net/2022/08/07/ZsNpeVUivEjCymt.png" alt="image-20220807211522409"></p><p>接着开始不断重复上面的步骤，首先是将队首元素出队，打印A，然后将A的左右孩子依次入队：</p><p><img src="https://s2.loli.net/2022/08/07/v8yXWNato3sfeUn.png" alt="image-20220807211631110"></p><p>现在队列中有B、C两个结点，继续重复上述操作，B先出队，打印B，然后将B的左右孩子依次入队：</p><p><img src="https://s2.loli.net/2022/08/07/Qkprfi5RhAXP7Cd.png" alt="image-20220807211723776"></p><p>现在队列中有C、D、E这三个结点，继续重复，C出队并打印，然后将F入队：</p><p><img src="https://s2.loli.net/2022/08/07/MxQTArlWK2gDjqi.png" alt="image-20220807211800852"></p><p>我们发现，这个过程中，打印的顺序正好就是我们层序遍历的顺序，所以说队列还是非常有用的，这里我们可以直接把之前的队列拿来用。那么现在我们就来上代码吧，首先是之前的队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedQueue</span>&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;E&gt; head = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">offer</span><span class="params">(E element)</span>&#123;</span><br><span class="line">        Node&lt;E&gt; last = head;</span><br><span class="line">        <span class="keyword">while</span> (last.next != <span class="literal">null</span>)</span><br><span class="line">            last = last.next;</span><br><span class="line">        last.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">poll</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        <span class="type">E</span> <span class="variable">e</span> <span class="operator">=</span> head.next.element;</span><br><span class="line">        head.next = head.next.next;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span>&#123;   <span class="comment">//这里多写了一个判断队列为空的操作，方便之后使用</span></span><br><span class="line">        <span class="keyword">return</span> head.next == <span class="literal">null</span>;   <span class="comment">//直接看头结点后面还有没有东西就行了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        E element;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(E element)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.element = element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来尝试编写一下层序遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">levelOrder</span><span class="params">(TreeNode&lt;T&gt; root)</span>&#123;</span><br><span class="line">    LinkedQueue&lt;TreeNode&lt;T&gt;&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedQueue</span>&lt;&gt;();  <span class="comment">//创建一个队列</span></span><br><span class="line">    queue.offer(root);    <span class="comment">//将根结点丢进队列</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;   <span class="comment">//如果队列不为空，就一直不断地取出来</span></span><br><span class="line">        TreeNode&lt;T&gt; node = queue.poll();   <span class="comment">//取一个出来</span></span><br><span class="line">        System.out.print(node.element);  <span class="comment">//打印</span></span><br><span class="line">        <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.offer(node.left);   <span class="comment">//如果左右孩子不为空，直接将左右孩子丢进队列</span></span><br><span class="line">        <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.offer(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到结果就是层序遍历的结果：</p><p><img src="https://s2.loli.net/2022/08/07/YlUfDhPoQrg9TkB.png" alt="image-20220807215630429"></p><p>当然，使用递归也可以实现，但是需要单独存放结果然后单独输出，不是很方便，所以说这里就不演示了。</p><h3 id="树：二叉查找树和平衡二叉树">树：二叉查找树和平衡二叉树</h3><p><strong>注意：</strong> 本部分只进行理论介绍，不做代码实现。</p><p>还记得我们开篇讲到的二分搜索算法吗？通过不断缩小查找范围，最终我们可以以很高的效率找到有序数组中的目标位置。而二叉查找树则利用了类似的思想，我们可以借助其来像二分搜索那样快速查找。</p><p><strong>二叉查找树</strong>也叫二叉搜索树或是二叉排序树，它具有一定的规则：</p><ul><li>左子树中所有结点的值，均小于其根结点的值。</li><li>右子树中所有结点的值，均大于其根结点的值。</li><li>二叉搜索树的子树也是二叉搜索树。</li></ul><p>一棵二叉搜索树长这样：</p><p><img src="https://s2.loli.net/2022/08/14/k9G7Ad2cqezgEtJ.png" alt="image-20220814191444130"></p><p>这棵树的根结点为18，而其根结点左边子树的根结点为10，包括后续结点，都是满足上述要求的。二叉查找树满足左边一定比当前结点小，右边一定比当前结点大的规则，比如我们现在需要在这颗树种查找值为15的结点：</p><ol><li>从根结点18开始，因为15小于18，所以从左边开始找。</li><li>接着来到10，发现10比15小，所以继续往右边走。</li><li>来到15，成功找到。</li></ol><p>实际上，我们在对普通二叉树进行搜索时，可能需要挨个进行查看比较，而有了二叉搜索树，查找效率就大大提升了，它就像我们前面的二分搜索那样。</p><p>利用二叉查找树，我们在搜索某个值的时候，效率会得到巨大提升。但是虽然看起来比较完美，也是存在缺陷的，比如现在我们依次将下面的值插入到这棵二叉树中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20 15 13 8 6 3</span><br></pre></td></tr></table></figure><p>在插入完成后，我们会发现这棵二叉树竟然长这样：</p><p><img src="https://s2.loli.net/2022/08/15/E1Pf2pGv4b9Lj7t.png" alt="image-20220815113242191"></p><p>因为根据我们之前编写的插入规则，小的一律往左边放，现在正好来的就是这样一串递减的数字，最后就组成了这样的一棵只有一边的二叉树，这种情况，与其说它是一棵二叉树，不如说就是一个链表，如果这时我们想要查找某个结点，那么实际上查找的时间并没有得到任何优化，直接就退化成线性查找了。</p><p>所以，二叉查找树只有在理想情况下，查找效率才是最高的，而像这种极端情况，就性能而言几乎没有任何的提升。我们理想情况下，这样的效率是最高的：</p><p><img src="https://s2.loli.net/2022/08/15/k1jzXPoOMp9caHy.png" alt="image-20220815113705827"></p><p>所以，我们在进行结点插入时，需要尽可能地避免这种一边倒的情况，这里就需要引入<strong>平衡二叉树</strong>的概念了。实际上我们发现，在插入时如果不去维护二叉树的平衡，某一边只会无限制地延伸下去，出现极度不平衡的情况，而我们理想中的二叉查找树左右是尽可能保持平衡的，<strong>平衡二叉树</strong>（AVL树）就是为了解决这样的问题而生的。</p><p>它的性质如下：</p><ul><li>平衡二叉树一定是一棵二叉查找树。</li><li>任意结点的左右子树也是一棵平衡二叉树。</li><li>从根节点开始，左右子树都高度差不能超过1，否则视为不平衡。</li></ul><p>可以看到，这些性质规定了平衡二叉树需要保持高度平衡，这样我们的查找效率才不会因为数据的插入而出现降低的情况。二叉树上节点的左子树高度 减去 右子树高度， 得到的结果称为该节点的<strong>平衡因子</strong>（Balance Factor），比如：</p><p><img src="https://s2.loli.net/2022/08/15/vaI9qji1KYOP8kt.png" alt="image-20220815210652973"></p><p>通过计算平衡因子，我们就可以快速得到是否出现失衡的情况。比如下面的这棵二叉树，正在执行插入操作：</p><p><img src="https://s2.loli.net/2022/08/15/DMnPqGhawy5Z92V.png" alt="image-20220815115219250"></p><p>可以看到，当插入之后，不再满足平衡二叉树的定义时，就出现了失衡的情况，而对于这种失衡情况，为了继续保持平衡状态，我们就需要进行处理了。我们可能会遇到以下几种情况导致失衡：</p><p><img src="https://s2.loli.net/2022/08/15/KcOQVhlFxzwsIb9.png" alt="image-20220815115836604"></p><p>根据插入结点的不同偏向情况，分为LL型、LR型、RR型、RL型。针对于上面这几种情况，我们依次来看一下如何进行调整，使得这棵二叉树能够继续保持平衡：</p><p>动画网站：<a href="https://www.cs.usfca.edu/~galles/visualization/AVLtree.html%EF%BC%88%E5%AE%9E%E5%9C%A8%E4%B8%8D%E7%90%86%E8%A7%A3%E5%8F%AF%E4%BB%A5%E7%9C%8B%E7%9C%8B%E5%8A%A8%E7%94%BB%E6%98%AF%E6%80%8E%E4%B9%88%E8%B5%B0%E7%9A%84%EF%BC%89">https://www.cs.usfca.edu/~galles/visualization/AVLtree.html（实在不理解可以看看动画是怎么走的）</a></p><ol><li><p><strong>LL型调整</strong>（右旋）</p><p><img src="https://s2.loli.net/2022/08/15/KqBaWLJwOj34Ec8.png" alt="image-20220815211641144"></p><p>首先我们来看这种情况，这是典型的LL型失衡，为了能够保证二叉树的平衡，我们需要将其进行<strong>旋转</strong>来维持平衡，去纠正最小不平衡子树即可。那么怎么进行旋转呢？对于LL型失衡，我们只需要进行右旋操作，首先我们先找到最小不平衡子树，注意是最小的那一个：</p><p><img src="https://s2.loli.net/2022/08/15/q4aYvzrnjdTgAtK.png" alt="image-20220815212552176"></p><p>可以看到根结点的平衡因子是2，是目前最小的出现不平衡的点，所以说从根结点开始向左的三个结点需要进行右旋操作，右旋需要将这三个结点中间的结点作为新的根结点，而其他两个结点现在变成左右子树：</p><p><img src="https://s2.loli.net/2022/08/15/fJKz3FWclm9orVT.png" alt="image-20220815213222964"></p><p>这样，我们就完成了右旋操作，可以看到右旋之后，所有的结点继续保持平衡，并且依然是一棵二叉查找树。</p></li><li><p><strong>RR型调整</strong>（左旋）</p><p>前面我们介绍了LL型以及右旋解决方案，相反的，当遇到RR型时，我们只需要进行左旋操作即可：</p><p><img src="https://s2.loli.net/2022/08/15/kIl8ZT6Psr7mNSg.png" alt="image-20220815214026710"></p><p>操作和上面是一样的，只不过现在反过来了而已：</p><p><img src="https://s2.loli.net/2022/08/15/LB9DOJpyIlxQWTm.png" alt="image-20220815214408651"></p><p>这样，我们就完成了左旋操作，使得这棵二叉树继续保持平衡状态了。</p></li><li><p><strong>RL型调整</strong>（先右旋，再左旋）</p><p>剩下两种类型比较麻烦，需要旋转两次才行。我们来看看RL型长啥样：</p><p><img src="https://s2.loli.net/2022/08/15/fwcrEIgBxWLVGXs.png" alt="image-20220815214859501"></p><p>可以看到现在的形状是一个回旋镖形状的，先右后左的一个状态，也就是RL型，针对于这种情况，我们需要先进行右旋操作，注意这里的右旋操作针对的是后两个结点：</p><p><img src="https://s2.loli.net/2022/08/15/ukK6C4PNBwoaJbc.png" alt="image-20220815215929303"></p><p>其中右旋和左旋的操作，与之前一样，该怎么分配左右子树就怎么分配，完成两次旋转后，可以看到二叉树重新变回了平衡状态。</p></li><li><p><strong>LR型调整</strong>（先左旋，再右旋）</p><p>和上面一样，我们来看看LR型长啥样，其实就是反着的：</p><p><img src="https://s2.loli.net/2022/08/15/6Cj8VlgGekULXvP.png" alt="image-20220815220609357"></p><p>形状是先向左再向右，这就是典型的LR型了，我们同样需要对其进行两次旋转：</p><p><img src="https://s2.loli.net/2022/08/15/y6WscFPxHuzTiaI.png" alt="image-20220815221349044"></p><p>这里我们先进行的是左旋，然后再进行的右旋，这样二叉树就能继续保持平衡了。</p></li></ol><p>这样，我们只需要在插入结点时注意维护整棵树的平衡因子，保证其处于稳定状态，这样就可以让这棵树一直处于高度平衡的状态，不会再退化了。</p><h3 id="树：红黑树">树：红黑树</h3><p><strong>注意：</strong> 本部分只进行理论介绍，不做代码实现。</p><p>很多人都说红黑树难，其实就那几条规则，跟着我推一遍其实还是很简单的，当然前提是一定要把前面的平衡二叉树搞明白。</p><p>前面我们讲解了二叉平衡树，通过在插入结点时维护树的平衡，这样就不会出现极端情况使得整棵树的查找效率急剧降低了。但是这样是否开销太大了一点，因为一旦平衡因子的绝对值超过1那么就失衡，这样每插入一个结点，就有很大的概率会导致失衡，我们能否不这么严格，但同时也要在一定程度上保证平衡呢？这就要提到红黑树了。</p><p>在线动画网站：<a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</a></p><p>红黑树也是二叉查找树的一种，它大概长这样，可以看到结点有红有黑：</p><p><img src="https://s2.loli.net/2022/08/15/t86B7sxvYeP9TiR.png" alt="image-20220815222810537"></p><p>它并不像平衡二叉树那样严格要求高度差不能超过1，而是只需要满足五个规则即可，它的规则如下：</p><ul><li>规则1：每个结点可以是黑色或是红色。</li><li>规则2：根结点一定是黑色。</li><li>规则3：红色结点的父结点和子结点不能为红色，也就是说不能有两个连续的红色。</li><li>规则4：所有的空结点都是黑色（空结点视为NIL，红黑树中是将空节点视为叶子结点）</li><li>规则5：每个结点到空节点（NIL）路径上出现的黑色结点的个数都相等。</li></ul><p>它相比平衡二叉树，通过不严格平衡和改变颜色，就能在一定程度上减少旋转次数，这样的话对于整体性能是有一定提升的，只不过我们在插入结点时，就有点麻烦了，我们需要同时考虑变色和旋转这两个操作了，但是会比平衡二叉树更简单。</p><p>那么什么时候需要变色，什么时候需要旋转呢？我们通过一个简单例子来看看：</p><p><img src="https://s2.loli.net/2022/08/16/wIj5qnhxFAHcyG7.png" alt="image-20220816104917851"></p><p>首先这棵红黑树只有一个根结点，因为根结点必须是黑色，所以说直接变成黑色。现在我们要插入一个新的结点了，所有新插入的结点，默认情况下都是红色：</p><p><img src="https://s2.loli.net/2022/08/16/yHRXgbsvOM27xLr.png" alt="image-20220816105119178"></p><p>所以新来的结点7根据规则就直接放到11的左边就行了，然后注意7的左右两边都是NULL，那么默认都是黑色，这里就不画出来了。同样的，我们往右边也来一个：</p><p><img src="https://s2.loli.net/2022/08/16/kJiA71fQuKHnIdb.png" alt="image-20220816105553070"></p><p>现在我们继续插入一个结点：</p><p><img src="https://s2.loli.net/2022/08/16/VEQLu5mb1tcTyzd.png" alt="image-20220816105656320"></p><p>插入结点4之后，此时违反了红黑树的规则3，因为红色结点的父结点和子结点不能为红色，此时为了保持以红黑树的性质，我们就需要进行<strong>颜色变换</strong>才可以，那么怎么进行颜色变换呢？我们只需要直接将父结点和其兄弟结点同时修改为黑色（为啥兄弟结点也需要变成黑色？因为要满足性质5）然后将爷爷结点改成红色即可：</p><p><img src="https://s2.loli.net/2022/08/16/kuc1B3lqhNUwaSM.png" alt="image-20220816113259643"></p><p>当然这里还需注意一下，因为爷爷结点正常情况会变成红色，相当于新来了个红色的，这时还得继续往上看有没有破坏红黑树的规则才可以，直到没有为止，比如这里就破坏了性质一，爷爷结点现在是根结点（不是根结点就不需要管了），必须是黑色，所以说还要给它改成黑色才算结束：</p><p><img src="https://s2.loli.net/2022/08/16/dpRX5DGsfWVwnQi.png" alt="image-20220816113339344"></p><p>接着我们继续插入结点：</p><p><img src="https://s2.loli.net/2022/08/16/4ZAhv7R9YusI8q6.png" alt="image-20220816113939172"></p><p>此时又来了一个插在4左边的结点，同样是连续红色，我们需要进行变色才可以讲解问题，但是我们发现，如果变色的话，那么从11开始到所有NIL结点经历的黑色结点数量就不对了：</p><p><img src="https://s2.loli.net/2022/08/16/n3M6Kfsb4jHtIci.png" alt="image-20220816114245996"></p><p>所以说对于这种<strong>父结点为红色，父结点的兄弟结点为黑色</strong>（NIL视为黑色）的情况，变色无法解决问题了，那么我们只能考虑旋转了，旋转规则和我们之前讲解的平衡二叉树是一样的，这实际上是一种LL型失衡：</p><p><img src="https://s2.loli.net/2022/08/16/POTaBfosmQiceWk.png" alt="image-20220816115015892"></p><p>同样的，如果遇到了LR型失衡，跟前面一样，先左旋在右旋，然后进行变色即可：</p><p><img src="https://s2.loli.net/2022/08/16/XqFr7hJwe38AakK.png" alt="image-20220816115924938"></p><p>而RR型和RL型同理，这里就不进行演示了，可以看到，红黑树实际上也是通过颜色规则在进行旋转调整的，当然旋转和变色的操作顺序可以交换。所以，在插入时比较关键的判断点如下：</p><ul><li>如果整棵树为NULL，直接作为根结点，变成黑色。</li><li>如果父结点是黑色，直接插入就完事。</li><li>如果父结点为红色，且父结点的兄弟结点也是红色，直接变色即可（但是注意得继续往上看有没有破坏之前的结构）</li><li>如果父结点为红色，但父结点的兄弟结点为黑色，需要先根据情况（LL、RR、LR、RL）进行旋转，然后再变色。</li></ul><p>在了解这些步骤之后，我们其实已经可以尝试去编写一棵红黑树出来了，当然代码太过复杂，这里就不演示了。</p><h3 id="哈希表">哈希表</h3><p>在之前，我们已经学习了多种查找数据的方式，比如最简单的，如果数据量不大的情况下，我们可以直接通过顺序查找的方式在集合中搜索我们想要的元素；当数据量较大时，我们可以使用二分搜索来快速找到我们想要的数据，不过需要要求数据按照顺序排列，并且不允许中途对集合进行修改。</p><p>在学习完树形结构篇之后，我们可以利用二叉查找树来建立一个便于我们查找的树形结构，甚至可以将其优化为平衡二叉树或是红黑树来进一步提升稳定性。</p><p>这些都能够极大地帮助我们查找数据，而散列表，则是我们数据结构系列内容的最后一块重要知识。</p><p>散列（Hashing）通过散列函数（哈希函数）将要参与检索的数据与散列值（哈希值）关联起来，生成一种便于搜索的数据结构，我们称其为散列表（哈希表），也就是说，现在我们需要将一堆数据保存起来，这些数据会通过哈希函数进行计算，得到与其对应的哈希值，当我们下次需要查找这些数据时，只需要再次计算哈希值就能快速找到对应的元素了：</p><p><img src="https://s2.loli.net/2022/08/18/Tcj6Spy2Pt5ZIuW.png" alt="image-20220818214145347"></p><p>散列函数也叫哈希函数，哈希函数可以对一个目标计算出其对应的哈希值，并且，只要是同一个目标，无论计算多少次，得到的哈希值都是一样的结果，不同的目标计算出的结果介乎都不同。哈希函数在现实生活中应用十分广泛，比如很多下载网站都提供下载文件的MD5码校验，可以用来判别文件是否完整，哈希函数多种多样，目前应用最为广泛的是SHA-1和MD5，比如我们在下载IDEA之后，会看到有一个验证文件SHA-256校验和的选项，我们可以点进去看看：</p><p><img src="https://s2.loli.net/2022/08/18/tD8AjiGwvJkdahE.png" alt="image-20220818214908458"></p><p>点进去之后，得到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e54a026da11d05d9bb0172f4ef936ba2366f985b5424e7eecf9e9341804d65bf *ideaIU-2022.2.1.dmg</span><br></pre></td></tr></table></figure><p>这一串由数字和小写字母随意组合的一个字符串，就是安装包文件通过哈希算法计算得到的结果，那么这个东西有什么用呢？我们的网络可能有时候会出现卡顿的情况，导致我们下载的文件可能会出现不完整的情况，因为哈希函数对同一个文件计算得到的结果是一样的，我们可以在本地使用同样的哈希函数去计算下载文件的哈希值，如果与官方一致，那么就说明是同一个文件，如果不一致，那么说明文件在传输过程中出现了损坏。</p><p>可见，哈希函数在这些地方就显得非常实用，在我们的生活中起了很大的作用，它也可以用于布隆过滤器和负载均衡等场景，这里不多做介绍了。</p><p>前面我们介绍了散列函数，我们知道可以通过散列函数计算一个目标的哈希值，那么这个哈希值计算出来有什么用呢，对我们的程序设计有什么意义呢？我们可以利用哈希值的特性，设计一张全新的表结构，这种表结构是专为哈希设立的，我们称其为哈希表（散列表）</p><p><img src="https://s2.loli.net/2022/08/18/M2o1vE7hHasN8DP.png" alt="image-20220818220944783"></p><p>我们可以将这些元素保存到哈希表中，而保存的位置则与其对应的哈希值有关，哈希值是通过哈希函数计算得到的，我们只需要将对应元素的关键字（一般是整数）提供给哈希函数就可以进行计算了，一般比较简单的哈希函数就是取模操作，哈希表长度是多少（长度最好是一个素数），模就是多少：</p><p><img src="https://s2.loli.net/2022/08/19/CAPhlJnQeLjMHfd.png" alt="image-20220819170355221"></p><p>比如现在我们需要插入一个新的元素（关键字为17）到哈希表中：</p><p><img src="https://s2.loli.net/2022/08/19/ovieRjrzlXhKMC2.png" alt="image-20220819171430332"></p><p>插入的位置为计算出来的哈希值，比如上面是8，那么就在下标位置8插入元素，同样的，我们继续插入27：</p><p><img src="https://s2.loli.net/2022/08/19/pisuSAIZyf5JE7B.png" alt="image-20220819210336314"></p><p>这样，我们就可以将多种多样的数据保存到哈希表中了，注意保存的数据是无序的，因为我们也不清楚计算完哈希值最后会放到哪个位置。那么如果现在我们想要从哈希表中查找数据呢？比如我们现在需要查找哈希表中是否有14这个元素：</p><p><img src="https://s2.loli.net/2022/08/19/H1hAvQPjNui2RYt.png" alt="image-20220819211656628"></p><p>同样的，直接去看哈希值对应位置上看看有没有这个元素，如果没有，那么就说明哈希表中没有这个元素。可以看到，哈希表在查找时只需要进行一次哈希函数计算就能直接找到对应元素的存储位置，效率极高。</p><p>我们来尝试编写一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashTable</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TABLE_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] TABLE = <span class="keyword">new</span> <span class="title class_">Object</span>[TABLE_SIZE];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(E element)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hash(element);</span><br><span class="line">        TABLE[index] = element;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E element)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hash(element);</span><br><span class="line">        <span class="keyword">return</span> TABLE[index] == element;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object object)</span>&#123;   <span class="comment">//哈希函数，计算出存放的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> object.hashCode();  </span><br><span class="line">      <span class="comment">//每一个对象都有一个独一无二的哈希值，可以通过hashCode方法得到（只有极小的概率会出现相同的情况）</span></span><br><span class="line">        <span class="keyword">return</span> hashCode % TABLE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们就实现了一个简单的哈希表和哈希函数，通过哈希表，我们可以将数据的查找时间复杂度提升到常数阶。</p><p>前面我介绍了哈希函数，通过哈希函数计算得到一个目标的哈希值，但是在某些情况下，哈希值可能会出现相同的情况：</p><p><img src="https://s2.loli.net/2022/08/19/XqpZd1YP5ulEJRy.png" alt="image-20220819215004653"></p><p>比如现在同时插入14和23这两个元素，他们两个计算出来的哈希值是一样的，都需要在5号下标位置插入，这时就出现了打架的情况，那么到底是把哪一个放进去呢？这种情况，我们称为<strong>哈希碰撞</strong>（哈希冲突）</p><p>这种问题是很严重的，因为哈希函数的设计不同，难免会出现这种情况，这种情况是不可避免的，我们只能通过使用更加高级的哈希函数来尽可能避免这种情况，但是无法完全避免。当然，如果要完全解决这种问题，我们还需要去寻找更好的方法。这里我们只介绍一种比较重要的，会在后面集合类中用到的方案。</p><p>实际上常见的哈希冲突解决方案是<strong>链地址法</strong>，当出现哈希冲突时，我们依然将其保存在对应的位置上，我们可以将其连接为一个链表的形式：</p><p><img src="https://s2.loli.net/2022/09/30/Hd1LDvkY6ScVTN2.png" alt="image-20220820220237535"></p><p>当表中元素变多时，差不多就变成了这样，我们一般将其横过来看：</p><p><img src="https://s2.loli.net/2022/09/30/kr4CcVEwI72AiDU.png" alt="image-20220820221104298"></p><p>通过结合链表的形式，哈希冲突问题就可以得到解决了，但是同时也会出现一定的查找开销，因为现在有了链表，我们得挨个往后看才能找到，当链表变得很长时，查找效率也会变低，此时我们可以考虑结合其他的数据结构来提升效率。比如当链表长度达到8时，自动转换为一棵平衡二叉树或是红黑树，这样就可以在一定程度上缓解查找的压力了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashTable</span>&lt;E&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TABLE_SIZE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Node&lt;E&gt;[] TABLE = <span class="keyword">new</span> <span class="title class_">Node</span>[TABLE_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashTable</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; TABLE_SIZE; i++)</span><br><span class="line">            TABLE[i] = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(E element)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hash(element);</span><br><span class="line">        Node&lt;E&gt; prev = TABLE[index];</span><br><span class="line">        <span class="keyword">while</span> (prev.next != <span class="literal">null</span>)</span><br><span class="line">            prev = prev.next;</span><br><span class="line">        prev.next = <span class="keyword">new</span> <span class="title class_">Node</span>&lt;&gt;(element);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">contains</span><span class="params">(E element)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> hash(element);</span><br><span class="line">        Node&lt;E&gt; node = TABLE[index].next;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node.element == element)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object object)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">hashCode</span> <span class="operator">=</span> object.hashCode();</span><br><span class="line">        <span class="keyword">return</span> hashCode % TABLE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> E element;</span><br><span class="line">        <span class="keyword">private</span> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">Node</span><span class="params">(E element)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.element = element;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这种方案代码写起来也会更简单，使用也更方便一些。</p><p>至此，数据结构相关内容，我们就讲解到这里，学习这些数据结构，实际上也是为了方便各位小伙伴对于后续结合类的学习，因为集合类的底层实现就是这些数据结构。</p><hr><h2 id="实战练习">实战练习</h2><p>合理利用集合类，我们可以巧妙地解决各种各样的难题。</p><h3 id="反转链表">反转链表</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></p><p>给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。</p><p>示例 1：</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><blockquote><p>输入：head = [1,2,3,4,5]<br>输出：[5,4,3,2,1]</p></blockquote><p>示例 2：</p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><blockquote><p>输入：head = [1,2]<br>输出：[2,1]</p></blockquote><p>这道题依然是考察各位小伙伴对于链表相关操作的掌握程度，我们如何才能将一个链表的顺序进行反转，关键就在于如何修改每个节点的指针指向。</p><h3 id="括号匹配问题">括号匹配问题</h3><p>本题来自LeetCode：<a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></p><p>给定一个只包括 ‘(’，‘)’，‘{’，‘}’，‘[’，‘]’ 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ol><p>示例 1：</p><blockquote><p>输入：s = “()”<br>输出：true</p></blockquote><p>示例 2：</p><blockquote><p>输入：s = “()[]{}”<br>输出：true</p></blockquote><p>示例 3：</p><blockquote><p>输入：s = “(]”<br>输出：false</p></blockquote><p><strong>示例 4：</strong></p><blockquote><p>输入：s = “([)]”<br>输出：false</p></blockquote><p><strong>示例 5：</strong></p><blockquote><p>输入：s = “{[]}”<br>输出：true</p></blockquote><p>题干很明确，就是需要我们去对这些括号完成匹配，如果给定字符串中的括号无法完成一一匹配的话，那么就表示匹配失败。实际上这种问题我们就可以利用前面学习的栈这种数据结构来解决，我们可以将所有括号的左半部分放入栈中，当遇到右半部分时，进行匹配，如果匹配失败，那么就失败，如果匹配成功，那么就消耗一个左半部分，直到括号消耗完毕。</p><h3 id="实现计算器">实现计算器</h3><p>输入一个计算公式（含加减乘除运算符，没有负数但是有小数）得到结果，比如输入：1+4*3/1.321，得到结果为：2.2</p><p>现在请你设计一个Java程序，实现计算器。</p><p>————————————————<br>版权声明：本文为柏码知识库版权所有，禁止一切未经授权的转载、发布、出售等行为，违者将被追究法律责任。<br>原文链接：<a href="https://www.itbaima.cn/document/hnkrjrkm3hjzeq6s">https://www.itbaima.cn/document/hnkrjrkm3hjzeq6s</a></p>]]></content>
    
    
    <summary type="html">Java SE 3️⃣ 泛型与集合类</summary>
    
    
    
    <category term="开发" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Java SE" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/Java-SE/"/>
    
    
    <category term="开发" scheme="https://www.angfff.top/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Java" scheme="https://www.angfff.top/tags/Java/"/>
    
    <category term="Java SE" scheme="https://www.angfff.top/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>互联网产品分析笔记(四)</title>
    <link href="https://www.angfff.top/posts/c59cc424.html"/>
    <id>https://www.angfff.top/posts/c59cc424.html</id>
    <published>2025-04-16T02:25:09.000Z</published>
    <updated>2025-05-22T04:31:09.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Wombo-Dream（AI艺术创作应用）">Wombo Dream（AI艺术创作应用）</h2><h3 id="产品概述"><strong>产品概述</strong></h3><p>Wombo Dream 是由加拿大 AI 公司 Wombo 开发的一款生成式艺术创作应用。用户只需输入一句文字描述，Wombo Dream 就能在数秒内生成一幅高质量的数字画作。其目标是“让每个人都成为艺术家”，打破艺术创作门槛。上线后，迅速风靡全球，尤其受内容创作者、NFT 玩家、社交媒体用户青睐。</p><h3 id="核心功能"><strong>核心功能</strong></h3><ol><li><strong>文本生成图片（Text-to-Image）</strong>：基于用户的 Prompt（提示词）生成 AI 图像，支持中英文输入。</li><li><strong>多种艺术风格模板</strong>：如幻想、动漫、未来主义、蒸汽波、油画、超现实等。</li><li><strong>一键下载与社交分享</strong>：可生成手机壁纸尺寸，并一键分享到 Instagram、TikTok、Twitter 等平台。</li><li><strong>NFT 一键上链功能</strong>：允许用户将生成作品发布到 OpenSea，直接参与加密艺术经济。</li><li><strong>社区浏览与收藏</strong>：用户可查看其他人生成的作品，进行点赞、评论和灵感采集。</li></ol><h3 id="用户体验评估">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>操作极简，无需绘画基础，Prompt + 选择风格即可完成创作。</li><li>图像生成速度快，视觉质量高，符合社交媒体爆款潜质。</li><li>风格多样，激发用户创作灵感，容易“上头”。</li></ul></li><li><strong>不足</strong>：<ul><li>Prompt控制力较弱，高级用户难以精准控制画面细节。</li><li>免费用户生成图像有水印且画质受限，限制传播与创作二次利用。</li><li>中文语义理解不如英文精准，影响国内用户生成体验。</li></ul></li></ul><h3 id="商业模式解释">商业模式解释</h3><ol><li><strong>订阅服务（Wombo Premium）</strong>：解锁高清下载、无水印、风格增强、批量生成等功能。</li><li><strong>NFT 链上服务抽成</strong>：用户生成的作品在 NFT 市场售出后，平台抽取一定比例作为手续费。</li><li><strong>B2B 定制服务</strong>：面向品牌、游戏、美术等行业提供艺术风格定制、API 接口接入。</li><li><strong>社交分享流量带货</strong>：通过用户生成内容引导平台内打赏与周边商品定制（T恤、海报等）。</li></ol><h3 id="竞争分析">竞争分析</h3><ul><li><strong>主要对手</strong>：<ul><li><strong>Midjourney</strong>：生成质量极高但操作路径复杂、需使用 Discord。</li><li><strong>DALL·E</strong>：由 OpenAI 推出，强调图像精度与合理性，控制力更强。</li><li><strong>Artbreeder</strong>：主打面部与人像风格变换，生成路径不同但目标用户部分重叠。</li></ul></li><li><strong>Wombo Dream 优势</strong>：<ul><li>极致轻量化体验，适合非专业用户快速“出图”。</li><li>移动端适配优良，生成节奏符合短视频内容节奏。</li></ul></li><li><strong>Wombo Dream 劣势</strong>：<ul><li>缺乏社区深度与创作沉淀机制，用户停留时间短。</li><li>商业化路径高度依赖生成质量和潮流热点，缺乏结构性护城河。</li></ul></li></ul><h3 id="运营策略">运营策略</h3><ol><li><strong>构建“AI艺术家挑战赛”机制</strong>：设置每日/每周主题，激发用户创作热情。</li><li><strong>与短视频平台达成联动</strong>：接入 TikTok、抖音模板机制，实现“AI画图视频化”趋势。</li><li><strong>开设“Prompt 学院”</strong>：用户教学、激励社区共创优秀提示词库，提升生成质量与复玩性。</li><li><strong>推动“AI艺术授权平台”上线</strong>：用户可出售、授权自己作品给周边生产、壁纸平台等第三方使用。</li></ol><h3 id="改进建议">改进建议</h3><ol><li><strong>推出“分镜式生成模式”</strong>：一次输入多句 Prompt 生成漫画或连环画，提高内容延展性。</li><li><strong>加强对中文语义与 ACG 场景理解能力</strong>，抓住泛二次元市场红利。</li><li><strong>加入 AI+人类混合创作模式</strong>：支持手绘上传后 AI 风格化或自动补全。</li><li><strong>引入“图像二次编辑器”</strong>：允许对生成图片进行局部调整、拼贴组合等创意加工。</li></ol><h3 id="总结">总结</h3><p>Wombo Dream 是一款“为普通人打开 AI 创作之门”的魔法钥匙。它不是给专业艺术家准备的 Photoshop，而是给创意灵光一现的你准备的“AI 筆仙”。未来它若能把“创作乐趣+视觉爆款+社交工具”三者融合得更紧密，就不仅是 AI 图片生成器，更是每个人灵感出口的“情绪画布”。🎨✨🧠</p><hr><h2 id="Shazam（全球音乐识别神器）">Shazam（全球音乐识别神器）</h2><h3 id="产品概述-2">产品概述</h3><p>Shazam 是一款由苹果公司拥有的音乐识别应用，用户只需点击一个按钮，就能迅速识别周围播放的音乐，并提供歌曲名称、艺术家、专辑信息、歌词片段、播放链接等内容。它是“你听过但叫不出名字的那首歌”的终结者。自2002年推出以来，Shazam 已成为全球最知名的声纹识别产品之一，月活跃用户超2亿。</p><h3 id="核心功能-2">核心功能</h3><ol><li><strong>音乐识别（Music ID）</strong>：通过麦克风捕捉环境中的音乐片段，几秒内精准识别并返回信息。</li><li><strong>自动历史记录</strong>：识别记录自动保存，可随时回顾、收藏或同步至 Apple Music/Spotify。</li><li><strong>浮动识别（Pop-Up Shazam）</strong>：支持在后台运行识别，即便在播放 TikTok、Instagram 时也能识别背景音乐。</li><li><strong>一键跳转播放平台</strong>：支持跳转至 Apple Music、Spotify、YouTube 等播放整首歌曲。</li><li><strong>实时排行榜与发现</strong>：提供地区/全球热门识别榜，支持新歌发现与音乐探索。</li></ol><h3 id="用户体验评估-2">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>识别速度快、准确率高，覆盖曲库广（尤其在流行乐、电子乐领域）。</li><li>极致极简的交互设计，一键即识别，适合所有年龄段用户。</li><li>与 Apple 生态深度整合（如 Siri 集成、Apple Watch 快捷识别、控制中心 widget）。</li></ul></li><li><strong>不足</strong>：<ul><li>对非主流、冷门曲目的识别率仍有提升空间。</li><li>歌词同步功能不稳定，某些语言/地区不完整。</li><li>社交分享路径不够丰富，缺乏社区讨论氛围。</li></ul></li></ul><h3 id="商业模式解释-2">商业模式解释</h3><ol><li><strong>流量引导（Affiliate Model）</strong>：用户点击跳转到音乐平台播放时，Shazam 从 Apple Music、Spotify 获取导流佣金。</li><li><strong>数据资产变现</strong>：作为全球最大“音乐发现行为数据库”，Shazam 数据可用于音乐推荐模型优化、音乐趋势研究。</li><li><strong>品牌合作与推广位</strong>：为艺人、专辑、电影等提供音乐推广入口，尤其在首发时段引爆榜单。</li><li><strong>与 Apple 产品捆绑</strong>：作为 Apple Music 的“流量入口”，间接提升其订阅用户基数。</li></ol><h3 id="竞争分析-2">竞争分析</h3><ul><li><strong>主要对手</strong>：<ul><li><strong>SoundHound</strong>：也具备识别能力，支持“哼唱识别”，但知名度低于 Shazam。</li><li><strong>Musixmatch</strong>：聚焦歌词同步与识别，在歌词生态中更强，但识别速度略慢。</li><li><strong>百度听歌识曲 / 腾讯听歌识曲</strong>：功能相近但主要面向中国市场，精度受限于版权曲库。</li></ul></li><li><strong>Shazam 优势</strong>：<ul><li>曲库广泛，全球性强，技术沉淀丰富，识别速度遥遥领先。</li><li>品牌辨识度极强，是“听歌识曲”这一场景的代名词。</li><li>与 Apple 系统深度集成，实现“零界面”唤起（如 Siri 识别）。</li></ul></li><li><strong>Shazam 劣势</strong>：<ul><li>功能过于单一，长期用户留存价值低。</li><li>缺乏社区化与内容生态，无法沉淀用户兴趣偏好与UGC内容。</li></ul></li></ul><h3 id="运营策略-2">运营策略</h3><ol><li><strong>推出“听歌挑战”模块</strong>：设置每周识别挑战，结合排行榜与分享机制激发用户活跃度。</li><li><strong>与音乐短视频平台合作</strong>：如 TikTok、Reels 内嵌 Shazam 小组件，实现一键识曲+同步跳转。</li><li><strong>强化“哼唱识曲”能力</strong>：补齐 SoundHound 技术差距，满足用户在无背景音乐时识别旋律需求。</li><li><strong>发展音乐图谱+个性化推荐系统</strong>：结合识别历史与时间地点信息，打造“你的音乐档案”。</li></ol><h3 id="改进建议-2">改进建议</h3><ol><li><strong>开发“音乐笔记”功能</strong>：用户可在识别页添加情绪标签、故事记录，建立音乐记忆场景。</li><li><strong>构建“Shazam 社区”</strong>：支持用户发布识别动态、组建歌单群组，探索音乐社交模式。</li><li><strong>开放 API 与小程序</strong>：让开发者、KTV、DJ工具接入识曲服务，拓展B端市场。</li><li><strong>引入“AR识曲”功能</strong>：结合画面与音频，如街头音乐场景识别，增强沉浸体验。</li></ol><h3 id="总结-2">总结</h3><p>Shazam 不是一个“工具型 App”，它其实是“瞬间记忆的封装器”——帮你在转瞬即逝的旋律里，留下可以反复回味的线索。它代表的是“AI与音乐之间最友善的交互形态”。如果它能进一步从识别工具进化成“音乐情感连接器”，它就不只是你口袋里的 Shazam，而是你心里的一部分旋律记忆管家。🎵🔍💙</p><hr><h2 id="Khan-Academy（可汗学院）——全球免费教育平台的标杆">Khan Academy（可汗学院）——全球免费教育平台的标杆</h2><h3 id="产品概述-3">产品概述</h3><p>Khan Academy 是一家非盈利在线教育平台，总部位于美国，旨在“为全球任何地方的任何人提供免费的优质教育”。它以动画视频与互动练习著称，覆盖从小学数学到大学物理、计算机科学、金融经济、SAT/GMAT等考试准备内容，在全球教育公平与知识普惠方面具有极强影响力。</p><h3 id="核心功能-3">核心功能</h3><ol><li><strong>视频课程</strong>：大量由 Salman Khan 本人录制的简洁动画讲解视频，配合黑板风格图解。</li><li><strong>互动练习题与打分系统</strong>：题目按知识点划分，带即时反馈、详细解析与错题强化。</li><li><strong>学习路径定制</strong>：支持 AI 推荐课程路径，追踪学习进度并自动调整内容难度。</li><li><strong>教师面板与班级功能</strong>：教师可布置作业、查看学生答题记录、引导个性化辅导。</li><li><strong>支持多语种</strong>：平台提供英语、西班牙语、法语、葡萄牙语等版本，并在逐步拓展更多语言内容（包括中文）。</li></ol><h3 id="用户体验评估-3">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>内容结构清晰、动画风格通俗易懂，极适合“自学”人群。</li><li>全平台完全免费，学习无广告干扰。</li><li>可跨设备使用，进度同步良好，支持低带宽模式。</li></ul></li><li><strong>不足</strong>：<ul><li>中文本地化滞后，国内用户依赖第三方字幕组/志愿者翻译。</li><li>高阶内容偏向美式教育体系，与部分国家的考试体系脱节。</li><li>缺乏沉浸式互动设计，不太适合喜欢“游戏化学习”的学生。</li></ul></li></ul><h3 id="商业模式解释-3">商业模式解释</h3><ol><li><strong>非盈利组织 + 慈善捐助</strong>：主要由盖茨基金会、<a href="http://Google.org">Google.org</a>、AT&amp;T、Bank of America 等资助。</li><li><strong>企业合作计划</strong>：为公司提供员工培训课程与素养提升模块，探索B2B路径。</li><li><strong>硬件厂商联合计划</strong>：与学校、Chromebook 等设备厂商合作，推广教育一体机内容。</li><li><strong>考试平台合作</strong>：与 College Board 合作推出 SAT 备考专版，强化考试学习场景。</li></ol><h3 id="竞争分析-3">竞争分析</h3><ul><li><strong>直接对手</strong>：<ul><li><strong>Coursera、edX</strong>：偏高等教育与证书认证，免费内容比例较低。</li><li><strong>Duolingo</strong>：语种学习领域内的游戏化引领者，但学科不全面。</li></ul></li><li><strong>间接对手</strong>：<ul><li><strong>国内如学而思网校、猿辅导</strong>：有更强本地化运营，但商业化色彩重。</li><li><strong>YouTube 教育区 + CrashCourse 等频道</strong>：自由度高但内容碎片化。</li></ul></li><li><strong>Khan Academy 优势</strong>：<ul><li>免费 + 品牌背书，几乎无信任门槛。</li><li>教师与家长可协同管理，适合教育系统使用。</li><li>内容更新稳定，课程体系持续拓展。</li></ul></li><li><strong>劣势</strong>：<ul><li>产品增长完全依赖口碑，缺少商业化驱动力。</li><li>缺乏短视频/社交功能，不适合内容传播型学习。</li></ul></li></ul><h3 id="运营策略建议">运营策略建议</h3><ol><li><strong>推动本地化社区运营计划</strong>：组建中文、印地语、阿拉伯语等母语内容制作志愿者团队，快速翻译与适配。</li><li><strong>强化AI学习助手模块</strong>：接入 LLM 模型进行错题讲解、个性推荐与学习问答。</li><li><strong>面向家庭用户推出“亲子联合学习包”</strong>：提升家长陪伴学习参与度。</li><li><strong>扩展“行业教育”路径</strong>：与Google、LinkedIn Learning 合作，推出“职场基础技能”课程合集。</li></ol><h3 id="改进建议-3">改进建议</h3><ol><li><strong>引入可视化成就系统</strong>：提升学生动机，如完成某模块自动生成“学习图谱”与数字勋章。</li><li><strong>开发“每日学习打卡 + 小挑战”机制</strong>：增加学习黏性并鼓励连续学习。</li><li><strong>增强教师社区功能</strong>：提供教师经验分享、试题资源共建平台，提升平台网络效应。</li><li><strong>移动端内容轻量化</strong>：推“1分钟知识点”短视频格式，增强碎片化传播力。</li></ol><h3 id="总结-3">总结</h3><p>Khan Academy 是数字教育时代里最温暖、最坚定的“知识守夜人”。在所有追求流量变现的平台中，它是一道反其道而行的光：不收钱、不广告、不焦虑，只想让你多懂一点。如果未来它能更好地结合 AI 个性辅导 + 本地化课程体系，它就不只是“免费教育平台”，而是“人人可得的世界级数字私塾”。📚🌍✨</p><hr><h2 id="Lapse（全球流行的“胶卷风格”社交相机应用）">Lapse（全球流行的“胶卷风格”社交相机应用）</h2><h3 id="产品概述-4">产品概述</h3><p>Lapse 是一款专注于“模拟胶卷相机体验”的社交拍照应用，主打“延迟成像”概念：用户拍照后无法立即查看照片，而是需要等待几小时“冲洗”完成。这种怀旧+反即时满足的设计，让它在Z世代中迅速流行，被称为“慢节奏版 Snapchat”。</p><h3 id="核心功能-4">核心功能</h3><ol><li><strong>胶卷拍摄体验</strong>：用户每天拥有有限“胶卷张数”，拍完后需等待冲洗时间。</li><li><strong>自动滤镜模拟胶片风格</strong>：照片风格独特，偏向复古色调与质感模糊的“底片感”。</li><li><strong>冲洗后自动上传私密相册</strong>：照片冲洗后会同步到用户相册，并可选择发布至社交页面。</li><li><strong>群组相册</strong>：支持好友之间共同记录旅行、派对等活动的“合辑”，增加互动性。</li><li><strong>分享机制</strong>：可将“冲洗好”的照片以带有时间戳和滤镜的方式发布到Instagram、TikTok等平台。</li></ol><h3 id="用户体验评估-4">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>“等待”机制极具差异化，打破社交平台的即时性焦虑，重拾拍照仪式感。</li><li>界面简洁复古，交互逻辑贴合胶卷体验，极具氛围感。</li><li>内容自然、不做作，激发用户对“真实记录”的热情。</li></ul></li><li><strong>不足</strong>：<ul><li>不支持前置相机，自拍党体验不佳。</li><li>拍摄次数受限，容易“用完就无聊”，限制留存。</li><li>缺乏强社交推荐机制，用户增长基本靠口碑与邀请制裂变。</li></ul></li></ul><h3 id="商业模式解释-4">商业模式解释</h3><ol><li><strong>订阅会员（Lapse Plus）</strong>：提供更多胶卷、优先冲洗、高清存储等功能。</li><li><strong>虚拟物品与胶卷主题包</strong>：售卖特殊风格滤镜包，如“暗黑夜景胶卷”、“节日限定胶片”。</li><li><strong>品牌联名营销</strong>：与潮牌、相机厂商合作推出联名胶卷风格与社交挑战。</li><li><strong>影像周边导出</strong>：提供照片冲洗成册、打印胶片、实物周边制作服务。</li></ol><h3 id="竞争分析-4">竞争分析</h3><ul><li><strong>直接竞争对手</strong>：<ul><li><strong>Dispo</strong>：由网红David Dobrik发起，理念类似但运营不如Lapse活跃。</li><li><strong>Huji Cam</strong>：单机类胶片滤镜应用，缺少社交能力。</li></ul></li><li><strong>间接竞争对手</strong>：<ul><li><strong>Instagram Threads / BeReal</strong>：强调真实记录和轻量社交，用户画像部分重合。</li></ul></li><li><strong>Lapse 优势</strong>：<ul><li>强概念感 + 精准定位：在“摄影即表达”与“慢社交”之间找到独特定位。</li><li>用户体验高度统一，从拍照、冲洗到发布，每一步都仪式感满满。</li></ul></li><li><strong>Lapse 劣势</strong>：<ul><li>过于“理念驱动”，缺乏平台效应和内容沉淀能力。</li><li>商业化路径单一，难以支撑大规模用户运营。</li></ul></li></ul><h3 id="运营策略建议-2">运营策略建议</h3><ol><li><strong>推出“胶卷挑战日”</strong>：如“影像星期五”“夏日派对胶卷”，引导用户连续打卡拍摄。</li><li><strong>与高校社团/独立乐队合作</strong>：拍摄幕后、排练等文艺场景，贴合用户兴趣。</li><li><strong>引入“胶卷拼图相册”玩法</strong>：用户可合力解锁拼图式群组照片，增强内容粘性。</li><li><strong>开拓亚洲市场（尤其是日韩）</strong>：复古文化氛围浓厚、摄影氛围活跃，匹配度高。</li></ol><h3 id="改进建议-4">改进建议</h3><ol><li><strong>增强照片故事化编辑功能</strong>：冲洗完成后可添加“胶卷日记”，打造图文结合叙事感。</li><li><strong>支持“慢直播”功能</strong>：让朋友们围观你今天拍了什么，形成“冲洗期待”。</li><li><strong>构建UGC精选与胶片话题页</strong>：提升曝光机制，构建内容流动性。</li><li><strong>开放API接入智能相机/手表</strong>：拓展拍摄终端，增强实用性与创作边界。</li></ol><h3 id="总结-4">总结</h3><p>Lapse 就像是社交时代的一台“慢快门”：你拍下的不只是画面，而是时间本身的流动与等待。它的核心不是照片质量，而是让用户重新找回拍照的“意义感”与“惊喜感”。如果它能从情绪社交产品走向日常记录平台，那么 Lapse 可能会成为下一个「非算法驱动」的相机社交新物种。📷✨🕰️</p><hr><h2 id="Wysa（AI驱动的心理健康对话工具）">Wysa（AI驱动的心理健康对话工具）</h2><h3 id="产品概述-5">产品概述</h3><p>Wysa 是一款来自英国的人工智能心理健康应用，结合了聊天机器人、情绪追踪与专业治疗师服务，旨在为全球用户提供随时可用的心理支持。用户可以匿名与 AI “Wysa” 聊天，获得情绪疏导、CBT（认知行为疗法）练习和冥想引导，广受职场人士、学生及睡眠困扰人群欢迎。它是“你口袋里的心理教练”。</p><h3 id="核心功能-5">核心功能</h3><ol><li><strong>AI 聊天机器人</strong>：可与用户进行非评判式情绪对话，识别关键词后推荐应对练习。</li><li><strong>CBT 练习包</strong>：引导用户完成如“情绪日志”“负面思维挑战”“习惯追踪”等心理行为练习。</li><li><strong>冥想与呼吸训练</strong>：结合音频提供放松训练、睡前冥想、焦虑减缓等内容。</li><li><strong>每日心情追踪</strong>：通过简单的问答记录情绪变化趋势，形成情绪图谱。</li><li><strong>专业人类治疗服务（付费可用）</strong>：与认证心理咨询师匹配进行1对1交流。</li></ol><h3 id="用户体验评估-5">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>AI 对话温和、鼓励性强，减轻用户初期开口压力，适合“低信任门槛”场景。</li><li>CBT 工具体系专业化，内容权威且结构清晰。</li><li>夜间模式与每日推送节奏温和，强化“陪伴感”。</li></ul></li><li><strong>不足</strong>：<ul><li>中文版本支持有限，AI 回答对中文提示词理解能力差。</li><li>高阶服务付费点较多，用户可能因预期“免费”而产生心理落差。</li><li>无法对长期问题做深度跟踪，偏向“轻咨询”而非“系统治疗”。</li></ul></li></ul><h3 id="商业模式解释-5">商业模式解释</h3><ol><li><strong>订阅制 Premium 版本</strong>：解锁全部 AI 工具箱与深度练习路径。</li><li><strong>雇主企业版（Wysa for Employers）</strong>：向公司销售员工心理健康管理平台。</li><li><strong>治疗师服务平台抽佣</strong>：用户升级为专业咨询服务后，平台按通话时长或疗程抽佣。</li><li><strong>数据洞察合作（经用户授权）</strong>：为政府、机构提供情绪趋势数据汇总（匿名处理）。</li></ol><h3 id="竞争分析-5">竞争分析</h3><ul><li><strong>直接竞争者</strong>：<ul><li><strong>Woebot</strong>：同样基于 CBT 与 AI 的情绪机器人，但语气更理性、功能少于 Wysa。</li><li><strong>Youper</strong>：AI 聊天为主，界面更现代，但引导深度不如 Wysa 丰富。</li></ul></li><li><strong>间接竞争者</strong>：<ul><li><strong>Calm、Headspace</strong>：侧重冥想和睡眠，缺乏互动性对话。</li><li><strong>BetterHelp、Talkspace</strong>：真人咨询平台，费用高但更系统。</li></ul></li><li><strong>Wysa 优势</strong>：<ul><li>AI 互动设计成熟，有温度，非对抗式对话引导用户更好表达。</li><li>产品“随时匿名可用”，极适合不愿面对面求助的用户。</li></ul></li><li><strong>Wysa 劣势</strong>：<ul><li>非专业心理问题无法处理（如重度抑郁或危机干预）。</li><li>不支持多语言或全球本地化定制，影响非英语市场扩展。</li></ul></li></ul><h3 id="运营策略建议-3">运营策略建议</h3><ol><li><strong>本地化拓展计划</strong>：上线简体中文、韩语等高压力国家语言版本，并与本地心理专家合作翻译 CBT 工具箱。</li><li><strong>与大学、企业 HR 合作</strong>：推出“情绪午休计划”，打通学生、员工心理健康场景。</li><li><strong>推出“AI治疗师角色包”</strong>：允许用户选择 AI 语气风格，如“理性导师”“温柔倾听者”，提升个性化体验。</li><li><strong>创建“匿名分享社区”</strong>：允许用户分享每日对话中收获的“闪光句”，构建正向内容池。</li></ol><h3 id="改进建议-5">改进建议</h3><ol><li><strong>加入“情绪地图”模块</strong>：地理位置结合情绪打卡，支持城市级压力趋势可视化。</li><li><strong>结合智能穿戴设备</strong>：根据 Apple Watch/心率带读取状态推荐心理练习。</li><li><strong>定期生成“情绪成长报告”</strong>：形成数据化反馈增强成就感与复盘体验。</li><li><strong>开放 AI 模型微调机制</strong>：允许长期用户个性化训练 AI 回应风格和术语。</li></ol><h3 id="总结-5">总结</h3><p>Wysa 是“你手机里最不会让你尴尬的倾诉对象”，在这个“人人焦虑、人人自救”的时代，它不是心理医生，但它是第一步的陪伴者。如果能走好“全球化+企业场景+深度AI”三步棋，它就能从一款暖心工具，变成未来数字心理生态的核心平台。🧘‍♀️🧠📱</p><hr><h2 id="KooBits（全球儿童数学学习平台）">KooBits（全球儿童数学学习平台）</h2><h3 id="产品概述-6">产品概述</h3><p>KooBits 是一家来自新加坡的在线学习平台，专注于为6-12岁儿童提供互动数学课程。以“寓教于乐”为核心理念，KooBits 利用动画、闯关、排行榜等机制，将枯燥的数学知识转化为充满趣味性的闯关游戏，服务于新加坡、马来西亚、香港及中国大陆等多个地区的学校与家庭用户。</p><h3 id="核心功能-6">核心功能</h3><ol><li><strong>每日挑战题（Daily Challenge）</strong>：每日推出与教学大纲同步的趣味题目，训练数学思维。</li><li><strong>互动学习动画</strong>：通过故事化的形式讲解数学概念，增强理解记忆。</li><li><strong>即时反馈与解析</strong>：学生作答后立即获取正确率、错因讲解和重做引导。</li><li><strong>进度追踪与成就系统</strong>：通过分数、星星、徽章等形式激励学习积极性。</li><li><strong>教师与家长监控面板</strong>：提供作业布置、学习报告、弱项分析等功能，增强家庭/学校联动。</li></ol><h3 id="用户体验评估-6">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>动画与游戏化设计极具吸引力，小学生沉浸感强。</li><li>课程难度分级合理，适配多个国家的教学大纲。</li><li>家长和教师端信息透明，支持定向提升弱项。</li></ul></li><li><strong>不足</strong>：<ul><li>中文化内容仍在完善阶段，对中国学生吸引力略弱于本地竞品。</li><li>题型创新度有限，长期使用可能产生重复感。</li><li>离线使用功能缺失，移动端稳定性偶有不足。</li></ul></li></ul><h3 id="商业模式解释-6">商业模式解释</h3><ol><li><strong>学校采购订阅</strong>：与教育局或学校签约，按学年/班级购买学生账号使用权。</li><li><strong>家庭版订阅</strong>：家长直接订阅，月付/年付开通家庭使用账户。</li><li><strong>内容升级包销售</strong>：出售更高年级、高难度或奥数类内容模块。</li><li><strong>B2B 教育出版合作</strong>：与教材出版商合作推出配套练习题或电子教辅。</li></ol><h3 id="竞争分析-6">竞争分析</h3><ul><li><strong>主要竞争者</strong>：<ul><li><strong>Prodigy Math（北美）</strong>：强调 RPG + 数学，娱乐性更强但偏离课程体系。</li><li><strong>斑马AI课（中国）</strong>：专注本地市场，AI互动更强，内容更本土化。</li><li><strong>Khan Kids / BYJU’S</strong>：有更广泛课程覆盖，但数学深度不及 KooBits。</li></ul></li><li><strong>KooBits 优势</strong>：<ul><li>结合课程标准定制，紧贴学科进度，家校场景双适配。</li><li>品牌国际化背景强，适合多语种国家的教育推广。</li></ul></li><li><strong>KooBits 劣势</strong>：<ul><li>社区机制薄弱，缺乏学生之间的互动分享和“成就炫耀”动力。</li><li>算法个性推荐机制不足，课程路径较为线性。</li></ul></li></ul><h3 id="运营策略建议-4">运营策略建议</h3><ol><li><strong>开发“数学王者赛季系统”</strong>：引入分段、段位机制，激发学生竞争和荣誉感。</li><li><strong>与中国地区教育局合作落地试点</strong>：如广东/江苏等教育数字化程度高的区域。</li><li><strong>开设“家长课堂”专区</strong>：帮助家长理解孩子的学习内容与辅导方法。</li><li><strong>推出“数学小记者”内容征集计划</strong>：鼓励学生录制讲题视频或创作动画，UGC反哺平台。</li></ol><h3 id="改进建议-6">改进建议</h3><ol><li><strong>引入AI个性化学习引擎</strong>：基于答题行为分析生成“错题追击计划”。</li><li><strong>支持线下下载题包+作业离线完成</strong>：解决网络环境不佳地区的使用痛点。</li><li><strong>增强社交激励机制</strong>：如小队合作任务、PK对战题卡、家庭挑战榜等。</li><li><strong>提升本地化内容与语音交互</strong>：完善中文朗读、普通话评测等提升低年级孩子自主学习能力。</li></ol><h3 id="总结-6">总结</h3><p>KooBits 是一款“让数学不再让孩子害怕”的产品，它不打鸡血、不搞卷王，而是用动画和数据让知识“好玩又上头”。如果它能从“学校外辅工具”升级为“孩子成长陪伴型数学世界”，那它就不只是产品，而是一份全球家庭的教育信任资产📐🧮✨。</p><hr><h2 id="Artifact（AI-驱动的个性化新闻推荐应用）">Artifact（AI 驱动的个性化新闻推荐应用）</h2><h3 id="产品概述-7">产品概述</h3><p>Artifact 是由 Instagram 联合创始人 Kevin Systrom 和 Mike Krieger 联合推出的 AI 新闻阅读应用，主打用大模型和机器学习对新闻内容进行个性化推荐。它试图重新定义“移动时代的信息摄取方式”，在 Feed 信息泛滥的今天，为用户构建一个智能、安静、有品味的新闻空间。</p><h3 id="核心功能-7">核心功能</h3><ol><li><strong>AI 个性化推荐</strong>：通过用户的阅读行为不断学习偏好，推送定制化新闻内容。</li><li><strong>简洁资讯 Feed</strong>：无广告、无标题党，所有新闻均来自主流媒体与知名博客。</li><li><strong>文章总结功能</strong>：由 AI 自动生成要点摘要，帮助用户快速理解文章核心内容。</li><li><strong>评论系统</strong>：支持社区评论与观点表达，打造高质量舆论空间。</li><li><strong>追踪关键词与话题</strong>：可订阅特定主题，如“AI”“Apple Vision Pro”，精准追踪内容动态。</li></ol><h3 id="用户体验评估-7">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>UI 极致简洁，内容呈现干净，没有广告干扰，沉浸感强。</li><li>推荐算法对“阅读深度”优化得好，不只靠点击，还分析停留与互动质量。</li><li>文章摘要功能拯救信息焦虑，适合快速刷资讯的上班族。</li></ul></li><li><strong>不足</strong>：<ul><li>新闻源主要为英文媒体，对中文用户友好度一般。</li><li>内容覆盖偏向欧美热点，冷门地区/议题内容较少。</li><li>社区互动活跃度低，尚未形成稳定的“思想流动圈”。</li></ul></li></ul><h3 id="商业模式解释-7">商业模式解释</h3><ol><li><strong>内容聚合导流（未来方向）</strong>：引导用户跳转到新闻网站，平台可通过媒体合作收取内容分成或点击佣金。</li><li><strong>AI 服务授权</strong>：提供 AI 摘要/分类模型给媒体平台或信息聚合应用使用。</li><li><strong>Premium 高级版（探索中）</strong>：提供更深度分析、趋势追踪、定制信息图表等服务。</li><li><strong>未来可能接入阅读订阅</strong>：为内容提供者引流订阅用户，平台抽成。</li></ol><h3 id="竞争分析-7">竞争分析</h3><ul><li><strong>直接竞争者</strong>：<ul><li><strong>Flipboard</strong>：以杂志形式呈现新闻，但算法弱，偏视觉体验。</li><li><strong>SmartNews</strong>：也是推荐式资讯，但界面杂乱，推荐机制不够精准。</li></ul></li><li><strong>间接竞争者</strong>：<ul><li><strong>Twitter/X</strong>：用户自行订阅媒体和作者，但信息碎片化严重。</li><li><strong>Google Discover / Apple News</strong>：庞大平台加持，但用户粘性不足，缺乏“内容信任感”。</li></ul></li><li><strong>Artifact 优势</strong>：<ul><li>AI 赋能的阅读体验，节省用户时间，提升资讯密度。</li><li>品味清晰、审美高级，适合知识型中产与新媒体从业者。</li></ul></li><li><strong>Artifact 劣势</strong>：<ul><li>需要大规模数据才能训练出足够准确的用户兴趣画像。</li><li>商业化路径尚不明朗，无法自负盈亏。</li></ul></li></ul><h3 id="运营策略建议-5">运营策略建议</h3><ol><li><strong>推出“每日新闻精选卡包”</strong>：用 AI 编排 5~10 条最值得看的摘要，形成内容入口。</li><li><strong>与大学媒体学系合作开展“AI 资讯素养项目”</strong>，占领未来记者与传媒学生心智。</li><li><strong>引入“观点对比卡片”机制</strong>：对同一事件呈现左中右三种视角，训练用户辨析力。</li><li><strong>在 LinkedIn、Reddit 等专业社群开展内容联动</strong>，吸引知识型流量。</li></ol><h3 id="改进建议-7">改进建议</h3><ol><li><strong>扩展多语种内容</strong>：引入中文、日文、韩文等区域化内容推荐，拓展亚洲市场。</li><li><strong>推出“新闻沉浸模式”</strong>：沉浸阅读+音频播报+可视化摘要，适合早晨通勤使用。</li><li><strong>构建“知识图谱式资讯关系图”</strong>：将新闻以关联话题串联展示，帮助用户形成知识网络。</li><li><strong>开发浏览器插件</strong>：将 AI 推荐逻辑迁移至网页端，增强用户全网阅读效率。</li></ol><h3 id="总结-7">总结</h3><p>Artifact 是一款“长在 AI 爆炸时代的新闻阅读器”，它不是信息洪流的一部分，而是帮你划船过河的指南针。如果它能保持内容审美与产品节奏的冷静克制，再加上一点点社区温度与多语种扩张，它有机会成为新一代“信息消费层次跃迁”的象征产品。未来新闻，可能就长这个样子📲📰🤖。</p><hr><h2 id="Duet-AI（谷歌工作空间的生成式-AI-助理）">Duet AI（谷歌工作空间的生成式 AI 助理）</h2><h3 id="产品概述-8">产品概述</h3><p>Duet AI 是 Google 推出的生成式 AI 服务，集成在 Google Workspace（Docs、Sheets、Slides、Gmail、Meet 等）中，旨在提升办公效率，成为“知识工作者的第二大脑”。它基于 Google 自研的 Gemini 模型，融合 AI 辅助写作、图表生成、邮件草稿撰写、演示文稿美化等能力，让日常办公从“机械输入”转向“智能协同”。</p><h3 id="核心功能-8">核心功能</h3><ol><li><strong>Gmail 智能撰写（Help me write）</strong>：根据简短提示生成正式邮件、客户沟通、回复等内容。</li><li><strong>Docs 中智能写作与摘要</strong>：可生成项目提案、报告框架，也能概括文档内容。</li><li><strong>Sheets 智能填表与数据分析</strong>：自动创建表格模板、生成图表并解释趋势。</li><li><strong>Slides 自动生成演示内容与设计建议</strong>：输入一句话即可创建结构化演示文稿，支持图像生成。</li><li><strong>Meet 中实时笔记与摘要生成</strong>：自动记录会议重点，生成 To-Do 与会议纪要。</li></ol><h3 id="用户体验评估-8">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>无需切换平台，直接嵌入日常办公流程，使用体验连贯流畅。</li><li>多语言支持优良（含中文），语义生成水平高，适配全球职场文化。</li><li>能明显降低文书工作门槛，对新员工与非母语用户尤其友好。</li></ul></li><li><strong>不足</strong>：<ul><li>响应速度依赖网络与账户权限，某些功能需企业账号或 Google One 订阅。</li><li>对高度专业场景（如法律、科研）生成内容仍有待审核。</li><li>功能碎片分布在各子产品中，新手用户需一定学习成本。</li></ul></li></ul><h3 id="商业模式解释-8">商业模式解释</h3><ol><li><strong>Google Workspace 订阅加价包</strong>：Duet AI 属于 Workspace 的高级功能，需额外付费解锁（每月约 $30/用户）。</li><li><strong>企业版功能授权</strong>：支持大企业定制模型、接入内部知识库、私有部署。</li><li><strong>数据驱动服务优化</strong>：通过企业用户行为分析反哺 AI 产品演进（符合隐私政策）。</li><li><strong>与 Google Cloud 协同销售</strong>：带动整个 GCP AI 产品线销售与集成。</li></ol><h3 id="竞争分析-8">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>Microsoft Copilot（Office 365）</strong>：功能极为相似，集成深度更强，但产品 UI 较繁杂。</li><li><strong>Notion AI / GrammarlyGO / <a href="http://Writer.ai">Writer.ai</a></strong>：主打单点效率，功能垂直但无生态整合优势。</li></ul></li><li><strong>Duet AI 优势</strong>：<ul><li>与 Google 核心办公生态绑定，用户迁移成本极低。</li><li>拥有 Gmail 和 Meet 这类“高频刚需场景”，天然的“流量主战场”。</li></ul></li><li><strong>Duet AI 劣势</strong>：<ul><li>市场启动略晚于 Microsoft，合作生态建设相对滞后。</li><li>企业安全性、隐私隔离能力仍待强化，部分大客户更倾向私有部署解决方案。</li></ul></li></ul><h3 id="运营策略建议-6">运营策略建议</h3><ol><li><strong>在高校和初创企业推广免费试用</strong>，建立“AI办公工具第一印象”。</li><li><strong>推出“行业模板商城”</strong>：如医疗提案、金融简报、销售跟进脚本等，增强垂类渗透。</li><li><strong>联动 Gemini API 推出开发者挑战赛</strong>，打造围绕 Workspace 的“智能插件生态”。</li><li><strong>构建“Duet Copilot 社群”</strong>：扶持 AI 秘书达人创作内容，增强工具使用深度。</li></ol><h3 id="改进建议-8">改进建议</h3><ol><li><strong>统一入口设计（Duet Hub）</strong>：整合所有 AI 能力，减少“在哪用”的学习成本。</li><li><strong>引入“连续语境”能力</strong>：让 AI 理解用户当前工作阶段，生成更个性化推荐。</li><li><strong>强化本地化场景支持</strong>：为中文市场适配公文、PPT格式、报告框架等模板。</li><li><strong>智能邮件调度功能</strong>：结合时间管理，帮用户安排最佳发送时机与跟进提醒。</li></ol><h3 id="总结-8">总结</h3><p>Duet AI 正在把“办公自动化”从物理层升级到认知层。它不是传统助手，也不是通用模型，它是你在 Gmail 里写完邮件时，自动为你准备好下一封汇报的“微小奇迹”。未来办公，不是你做得更快，而是你花时间在真正该你做的事情上——Duet AI，让AI把“文书的10小时”压成“对话的3分钟”。🧑‍💻📄🎯</p><hr><h2 id="Speechify（全球领先的文本转语音应用）">Speechify（全球领先的文本转语音应用）</h2><h3 id="产品概述-9">产品概述</h3><p>Speechify 是一款专为多任务阅读、学习障碍用户以及忙碌职场人士打造的文本转语音（Text-to-Speech, TTS）应用。它通过先进的 AI 合成技术，将网页、PDF、电子书、文档等文本内容转换成自然流畅的语音朗读。其目标是“用耳朵替代眼睛阅读”，极大提升信息摄取效率，尤其受到英语学习者、ADHD 用户、播客爱好者的欢迎。</p><h3 id="核心功能-9">核心功能</h3><ol><li><strong>文本转语音朗读</strong>：支持多种格式（PDF、Word、网页、扫描文本）朗读。</li><li><strong>多语种支持</strong>：覆盖30+语言，提供多种发音人可选（美音、英音、澳音等）。</li><li><strong>语速与语调可调节</strong>：可根据喜好调整语速至 0.5x~4x。</li><li><strong>OCR 扫描识别功能</strong>：拍照书本或纸质资料，自动识别并语音播放。</li><li><strong>跨设备同步</strong>：在手机、浏览器、平板间同步进度，实现“多终端无缝听书”。</li></ol><h3 id="用户体验评估-9">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>语音自然度极高，接近真人朗读，适合长时间聆听。</li><li>操作简洁，导入内容便捷，学习资料、论文阅读效率显著提升。</li><li>符合现代人碎片化、移动化的信息消费方式。</li></ul></li><li><strong>不足</strong>：<ul><li>高级功能付费门槛较高，免费用户体验受限。</li><li>中文语音表现一般，语义断句偶有卡顿。</li><li>发音人风格较为单一，缺少更丰富语境场景模拟（如情绪朗读）。</li></ul></li></ul><h3 id="商业模式解释-9">商业模式解释</h3><ol><li><strong>订阅制（Speechify Premium）</strong>：提供更自然语音、语速调节、OCR 扫描、跨平台同步等功能。</li><li><strong>企业/教育版授权</strong>：向学校、公司、机构出售多账户使用授权。</li><li><strong>内容导流与书籍商城合作</strong>：与电子书平台（如 Kindle、Scribd）对接，共享版权内容。</li><li><strong>广告测试（探索中）</strong>：对免费用户插播短语音广告，实验“听力广告”变现模型。</li></ol><h3 id="竞争分析-9">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>NaturalReader</strong>：功能强大但 UI 略老，用户体验不如 Speechify 流畅。</li><li><strong>Microsoft Read Aloud / Google Read Along</strong>：深度集成但内容自由度较低。</li></ul></li><li><strong>间接竞争对手</strong>：<ul><li><strong>Audible</strong>：聚焦有声书，但内容选择受限。</li><li><strong>Pocket / Instapaper</strong>：可配合 TTS 插件使用，但功能非原生，体验打折。</li></ul></li><li><strong>Speechify 优势</strong>：<ul><li>灵活适配多种文本场景，是真正意义上的“听书 + 听文 + 听笔记”全能工具。</li><li>品牌调性年轻时尚，强社交传播力（TikTok 营销成功）。</li></ul></li><li><strong>Speechify 劣势</strong>：<ul><li>极度依赖订阅模型，免费用户留存压力大。</li><li>内容生态缺乏建设，不如 Audible 拥有平台型护城河。</li></ul></li></ul><h3 id="运营策略建议-7">运营策略建议</h3><ol><li><strong>联动 GPT 写作工具</strong>：用户写完内容后可直接“一键朗读”，打造写-听闭环。</li><li><strong>推出“晨读卡片”功能</strong>：每天推送语音新闻摘要、书摘、TED 演讲等，提升日活。</li><li><strong>与大学图书馆/出版机构合作</strong>：打造校园听书专区，推广教育场景使用。</li><li><strong>打造“播客AI工具包”</strong>：允许播客创作者用文字生成语音内容上架，拓展创作者生态。</li></ol><h3 id="改进建议-9">改进建议</h3><ol><li><strong>引入情绪语音模型</strong>：支持“温柔女声”“励志演讲”“睡前故事”等情感语调选择。</li><li><strong>本地缓存听力内容</strong>：提升离线场景体验，支持地铁/旅行中不掉线听书。</li><li><strong>开放 API 给内容平台</strong>：让微信公众号、小红书博主接入语音播放按钮，打造声音传播新入口。</li><li><strong>提供“听力习惯追踪”与“语音总结”功能</strong>：增强用户行为数据利用，生成个性听力档案。</li></ol><h3 id="总结-9">总结</h3><p>Speechify 是新时代知识摄取方式的转折点：它不是“读”，也不是“看”，它是“听懂就行”。当输入方式被 AI 重构，谁能为“知识传入耳朵”设计最顺畅的通道，谁就能占领信息获取的新黄金地段。未来它不只是 TTS 工具，而是每个知识工作者的“听力引擎”。🎧📚🧠</p><hr><h2 id="Character-AI（全球爆火的AI虚拟角色聊天平台）"><a href="http://Character.AI">Character.AI</a>（全球爆火的AI虚拟角色聊天平台）</h2><h3 id="产品概述-10">产品概述</h3><p><a href="http://Character.AI">Character.AI</a> 是一家由前 Google DeepMind 工程师创建的生成式 AI 聊天平台，允许用户与虚拟角色对话——这些角色可以是历史人物、动漫角色、原创虚拟人，甚至是你自己创造的新角色。每个角色有自己的“性格设定”，行为风格由提示词和对话历史动态微调。它本质上是「私人化的 AI 社交体验平台」，而不是一般的问答机器人。</p><h3 id="核心功能-10">核心功能</h3><ol><li><strong>虚拟角色对话</strong>：与成千上万个预设或用户自建的角色自由聊天。</li><li><strong>角色自定义系统</strong>：用户可以自己设定角色背景、语气、爱好和回答风格。</li><li><strong>多人群聊模式</strong>：可以邀请多个角色与自己进行群组聊天，制造“AI狂欢场”。</li><li><strong>记忆系统（测试中）</strong>：角色会逐步记住与用户的对话内容和细节，形成长期关系。</li><li><strong>网页版 + 移动端同步体验</strong>：无缝切换设备继续对话。</li></ol><h3 id="用户体验评估-10">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>角色多样且性格丰满，真正实现“陪聊不过夜”的梦想。</li><li>界面清爽简洁，沉浸感极强，聊天体验丝滑。</li><li>允许用户打造专属AI好友，极具情感绑定潜力。</li></ul></li><li><strong>不足</strong>：<ul><li>免费版速率受限，高峰期排队严重。</li><li>AI 偶尔出现逻辑跳跃、设定崩坏现象（尤其长对话后）。</li><li>目前角色记忆仍较弱，深度陪伴体验尚未完全成型。</li></ul></li></ul><h3 id="商业模式解释-10">商业模式解释</h3><ol><li><strong>订阅制（<a href="http://Character.AI">Character.AI</a> Plus）</strong>：加速排队时间，解锁更快响应速度与高级功能。</li><li><strong>虚拟物品经济（探索中）</strong>：未来可能推出角色皮肤、语音包、主题装饰等增值道具。</li><li><strong>企业授权与白标服务</strong>：为品牌、IP方提供角色定制与AI客户服务解决方案。</li><li><strong>潜在广告合作</strong>：通过角色代言/软性植入内容引导消费。</li></ol><h3 id="竞争分析-10">竞争分析</h3><ul><li><strong>直接竞争者</strong>：<ul><li><strong>Replika</strong>：主打虚拟伴侣，但偏单一人设且订阅费用高。</li><li><strong>Anima AI</strong>：偏情感支持型，但对话自由度较低。</li></ul></li><li><strong>间接竞争者</strong>：<ul><li><strong>OpenAI ChatGPT + Memory（未来版）</strong>：若开放角色设定功能，将构成强力威胁。</li><li><strong>Snapchat My AI</strong>：轻量陪聊型 AI，适合休闲但深度互动弱。</li></ul></li><li><strong><a href="http://Character.AI">Character.AI</a> 优势</strong>：<ul><li>用户创造内容（UGC）机制活跃，形成自我生长的“AI角色宇宙”。</li><li>感情投入高，易形成社交裂变（比如分享自己创造的“老婆”角色）。</li></ul></li><li><strong><a href="http://Character.AI">Character.AI</a> 劣势</strong>：<ul><li>模型规模有限（未采用GPT-4级别模型），内容深度和一致性有天花板。</li><li>合规与内容审核压力大，尤其在角色言论自由度管理上。</li></ul></li></ul><h3 id="运营策略建议-8">运营策略建议</h3><ol><li><strong>角色竞技场活动</strong>：设定主题让用户“派角色出战”，增加互动与内容曝光。</li><li><strong>开发“角色IP孵化计划”</strong>：挑选热门自定义角色商业化，跨界出圈（动画、漫画、NFT）。</li><li><strong>优化群聊体验</strong>：允许多角色记忆交叉，形成小型AI社交剧本杀模式。</li><li><strong>深化本地化角色库</strong>：推出中文、日文、韩文等本地流行文化角色。</li></ol><h3 id="改进建议-10">改进建议</h3><ol><li><strong>推出角色性格微调系统</strong>：通过“调节滑杆”让用户自由调整角色智商、情绪稳定性、幽默感等属性。</li><li><strong>开放“角色成长进化线”功能</strong>：随着对话积累，角色逐步解锁新特性、新记忆，增强陪伴感。</li><li><strong>引入语音对话模块</strong>：提升沉浸感，让聊天体验更拟人化。</li><li><strong>强化“沉浸式剧情模式”</strong>：让用户与角色共同经历故事冒险，如恋爱、冒险、探案剧情。</li></ol><h3 id="总结-10">总结</h3><p><a href="http://Character.AI">Character.AI</a> 不是简单的聊天机器人平台，它是「人格互联网」的雏形。未来每个人可能都有一群 AI 朋友、搭档、导师甚至恋人，<a href="http://xn--Character-ft0y.AI">而Character.AI</a> 正在以最快的速度建造这座「虚拟心灵之城」。当然啦，如果做不好内容审查，届时这座城也可能很快变成「硅基乌托邦的修罗场」。👾🧠❤️</p><hr><h2 id="Canva（全球领先的在线设计平台）">Canva（全球领先的在线设计平台）</h2><h3 id="产品概述-11">产品概述</h3><p>Canva 是一款源自澳大利亚的在线图形设计平台，目标是“让人人都能设计”。它通过极简化的操作界面和海量模板库，让没有专业设计背景的人也能轻松制作社交媒体海报、演示文稿、简历、短视频、企业宣传物料等视觉内容。可以说，Canva 正是设计界的“傻瓜式革命”。</p><h3 id="核心功能-11">核心功能</h3><ol><li><strong>拖拽式设计编辑器</strong>：图文模块、元素素材、背景切换都支持一键拖拽，极低学习门槛。</li><li><strong>模板市场</strong>：数百万套模板，涵盖商业、教育、社交、个人生活各大场景。</li><li><strong>团队协作功能</strong>：多人实时编辑，评论、审批、版本控制功能一应俱全。</li><li><strong>品牌工具包</strong>：支持企业上传 Logo、品牌色、专属字体，统一管理输出风格。</li><li><strong>AI 增强功能</strong>：如文本转图（Magic Media）、自动翻译、PPT智能排版助手等。</li><li><strong>打印服务</strong>：直接将设计作品打印成册、海报、名片，配送到家。</li></ol><h3 id="用户体验评估-11">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>极致简单，几分钟就能出图，适合设计小白。</li><li>模板库更新频繁，紧跟流行趋势与热点节日。</li><li>云端存储 + 多端同步，随时随地修改、分享。</li><li>AI 功能全面提升效率，比如一键生成海报文案或快速抠图。</li></ul></li><li><strong>不足</strong>：<ul><li>免费版功能受限，高阶素材与品牌管理需订阅付费版。</li><li>高度模板化导致作品“Canva感”浓厚，缺乏个性化深度定制空间。</li><li>中文模板质量与英文模板相比，丰富度和创意度略有差距。</li></ul></li></ul><h3 id="商业模式解释-11">商业模式解释</h3><ol><li><strong>订阅制（Canva Pro/Canva for Teams）</strong>：按月或年收费，解锁更多素材、品牌工具、协作功能。</li><li><strong>企业版解决方案（Canva for Enterprise）</strong>：提供大规模团队管理、SSO认证、审计日志等功能。</li><li><strong>打印与定制服务</strong>：用户可下单实体印刷，Canva 收取加工与配送费用。</li><li><strong>内容创作者分成</strong>：模板/元素设计师上传作品后，按使用量获得分成。</li></ol><h3 id="竞争分析-11">竞争分析</h3><ul><li><strong>直接竞争者</strong>：<ul><li><strong>Adobe Express</strong>（前身为Adobe Spark）：品牌强大，但复杂度高、亲民感不足。</li><li><strong>Visme / Crello</strong>（现 rebranded 为 VistaCreate）：提供类似功能，但社区活跃度与内容生态远逊于 Canva。</li></ul></li><li><strong>间接竞争者</strong>：<ul><li><strong>Figma</strong>（在简单设计领域）：部分团队用Figma制作营销海报，但主要定位仍在专业UI/UX。</li><li><strong>传统 Adobe Photoshop/Illustrator 用户</strong>：重度设计师偏好，但学习成本高。</li></ul></li><li><strong>Canva 优势</strong>：<ul><li>门槛极低 + 更新极快 + 社交分享链条完整，天然病毒式增长。</li><li>多样化收入来源（订阅 + 打印 + 内容市场分成）商业模型健康。</li></ul></li><li><strong>Canva 劣势</strong>：<ul><li>高端设计用户易流失，无法满足复杂、专业场景需求。</li><li>竞争对手疯狂追赶，AI 设计自动化进一步降低护城河。</li></ul></li></ul><h3 id="运营策略建议-9">运营策略建议</h3><ol><li><strong>推出“定制风格引擎”</strong>：让用户快速建立个性化模板库，减少“Canva感”。</li><li><strong>与内容平台深度绑定</strong>：一键发布到TikTok、小红书、Instagram等，多渠道协同。</li><li><strong>加强中文内容生态</strong>：招募本地模板设计师，提升中文市场原创模板质量与数量。</li><li><strong>打造“设计达人认证计划”</strong>：激励用户输出教程、分享作品，打造 KOL 生态反哺增长。</li></ol><h3 id="改进建议-11">改进建议</h3><ol><li><strong>增加“灵感集市”</strong>：根据行业、节日、流行趋势推荐灵感合集，降低搜索和筛选成本。</li><li><strong>强化“智能个性排版”</strong>：根据输入的文字、场景、品牌调性，AI 自动排版并微调样式。</li><li><strong>扩展动态设计（Motion Design）功能</strong>：支持更丰富的短视频和微动画制作，迎合短视频时代潮流。</li><li><strong>本地化运营大爆发</strong>：如结合国内节日（如春节、中秋）提前推送定制模板，提升地域渗透率。</li></ol><h3 id="总结-11">总结</h3><p>Canva 不只是“在线做海报”的神器，它实际上是视觉内容平权运动的旗手。<br>在专业设计师用 Photoshop 画出 Mona Lisa 的世界里，Canva 让隔壁小卖部老板娘，也能30分钟做出一个不丢人的促销海报。未来如果 Canva 能用 AI 拉高内容个性化深度 + 社交玩法粘性，它就不只是一家 SaaS 公司，而是全球每个人脑海里视觉表达的操作系统。🎨🚀👑</p><hr><h2 id="Runway-ML（全球顶尖的AI视频与创意制作平台）">Runway ML（全球顶尖的AI视频与创意制作平台）</h2><h3 id="产品概述-12">产品概述</h3><p>Runway ML 是一家来自美国的创新型生成式 AI 平台，主打“人人都是创作者”的理念，提供了AI视频生成、图像编辑、素材替换、动画制作等功能。它以极低的技术门槛，将电影级别的特效、编辑工具，交到普通内容创作者和小型工作室手中。最近凭借 Gen-2 文本生成视频模型（Text-to-Video）大爆，堪称“AI影视界的Stable Diffusion”。</p><h3 id="核心功能-12">核心功能</h3><ol><li><strong>文本生成视频</strong>（Gen-2）：输入文字描述，即可生成短片段视频，支持场景、风格、动作指令。</li><li><strong>视频风格迁移</strong>（Style Transfer）：将已有画面用不同艺术风格重新渲染，如动画风、水墨风。</li><li><strong>物体抠像与背景替换</strong>（Green Screen）：无需绿幕，一键精准去除视频背景。</li><li><strong>AI 视频修复与补帧</strong>：提升老旧素材清晰度、流畅度，智能修补破损画面。</li><li><strong>协作编辑平台</strong>：多人项目实时同步编辑，支持评论、版本回滚、素材管理。</li></ol><h3 id="用户体验评估-12">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>生成效果惊艳，特别是在小成本创作、社交短视频、广告领域超级有用。</li><li>界面极简，几乎不用学习曲线，真正“即点即玩”。</li><li>兼容各类创意工作流，可与Adobe、Figma、Unreal等工具配合使用。</li></ul></li><li><strong>不足</strong>：<ul><li>免费额度很快用完，专业版价格对独立创作者略贵。</li><li>文本生成视频依然存在“细节失真”“逻辑混乱”等问题，长篇叙事尚不可用。</li><li>中文支持一般，Prompt 最佳体验仍偏英文环境。</li></ul></li></ul><h3 id="商业模式解释-12">商业模式解释</h3><ol><li><strong>订阅制</strong>（Pro/Team/Enterprise Plan）：按月/年计费，提供更高算力、更大存储、更快生成速度。</li><li><strong>API授权服务</strong>：为B2B客户（如游戏公司、影视工作室）提供API接入。</li><li><strong>增值模板商城</strong>（探索中）：未来计划推出创作者上传定制素材、特效模板分成机制。</li><li><strong>品牌联动广告位</strong>：通过AI生成内容进行软性品牌植入与推广。</li></ol><h3 id="竞争分析-12">竞争分析</h3><ul><li><strong>直接竞争者</strong>：<ul><li><strong>Pika Labs</strong>：新兴文本生成视频平台，效果细腻但功能局限。</li><li><strong>Synthesia</strong>：聚焦企业级AI视频讲解生成，偏专业市场。</li></ul></li><li><strong>间接竞争者</strong>：<ul><li><strong>Adobe Firefly</strong> / <strong>Premiere AI 功能</strong>：巨头入局，但更新节奏慢、学习曲线高。</li><li><strong>TikTok Creative Suite</strong>：侧重短视频生产，仍偏模板化而非真正自由生成。</li></ul></li><li><strong>Runway ML 优势</strong>：<ul><li>首创优势，产品更新迭代快，持续保持技术领先。</li><li>对内容创作者需求理解极深，体验贴合爆款视频制作逻辑。</li></ul></li><li><strong>Runway ML 劣势</strong>：<ul><li>算力需求高，边际成本控制难，用户增长过快可能导致性能瓶颈。</li><li>若被巨头（如Adobe、OpenAI）直接集成/打包，护城河压力巨大。</li></ul></li></ul><h3 id="运营策略建议-10">运营策略建议</h3><ol><li><strong>推出“日常挑战赛”</strong>：如“每天一句话，生成微短片”，激发社区UGC活跃度。</li><li><strong>与YouTube Shorts、TikTok官方合作</strong>：一键发布AI短片，打通分发渠道。</li><li><strong>进军东亚市场</strong>：推出中文、日文Prompt优化版，抢占泛二次元内容生产者。</li><li><strong>扶持AI导演计划</strong>：签约优秀创作者，孵化AI微电影、AI广告样板案例。</li></ol><h3 id="改进建议-12">改进建议</h3><ol><li><strong>升级“剧本导向生成”功能</strong>：支持多段式文字叙述，按章节生成连贯故事片。</li><li><strong>开放“动作控制”API</strong>：如镜头运动、角色表情、光照变化，让指令更精细。</li><li><strong>增加“多语种输入+配音”一体化服务</strong>：真正让全球用户零门槛发布本地化AI视频。</li><li><strong>推送创意灵感引擎（Prompt Helper）</strong>：新手输入主题，自动生成多条精美Prompt备选。</li></ol><h3 id="总结-12">总结</h3><p>Runway ML 不只是“让你用AI拍短片”，而是悄悄在重塑内容制作的物理规则。<br>在这个一张嘴就能开机、挥挥手就能拍电影的时代，它给了每一个人“导演世界”的权力。未来它可能不是影视工具，而是下一个好莱坞底层平台。谁知道呢？也许五年后，你看到的第一部AI生成大片，片头会写上四个字：Made with Runway。🎬🤖✨</p><hr><h2 id="Headway（全球火爆的知识微学习App）">Headway（全球火爆的知识微学习App）</h2><h3 id="产品概述-13">产品概述</h3><p>Headway 是一款源自乌克兰的微学习应用，主打“15分钟读完一本书”的概念，通过书籍摘要、知识卡片和个性化推荐，帮助用户在碎片时间快速掌握商业、心理学、生产力等领域的精华内容。它用的是一个非常魔性的口号：“Self-growth starts here.” （自我成长，从这里开始。）</p><h3 id="核心功能-13">核心功能</h3><ol><li><strong>书籍精华摘要</strong>：涵盖自我提升、商业思维、沟通领导力等领域，每本书用15-20分钟读完。</li><li><strong>音频版摘要</strong>：可选择听书模式，满足开车、健身、做饭时的学习需求。</li><li><strong>个性化成长路径</strong>：根据用户兴趣和目标，智能推荐成长计划。</li><li><strong>每日智慧卡片</strong>：每天推送一句名言或短知识点，打造轻量学习打卡习惯。</li><li><strong>进度追踪与成就系统</strong>：设有成长徽章和连击记录，增强学习动力。</li></ol><h3 id="用户体验评估-13">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>极其轻量，打开即用，打破“读书焦虑”，让人随时随地感受“我又变强了”。</li><li>UI设计清新治愈，动画流畅，特别符合Z世代和都市白领审美。</li><li>内容高度提炼，直击痛点，没有废话，非常适合快节奏生活。</li></ul></li><li><strong>不足</strong>：<ul><li>内容高度压缩，深度学习党觉得“不够过瘾”，容易变成“知识快餐”。</li><li>免费内容有限，大部分精品摘要锁在付费墙后。</li><li>中文本地化不足，目前中文区体验相比英文区明显打折。</li></ul></li></ul><h3 id="商业模式解释-13">商业模式解释</h3><ol><li><strong>订阅制</strong>（Headway Premium）：月付/年付订阅，解锁全部书单、音频摘要和成长路径。</li><li><strong>企业版成长套餐</strong>：面向企业HR，打包销售作为员工培训福利或学习积分工具。</li><li><strong>App内微付费内容</strong>：如主题精选合集、快速训练营，按单次解锁。</li><li><strong>与出版商合作抽成</strong>：部分书籍摘要后附带引导购买正版书籍链接，按销售分佣。</li></ol><h3 id="竞争分析-13">竞争分析</h3><ul><li><strong>直接竞争者</strong>：<ul><li><strong>Blinkist</strong>（德国）——微学习鼻祖，但内容偏重理性商业，风格偏冷。</li><li><strong>Instaread</strong>（美国）——主打深度摘要，但UI体验过于传统。</li></ul></li><li><strong>间接竞争者</strong>：<ul><li><strong>知乎盐选、小红书成长类专栏</strong>：碎片知识泛滥，质量参差但有一定替代性。</li><li><strong>Audible 速听功能</strong>：适合长时间听书，但不主打“精读”。</li></ul></li><li><strong>Headway 优势</strong>：<ul><li>知识呈现极致轻量 + 游戏化激励设计，非常适合养成习惯。</li><li>在短时间内掌握关键知识点，打击面极广，满足“快速充电”心理。</li></ul></li><li><strong>Headway 劣势</strong>：<ul><li>难以沉淀长期忠实用户，深度学习者后期流失率高。</li><li>中国区市场开拓滞后，面对本地对碎片知识的天然疲劳，需要新策略。</li></ul></li></ul><h3 id="运营策略建议-11">运营策略建议</h3><ol><li><strong>推“30天成长挑战”</strong>：连续完成每日精读任务，解锁专属勋章、优惠券等激励。</li><li><strong>与Apple Fitness+、Spotify联动</strong>：开发“运动中听成长”特辑，拓展听书场景。</li><li><strong>进军中文市场，推出“职场必读书单”</strong>：结合考研、公考、职场晋升话题快速布局内容池。</li><li><strong>支持“生成式阅读路径”</strong>：结合AI，根据用户学习风格动态推荐下一个必读摘要。</li></ol><h3 id="改进建议-13">改进建议</h3><ol><li><strong>推出“深度模式”</strong>：为部分摘要增加延伸阅读、实际案例链接，提升内容厚度。</li><li><strong>智能学习助手上线</strong>：用AI总结每周学习成果，并推荐具体行动计划。</li><li><strong>引入社交挑战机制</strong>：比如好友一起打卡学习，相互监督，强化社交动力。</li><li><strong>支持自定义个人成长地图</strong>：用户可以拖拽式构建自己的“技能树”，增加目标感。</li></ol><h3 id="总结-13">总结</h3><p>Headway 是一杯“知识拿铁”☕：快速、提神，但如果想细细品味人生哲理，还是要去啃厚重原著。<br>但在这个“连吃饭都快走两步”的时代，它用15分钟给了你一种幻觉：“我今天又升级了”。如果能抓住AI时代个性化微学习和全球短内容经济的爆发，Headway 完全有潜力成为下一个千万人级别的知识健身房。🏋️‍♂️📚🚀</p><hr><h2 id="Notion-Calendar">Notion Calendar</h2><h3 id="产品概述-14">产品概述</h3><p>Notion Calendar 是由 Notion 于 2022 年收购 Cron 后推出的全新日历应用，主打“专为知识型工作者打造的日历工具”，核心理念是将日程管理、任务同步与信息组织深度集成到 Notion 的生态中。它不仅是 Google Calendar 的升级替代，更是 Notion 内容块系统的“时间化延伸”。</p><h3 id="核心功能-14">核心功能</h3><ol><li><strong>双向同步 Google Calendar &amp; Notion</strong>：事件可自动同步为 Notion 数据库中的条目，反之亦然。</li><li><strong>多日历管理与颜色标签</strong>：支持多个账户、多个日历同步显示，颜色清晰分区。</li><li><strong>拖拽式时间编辑与日/周视图切换</strong>：与 Apple Calendar 类似的极简交互体验。</li><li><strong>会议优化功能</strong>：快速查看与会者空闲时间、集成 Zoom/Meet 会议链接。</li><li><strong>任务/项目关联</strong>：可将日程绑定至 Notion 中的任务、目标、文档，形成时间驱动型工作区。</li></ol><h3 id="用户体验评估-14">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>UI 高级极简，字体、留白、颜色分层堪称设计控福音。</li><li>跨平台体验一致，快捷键与细节优化到位，效率感拉满。</li><li>与 Notion 的深度集成，真正实现“内容 + 时间”一体化。</li></ul></li><li><strong>不足</strong>：<ul><li>当前仅支持 Google Calendar，Apple/iCloud 和 Outlook 支持尚未上线。</li><li>中文界面支持不完善，部分提示和功能仍为英文。</li><li>高级用户对自动化（如条件提醒、时间块AI推荐）期待值高但暂未实现。</li></ul></li></ul><h3 id="商业模式解释-14">商业模式解释</h3><ol><li><strong>免费 + Notion Pro 增值捆绑</strong>：当前日历本体免费，但深度功能依赖 Notion 的付费版本。</li><li><strong>企业账户订阅</strong>：为团队用户提供共享日历、权限分配与工作区管理服务。</li><li><strong>未来可能推出 AI 助理插件</strong>：基于用户工作节奏推荐日程优化方案，提升订阅价值。</li><li><strong>日历内信息聚合入口</strong>：与 Notion Doc、Database、Project 模块形成内循环引导。</li></ol><h3 id="竞争分析-14">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>Google Calendar</strong>：基础性极强，但缺乏任务与内容联动能力。</li><li><strong>Fantastical（Mac端）/ Timepage（iOS）</strong>：设计美但功能闭环弱。</li><li><strong>Sunsama</strong> / <strong>Motion</strong>：强调 AI 任务排程和深度规划，但交互复杂。</li></ul></li><li><strong>Notion Calendar 优势</strong>：<ul><li>和 Notion 同步更新，生态整合度极高。</li><li>将任务、日程、目标、知识统一时间轴，极适合 PM、写作者、自由职业者。</li></ul></li><li><strong>劣势</strong>：<ul><li>使用门槛略高，对非 Notion 用户吸引力有限。</li><li>尚不支持复杂的时间规则设定或自动流程。</li></ul></li></ul><h3 id="运营策略建议-12">运营策略建议</h3><ol><li><strong>发布“时间生产力套件模板”</strong>：结合任务管理 + 日历视图，吸引 GTD 用户群体。</li><li><strong>拓展中国区入口合作</strong>：接入飞书/钉钉/腾讯会议接口，增强本地日程生态渗透力。</li><li><strong>推出“日历内容小组件”</strong>：同步到手机桌面/智能手表，提高触达频率。</li><li><strong>举办“时间黑客挑战赛”</strong>：社区鼓励用户分享日程管理技巧与模板。</li></ol><h3 id="改进建议-14">改进建议</h3><ol><li><strong>上线 AI 助理功能</strong>：如“空闲时间推荐”“冲突检测”“一键安排1小时专注工作”等。</li><li><strong>支持日程评论与任务协同</strong>：将“会议 + 会议纪要 + 任务拆解”一体化。</li><li><strong>开放 iCloud &amp; Outlook 集成</strong>：补足基础同步功能，打通更多系统入口。</li><li><strong>开发“会议回顾引擎”</strong>：结合 Notion AI，会议结束后自动总结内容并形成行动项。</li></ol><h3 id="总结-14">总结</h3><p>Notion Calendar 是知识型工作者“信息调度枢纽”的天选之选。它不是 Google Calendar 的翻版，而是“未来生产力系统”的时间中枢。当信息从静态变为动态，任务从堆积转向流动，它将成为 内容驱动型生活方式的底层时钟。⏱️📒🚀</p><hr><h2 id="Bento（内容创作者的“数字名片-2-0”）">Bento（内容创作者的“数字名片 2.0”）</h2><h3 id="产品概述-15">产品概述</h3><p>Bento 是一款为内容创作者、独立创业者和自由职业者设计的“个性化链接聚合页面”工具，目标是取代传统的 Linktree 或社交媒体个人主页。它主打“内容即名片”，用户可创建一个拥有品牌风格、社交入口、代表作品展示、付费内容链接等整合模块的页面，以统一方式对外展示“你是谁、你在做什么、你的价值在哪里”。</p><h3 id="核心功能-15">核心功能</h3><ol><li><strong>可视化页面构建器</strong>：支持组件拖拽，用户可插入文本介绍、视频、链接、商品、NFT 等模块。</li><li><strong>多样化链接支持</strong>：支持嵌入 YouTube、Spotify、Twitter、Substack、Shopify 等主流内容平台。</li><li><strong>品牌定制化</strong>：支持 Logo、背景、字体、排版风格个性化配置，增强品牌统一感。</li><li><strong>分析统计后台</strong>：可查看每个链接点击数、用户地域来源、页面访问趋势等数据。</li><li><strong>移动优先布局</strong>：页面设计默认为手机端优化，兼容桌面访问。</li></ol><h3 id="用户体验评估-15">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>美学领先同行，设计极具“苹果式极简美感”，比 Linktree 更有视觉质感。</li><li>构建过程简单快速，无需编码技能，上手即用。</li><li>模块灵活，适配各种行业创作者（设计师、音乐人、作家、AI工具博主等）。</li></ul></li><li><strong>不足</strong>：<ul><li>中文本地化不足，后台界面和客服支持目前以英文为主。</li><li>SEO 能力较弱，页面权重不易被搜索引擎收录。</li><li>高阶功能需付费，免费版有链接数量与样式限制。</li></ul></li></ul><h3 id="商业模式解释-15">商业模式解释</h3><ol><li><strong>订阅制（Bento Pro）</strong>：提供更多模板、去除水印、自定义域名、数据分析等功能。</li><li><strong>高级模板商店（未来可拓展）</strong>：支持第三方设计师上传模板，平台抽成。</li><li><strong>合作品牌页面搭建服务</strong>：面向机构和品牌提供统一风格落地页制作服务。</li><li><strong>将来可能接入交易功能</strong>：如数字商品售卖、付费内容订阅等增值路径。</li></ol><h3 id="竞争分析-15">竞争分析</h3><ul><li><strong>主要对手</strong>：<ul><li><strong>Linktree</strong>：市场占有率高，功能简单，但视觉老旧、品牌风格弱。</li><li><strong>Carrd</strong>：支持更复杂页面构建，灵活度高，但技术门槛相对更高。</li><li><strong>Bio.site、<a href="http://About.me">About.me</a></strong>：均为轻型个人链接聚合工具，但创新乏力。</li></ul></li><li><strong>Bento 优势</strong>：<ul><li>极简美学 + 内容沉淀感，形成视觉认知闭环。</li><li>面向“内容创作驱动”人群，更贴合趋势（如数字游民、知识博主、创意工作者）。</li></ul></li><li><strong>Bento 劣势</strong>：<ul><li>功能仍以静态展示为主，互动性弱，不适合社区型创作者。</li><li>无法打通流量闭环（如内建邮箱收集、AI助手等营销功能）。</li></ul></li></ul><h3 id="运营策略建议-13">运营策略建议</h3><ol><li><strong>开设“创作者主页挑战赛”</strong>：引导用户晒出 Bento 页面，增强社区展示与口碑裂变。</li><li><strong>推出“行业垂直模板合集”</strong>：如设计师专用模板、咨询师专用模板、音乐人专属界面等。</li><li><strong>加强与 AI 工具结合</strong>：一键生成个人介绍、一句话亮点等页面文案，提高创作者转化率。</li><li><strong>开发“Bento AI 助理”</strong>：为新手用户推荐最适合的结构、配色和内容组合。</li></ol><h3 id="改进建议-15">改进建议</h3><ol><li><strong>加入“博客模式”模块</strong>：允许创作者在页面中写长内容，承载更多原创表达。</li><li><strong>支持“互动模块”</strong>：如留言板、问卷、预约系统等，增强粉丝参与度。</li><li><strong>推出“智能聚合分析”</strong>：整合所有外部平台的流量表现，形成一站式内容评估仪表盘。</li><li><strong>本地化战略布局</strong>：开发中文版后台，引入中文模板和亚洲风格元素，拓展亚洲创作者市场。</li></ol><h3 id="总结-15">总结</h3><p>Bento 是下一个“你是谁”时代的入口工具。它不靠复杂的功能取胜，而是用设计感、精简性和创作者思维重新定义了“数字名片”。<br>如果说 Notion 是写作思维的扩展器，那 Bento 就是你人格品牌的灯塔页面。<br>在这个“一人品牌”崛起的时代，它完全有机会取代 Linktree 成为新一代的创作者主页默认选项。<br>一句话评价：它不是链接聚合，是个性聚合。📱🧠🌐</p><hr><h2 id="Lemon8（字节跳动出海版“小红书”）">Lemon8（字节跳动出海版“小红书”）</h2><h3 id="产品概述-16">产品概述</h3><p>Lemon8 是由字节跳动推出的一款生活方式类内容平台，定位于“年轻人种草社区”，被广泛认为是字节出海对标“小红书”的关键产品。Lemon8 集内容分享、社区互动、兴趣推荐于一体，主打美妆、穿搭、健身、旅行、读书等生活方式领域，重点市场是日本、东南亚、美国等非中文区国家。</p><h3 id="核心功能-16">核心功能</h3><ol><li><strong>图文笔记发布</strong>：支持发布美图 + 长文心得，适配穿搭、美妆、vlog 等轻内容。</li><li><strong>内容分类 + 标签体系</strong>：精细的兴趣分类体系，引导用户发现垂直领域内容。</li><li><strong>个性化推荐流</strong>：字节系招牌推荐算法，结合图文兴趣行为优化内容流呈现。</li><li><strong>社交互动系统</strong>：点赞、收藏、评论、关注，增强内容互动与社区粘性。</li><li><strong>内容创作工具</strong>：内嵌模板、滤镜、字体搭配助手，帮助创作者提高内容美感。</li></ol><h3 id="用户体验评估-16">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>UI 时尚简洁，符合全球年轻女性用户审美偏好。</li><li>内容结构类“小红书”，但轻广告感更强，初期氛围更“纯粹”。</li><li>推荐系统精准，探索页停留时间高。</li></ul></li><li><strong>不足</strong>：<ul><li>社区氛围仍处冷启动阶段，用户互动密度不高。</li><li>英文市场内容多为亚洲风格，文化适配度待提升。</li><li>缺乏电商闭环，种草后“拔草”路径中断。</li></ul></li></ul><h3 id="商业模式解释-16">商业模式解释</h3><ol><li><strong>品牌合作与内容投放</strong>：未来通过品牌合作推出内容种草计划，收取营销费用。</li><li><strong>创作者激励计划</strong>：通过播放量/点赞数补贴内容创作者，吸引KOC、KOL入驻。</li><li><strong>电商联动变现（规划中）</strong>：逐步探索与 TikTok Shop 或第三方平台的导购链接接入。</li><li><strong>数据洞察服务</strong>：为品牌方提供用户兴趣偏好、趋势分析工具作为B端增值服务。</li></ol><h3 id="竞争分析-16">竞争分析</h3><ul><li><strong>主要竞争者</strong>：<ul><li><strong>Pinterest</strong>：在欧美用户中影响力强，但互动性差、内容商业化慢。</li><li><strong>Instagram（Reels + Guides）</strong>：轻内容生态极强，但种草深度不足。</li><li><strong>RedNote (小红书国际版)</strong>：小红书进军国际市场，可能形成正面冲突。</li></ul></li><li><strong>Lemon8 优势</strong>：<ul><li>有 TikTok 强大生态支持（用户导流+技术栈+广告投放）</li><li>更加系统的内容组织能力（笔记风格更强，非短视频）。</li></ul></li><li><strong>Lemon8 劣势</strong>：<ul><li>在美国缺乏品牌信任基础，面临中资背景“信任红线”问题。</li><li>用户高质量内容依赖度大，冷启动成本高。</li></ul></li></ul><h3 id="运营策略建议-14">运营策略建议</h3><ol><li><strong>打造“百大真实生活分享者”计划</strong>：在垂直领域签约创作者，形成初始内容阵地。</li><li><strong>与校园/女性社群合作</strong>：在大学、美妆社群中打种子用户牌，强化UGC内容密度。</li><li><strong>开展“种草即得”计划</strong>：与本地电商、快时尚品牌合作推出购买返现机制。</li><li><strong>优化跨平台分发能力</strong>：一键同步内容至 TikTok、IG，帮助创作者提升曝光。</li></ol><h3 id="改进建议-16">改进建议</h3><ol><li><strong>推出“兴趣圈”机制</strong>：用户可以加入如“英美穿搭圈”“书香女孩圈”等，加强社交互动。</li><li><strong>支持多语言自动翻译</strong>：打破语言壁垒，提升内容全球可阅读性。</li><li><strong>开放“商品链接组件”</strong>：允许创作者植入淘宝、Amazon 等商品页，提高变现率。</li><li><strong>开发“内容复盘周报”</strong>：给创作者分析数据表现 + 推荐优化建议，提升留存。</li></ol><h3 id="总结-16">总结</h3><p>Lemon8 是字节跳动继 TikTok 之后在全球内容生态中下的又一枚重子，它不靠“热舞”、“梗文化”，而是靠“美感生活、真实分享”打出新的内容高地。<br>它像是一块全新的内容自留地，等着新一代“生活方式表达者”来种草和收割。<br>一句话评价：Lemon8 是“种草的精致感”，也是 TikTok 之后内容战略的“品味补足”。🍋📱✨</p><hr><h2 id="HeyGen（AI驱动的视频生成与虚拟演示平台）">HeyGen（AI驱动的视频生成与虚拟演示平台）</h2><h3 id="产品概述-17">产品概述</h3><p>HeyGen 是一款基于 AI 技术的视频生成平台，支持用户通过文本生成带真人虚拟讲解的视频。它的核心理念是“让每个人都能用AI创造专业视频内容”，应用场景涵盖产品演示、课程教学、员工培训、市场营销等。HeyGen 最大的亮点是拥有逼真的数字人讲解功能，让视频内容更具表现力与可信度。</p><h3 id="核心功能-17">核心功能</h3><ol><li><strong>AI 虚拟人主播生成</strong>：用户上传文字脚本，平台自动生成口型匹配的 AI 讲解视频。</li><li><strong>多语言语音合成</strong>：支持50+种语言和多种发音风格，适配全球用户需求。</li><li><strong>模板化视频编辑器</strong>：可添加品牌元素、字幕、过渡动画等，无需专业剪辑技能。</li><li><strong>角色定制功能</strong>：上传照片或视频即可生成专属 AI 虚拟人，打造“企业AI代言人”。</li><li><strong>团队协作功能</strong>：支持多成员编辑、权限控制、项目管理。</li></ol><h3 id="用户体验评估-17">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>一键生成，极大降低制作成本，尤其适合非设计、非拍摄出身的内容创作者。</li><li>虚拟主播高度仿真，口型和面部表情自然，整体视频专业感强。</li><li>视频渲染速度快，操作门槛低，界面友好。</li></ul></li><li><strong>不足</strong>：<ul><li>虽然人物仿真度高，但仍可辨识为“AI脸”，情感表达略显生硬。</li><li>免费用户有强水印、时间限制；高阶套餐价格略贵。</li><li>中文语音合成虽然准确，但偶尔语调不自然。</li></ul></li></ul><h3 id="商业模式解释-17">商业模式解释</h3><ol><li><strong>订阅制（Starter / Pro / Enterprise）</strong>：按月或年计费，限制生成时长、功能权限、可用虚拟人种类。</li><li><strong>品牌定制服务</strong>：企业可定制专属虚拟主播，包含训练模型、品牌素材整合等。</li><li><strong>API 接口调用</strong>：向第三方平台（如教育平台、电商系统）开放视频生成API，按调用次数计费。</li><li><strong>代理商分销体系</strong>：在多个国家发展本地合作伙伴，拓展本地化商用客户。</li></ol><h3 id="竞争分析-17">竞争分析</h3><ul><li><strong>直接竞争者</strong>：<ul><li><strong>Synthesia</strong>：英国公司，全球领先的AI视频生成平台，企业级客户众多。</li><li><strong><a href="http://Elai.io">Elai.io</a></strong>：主打企业演示和多语言生成，定价略低，操作逻辑类似。</li></ul></li><li><strong>间接竞争者</strong>：<ul><li><strong>Lumen5 / Pictory</strong>：侧重文本转视频，内容展示以剪辑动画为主，缺少虚拟人功能。</li><li><strong>Canva + AI语音工具组合</strong>：虽然不是专门的视频平台，但通过组合工具也能实现类似效果。</li></ul></li><li><strong>HeyGen 优势</strong>：<ul><li>拥有极佳的人物质感表现，结合灵活模板，适配性强。</li><li>多语言 &amp; 高度个性化，使其更适合跨国品牌与小型创作者。</li></ul></li><li><strong>HeyGen 劣势</strong>：<ul><li>高级功能壁垒低，若缺乏生态建设，易被后起产品快速追赶。</li><li>过度依赖 AI 合成平台（如 ElevenLabs、Stable Diffusion 等）底层技术。</li></ul></li></ul><h3 id="运营策略建议-15">运营策略建议</h3><ol><li><strong>推出“AI数字代言人孵化计划”</strong>：鼓励品牌、主播、培训讲师构建个人专属AI形象。</li><li><strong>加强中文市场本地化运营</strong>：优化中文语音合成与表情模型，引入本地明星脸授权合作。</li><li><strong>与课程平台合作联动</strong>：如与Coursera、腾讯课堂等平台合作，嵌入生成视频流程。</li><li><strong>强化创作者社区建设</strong>：鼓励优秀视频内容分享与“爆款剧本”交流，激活内容生态。</li></ol><h3 id="改进建议-17">改进建议</h3><ol><li><strong>支持剧本分镜式生成</strong>：让视频内容更具节奏感，适应复杂场景如产品介绍或微课程。</li><li><strong>引入AI剪辑助手</strong>：自动生成过场、BGM推荐、字幕同步，提高非专业用户产出效率。</li><li><strong>开放角色表演控制参数</strong>：如语速、情绪色彩、手势动作选择，让视频更具表现力。</li><li><strong>构建“视频插件生态”</strong>：吸引第三方开发视频贴纸、模板、配音资源等，提升平台粘性。</li></ol><h3 id="总结-17">总结</h3><p>HeyGen 正在引爆一场“人人都有自己数字分身”的革命。<br>在这个“屏幕就是舞台、AI就是主持人”的时代，它正在把每一句话，变成一个能说会演的虚拟你。它不仅是内容生产力工具，更是数字人格经济的入场券。<br>一句话总结：HeyGen，是把AI嘴巴“借给你”的视频演说平台。📹🧠🗣️</p><hr><h2 id="Zocdoc（美国最大的在线医疗预约平台）">Zocdoc（美国最大的在线医疗预约平台）</h2><h3 id="产品概述-18">产品概述</h3><p>Zocdoc 是一家总部位于纽约的数字医疗平台，专注于帮助用户在线搜索医生、查看评价并预约线下或远程医疗服务。其核心定位是：“让看病像订外卖一样简单”。它连接患者与医生，并为医生提供日程管理、患者预订和评价收集等服务，是美国数字健康领域的标杆级产品。</p><h3 id="核心功能-18">核心功能</h3><ol><li><strong>医生搜索引擎</strong>：支持按保险、专科、地点、可预约时间等维度筛选医生。</li><li><strong>一键预约系统</strong>：用户可查看实时空位并直接在线预约，不需电话确认。</li><li><strong>患者评价系统</strong>：透明的评分与评价机制，帮助用户选择合适的医生。</li><li><strong>电子表格填写与预问诊功能</strong>：预约前填写症状与历史病史，提升问诊效率。</li><li><strong>视频问诊集成</strong>：提供远程看诊选项，满足疫情后居家医疗需求。</li></ol><h3 id="用户体验评估-18">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>流程极简：搜索 → 筛选 → 预约只需几步，操作顺滑。</li><li>数据全面：医生背景、保险支持情况、患者评价一目了然。</li><li>用户粘性高，自动化提醒、电子病历回顾等极大提升复诊体验。</li></ul></li><li><strong>不足</strong>：<ul><li>非所有医生支持在线预约，有些仍需电话确认，体验割裂。</li><li>页面风格偏传统，缺少“现代感”或健康数据可视化等创新功能。</li><li>中低收入人群与老年人接入门槛仍较高（尤其非英语使用者）。</li></ul></li></ul><h3 id="商业模式解释-18">商业模式解释</h3><ol><li><strong>医生端订阅费</strong>：医生或诊所需为每月展示与管理服务支付一定费用。</li><li><strong>广告位推荐机制</strong>：支付更多费用的医生可获得更靠前的展示位置。</li><li><strong>视频问诊平台佣金</strong>：远程看诊可从医生端收取一定比例服务费。</li><li><strong>数据服务与保险合作</strong>：与保险公司合作，提升用户就诊路径效率（匹配保险覆盖范围）。</li></ol><h3 id="竞争分析-18">竞争分析</h3><ul><li><strong>直接竞争者</strong>：<ul><li><strong>Healthgrades</strong>：偏重医生评分与科普内容，预约体验不如Zocdoc流畅。</li><li><strong>Doctolib（法国）</strong>：在欧洲市场影响力强，但尚未深入美国本土。</li></ul></li><li><strong>间接竞争者</strong>：<ul><li><strong>Teladoc Health</strong>：专注远程医疗服务，不提供线下医生预约。</li><li><strong>Google Maps + Yelp 医疗评价组合</strong>：碎片式体验，但覆盖范围广。</li></ul></li><li><strong>Zocdoc 优势</strong>：<ul><li>高度结构化的医疗预约系统，信任度与便利性在美国家庭中扎根已久。</li><li>提前布局移动端和远程医疗市场，有稳固市场基础。</li></ul></li><li><strong>Zocdoc 劣势</strong>：<ul><li>增长空间受限于医生端合作意愿与地区医疗资源分布。</li><li>缺乏面向新兴市场（如亚洲、拉美）适配能力。</li></ul></li></ul><h3 id="运营策略建议-16">运营策略建议</h3><ol><li><strong>与企业医保福利绑定</strong>：接入雇主福利系统，推动员工使用Zocdoc预约家庭医生。</li><li><strong>拓展“二线城市家庭市场”</strong>：以“家庭健康管家”定位推广复诊与儿童问诊场景。</li><li><strong>开发Zocdoc Health Pass</strong>：结合体检记录、处方记录，打造个人健康数字档案。</li><li><strong>在大学与老年社区试点“数字医疗指导计划”</strong>：教育“数字边缘人群”学会使用Zocdoc。</li></ol><h3 id="改进建议-18">改进建议</h3><ol><li><strong>引入 AI 症状初筛助手</strong>：基于用户输入判断可能疾病并推荐相应科室/医生。</li><li><strong>建设慢病管理模块</strong>：支持高血压、糖尿病等人群的定期复诊提醒与检测计划。</li><li><strong>优化医生端管理体验</strong>：简化日程维护与患者管理，提高医生端留存。</li><li><strong>增加保险推荐与比价功能</strong>：帮助用户匹配更适合自身情况的保险计划，延伸服务链。</li></ol><h3 id="总结-18">总结</h3><p>Zocdoc 是美国人“找医生”的第一入口，但在 AI 驱动的健康生态里，它必须从“预约平台”进化为“健康运营中心”。如果能整合数据、服务与社区，它将不仅解决“看谁”的问题，还能帮助用户“少生病”。<br>一句话总结：Zocdoc 就是医疗版的 OpenTable，只不过你点的是医生而不是牛排。🩺📲🍽️</p><hr><h2 id="Tubi（美国免费流媒体视频平台黑马）">Tubi（美国免费流媒体视频平台黑马）</h2><h3 id="产品概述-19">产品概述</h3><p>Tubi 是一家来自美国的免费流媒体平台，主打“免费看电影和电视剧”，无需订阅费用，靠广告盈利。它由 Fox Corporation 拥有，定位类似“流媒体界的 YouTube + 传统电视台混合体”。Tubi 在内容库上聚焦长尾电影、老剧、独立电影与部分合作原创内容，吸引了大量预算有限、内容多样化偏好的用户群体。</p><h3 id="核心功能-19">核心功能</h3><ol><li><strong>免费无登录观看</strong>：大多数内容无需注册账户即可观看，最大化降低用户门槛。</li><li><strong>海量内容库</strong>：涵盖好莱坞经典电影、儿童节目、纪录片、惊悚片、日韩剧等品类。</li><li><strong>多终端同步</strong>：支持 iOS、Android、网页端、Apple TV、Roku、Xbox 等多平台播放。</li><li><strong>智能推荐算法</strong>：基于观看行为推荐内容，但算法较浅，更多基于“人群标签”。</li><li><strong>快速播放与插播广告系统</strong>：每部片含2-6个短广告，广告时间远低于传统电视。</li></ol><h3 id="用户体验评估-19">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>免费！免费！免费！（在北美这三个字就是King）</li><li>内容多样，有不少B级片、冷门老片，颇具“视频淘宝”式探宝乐趣。</li><li>界面简洁，响应快，广告插入频率合理，不干扰体验。</li></ul></li><li><strong>不足</strong>：<ul><li>新片、新剧数量少，基本没有主流热门剧集或一线新电影。</li><li>广告不可跳过，且内容与用户兴趣不一定匹配。</li><li>不支持下载/离线观看，限制了出行场景使用。</li></ul></li></ul><h3 id="商业模式解释-19">商业模式解释</h3><ol><li><strong>广告变现（AVOD）</strong>：主盈利模式，通过插播广告收取品牌费用，与 CPM 挂钩。</li><li><strong>数据洞察服务</strong>：将用户观影偏好和广告点击率等行为数据打包出售给品牌方。</li><li><strong>内容联营合作</strong>：与中小型影视公司签署长尾内容分成协议，成本低风险低。</li><li><strong>Tubi Originals（尝试中）</strong>：部分原创内容实验品牌联动与赞助商业化。</li></ol><h3 id="竞争分析-19">竞争分析</h3><ul><li><strong>直接竞争者</strong>：<ul><li><strong>Pluto TV（Paramount）</strong>：主打频道式体验，但频道划分略繁琐。</li><li><strong>Peacock Free（NBC）</strong>：免费内容偏向美剧，但总量受限。</li></ul></li><li><strong>间接竞争者</strong>：<ul><li><strong>YouTube</strong>：虽然也是免费，但更偏短视频与UGC，不专注“影视级内容”。</li><li><strong>Netflix / Disney+ / Hulu 等</strong>：高质量订阅平台，但价格劝退部分用户。</li></ul></li><li><strong>Tubi 优势</strong>：<ul><li>无需订阅，易于传播与低门槛渗透。</li><li>内容长尾策略有效延长影视 IP 的生命周期。</li></ul></li><li><strong>Tubi 劣势</strong>：<ul><li>品牌认知度仍低，缺乏“爆款”推动力。</li><li>广告体验虽可接受，但在AI定向广告尚未成熟时缺乏个性化投放。</li></ul></li></ul><h3 id="运营策略建议-17">运营策略建议</h3><ol><li><strong>推出“Tubi 派对”功能</strong>：支持好友一起在线看老片+聊天室互动，打造情绪共振场景。</li><li><strong>强化“猎奇内容推荐”标签</strong>：聚焦“B级片爱好者”“废片影帝”等垂类标签，培养内容亚文化。</li><li><strong>和老电影工作室合作数字修复</strong>：打造“经典再现计划”，吸引复古爱好者。</li><li><strong>进军多语种市场（如拉美、西非）</strong>：快速占领缺乏OTT能力但有手机设备的国家市场。</li></ol><h3 id="改进建议-19">改进建议</h3><ol><li><strong>增加“稍后看 + 断点续播”功能</strong>：让用户养成日常刷 Tubi 的习惯。</li><li><strong>开发轻量 Tubi Go 版本</strong>：适配低带宽国家市场（东南亚、非洲等）。</li><li><strong>广告动态匹配引擎升级</strong>：引入 AI 增强广告推荐系统，提高品牌点击转化率。</li><li><strong>引入 UGC 影视解说/剪辑节目</strong>：允许创作者在平台内发布“复古片推荐”“烂片剪辑秀”。</li></ol><h3 id="总结-19">总结</h3><p>Tubi 是流媒体战场里不靠爆款、不烧钱、不卷版权的小透明——但它用“长尾+免费+少广告”这三板斧打穿了一个你想不到但又确实存在的市场。<br>未来流媒体不是“谁买的版权多”，而是谁抓住了沉默用户的注意力缝隙。<br>一句话总结：Tubi 是“看片不花钱”的快乐工厂，也是“烂片天堂”的内容黑马。📺🍿🐎</p><hr><h2 id="Prezi（演示软件的结构化进化者）">Prezi（演示软件的结构化进化者）</h2><h3 id="产品概述-20">产品概述</h3><p>Prezi 是一个来自匈牙利的创新型演示工具平台，区别于传统线性幻灯片工具（如 PowerPoint、Google Slides），Prezi 采用非线性、画布式结构逻辑展示信息，强调“内容之间的关系”而非单页堆叠。近年来，Prezi 推出了视频演示、虚拟摄像头、AI 内容建议等功能，力图重新定义远程表达与视觉沟通。</p><h3 id="核心功能-20">核心功能</h3><ol><li><strong>画布式演示结构</strong>：通过缩放、旋转、跳转展示信息，实现空间感逻辑表达。</li><li><strong>Prezi Video</strong>：将演示内容叠加在演讲者摄像头画面中，适配Zoom、Teams、Google Meet等。</li><li><strong>AI内容建议与模板系统</strong>：根据主题自动生成内容结构与视觉布局，提升效率。</li><li><strong>协作与版本管理</strong>：团队成员可同时编辑、评论演示文档，适配协同办公。</li><li><strong>分析追踪</strong>：可查看观众点击率、停留时间等，适用于营销类演示追踪反馈。</li></ol><h3 id="用户体验评估-20">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>动态转场极具冲击力，适合讲故事型演示，如TED、创业路演、课程讲座。</li><li>Prezi Video 赋能远程会议，演讲者+内容同步出镜提升表达效率。</li><li>模板种类丰富，覆盖教育、商务、市场等场景，极具专业感。</li></ul></li><li><strong>不足</strong>：<ul><li>初学者存在学习曲线，容易“玩嗨”导致逻辑混乱。</li><li>中文内容支持较弱，AI辅助写作和模板偏英语环境。</li><li>免费版限制较大，如导出受限、水印、团队功能缺失。</li></ul></li></ul><h3 id="商业模式解释-20">商业模式解释</h3><ol><li><strong>订阅付费（Prezi Plus / Prezi Teams）</strong>：按月/年收取费用，解锁高阶模板、协作、导出功能。</li><li><strong>企业定制服务</strong>：为大型组织提供品牌模板、统一演示规范、数据加密等服务。</li><li><strong>教育市场折扣</strong>：面向高校/教师提供折扣计划，强化教育端口碑扩张。</li><li><strong>视频会议SaaS集成</strong>：与Zoom、Webex等视频平台形成合作授权通道。</li></ol><h3 id="竞争分析-20">竞争分析</h3><ul><li><strong>直接竞争者</strong>：<ul><li><strong>Canva Presentations</strong>：主打美观模板与团队协作，入门友好但动态性弱。</li><li><strong><a href="http://Pitch.com">Pitch.com</a></strong>：聚焦现代化团队协作与融资演示，强调结构性与故事感。</li></ul></li><li><strong>间接竞争者</strong>：<ul><li><strong>Microsoft PowerPoint</strong> / <strong>Google Slides</strong>：办公场景标配，生态闭环强，更新频率低。</li><li><strong>Loom + Notion 页面演示模式</strong>：短视频表达+结构文档逐渐侵蚀传统演示场景。</li></ul></li><li><strong>Prezi 优势</strong>：<ul><li>视觉结构化逻辑领先，极适合需要空间表达或强调内容关联的场景。</li><li>视频化模块前沿，弥补传统PPT在远程会议中的表达效率短板。</li></ul></li><li><strong>Prezi 劣势</strong>：<ul><li>商业客户粘性弱于微软/谷歌生态，使用频率易断裂。</li><li>对一般场景（如汇报、培训）存在“过度设计”的风险。</li></ul></li></ul><h3 id="运营策略建议-18">运营策略建议</h3><ol><li><strong>强化AI生成工具链</strong>：支持自动写稿 → 自动结构图 → 自动画布布局一站式演示生成。</li><li><strong>开通“演讲人训练营”</strong>：提供线上口才/表达训练课程，绑定“Prezi即表达力”的品牌心智。</li><li><strong>推出“校园大使”计划</strong>：让大学生用 Prezi 做课件、比赛，形成教育端品牌渗透。</li><li><strong>支持多语言模板本地化</strong>：推出中文、日文、韩文演示模版集，扩展亚洲市场。</li></ol><h3 id="改进建议-20">改进建议</h3><ol><li><strong>增强“内容快照”模式</strong>：支持导出每个节点为图片/PDF，方便线下演示与复用。</li><li><strong>上线“演示导航模式”</strong>：在演示过程中支持观众自选路径或提问跳转，提高互动性。</li><li><strong>引入“视频生成API”</strong>：让SaaS公司快速接入Prezi Video功能，打造“可说话内容页”。</li><li><strong>丰富数据展示组件</strong>：增加图表、动画数字、实时数据嵌入模块，适配业务场景。</li></ol><h3 id="总结-20">总结</h3><p>Prezi 是演示世界里最具“空间想象力”的一匹老将，它不满足于“翻页讲PPT”，而是要用动态画布+结构视觉+远程出镜的方式，让表达像做一场导览而非朗读剧本。<br>如果它能顺利进化为“AI表达工具链”，它依然有可能在演示工具3.0时代占一席之地。<br>一句话总结：Prezi 不只是演示工具，它是一个“你带观众旅行”的表达引擎。📊🌍🧠</p><hr>]]></content>
    
    
    <summary type="html">互联网产品分析笔记(四)</summary>
    
    
    
    <category term="产品分析" scheme="https://www.angfff.top/categories/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="互联网产品" scheme="https://www.angfff.top/tags/%E4%BA%92%E8%81%94%E7%BD%91%E4%BA%A7%E5%93%81/"/>
    
    <category term="产品分析" scheme="https://www.angfff.top/tags/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"/>
    
    <category term="PM" scheme="https://www.angfff.top/tags/PM/"/>
    
  </entry>
  
  <entry>
    <title>互联网产品分析笔记(三)</title>
    <link href="https://www.angfff.top/posts/3fdf2b2b.html"/>
    <id>https://www.angfff.top/posts/3fdf2b2b.html</id>
    <published>2025-03-26T03:02:05.000Z</published>
    <updated>2025-05-22T04:31:09.395Z</updated>
    
    <content type="html"><![CDATA[<h2 id="咔哒故事（KaDa-Story）">咔哒故事（KaDa Story）</h2><h3 id="产品概述"><strong>产品概述</strong></h3><p>咔哒故事是一款专为儿童打造的图画书阅读与听书平台，致力于用高质量、有趣、寓教于乐的故事内容，培养孩子的阅读兴趣与语言表达能力。它融合了有声故事、分级阅读、互动动画、家庭共读等多种形式，是家庭育儿类APP中的佼佼者，主要面向0-9岁儿童及其家长。</p><h3 id="核心功能"><strong>核心功能</strong></h3><ol><li><strong>绘本阅读馆</strong>：数千本精选绘本，涵盖经典童话、成长教育、科普知识等。</li><li><strong>分级阅读系统</strong>：根据儿童年龄与阅读能力匹配内容，支持语音朗读与自主阅读。</li><li><strong>有声故事</strong>：专业配音团队录制，沉浸式故事体验，解放父母时间。</li><li><strong>家庭账号共享</strong>：多个孩子共用一个家庭空间，支持成长记录与个性推荐。</li><li><strong>阅读激励机制</strong>：阅读打卡、成就系统、徽章奖励，培养阅读习惯。</li></ol><h3 id="用户体验评估"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>UI 界面卡通化、交互友好，适合低龄儿童自主操作。</li><li>内容质量高，部分引进国际版权绘本，图文精美、配音专业。</li><li>家长管理功能完备，可设置阅读时长、防沉迷模式，便于监护。</li></ul></li><li><strong>不足</strong>：<ul><li>部分内容深度有限，偏娱乐向，对于高认知孩子吸引力下降。</li><li>内容库虽大，但免费内容有限，非会员体验不佳。</li><li>个性推荐不够精准，年龄分级偶有偏差。</li></ul></li></ul><h3 id="商业模式解释"><strong>商业模式解释</strong></h3><ol><li><strong>会员订阅</strong>：按月/年付费，解锁全部绘本与故事资源。</li><li><strong>内容联名与合作</strong>：与出版社合作开发品牌绘本，销售实体图书与周边产品。</li><li><strong>教育机构B端合作</strong>：提供园所阅读解决方案，拓展到校园场景。</li><li><strong>数据报告服务</strong>：为家长提供孩子阅读习惯与成长评估报告。</li></ol><h3 id="竞争分析"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>宝宝巴士</strong>：动画+早教工具整合，娱乐性更强。</li><li><strong>凯叔讲故事</strong>：以音频故事为核心，品牌影响力大。</li><li><strong>小伴龙、洪恩识字</strong>：功能更聚焦基础启蒙教育。</li></ul></li><li><strong>优势</strong>：<ul><li>内容形式多样，融合图文、音频、互动三位一体。</li><li>阅读素养导向明确，符合新课标与家庭教育趋势。</li></ul></li><li><strong>劣势</strong>：<ul><li>缺乏爆款IP内容，传播影响力不足。</li><li>市场营销声量偏弱，与凯叔等大厂支持平台相比处于劣势。</li></ul></li></ul><h3 id="运营策略"><strong>运营策略</strong></h3><ol><li><strong>打造专属 IP 人物</strong>，如“咔哒小熊”，形成品牌识别，拓展绘本和动画线。</li><li><strong>强化用户社群运营</strong>，组织线上亲子共读打卡、家长育儿讲座，提升活跃度与留存率。</li><li><strong>构建内容生产平台</strong>，吸引儿童文学创作者入驻，扩大原创内容占比。</li><li><strong>深度合作线下幼教体系</strong>，开设“故事时间”课程包，增加B端营收渠道。</li></ol><h3 id="改进建议"><strong>改进建议</strong></h3><ol><li><strong>提升推荐算法</strong>，结合年龄、性别、阅读历史，更精准地推送内容。</li><li><strong>拓展交互体验</strong>，引入语音互动、手势识别等低门槛玩法。</li><li><strong>推出家庭教育陪伴模块</strong>，为家长提供每日共读建议与亲子沟通引导。</li><li><strong>增加AI语音识别功能</strong>，辅助孩子朗读练习，提升表达能力。</li></ol><h3 id="总结"><strong>总结</strong></h3><p>咔哒故事在儿童阅读垂直领域耕耘多年，具备内容沉淀和用户基础。但要在激烈的亲子内容市场中进一步破圈，未来应强化品牌IP建设、优化用户分层策略，并深挖“内容+陪伴+教育”三维价值，构建多元盈利模式。</p><hr><h2 id="Pika-Labs（AI-动画生成平台）">Pika Labs（AI 动画生成平台）</h2><h3 id="产品概述-2"><strong>产品概述</strong></h3><p>Pika Labs 是一个主打“文本生成动画视频”的 AI 创意平台，用户输入一段描述，系统即刻生成动态视觉内容（视频），适合用于短片创作、广告草图、动画原型等场景。它结合了扩散模型（Diffusion）与生成式 AI，让非专业用户也能轻松上手做“动态创意内容生产”。</p><h3 id="核心功能-2"><strong>核心功能</strong></h3><ol><li><strong>文本生成动画（Text-to-Video）</strong>：输入简单指令或脚本，AI 即刻生成短视频片段。</li><li><strong>风格控制</strong>：支持卡通、现实、像素、赛博朋克等多种视觉风格。</li><li><strong>编辑扩展</strong>：可对生成视频进行续帧、帧间插值、风格迁移等编辑操作。</li><li><strong>多人协作与云存储</strong>：项目云端同步，多人可协作创作并导出素材。</li><li><strong>Prompt 模板市场</strong>：开放社区共享 prompt 配方，降低创作门槛。</li></ol><h3 id="用户体验评估-2"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>极简操作，零基础即可出片，适合快速原型迭代。</li><li>视频质量不断进化，适合做 AI 视觉表达实验。</li><li>社区氛围活跃，有许多创作者分享技巧和 prompt 配方。</li></ul></li><li><strong>不足</strong>：<ul><li>模型运算资源需求大，非会员用户等待时间较长。</li><li>视频内容偏短，帧率不稳定，暂时难以满足专业动画需求。</li><li>对中文描述支持一般，prompt 仍需英文表达才更精准。</li></ul></li></ul><h3 id="商业模式解释-2"><strong>商业模式解释</strong></h3><ol><li><strong>订阅制会员（Pro/Team）</strong>：提升渲染速度、视频时长、风格选择等资源配额。</li><li><strong>B2B 定制服务</strong>：为广告公司、短视频团队、品牌方提供定制化生成方案。</li><li><strong>Prompt 商店与素材市场</strong>：未来可能允许创作者出售 prompt 模板或视频版权。</li><li><strong>API 接口收费</strong>：开放平台接入第三方创作工具或游戏引擎，按调用次数计费。</li></ol><h3 id="竞争分析-2"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>Runway ML</strong>：功能成熟，支持绿幕、视频编辑、AI 视频生成等一站式服务。</li><li><strong>Kaiber</strong>：更侧重音乐驱动型动画，偏艺术风。</li><li><strong>Stability AI 视频版（Stable Video Diffusion）</strong>：开源但尚未商业化。</li></ul></li><li><strong>Pika 的优势</strong>：<ul><li>社区成长快，用户生成内容丰富；</li><li>风格多样，支持更多实验性表达；</li><li>对短视频时代的“快速视觉生成”特别友好。</li></ul></li><li><strong>劣势</strong>：<ul><li>AI 模型非开源，依赖基础设施重；</li><li>尚无显著内容监管机制，存在潜在伦理与版权风险。</li></ul></li></ul><h3 id="运营策略-2"><strong>运营策略</strong></h3><ol><li><strong>培养创作者生态</strong>：鼓励用户上传“模板+成片”，打造 UGC 市场。</li><li><strong>拓展教育场景</strong>：切入影视院校、创意课程，为学生提供试用计划。</li><li><strong>加快模型更新频率</strong>：不断优化生成速度与帧率，提升成片质量。</li><li><strong>与内容平台合作</strong>：如与 TikTok、B 站打通，鼓励创作者用 AI 片段做混剪。</li></ol><h3 id="改进建议-2"><strong>改进建议</strong></h3><ol><li><strong>提升中文 prompt 适配性</strong>，增强国内用户体验。</li><li><strong>加入人物面部一致性控制</strong>，提高生成角色的连贯性与可信度。</li><li><strong>开放 API 接入 Unity/Unreal 引擎</strong>，进军游戏与元宇宙内容市场。</li><li><strong>建立版权保护与水印机制</strong>，强化内容安全合规保障。</li></ol><h3 id="总结-2"><strong>总结</strong></h3><p>Pika Labs 是“AI + 动画创意”赛道上极具潜力的黑马，它把“视觉内容生产”从专业门槛降到全民娱乐。随着 AI 模型迭代与平台生态成熟，它很可能成为下一代视觉创作工具的入口。接下来的关键是内容质量、商业路径与生态控制的“三驾马车”能否跑得更稳、更快。</p><hr><h2 id="Luminar-Neo（AI-图像编辑软件）">Luminar Neo（AI 图像编辑软件）</h2><h3 id="产品概述-3"><strong>产品概述</strong></h3><p>Luminar Neo 是由乌克兰公司 Skylum 推出的 AI 图像编辑工具，主打“一键修图”与“AI 驱动的创意图像处理”，面向摄影师、设计师、内容创作者等用户群体。它以“简化复杂编辑流程”为使命，致力于降低照片后期的学习门槛，在 Adobe Lightroom 和 Photoshop 长期统治的专业市场中，打出一张智能化和创意化的牌。</p><h3 id="核心功能-3"><strong>核心功能</strong></h3><ol><li><strong>AI 场景识别与增强</strong>：自动识别照片内容（天空、人像、光线等），进行智能优化。</li><li><strong>AI 换天/天气特效</strong>：一键替换天空、添加阳光、雾气、闪电等视觉特效。</li><li><strong>背景移除与分层处理</strong>：无需抠图基础，自动分离前后景，便于创意合成。</li><li><strong>图像修复 &amp; 去除杂物</strong>：AI 自动识别画面瑕疵，如电线、游客等并删除。</li><li><strong>预设模板系统（Presets）</strong>：支持社区模板导入，快速风格化处理。</li><li><strong>插件扩展 &amp; 批量处理</strong>：支持 RAW 格式、多图同步处理，提高工作效率。</li></ol><h3 id="用户体验评估-3"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>交互界面现代感强，学习曲线平缓，对初学者极其友好。</li><li>多数 AI 工具可达“点一下就能发朋友圈”的水准，效率远超传统 PS。</li><li>Mac 系统优化良好，适配 Apple Silicon，体验丝滑流畅。</li></ul></li><li><strong>不足</strong>：<ul><li>稳定性一般，大图处理过程中偶有崩溃，尤其在插件多开场景。</li><li>缺少精细手动控制选项，高阶用户可能觉得“用不精”。</li><li>中文本地化略显粗糙，专业术语翻译存在歧义。</li></ul></li></ul><h3 id="商业模式解释-3"><strong>商业模式解释</strong></h3><ol><li><strong>一次性买断 + 年度订阅</strong>：提供买断版本和 Pro 订阅，后者含更多功能与插件更新。</li><li><strong>插件商城</strong>：销售 AI 擴展包（如人像增强、叠图特效），形成复购收入。</li><li><strong>内容市场联动</strong>：模板、滤镜包由用户/摄影师上传并售卖，平台抽成。</li><li><strong>B2B 合作</strong>：与设备厂商（如无人机、相机）联名提供简版 AI 修图模块。</li></ol><h3 id="竞争分析-3"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>Adobe Lightroom</strong>：专业强、生态广、稳定性高，适合资深摄影师。</li><li><strong>Fotor、Canva Photo Editor</strong>：走轻量快速设计路线，更偏向营销场景。</li><li><strong>Topaz Labs</strong>：专注 AI 超分、去噪方向，技术实力强但用途单一。</li></ul></li><li><strong>优势总结</strong>：<ul><li>AI 修图体验出色，降低用户门槛，赋能非专业创作者。</li><li>创意风格多变，适合用于短视频封面、电商图、美图场景。</li></ul></li><li><strong>劣势总结</strong>：<ul><li>社区用户基数小，生态尚未成熟。</li><li>商业化策略偏传统，缺乏订阅诱因与长期锁客机制。</li></ul></li></ul><h3 id="运营策略-3"><strong>运营策略</strong></h3><ol><li><strong>打造“创意修图挑战赛”</strong>，鼓励用户用模板做内容分享，提升曝光度。</li><li><strong>强化社交化分享插件</strong>，一键导出至 Instagram、抖音，增强传播力。</li><li><strong>与教育平台合作</strong>，推出摄影后期课程包，培养创作者群体认知与依赖。</li><li><strong>结合 iPad Pro &amp; Vision Pro</strong>，打造空间修图体验，提前布局空间计算图像工作流。</li></ol><h3 id="改进建议-3"><strong>改进建议</strong></h3><ol><li><strong>引入 AI 自动风格学习机制</strong>，记录用户喜好，生成个性化“AI 滤镜”。</li><li><strong>优化稳定性与多线程性能</strong>，特别是大图输出与批处理环节。</li><li><strong>升级本地化适配</strong>，增强对中文市场的内容与社群运营。</li><li><strong>推出“修图即NFT”功能</strong>，绑定 Web3 创作资产管理工具，引入未来变现场景。</li></ol><h3 id="总结-3"><strong>总结</strong></h3><p>Luminar Neo 是“AI 美学工具”的新物种，它比 Lightroom 更轻巧，比 Canva 更智能，在图像创作工具中开辟了一条“创意快剪+智能后期”的新赛道。未来若能补强社区、稳定性和深度创作能力，它有机会在全球视觉内容爆发的大潮中，撬动更大的用户增长杠杆。创作者经济时代，它绝对是一款值得关注的工具型产品。</p><hr><h2 id="小宇宙播客（Xiaoyuzhou-fm）">小宇宙播客（<a href="http://Xiaoyuzhou.fm">Xiaoyuzhou.fm</a>）</h2><h3 id="产品概述-4"><strong>产品概述</strong></h3><p>小宇宙是一款专注于中文播客体验的音频应用，定位“年轻人的播客社区”。它主打“发现好内容、连接听众与主播、建立深度交流”的价值主张，以高质量中文播客内容和活跃听众互动为核心，成功抓住了一批内容敏感、偏好深度思考的用户。</p><h3 id="核心功能-4"><strong>核心功能</strong></h3><ol><li><strong>播客订阅与播放</strong>：聚合全球播客 RSS 流，支持订阅、缓存与倍速播放。</li><li><strong>评论时间轴</strong>：用户可在具体时间节点发布评论，形成“章节式讨论”。</li><li><strong>话题发现与榜单</strong>：每日推荐与主题策展机制，提升内容曝光度。</li><li><strong>笔记摘录功能</strong>：用户可一键生成语音笔记片段，便于分享和复听。</li><li><strong>社区互动与主播空间</strong>：听众可以“打招呼”、留言、加入播客话题小组，形成私域社群。</li></ol><h3 id="用户体验评估-4"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>UI 极简温暖，操作顺滑，设计感十足。</li><li>“时间轴评论”功能极具创意，让听播客变成一种“社交行为”。</li><li>内容策展水准高，推荐精准，适合对内容有一定门槛期待的用户。</li></ul></li><li><strong>不足</strong>：<ul><li>非 RSS 频道的“封闭性”使部分老牌播客不易被收录。</li><li>功能性上仍不如 Pocket Casts、Overcast 等国际播客工具强大。</li><li>推荐机制偏手动编辑，不够算法驱动，对冷启动主播帮助有限。</li></ul></li></ul><h3 id="商业模式解释-4"><strong>商业模式解释</strong></h3><ol><li><strong>未来订阅制会员</strong>（尚未推出）：可能包含离线播放增强、音质提升、笔记云同步等增值功能。</li><li><strong>品牌合作播客制作</strong>：与品牌共创播客内容，如「看理想」「声东击西」等商业节目赞助。</li><li><strong>社区商业化尝试</strong>：围绕播客社群探索数字藏品、知识打赏、内容电商等形式。</li><li><strong>数据 API/内容分发合作</strong>：将精选节目分发给喜马拉雅、微信听书等流量平台。</li></ol><h3 id="竞争分析-4"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>喜马拉雅</strong>：中文音频最大平台，但娱乐性重，播客氛围不浓。</li><li><strong>荔枝播客</strong>：工具属性更强，缺乏社区与策展能力。</li><li><strong>苹果播客</strong>：生态集成强，但中文播客用户活跃度有限。</li></ul></li><li><strong>优势总结</strong>：<ul><li>社区氛围浓郁，评论与共听机制增强用户参与感。</li><li>设计体验拉满，UI/UX 是音频 App 里的顶流。</li></ul></li><li><strong>劣势总结</strong>：<ul><li>内容平台属性不够强，缺乏分发能力。</li><li>商业化探索缓慢，未来生存压力不小。</li></ul></li></ul><h3 id="运营策略-4"><strong>运营策略</strong></h3><ol><li><strong>发展主播扶持计划</strong>：提供冷启动流量池、社区共创活动，降低播客创作门槛。</li><li><strong>联动高校/书店/内容平台</strong>：将播客节目嵌入更多线下文化空间，扩大品牌影响力。</li><li><strong>发掘垂类内容场景</strong>：如“职场+播客”、“心理健康+播客”、“播客+英语泛听”等。</li><li><strong>推出社区内容二创激励机制</strong>：如播客剪辑、摘要笔记、短视频推广等，提高 UGC 活力。</li></ol><h3 id="改进建议-4"><strong>改进建议</strong></h3><ol><li><strong>引入算法推荐引擎</strong>，基于收听行为、情绪分类等精准推荐节目。</li><li><strong>开放 API 接入 Telegram / Discord / 飞书群聊</strong>，打造更活跃的私域播客生态。</li><li><strong>支持主播内容商业化</strong>，如付费订阅、内容专辑、付费提问机制等。</li><li><strong>提升后台分析能力</strong>，为主播提供听众画像、停留率、评论热点分析等运营工具。</li></ol><h3 id="总结-4"><strong>总结</strong></h3><p>小宇宙不是“最全”的播客 App，但一定是“最有灵魂”的。它在社区氛围、审美体验和用户参与度方面有着极强差异化，但要打破播客作为“小众媒介”的局限，还需在分发、推荐和商业化上大胆创新。下一步，如果它能抓住 AI + 音频生产、AIGC 自动剪辑这类机会，或许有机会成为中文播客界的 Notion + SoundCloud 混合体。真正连接「内容、社区与创作」。</p><hr><h2 id="Paperpal（学术写作-AI-助手）">Paperpal（学术写作 AI 助手）</h2><h3 id="产品概述-5"><strong>产品概述</strong></h3><p>Paperpal 是一款为科研人员量身定制的 AI 学术写作助手，主打“润色+写作+翻译+智能建议”一体化服务。由全球学术出版巨头 Cactus Communications 推出，定位是“AI 帮你写好论文”，广泛应用于论文投稿前的语言润色、学术表达优化与逻辑结构建议场景。</p><h3 id="核心功能-5"><strong>核心功能</strong></h3><ol><li><strong>语法与语言润色</strong>：专为英文学术语境设计，避免中式英语、语法错误、用词不当。</li><li><strong>句子改写/增强表达</strong>：根据上下文提供更正式、精准的表达建议。</li><li><strong>论文结构建议</strong>：识别逻辑结构问题，如过渡句缺失、论证薄弱等，并提供改进意见。</li><li><strong>中英互译优化</strong>：支持中文草稿直接翻译成地道学术英语，并智能润色。</li><li><strong>期刊风格匹配</strong>：自动检测文章风格是否与目标期刊（如Nature、IEEE）匹配。</li><li><strong>实时AI辅助写作</strong>：边写边改，支持段落级别的智能预测与语义优化。</li></ol><h3 id="用户体验评估-5"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>界面简洁、操作直觉，符合科研人使用习惯。</li><li>翻译准确率极高，尤其在术语处理与学术语境中表现优异。</li><li>支持 LaTeX 格式与 PDF 文档输入，适配科研场景需求。</li></ul></li><li><strong>不足</strong>：<ul><li>免费额度较少，深度润色功能大多需付费解锁。</li><li>某些小语种（如德语、法语）支持有限，英文优化依赖语言模型局限。</li><li>对于某些理工科“非传统句式”建议略显机械。</li></ul></li></ul><h3 id="商业模式解释-5"><strong>商业模式解释</strong></h3><ol><li><strong>Freemium 模式</strong>：基础润色功能免费，高级优化、专业翻译为付费功能。</li><li><strong>订阅计划（Pro/Team）</strong>：面向个人科研人员和高校实验室，提供批量处理、团队协作功能。</li><li><strong>B2B 教育出版合作</strong>：与 Elsevier、Springer、Wiley 等出版集团合作提供嵌入式 AI 服务。</li><li><strong>论文投稿服务捆绑</strong>：与期刊投稿平台打通，集成润色→投递一条龙流程，形成闭环变现。</li></ol><h3 id="竞争分析-5"><strong>竞争分析</strong></h3><ul><li><strong>主要对手</strong>：<ul><li><strong>Grammarly Premium</strong>：语法与语义优化强，但学术语境下表达略显平淡。</li><li><strong>Writefull</strong>：专注学术写作，功能细分但界面偏工具化。</li><li><strong>DeepL Write</strong>：翻译质量优秀，但不够学术化和结构化。</li></ul></li><li><strong>Paperpal 优势</strong>：<ul><li>对科研语境理解深，润色建议更契合专业学术写作逻辑。</li><li>拥有学术出版背书，信任度高。</li></ul></li><li><strong>劣势</strong>：<ul><li>依赖英语为主，对非英文学术论文支持较弱。</li><li>免费用户转化率低，需加强教育引导和留存机制。</li></ul></li></ul><h3 id="运营策略-5"><strong>运营策略</strong></h3><ol><li><strong>与高校图书馆合作部署校园授权版</strong>，快速铺开科研场景用户。</li><li><strong>推出“学术写作营”</strong>，以训练营形式吸引硕博研究生深度使用。</li><li><strong>内容运营 + 模板化创作指导</strong>：引导新用户掌握 prompt 技巧与高频使用场景。</li><li><strong>与论文管理工具联动（如Zotero、EndNote）</strong>，打造一体化科研写作平台。</li></ol><h3 id="改进建议-5"><strong>改进建议</strong></h3><ol><li><strong>加入 AI 期刊推荐器</strong>，根据关键词与内容自动匹配投稿期刊。</li><li><strong>开发 Chat 模式</strong>，允许用户与 AI 对话式推演逻辑链或生成摘要引言。</li><li><strong>引入多语言写作支持</strong>，尤其是面向德语、法语、西班牙语科研作者。</li><li><strong>强化团队协作功能</strong>，支持多人批注、版本对比与编辑日志查看。</li></ol><h3 id="总结-5"><strong>总结</strong></h3><p>Paperpal 是一款专为科研圈打造的“写作黑科技”，它不像 Grammarly 关注语言通顺，而是致力于“让你写得更像一个被 Nature 接收的博士”。在全球科研内容爆炸式增长的今天，它的价值不止在于润色，更在于“帮助非母语科研人被世界看见”。下一步，AI写作助手不再只是润色工具，而将是研究方法论的 co-pilot。Paperpal 已经在这条路上了。</p><hr><h2 id="Gowild-公路商店（Gowild-Highway-Store）">Gowild 公路商店（Gowild Highway Store）</h2><h3 id="产品概述-6"><strong>产品概述</strong></h3><p>Gowild 公路商店是一款专注于“都市青年亚文化消费”的生活方式电商平台。它不像传统电商那样主打性价比，而是强调“酷”、“反叛”、“个性化”的内容与商品策展，风格调性接近美式便利店和独立杂志的混合体，产品涵盖潮玩、轻饮、文创、服饰等品类。</p><h3 id="核心功能-6"><strong>核心功能</strong></h3><ol><li><strong>内容电商模式</strong>：主页由内容卡片构成，每个产品都配有精致文案和视觉创意，构建情绪共鸣。</li><li><strong>IP联名快闪</strong>：频繁推出与独立艺术家、品牌、展览合作的限定款，引导“收藏式消费”。</li><li><strong>独立设计师品牌入驻</strong>：扶持新锐设计师与独立厂牌，强调“反主流”的差异化表达。</li><li><strong>用户共创空间</strong>：“酷友社区”用户可参与命名、包装、联名提案，增强品牌共建感。</li><li><strong>快闪与快递结合</strong>：部分城市设立线下展柜+即配配送，打造“逛便利店”式体验。</li></ol><h3 id="用户体验评估-6"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>强烈的品牌风格识别，界面就像一本有趣的潮流杂志，充满个性。</li><li>商品策展独具匠心，哪怕不买也像在浏览灵感图库。</li><li>社区氛围有“地下电波”感，用户表达自由且真实，易形成文化认同感。</li></ul></li><li><strong>不足</strong>：<ul><li>商品价格略高，性价比低于主流平台，易劝退价格敏感型用户。</li><li>用户留存与复购依赖“爆款”与视觉刺激，缺乏实用刚需抓手。</li><li>平台内容更新较慢，若无新品或联名活动，用户粘性下降较快。</li></ul></li></ul><h3 id="商业模式解释-6"><strong>商业模式解释</strong></h3><ol><li><strong>商品差价收入</strong>：主收入来源，精选SKU后通过内容赋能溢价销售。</li><li><strong>品牌联名与定制费</strong>：与设计师/机构联合推出独家系列，获得联合营销曝光与分成。</li><li><strong>社群衍生收入</strong>：未来潜力包括线下展览门票、数字藏品发行、会员独享产品等。</li><li><strong>IP 授权运营</strong>：将自研角色和风格符号外放授权，发展成为潮流文化品牌。</li></ol><h3 id="竞争分析-6"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>泡泡玛特 Pop Mart</strong>（潮玩为主，IP打造能力更强）。</li><li><strong>得物</strong>（调性接近但更偏潮流消费，缺乏文化内容策展）。</li><li><strong>小红书商城/即刻商店</strong>（注重生活方式但缺乏品牌独立性）。</li></ul></li><li><strong>Gowild 优势</strong>：<ul><li>内容调性鲜明，主打亚文化人群的心理归属。</li><li>拥有完整视觉语言体系，品牌资产累积快。</li></ul></li><li><strong>劣势</strong>：<ul><li>用户规模小，产品生命周期短，易被模仿。</li><li>商业化能力尚不成熟，SKU选品依赖强策展人队伍。</li></ul></li></ul><h3 id="运营策略-6"><strong>运营策略</strong></h3><ol><li><strong>扩大IP矩阵建设</strong>，打造专属形象如“公路熊”、“喵喵电波”等，向LINE FRIENDS 看齐。</li><li><strong>社区反向供货机制</strong>：通过社区提案与投票，反向决定下一批SKU与联名方向。</li><li><strong>引入虚拟形象直播带货</strong>，将IP人格化，与社区用户建立更紧密情感联系。</li><li><strong>深化线下空间布局</strong>：在潮流商圈投放“快闪便利站”，融合品牌体验与销售转化。</li></ol><h3 id="改进建议-6"><strong>改进建议</strong></h3><ol><li><strong>推出会员体系</strong>，提供限量抢购资格、数字藏品、生日专属礼包等，提升粘性。</li><li><strong>构建用户内容激励机制</strong>，开放“灵感征集”“新品命名”等活动，反哺平台内容。</li><li><strong>提升物流履约体验</strong>，限量商品延迟发货问题需优化，保证用户期待感不落空。</li><li><strong>开发周边工具类产品</strong>，如潮流贴纸、AR 滤镜、桌搭装饰，为文化周边造势。</li></ol><h3 id="总结-6"><strong>总结</strong></h3><p>Gowild 公路商店不是卖产品的电商，而是卖“你是谁”的镜子。它不是做“流量规模化”，而是做“风格人格化”。在“平替横行、价格为王”的电商环境下，它以“文化电商”逆流而上。只要持续供给高频高质的文化表达，并建立一套护城河式的内容生产机制，它就能活成一个时代潮牌的种子库。</p><hr><h2 id="Pixso（在线协同设计工具）">Pixso（在线协同设计工具）</h2><h3 id="产品概述-7"><strong>产品概述</strong></h3><p>Pixso 是一款由中国团队开发的在线协同 UI/UX 设计平台，主打“国产替代 Figma”的战略定位。它整合了产品原型设计、UI 设计、多人协同、设计资产管理等功能，面向设计师、产品经理、开发团队，支持本地部署，强调团队协作与数据安全，在国产化替代政策驱动下逐渐被政企市场关注。</p><h3 id="核心功能-7"><strong>核心功能</strong></h3><ol><li><strong>多端在线协同设计</strong>：多人可实时编辑同一个页面，功能上与 Figma 高度接近。</li><li><strong>组件库管理</strong>：支持设计资产复用，企业可构建统一的设计系统。</li><li><strong>原型交互与注释</strong>：内置高保真原型设计功能，支持交互动效与注释沟通。</li><li><strong>一键交付开发</strong>：代码标注、切图导出、变量同步，方便开发对接。</li><li><strong>国产私有部署</strong>：政企单位可选择私有化部署，满足数据安全合规要求。</li></ol><h3 id="用户体验评估-7"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>上手门槛低，Figma 用户几乎可以“无痛迁移”。</li><li>支持中文界面和快捷键，极大优化本地化使用体验。</li><li>支持多人同时编辑且不延迟，协同体验成熟。</li><li>私有部署选项对政府/大企业极具吸引力。</li></ul></li><li><strong>不足</strong>：<ul><li>功能更新频率不及 Figma，部分高级插件生态尚未建立。</li><li>社区内容与学习资源稀缺，对新手不够友好。</li><li>大型项目下偶有性能瓶颈，稳定性待提升。</li></ul></li></ul><h3 id="商业模式解释-7"><strong>商业模式解释</strong></h3><ol><li><strong>Freemium 模式</strong>：基础功能免费，高级功能（如项目权限控制、无限文件）需付费解锁。</li><li><strong>企业版订阅</strong>：提供团队管理、版本控制、私有部署等高级服务，面向中大型公司。</li><li><strong>政企定制服务</strong>：针对国企、金融、政府客户提供私有部署+定制开发解决方案。</li><li><strong>插件与模板市场（规划中）</strong>：允许第三方开发插件与设计模板，平台抽佣。</li></ol><h3 id="竞争分析-7"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>Figma</strong>：国际霸主，功能强大、生态完整，但存在“卡脖子”风险。</li><li><strong>MasterGo（阿里系）</strong>：同样主打国产协同设计，产品节奏更快，背靠大厂资源。</li><li><strong>蓝湖 + Sketch</strong>：经典组合，但非云原生，协同性较差。</li></ul></li><li><strong>Pixso 优势</strong>：<ul><li>接近 Figma 的产品体验 + 完全国产可控 + 私有部署能力。</li><li>支持一站式“设计-交互-交付”闭环，适合产品全流程。</li></ul></li><li><strong>Pixso 劣势</strong>：<ul><li>缺乏生态优势，目前缺少插件、模板、社区三大生态支撑。</li><li>品牌影响力较弱，尚未形成设计师首选心智。</li></ul></li></ul><h3 id="运营策略-7"><strong>运营策略</strong></h3><ol><li><strong>打入政企标书系统</strong>：积极参与政府采购，推进国产替代进程。</li><li><strong>建立教育合作渠道</strong>：与设计类高校合作，推动 Pixso 成为学生第一设计工具。</li><li><strong>孵化设计社区内容</strong>：扶持原创教程、模板创作者，建立中文设计内容生态。</li><li><strong>加强插件平台建设</strong>：鼓励开发者与第三方工具接入，提升产品粘性。</li></ol><h3 id="改进建议-7"><strong>改进建议</strong></h3><ol><li><strong>开放 AI 辅助功能</strong>，如 AI 生成页面布局、文案建议、组件自动对齐等，提高设计效率。</li><li><strong>推出桌面离线版本</strong>，满足高安全性用户需求，增强产品灵活性。</li><li><strong>打造“Pixso Studio”线上大会</strong>，发布版本更新、用户案例、设计趋势，引爆品牌关注度。</li><li><strong>强化国际化战略</strong>，抢占东南亚和中东等 Figma 使用受限市场，争取技术出海机会。</li></ol><h3 id="总结-7"><strong>总结</strong></h3><p>Pixso 是一款兼具“国产可控”与“设计体验”的协同工具，是在国产替代浪潮下异军突起的种子选手。短期内它可能无法完全替代 Figma，但如果能在私有部署、AI协作与设计生态上持续发力，它将成为中国数字设计基础设施的重要构建者。对于国家级和行业级大项目，它已经是值得信赖的 Plan B——未来甚至可能是 Plan A。</p><hr><h2 id="Replit（云端代码开发平台）">Replit（云端代码开发平台）</h2><h3 id="产品概述-8"><strong>产品概述</strong></h3><p>Replit 是一个基于浏览器的多人协作编程平台，用户无需本地配置环境，即可在线编写、运行、调试程序。支持多种编程语言（Python、JavaScript、C++ 等），内建云端 IDE、部署系统、AI 辅助编程工具，主打“Anywhere Code”理念，被誉为“下一代开发者的乐高积木”。</p><h3 id="核心功能-8"><strong>核心功能</strong></h3><ol><li><strong>多语言支持的云端IDE</strong>：零配置即开写，支持几十种主流编程语言。</li><li><strong>实时协作编程</strong>：多人编辑+聊天功能，像 Google Docs 一样协同写代码。</li><li><strong>内建部署环境</strong>：支持一键部署 Web 服务，自动分配域名。</li><li><strong>AI 编程助手 Ghostwriter</strong>：代码自动补全、解释、重构、生成文档，提升效率。</li><li><strong>社区项目库</strong>：可搜索、Fork、复用他人开源项目，降低学习门槛。</li></ol><h3 id="用户体验评估-8"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>上手即用，完全免去开发环境配置烦恼。</li><li>UI 现代清爽，交互逻辑顺畅，适合初学者和轻量开发者。</li><li>协作体验优秀，远程 Pair Programming 的首选。</li><li>Ghostwriter 辅助写码能力逐步接近 Copilot，性能不俗。</li></ul></li><li><strong>不足</strong>：<ul><li>免费版资源受限（运行内存、存储空间等），中大型项目吃力。</li><li>移动端体验一般，不适合在 iPad 等设备上高效开发。</li><li>社区内容良莠不齐，Fork 项目质量不稳定。</li></ul></li></ul><h3 id="商业模式解释-8"><strong>商业模式解释</strong></h3><ol><li><strong>订阅制（Pro/Teams/Enterprise）</strong>：解锁更高配额、更强 AI 支持、团队协作工具等功能。</li><li><strong>AI Ghostwriter 增值服务</strong>：按月或按调用量付费，提供 Copilot 式 AI 编程辅助。</li><li><strong>企业定制部署</strong>：为教育机构、大型公司提供私有云部署服务。</li><li><strong>开发者工具生态分成</strong>：未来可能发展 Replit 插件生态，抽成收入。</li></ol><h3 id="竞争分析-8"><strong>竞争分析</strong></h3><ul><li><strong>主要对手</strong>：<ul><li><strong>GitHub Codespaces</strong>：微软出品，深度集成 VS Code 和 GitHub 流程。</li><li><strong>Glitch</strong>：更偏向 Web 项目演示与快速原型构建，适合创意开发。</li><li><strong>CodeSandbox</strong>：前端友好度极高，适合 React/Vue 等 UI 组件开发。</li></ul></li><li><strong>Replit 优势</strong>：<ul><li>支持语言种类多，真正做到了“全栈即写即跑”。</li><li>社区生态庞大，适合教学、入门、编程竞赛等场景。</li><li>Ghostwriter 有持续演进空间，未来可挑战 Copilot。</li></ul></li><li><strong>劣势</strong>：<ul><li>专业开发者可能嫌“过于简化”，不适合深度项目开发。</li><li>与本地开发工具集成度差，无法形成完整 DevOps 流程。</li></ul></li></ul><h3 id="运营策略-8"><strong>运营策略</strong></h3><ol><li><strong>强化教育市场渗透</strong>：与高校/编程教育机构深度合作，成为学生第一 IDE。</li><li><strong>Ghostwriter 中文版本优化</strong>：打通中文提示词与代码生成闭环，抢占中文 AI 编程用户。</li><li><strong>推出“创意项目挑战赛”</strong>，激活社区活力，提升留存率与项目质量。</li><li><strong>引入 Plugin 市场机制</strong>，扶持第三方开发者构建 Replit 插件生态，打造平台效应。</li></ol><h3 id="改进建议-8"><strong>改进建议</strong></h3><ol><li><strong>本地调试连接器</strong>：允许用户将 Replit 项目对接本地数据库或容器，提升灵活性。</li><li><strong>推出移动端 IDE Lite 模式</strong>，满足轻度编辑或紧急修复场景的需求。</li><li><strong>AI 模型可定制训练</strong>：允许团队导入自有代码库训练 Ghostwriter，更精准补全。</li><li><strong>强化开源项目孵化机制</strong>，激励创作者打造“爆款项目模板”，形成流量与收益正循环。</li></ol><h3 id="总结-8"><strong>总结</strong></h3><p>Replit 是“开发者即服务”的未来实验室。它不只是一个在线 IDE，而是一个新型“代码社交平台”，正在用 AI + 云端协作的方式重塑编程的入口门槛。如果它能在教育市场站稳、在 AI 编程层面持续创新，并发展出“插件化+创作者经济”的平台模型，那它就是“开发界的 Canva + Notion + GitHub”。未来，Replit 很可能成为 Web3、AI 创业者的第一块积木。</p><hr><h2 id="Notion（全球协同工作区）">Notion（全球协同工作区）</h2><h3 id="产品概述-9"><strong>产品概述</strong></h3><p>Notion 是一款集笔记、数据库、任务管理、知识库和协作功能于一体的全能型办公工具。它打破传统应用模块的边界，用“块（Block）”为基础构建灵活页面，被广泛用于个人知识管理、团队协作、产品规划等场景。随着全球远程协作趋势加速，Notion 正在逐步从“文档工具”升级为“第二大脑平台”。</p><h3 id="核心功能-9"><strong>核心功能</strong></h3><ol><li><strong>文档编辑器</strong>：支持文本、代码、表格、图片、嵌入网页等模块，块级结构灵活强大。</li><li><strong>数据库系统</strong>：支持表格、看板、日历、列表等视图，自定义属性与筛选器。</li><li><strong>团队协作</strong>：页面共享权限、协同编辑、评论机制支持高效远程办公。</li><li><strong>模板市场</strong>：内置丰富模板，涵盖OKR、CRM、周报、课程计划等场景。</li><li><strong>Notion AI（AI 助手）</strong>：可辅助写作、总结、翻译、生成表格，提升内容生产效率。</li></ol><h3 id="用户体验评估-9"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>极致自由度</strong>，适合构建个性化信息系统或项目管理工具。</li><li><strong>UI 简洁优雅</strong>，跨平台体验一致，尤其适配 macOS / iOS 用户。</li><li><strong>社区生态繁荣</strong>，模板与二创内容丰富，学习成本逐步降低。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>移动端性能偶有卡顿</strong>，大型数据库渲染延迟较明显。</li><li><strong>权限管理细粒度略显不足</strong>，企业复杂协作仍需优化。</li><li><strong>对中文语境支持提升中</strong>，部分 AI 生成功能偏英文习惯。</li></ul></li></ul><h3 id="商业模式解释-9"><strong>商业模式解释</strong></h3><ol><li><strong>Freemium 模式</strong>：个人版免费，付费解锁文件上传、历史版本、协作人数等限制。</li><li><strong>团队订阅计划</strong>：按成员计费，提供管理后台、权限控制、集成能力等功能。</li><li><strong>AI 功能订阅</strong>：Notion AI 需额外付费，按使用量或月度付费。</li><li><strong>模板与插件市场（建设中）</strong>：未来或发展为平台型生态，分成内容创作者收入。</li></ol><h3 id="竞争分析-9"><strong>竞争分析</strong></h3><ul><li><strong>主要对手</strong>：<ul><li><strong>Coda</strong>：更侧重数据驱动，适合构建“微应用”。</li><li><strong>Confluence</strong>：传统企业知识管理首选，适配大型组织。</li><li><strong>Obsidian</strong>：极客向本地知识管理系统，适合高阶笔记用户。</li></ul></li><li><strong>Notion 优势</strong>：<ul><li>操作逻辑贴近 Z 世代用户，低代码+美感兼顾。</li><li>模块化构建能力强，既能做 Wiki，又能当任务板。</li><li>AI 辅助能力逐步成为护城河，内容效率大幅提升。</li></ul></li><li><strong>Notion 劣势</strong>：<ul><li>商业场景拓展缓慢，未形成强粘性的 B 端生态。</li><li>性能天花板问题未解，尤其面对超大型组织数据库管理。</li></ul></li></ul><h3 id="运营策略-9"><strong>运营策略</strong></h3><ol><li><strong>深耕教育市场</strong>：扩大高校、研究机构内推广力度，提前培育未来用户。</li><li><strong>强化中文社区</strong>：扶持中文模板创作者与博主，增强本地适配。</li><li><strong>加速插件平台搭建</strong>：支持第三方组件接入，增强工具属性。</li><li><strong>打造知识型创作者生态</strong>：扶持 Notion 内容创业者，通过订阅分成实现 Creator Economy 模式。</li></ol><h3 id="改进建议-9"><strong>改进建议</strong></h3><ol><li><strong>推出离线桌面重构版</strong>，降低加载压力，提高本地性能与数据安全。</li><li><strong>增加权限继承与部门级角色管理</strong>，满足企业复杂协作流程。</li><li><strong>AI 功能强化中文语料训练</strong>，改善中文逻辑输出质量与本地表达自然度。</li><li><strong>开放数据接口 API 与自动化集成</strong>，对接 Zapier、Make 等工具，打通自动化场景。</li></ol><h3 id="总结-9"><strong>总结</strong></h3><p>Notion 是“数字工作空间”的开创者和引领者，它不仅重新定义了“文档”的结构，还在“协作”、“创作”和“知识沉淀”之间搭建了一座桥梁。它最强的不是功能，而是“思想可塑性”：既能服务个人的第二大脑，也能撑起一个团队的知识基建。未来只要继续围绕内容生态、AI 辅助和插件平台做深做透，它很可能成为“新时代办公平台的 WordPress + Zapier + GPT”。</p><hr><h2 id="Koo（印度本土社交媒体平台）">Koo（印度本土社交媒体平台）</h2><h3 id="产品概述-10"><strong>产品概述</strong></h3><p>Koo 是一个由印度本土创业公司开发的社交媒体平台，定位为“印度版 Twitter”，主打多语言内容创作与本地化表达。自 2020 年以来，在印度政府与 Twitter 发生监管摩擦的背景下，Koo 迅速蹿红，号称“为印度人发声的平台”。</p><h3 id="核心功能-10"><strong>核心功能</strong></h3><ol><li><strong>多语言内容发布</strong>：支持 10 多种印度本土语言（印地语、泰米尔语、卡纳达语等）。</li><li><strong>简短帖子系统</strong>：最多 500 字的文字内容 + 图片/视频，类似 Twitter 的动态形式。</li><li><strong>趋势话题与标签</strong>：通过“热议话题”引导用户参与公共讨论。</li><li><strong>用户认证与影响力体系</strong>：认证创作者/政治人物/媒体账号，推动话语权本地化。</li><li><strong>语言翻译功能</strong>：自动将用户发文翻译成其他本地语言，促进跨语种交流。</li></ol><h3 id="用户体验评估-10"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>本地化极致</strong>：界面和内容完美适配印度多语言社会的实际需求。</li><li><strong>操作简洁</strong>，对比 Twitter 更易上手。</li><li><strong>各邦政府官员与主流媒体纷纷入驻</strong>，平台公信力有所增强。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>内容质量参差不齐</strong>，审核机制尚不成熟。</li><li><strong>活跃用户数与留存率远不如 Twitter</strong>，社区氛围仍显稚嫩。</li><li><strong>推广过度依赖政策导向</strong>，缺乏市场驱动的用户拉力。</li></ul></li></ul><h3 id="商业模式解释-10"><strong>商业模式解释</strong></h3><ol><li><strong>品牌合作推广</strong>：政府机构、新闻媒体通过合作投放传播。</li><li><strong>数据服务（规划中）</strong>：利用平台趋势分析提供社会舆情洞察。</li><li><strong>创作者激励体系</strong>：通过影响力评级系统与广告共享进行初步探索。</li><li><strong>B2G 定制部署</strong>：向地方政府、国有媒体提供定制版内容平台服务。</li></ol><h3 id="竞争分析-10"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>Twitter/X</strong>：全球社交平台龙头，在印度仍有大量忠实用户。</li><li><strong>ShareChat</strong>：另一个本土短内容平台，但偏向娱乐化。</li><li><strong>Facebook/Instagram</strong>：受众更广但并不强调多语言细分。</li></ul></li><li><strong>Koo 优势</strong>：<ul><li>主打“印度制造+多语言”，在民族情绪与语言平权中占领高地。</li><li>政策背书强，适合接入政务传播与选举场景。</li></ul></li><li><strong>Koo 劣势</strong>：<ul><li>商业化路径模糊，未形成持续盈利能力。</li><li>平台活跃度低，缺乏 UGC 激励生态，导致“官媒味重”。</li></ul></li></ul><h3 id="运营策略-10"><strong>运营策略</strong></h3><ol><li><strong>强化地方性 IP 策划</strong>：与各邦文化节、宗教活动深度绑定内容。</li><li><strong>推出 Koo 创作者基金</strong>：吸引小语种内容创作者稳定输出内容。</li><li><strong>开放 API 接入政务系统</strong>：打造“政务公开 + 群众互动”通道。</li><li><strong>推动“海外印度语”社群运营</strong>：在东南亚、非洲拓展印地语及乌尔都语社区。</li></ol><h3 id="改进建议-10"><strong>改进建议</strong></h3><ol><li><strong>强化内容推荐算法</strong>，提升用户粘性与内容分发精准度。</li><li><strong>推出短视频互动模块</strong>，对标 Threads 与 Instagram 的轻量化玩法。</li><li><strong>建立 AI 内容审查机制</strong>，确保跨语种语境下内容合规。</li><li><strong>探索“本地生活 + 民意反馈”功能</strong>，从社交平台升级为政民互动工具。</li></ol><h3 id="总结-10"><strong>总结</strong></h3><p>Koo 是典型的“替代型互联网产品”，在政策窗口期迅速占据民族品牌定位。但未来的关键在于：能否脱离政治红利，真正用产品价值圈住多语种用户，并构建自我驱动的社区与商业循环。如果能继续围绕“本地语言互联网的最后一公里”深耕，它就不仅是印度的“Twitter 替代品”，而是“社交网络的多语种革命试验田”。</p><hr><h2 id="Blinkist（知识浓缩音频平台）">Blinkist（知识浓缩音频平台）</h2><h3 id="产品概述-11"><strong>产品概述</strong></h3><p>Blinkist 是一款德国团队开发的“知识速读”服务平台，主打将非虚构类书籍浓缩成 15 分钟的音频或文字摘要，方便用户在碎片时间快速学习新知识。平台内容涵盖领导力、心理学、生产力、理财等多个主题，是“认知型用户”必备的通勤神器。</p><h3 id="核心功能-11"><strong>核心功能</strong></h3><ol><li><strong>书籍浓缩摘要（Blinks）</strong>：每本书浓缩为 10-15 分钟的要点音频或文本，结构清晰。</li><li><strong>个性化推荐</strong>：根据阅读历史与兴趣偏好，算法推送相关主题内容。</li><li><strong>多语种音频播放</strong>：支持英文原音播放，部分内容已有德语/西语版本。</li><li><strong>收藏与离线功能</strong>：可下载内容用于离线收听，支持标注与笔记同步。</li><li><strong>专业主题清单（Collections）</strong>：围绕技能成长、商业趋势等构建阅读路径。</li></ol><h3 id="用户体验评估-11"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>内容浓缩质量高</strong>，逻辑清晰，非常适合“泛学习”或入门了解新领域。</li><li><strong>UI 简洁直观</strong>，听读体验一流，切换方式灵活。</li><li><strong>每周更新新书内容</strong>，紧跟商业和流行趋势。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>部分摘要略显表面</strong>，深度不及长篇原书。</li><li><strong>中文市场缺乏本地化版本</strong>，不支持中文内容，门槛较高。</li><li><strong>订阅价格相对偏高</strong>，对轻度用户性价比一般。</li></ul></li></ul><h3 id="商业模式解释-11"><strong>商业模式解释</strong></h3><ol><li><strong>订阅制</strong>：基础版本免费体验少量内容，Premium 订阅解锁完整库及高级功能。</li><li><strong>B2B 企业培训</strong>：向公司提供团队账号，用于员工碎片化学习与领导力培养。</li><li><strong>品牌合作栏目</strong>：与出版商/作者联名推荐书目，提升新书曝光与转化。</li><li><strong>即将拓展的课程服务</strong>：上线 mini-course 模块，尝试与 Coursera/LinkedIn Learning 差异互补。</li></ol><h3 id="竞争分析-11"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>Headway</strong>：界面更 gamified，内容偏轻量娱乐化。</li><li><strong>Audm/Curio</strong>：聚焦新闻文章朗读，不是书籍类浓缩但用户群重叠。</li><li><strong>Kindle 电子书 + 要点服务（如 Readwise）</strong>：功能分散但有替代性。</li></ul></li><li><strong>Blinkist 优势</strong>：<ul><li>高质量内容制作标准（非 AI 自动摘要），语言清晰、结构规范。</li><li>品牌认知度高，欧美市场“学习型白领”的首选。</li></ul></li><li><strong>Blinkist 劣势</strong>：<ul><li>本地化推进缓慢，中文/韩语等市场空白。</li><li>用户粘性不足，容易被视作“快餐式知识”而非深度平台。</li></ul></li></ul><h3 id="运营策略-11"><strong>运营策略</strong></h3><ol><li><strong>拓展亚洲市场</strong>：联合当地出版商与平台，推出本地语种版本，切入通勤文化浓厚国家如日本、韩国、台湾。</li><li><strong>引入生成式 AI 总结辅助</strong>：提升新书上架速度，降低内容生产成本。</li><li><strong>建设“书籍+行动指南”生态</strong>：围绕书籍内容延伸 checklist、行动卡片、反思工具，增强实用性。</li><li><strong>推出“碎片学习课程包”</strong>：按主题（如“年入百万思维”、“10天打造表达力”）整合 Blink 内容，强化转化路径。</li></ol><h3 id="改进建议-11"><strong>改进建议</strong></h3><ol><li><strong>推出中文版本与微信小程序接入</strong>，抢占中文信息焦虑型中产市场。</li><li><strong>开放社群功能</strong>，让用户就某书讨论要点/批判性思考，提升互动度。</li><li><strong>引入“沉浸式微播客”功能</strong>，用主播+书摘混剪形式，增强听觉趣味。</li><li><strong>增强学习路径引导</strong>，通过 AI 个性化构建“认知成长路线图”，让用户持续留在平台。</li></ol><h3 id="总结-11"><strong>总结</strong></h3><p>Blinkist 就像认知界的“特斯拉超充站”，不提供完整旅行，但让人快速补能。在注意力稀缺、时间碎片化的时代，它不是书的替代品，而是探索世界的新地图。若能继续围绕“认知密度+时间效率”双轮驱动，并拓展全球市场特别是中文圈，它将成为“现代知识消费品”的范式产品。</p><hr><h2 id="Duolingo（多邻国）">Duolingo（多邻国）</h2><h3 id="产品概述-12"><strong>产品概述</strong></h3><p>Duolingo 是一个主打“免费+游戏化”的在线语言学习平台，总部位于美国匹兹堡，自 2011 年上线以来迅速风靡全球。它将语言学习拆解为轻量任务，并通过“打怪升级、连胜奖励、排行榜”等机制，重塑了语言学习的交互体验。核心用户群包括英语为非母语的学习者、小语种初学者，以及希望利用碎片时间提升外语能力的泛学习者。</p><h3 id="核心功能-12"><strong>核心功能</strong></h3><ol><li><strong>课程体系化模块</strong>：基于 CEFR（欧洲共同语言参考框架）设计，覆盖从初级到中级内容。</li><li><strong>互动练习题</strong>：包括听力、翻译、拼写、口语判断、词汇连线等多类型题目。</li><li><strong>游戏化学习机制</strong>：每日连胜、经验值、语言宝石、排行榜等设计提升使用粘性。</li><li><strong>AI 教学推荐</strong>：动态调整学习路径，根据错误记录推荐强化练习。</li><li><strong>Duolingo Stories 和 Podcasts</strong>：提升语境理解能力，适配进阶用户需求。</li></ol><h3 id="用户体验评估-12"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>极易上手</strong>，界面友好且趣味十足，适合“学习倦怠期”的用户。</li><li><strong>零门槛免费使用</strong>，降低学习尝试成本。</li><li><strong>适配多端（Web/iOS/Android）</strong>，同步性良好。</li><li><strong>动画形象和音效反馈丰富</strong>，正向激励系统设计优秀。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>中高级内容深度略显不足</strong>，不能满足考试或专业学习需求。</li><li><strong>AI 判别系统对口语识别存在误判</strong>，反馈体验不稳定。</li><li><strong>部分语言课程内容不对称</strong>，如西班牙语比韩语更完善。</li></ul></li></ul><h3 id="商业模式解释-12"><strong>商业模式解释</strong></h3><ol><li><strong>Freemium 模式</strong>：基础功能永久免费，学习过程中有广告。</li><li><strong>Duolingo Plus（现称 Super Duolingo）</strong>：移除广告、离线下载、错题复练、无限心功能。</li><li><strong>企业与学校版（Duolingo for Schools）</strong>：为教师提供学生监控与课程定制支持。</li><li><strong>新增长点——Duolingo English Test</strong>：付费英语水平考试，受全球高校广泛认可。</li></ol><h3 id="竞争分析-12"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>Babbel</strong>：强调实际语言交流能力，更注重语法教学。</li><li><strong>Rosetta Stone</strong>：老牌语言学习平台，内容沉淀深厚但交互较老旧。</li><li><strong>Memrise</strong>：以记忆训练为主，适合背单词但体系不完整。</li></ul></li><li><strong>Duolingo 优势</strong>：<ul><li>强烈品牌辨识度，吉祥物 Duo 鸟深入人心。</li><li>内容更新频繁，AI 训练反馈闭环完善。</li><li>用户基础庞大，社群活跃度高，形成语言学习“社交圈”。</li></ul></li><li><strong>劣势</strong>：<ul><li>难以转化为高阶教学平台，用户留存挑战大。</li><li>广告收入受限于用户活跃度波动，商业抗风险能力仍需增强。</li></ul></li></ul><h3 id="运营策略-12"><strong>运营策略</strong></h3><ol><li><strong>深化 AI 自适应学习能力</strong>：结合 GPT 生成式技术，生成个性化练习题与语境对话。</li><li><strong>拓展课程种类</strong>：新增编程语言（如 Python）、文化课程、留学准备包等差异化模块。</li><li><strong>内容创作者计划</strong>：开放课程制作权限，吸引语言专家与教师共同建设内容生态。</li><li><strong>“学伴计划”与社交互动机制</strong>：鼓励用户互相点评纠错，增强社区归属感。</li></ol><h3 id="改进建议-12"><strong>改进建议</strong></h3><ol><li><strong>推出“深度课程路径”</strong>，为备考 IELTS/TOEFL 用户提供分级突破方案。</li><li><strong>优化口语评估技术</strong>，结合真实语音模型提供即时反馈与打分。</li><li><strong>增强中文支持</strong>，扩展中文用户使用场景并推出“中国特色课程”（如普通话+方言）。</li><li><strong>引入“学习导师”订阅服务</strong>，提供轻咨询/答疑，增加高端用户转化率。</li></ol><h3 id="总结-12"><strong>总结</strong></h3><p>Duolingo 不是最专业的语言工具，但它绝对是最具可持续性的语言学习“入口产品”。它用游戏化打破了语言学习的枯燥天花板，是教育科技领域“娱乐驱动学习”最成功的商业化样本之一。未来，只要它能不断向“AI+多场景个性学习”升级，Duolingo 有望成为全球认知型教育的“Netflix”。</p><hr><h2 id="BeReal（全球社交“真我”应用）">BeReal（全球社交“真我”应用）</h2><h3 id="产品概述-13"><strong>产品概述</strong></h3><p>BeReal 是一款由法国团队推出的社交应用，以“每天随机一次，展示当下真实生活”为核心理念，主打反滤镜、反摆拍的“真诚社交”。用户每天在系统随机时间收到通知后需在2分钟内拍照上传，前后摄像头同时启用，展现此刻最真实的自己与环境。这款产品迅速走红于欧美高校与年轻人群，被誉为“Z世代的反Instagram”。</p><h3 id="核心功能-13"><strong>核心功能</strong></h3><ol><li><strong>每日一次拍摄提醒</strong>：系统每天随机时间推送拍照通知，鼓励即时记录生活。</li><li><strong>双镜头同步拍摄</strong>：前置+后置摄像头同时工作，避免“伪记录”与“自拍修饰”。</li><li><strong>朋友限定可见</strong>：照片仅在你发布当日 BeReal 后才能查看朋友内容。</li><li><strong>迟到发布标识</strong>：超过两分钟上传会被标记，增加真实性社交压力。</li><li><strong>留言与 Reaction 表情</strong>：支持自拍 Reaction，打造个性化互动形式。</li></ol><h3 id="用户体验评估-13"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>打破精致社交疲劳</strong>，强化真实人设认同感。</li><li><strong>使用节奏轻松</strong>，每天只需一次互动，反社交焦虑。</li><li><strong>操作极简</strong>，设计清爽，社交门槛低。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>对内容创造依赖“突发性”</strong>，不适合重度社交用户。</li><li><strong>缺乏持续留存机制</strong>，用户流失较快。</li><li><strong>功能同质化风险上升</strong>，竞争产品易复制。</li></ul></li></ul><h3 id="商业模式解释-13"><strong>商业模式解释</strong></h3><p>目前 BeReal 尚无明确商业化路径，但未来可能包括：</p><ol><li><strong>付费功能解锁</strong>：如历史回顾、时间轴归档、延时拍摄权等。</li><li><strong>品牌联动挑战活动</strong>：与生活方式类品牌共创主题拍照挑战。</li><li><strong>校园/社群推广合作</strong>：基于高校和兴趣社区做分发与定制版本。</li><li><strong>反向导流电商</strong>：以“真实推荐”引导用户查看穿搭、美食、设备等信息。</li></ol><h3 id="竞争分析-13"><strong>竞争分析</strong></h3><ul><li><strong>直接竞争对手</strong>：<ul><li><strong>Instagram Notes &amp; Threads</strong>：已在复制“BeReal”风格照片机制。</li><li><strong>Snapchat</strong>：主打快速私密分享，年轻用户重叠度高。</li></ul></li><li><strong>间接竞争对手</strong>：<ul><li><strong>Locket Widget</strong>：主打桌面好友照片分享，核心机制相近但轻度。</li><li><strong>Zenly</strong>（已关闭）：共享生活状态的思路类似。</li></ul></li><li><strong>BeReal 优势</strong>：<ul><li>抢占“真实社交”定位，构建差异化用户心智。</li><li>社交负担小，适合日常快照记录与轻社交。</li></ul></li><li><strong>BeReal 劣势</strong>：<ul><li>不具备强社交网络效应，易形成“单点体验孤岛”。</li><li>缺乏内容沉淀机制，不利于深度用户关系维系。</li></ul></li></ul><h3 id="运营策略-13"><strong>运营策略</strong></h3><ol><li><strong>推进高校大使计划</strong>：持续发力Z世代种子用户群体，保持用户文化活力。</li><li><strong>引入周期性主题挑战</strong>：如“卧室大曝光周”、“一起下厨日”，激活UGC生产。</li><li><strong>探索限定版 Reaction NFT 表情</strong>，与用户头像、成就绑定，刺激收藏与分享欲。</li><li><strong>开放第三方合作相机滤镜+拍摄插件</strong>，延伸生态工具，形成创作围栏。</li></ol><h3 id="改进建议-13"><strong>改进建议</strong></h3><ol><li><strong>引入“好友故事墙”功能</strong>，支持自动拼接好友一天动态，增加浏览欲望。</li><li><strong>推出“回忆卡片”系统</strong>，每周生成真实生活回顾，鼓励数据留存。</li><li><strong>AI 生成式提醒风格</strong>，加入有趣语音或图像风格，提升打开率。</li><li><strong>构建兴趣小组+线下见面机制</strong>，让“真实社交”从线上扩展至线下场景。</li></ol><h3 id="总结-13"><strong>总结</strong></h3><p>BeReal 是一次对社交媒体“原教旨主义”的反击，它主张的不是“让你变得更好”，而是“接纳本真的自己”。它不需要用户内容策划，也不鼓励流量算法干预，靠的就是一种“反精致的信仰共识”。要继续向前，它需要从“反主流”变成“创生态”——不只是反社交网络，更要重构真实连接的新范式。</p><hr><h2 id="Tandem（语言交换学习社区）">Tandem（语言交换学习社区）</h2><h3 id="产品概述-14"><strong>产品概述</strong></h3><p>Tandem 是一款来自德国的语言学习应用，旨在通过“母语互助”的方式促进全球用户进行语言交流与学习。用户可以选择想学习的语言，并与母语使用者进行一对一聊天、语音或视频通话，采用“你教我中文，我教你西班牙语”式的互助学习模式。它结合了社交与教育，是全球最具代表性的语言交换社区之一。</p><h3 id="核心功能-14"><strong>核心功能</strong></h3><ol><li><strong>语言匹配系统</strong>：基于用户母语、目标语言、兴趣标签进行智能推荐学习伙伴。</li><li><strong>文字+语音+视频聊天</strong>：支持多种交流方式，提升沟通真实感与语言实用性。</li><li><strong>语音纠正与翻译助手</strong>：内建翻译与语音回放功能，帮助用户理解并提升表达。</li><li><strong>学习计划与话题引导</strong>：提供话题模板和问题卡片，减少冷场，提升语言输入输出效率。</li><li><strong>专业导师功能（Tandem Tutors）</strong>：可选择付费专业语言教师进行系统学习。</li></ol><h3 id="用户体验评估-14"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>用户全球化、多语种覆盖全面</strong>，真正实现语言沉浸式交流。</li><li><strong>匹配机制精准</strong>，且支持手动筛选，用户掌控感强。</li><li><strong>社交氛围友好</strong>，社区秩序较好，用户普遍“有学习动机”。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>免费用户聊天频率有限制</strong>，部分功能需订阅才能解锁。</li><li><strong>存在“假装语言交换实为社交搭讪”风险</strong>，对新手可能不友好。</li><li><strong>中文支持不够深入</strong>，界面翻译偶有错误，用户教育不完善。</li></ul></li></ul><h3 id="商业模式解释-14"><strong>商业模式解释</strong></h3><ol><li><strong>订阅制（Tandem Pro）</strong>：付费用户可获得无限匹配、全球定位、隐藏广告等高级功能。</li><li><strong>付费语言导师课程</strong>：通过平台预约一对一专业语言教师，Tandem 抽佣。</li><li><strong>礼物系统（实验中）</strong>：用户可互相打赏或赠送虚拟礼物，增强互动与粘性。</li><li><strong>B2B 合作潜力</strong>：未来可为语言学校或跨国企业提供员工语言训练平台。</li></ol><h3 id="竞争分析-14"><strong>竞争分析</strong></h3><ul><li><strong>直接竞争对手</strong>：<ul><li><strong>HelloTalk（中国团队开发）</strong>：功能与理念相似，中文用户基础更强。</li><li><strong>Speaky</strong>：也是语言交换平台，但活跃度和用户体验逊色于 Tandem。</li></ul></li><li><strong>间接竞争对手</strong>：<ul><li><strong>Duolingo</strong>：偏向课程式学习，强调游戏化；Tandem更偏真实语境交流。</li><li><strong>italki / Preply</strong>：专注付费教师服务，缺少“用户互助”特色。</li></ul></li><li><strong>Tandem 优势</strong>：<ul><li>口碑强、界面简洁、匹配算法成熟，沉浸式语言体验领先。</li><li>交友+学习结合，具备较高用户粘性与二次留存价值。</li></ul></li><li><strong>Tandem 劣势</strong>：<ul><li>商业化节奏较慢，变现能力弱于 Duolingo 或专业语言平台。</li><li>依赖用户自觉维护社区氛围，扩张难度大于自动化课程平台。</li></ul></li></ul><h3 id="运营策略-14"><strong>运营策略</strong></h3><ol><li><strong>本地化运营落地</strong>：进入中国、东南亚等新兴市场时应构建中文社群与本地客服支持。</li><li><strong>高校推广计划</strong>：与全球高校语言中心合作，成为交换生首选交流工具。</li><li><strong>优化内容引导机制</strong>：加入“每日对练任务”“视频话题挑战”等激励形式。</li><li><strong>搭建语言社区榜单与徽章系统</strong>：增强成就感，促进内容创作与活跃度。</li></ol><h3 id="改进建议-14"><strong>改进建议</strong></h3><ol><li><strong>推出 AI 模拟对话功能</strong>，在真实用户稀缺时提供 AI 语言伙伴训练模式。</li><li><strong>支持翻译插件定制</strong>，允许用户绑定外部翻译 API（如 DeepL、GPT）提升学习效率。</li><li><strong>优化安全机制与举报系统</strong>，保护用户免受语言骚扰与文化歧视。</li><li><strong>提供用户画像分析</strong>，定期总结语言成长报告，增强长期学习目标感。</li></ol><h3 id="总结-14"><strong>总结</strong></h3><p>Tandem 是那种“不靠 AI 靠人性”的语言学习产品，它提供的不是知识点背诵，而是连接与互动。在语言焦虑时代，它主张“用语言建立关系”，而非“为了考试学习语言”。如果它能逐步打通社区社交闭环、AI 互动能力和教学变现逻辑，未来完全有机会成为“语言学习中的 LinkedIn + Tinder + ChatGPT”的超级混合平台。</p><hr><h2 id="Strava（全球运动社交应用）">Strava（全球运动社交应用）</h2><h3 id="产品概述-15"><strong>产品概述</strong></h3><p>Strava 是一款面向运动爱好者的 GPS 追踪与社交分享平台，主要服务跑步、骑行、徒步、游泳等耐力运动用户。它不仅记录运动数据，还构建了一个“朋友圈式”的社区，让用户可以晒成绩、比排名、组团挑战，堪称“运动界的Instagram + Garmin + Reddit”。</p><h3 id="核心功能-15"><strong>核心功能</strong></h3><ol><li><strong>GPS 运动追踪</strong>：支持记录轨迹、配速、海拔、心率等关键运动数据。</li><li><strong>细分运动模式</strong>：支持超过30种运动类型（从骑行、跑步到瑜伽、滑雪）。</li><li><strong>挑战与成就系统</strong>：月度挑战、排行榜、勋章体系，驱动用户持续参与。</li><li><strong>社交互动</strong>：用户可以点赞、评论他人运动记录，构建运动圈关系。</li><li><strong>路线规划与探索</strong>：提供全球热门路线、Strava热力图支持路线发现。</li><li><strong>第三方设备同步</strong>：完美兼容 Garmin、Apple Watch、Wahoo 等智能设备。</li></ol><h3 id="用户体验评估-15"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>数据呈现清晰直观</strong>，适合中高级运动爱好者进行训练管理。</li><li><strong>社区氛围积极</strong>，成就系统设计激励性强，有很强社交驱动。</li><li><strong>支持多人路线重叠分析与“Segment（片段）”竞赛机制</strong>，提升互动性与竞技感。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>免费版功能有限</strong>，细节数据、分析报告需订阅。</li><li><strong>中文本地化一般</strong>，中国大陆地图精度不高。</li><li><strong>偶有 GPS 偏移或数据同步延迟的问题。</strong></li></ul></li></ul><h3 id="商业模式解释-15"><strong>商业模式解释</strong></h3><ol><li><strong>订阅制（Strava Premium）</strong>：提供详细训练分析、个性化目标设定、心率/功率训练建议等进阶功能。</li><li><strong>品牌合作营销</strong>：与耐克、Garmin、Red Bull 等品牌合作开展挑战赛或联名活动。</li><li><strong>B2B 数据服务</strong>：热力图与运动趋势数据被城市规划、骑行基础设施建设团队采纳。</li><li><strong>运动内容创作者合作</strong>：扶持“运动KOL”产生UGC内容与社区影响力。</li></ol><h3 id="竞争分析-15"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>Nike Run Club（NRC）</strong>：UI更友好，适合跑步新手。</li><li><strong>Garmin Connect</strong>：深度整合硬件，专业性更强，但缺乏社交活跃度。</li><li><strong>Keep / Joyrun（国内）</strong>：偏重健身/打卡体系，本地运营更强。</li></ul></li><li><strong>Strava 优势</strong>：<ul><li>多运动类型融合，跨设备整合度高，社交系统完备。</li><li>拥有极强“Segment社群文化”，用户参与感和忠诚度高。</li></ul></li><li><strong>Strava 劣势</strong>：<ul><li>本地化进程慢，亚洲市场渗透不深，缺乏线下品牌绑定。</li><li>免费体验“割裂感”强，付费转化率仍有提升空间。</li></ul></li></ul><h3 id="运营策略-15"><strong>运营策略</strong></h3><ol><li><strong>强化本地运营</strong>：在中国、日本、韩国推出在地化地图与社区挑战。</li><li><strong>与智能手表/健身房平台联合运营</strong>：打通 Apple 健身圈、华为运动健康等本地硬件系统。</li><li><strong>打造“城市挑战排行榜”</strong>：按城市划分挑战榜单，激发区域用户荣誉感与活跃度。</li><li><strong>社区赛事合作</strong>：与马拉松、自行车赛、越野跑活动绑定，增强线下影响力。</li></ol><h3 id="改进建议-15"><strong>改进建议</strong></h3><ol><li><strong>推出“运动组队匹配”功能</strong>，让用户能自动匹配附近运动伙伴，增强陪练体验。</li><li><strong>基于AI训练反馈优化建议</strong>，结合用户目标自动生成训练计划与饮食建议。</li><li><strong>本地语言社区运营官机制</strong>，提升用户活跃度与内容生成质量。</li><li><strong>推出“运动Vlog”功能</strong>，让轨迹、照片、数据合成故事形式分享，增强趣味性。</li></ol><h3 id="总结-15"><strong>总结</strong></h3><p>Strava 是数字运动时代的社交引擎，它不只是记录运动，更在“连接热爱运动的灵魂”。它的精妙之处，在于将数据变成荣誉，将地图变成赛道，将个人变成社群的一部分。未来，谁能掌控这群“愿为进步付出努力”的高质量用户，谁就能真正打开“运动互联网”的黄金赛道。而 Strava，已经在起跑线领先了一圈。🏃‍♂️💨</p><hr><h2 id="Headspace（全球冥想与心理健康应用）">Headspace（全球冥想与心理健康应用）</h2><h3 id="产品概述-16"><strong>产品概述</strong></h3><p>Headspace 是一款来自美国的冥想与心理健康类应用，以“用科学改善心智状态”为目标，提供冥想引导、睡眠辅助、减压练习和情绪管理等内容。它面向所有年龄段用户，尤其受到职场人群、焦虑人群和心理成长爱好者的欢迎。它被称为“冥想界的 Netflix”。</p><h3 id="核心功能-16"><strong>核心功能</strong></h3><ol><li><strong>冥想课程</strong>：涵盖入门、正念呼吸、专注力、情绪调节、压力释放等多个主题。</li><li><strong>睡眠辅助</strong>：Sleepcast、白噪音、放松音乐、深度引导，改善用户睡眠质量。</li><li><strong>情绪调节工具</strong>：提供“焦虑缓解”、“愤怒放松”等即时情绪引导课程。</li><li><strong>日常正念训练</strong>：如洗澡冥想、通勤冥想、工作专注力训练等，贴近生活场景。</li><li><strong>儿童冥想内容</strong>：帮助孩子调节情绪、提高注意力、建立自我意识。</li></ol><h3 id="用户体验评估-16"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>内容丰富专业</strong>，语音质量高，适合长期使用建立习惯。</li><li><strong>界面极简柔和</strong>，配色和插画风格具有疗愈感。</li><li><strong>可高度个性化设置计划和目标</strong>，提升用户主动性。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>英文为主</strong>，对非英语母语用户不够友好（中文版尚无本地化内容）。</li><li><strong>高阶内容需订阅才能解锁</strong>，门槛对轻度用户略高。</li><li><strong>部分内容缺乏交互反馈</strong>，体验感偏“广播式”。</li></ul></li></ul><h3 id="商业模式解释-16"><strong>商业模式解释</strong></h3><ol><li><strong>订阅制（Headspace Plus）</strong>：月付/年付，解锁全部冥想课程与个性计划。</li><li><strong>企业合作（Headspace for Work）</strong>：为公司提供员工心理健康解决方案。</li><li><strong>品牌联动（Nike、Spotify 等）</strong>：通过冥想专题合作进行品牌露出。</li><li><strong>教育/非营利捐赠渠道</strong>：免费向学校和教育组织开放部分资源，增强社会影响力。</li></ol><h3 id="竞争分析-16"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>Calm</strong>：UI 更具沉浸感，注重睡眠场景，内容更娱乐化。</li><li><strong>Insight Timer</strong>：提供海量免费内容与冥想教师社群，社区粘性强。</li><li><strong>国内如“潮汐”、“NOW冥想”</strong>：专注中文场景与文化适配。</li></ul></li><li><strong>Headspace 优势</strong>：<ul><li>心理专家背景扎实，科学与内容结合度高。</li><li>品牌定位清晰，在欧美市场渗透率极高。</li><li>产品矩阵广泛，从儿童、家庭到企业，覆盖全人群。</li></ul></li><li><strong>Headspace 劣势</strong>：<ul><li>国际化步伐缓慢，中文和东亚市场适配严重滞后。</li><li>使用门槛偏高，对冥想新手缺少短期激励机制。</li></ul></li></ul><h3 id="运营策略-16"><strong>运营策略</strong></h3><ol><li><strong>强化语言本地化</strong>：针对中国、日本、韩国市场推出母语冥想教练与文化适配内容。</li><li><strong>打造“心理健康节”IP</strong>：与学校、公司联合发起线上冥想节，扩大影响力。</li><li><strong>与Apple Watch/智能手环整合</strong>：基于HRV/心率波动实时推荐减压课程。</li><li><strong>扶持冥想KOL与播客主</strong>：鼓励内容共创，扩展“心智健康内容创作者生态”。</li></ol><h3 id="改进建议-16"><strong>改进建议</strong></h3><ol><li><strong>开发“短时冥想打卡”机制</strong>：提供3分钟以内快冥想内容，适配碎片场景。</li><li><strong>引入AI情绪检测工具</strong>：结合语音或情绪打卡数据推荐最适合的引导内容。</li><li><strong>加入社群与互动模块</strong>：让用户分享冥想心得或组织冥想挑战，增加留存。</li><li><strong>建立“冥想任务树”机制</strong>：为用户建立冥想成就路径图，持续激励练习。</li></ol><h3 id="总结-16"><strong>总结</strong></h3><p>Headspace 不只是一个冥想App，更是“现代人情绪基础设施”的原型。它将内观能力变成产品功能，把“放松”这件事做出了流量与商业的双赢范式。如果它能在全球实现更深本地化，未来完全有可能成为“全球心理韧性管理第一平台”。真正意义上的数字时代“情绪教练”。🧘‍♂️💡</p><hr><h2 id="Splitwise（全球多人账单分摊应用）">Splitwise（全球多人账单分摊应用）</h2><h3 id="产品概述-17"><strong>产品概述</strong></h3><p>Splitwise 是一款专为朋友、家庭、室友之间的“账单共享与费用分摊”而设计的应用，起源于美国。它帮助用户记录共同消费、自动计算应付款项、追踪欠款状况，是留学生、旅行团体、合租群体的“财务神器”。在全球年轻用户中广受欢迎。</p><h3 id="核心功能-17"><strong>核心功能</strong></h3><ol><li><strong>账单记录与分类</strong>：支持按人头/比例/定额等方式分摊各类费用（租金、水电、旅游、聚餐等）。</li><li><strong>多人群组管理</strong>：用户可创建不同账单群组，便于旅行、合租等多场景账务管理。</li><li><strong>实时同步与自动结算</strong>：记录自动同步云端，并计算总欠款与最简转账路径。</li><li><strong>跨币种与本地货币支持</strong>：支持多达100+币种，可适配全球用户旅行消费习惯。</li><li><strong>和支付工具集成</strong>：可与 PayPal、Venmo 等整合实现直接转账（地区视情况支持）。</li></ol><h3 id="用户体验评估-17"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>简单直观</strong>，上手极快，适合非财务背景用户。</li><li><strong>多种分摊模式</strong>，适应各种复杂账单情况。</li><li><strong>群组记录清晰透明</strong>，避免社交尴尬和“谁多出钱”的问题。</li><li><strong>自动提醒和月度结算机制降低沟通成本</strong>。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>付费版限制部分关键功能</strong>（如导出、优化结算路径等）。</li><li><strong>国内支付工具（如微信、支付宝）未能集成</strong>，影响本地使用流畅度。</li><li><strong>不支持语音/票据OCR导入</strong>，对习惯“拍发票”的用户不够友好。</li></ul></li></ul><h3 id="商业模式解释-17"><strong>商业模式解释</strong></h3><ol><li><strong>订阅制（Splitwise Pro）</strong>：提供高阶功能如导出、货币汇率历史、图片上传、高级报告等。</li><li><strong>B2B 合作场景（规划中）</strong>：如针对旅行社、合租平台提供 API 嵌入服务。</li><li><strong>潜在广告位</strong>：目前未投放，但账单上下游可引入品牌信用卡、分期服务等联动合作。</li></ol><h3 id="竞争分析-17"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>Settle Up</strong>：功能类似但界面老旧，用户体验较弱。</li><li><strong>Tricount</strong>：在欧洲用户中使用率较高，重视旅行分账场景。</li><li><strong>微信 AA 账单小程序（在中国）</strong>：轻量快捷但功能简单，缺乏多人长期管理能力。</li></ul></li><li><strong>Splitwise 优势</strong>：<ul><li>品牌认知度强，尤其在北美和印度市场。</li><li>群组机制成熟，适合持久账单关系（如室友、情侣、固定旅行团）。</li><li>多币种支持完整，适配全球留学生、国际旅行者使用习惯。</li></ul></li><li><strong>Splitwise 劣势</strong>：<ul><li>地区支付系统整合薄弱，结算过程需跳出APP。</li><li>缺乏数据图表呈现，用户很难从账务角度优化消费行为。</li></ul></li></ul><h3 id="运营策略-17"><strong>运营策略</strong></h3><ol><li><strong>拓展支付生态集成</strong>：在各国版本中集成本地主流支付方式（如UPI、支付宝、PIX等）。</li><li><strong>推出“情侣账本/家庭预算”模式</strong>：挖掘亲密关系财务协作场景，形成高频使用习惯。</li><li><strong>社区化推荐机制</strong>：设立“最常分账群组排行榜”，鼓励用户邀请亲友加入。</li><li><strong>联合旅行类产品</strong>：与Airbnb、Skyscanner等达成数据接口共享，自动生成行程账单草稿。</li></ol><h3 id="改进建议-17"><strong>改进建议</strong></h3><ol><li><strong>引入AI账单语义识别</strong>：支持语音识别和账单OCR上传，自动生成结构化分账建议。</li><li><strong>支持“月度结算提醒+一键转账”功能</strong>，提升结算率与回款效率。</li><li><strong>开发“账单故事模式”</strong>：结合位置、标签、图片等回顾聚会/旅行账单，提升内容温度。</li><li><strong>推出“账单习惯分析报告”</strong>：帮助用户审视消费分担、节约倾向，增强理财感知力。</li></ol><h3 id="总结-17"><strong>总结</strong></h3><p>Splitwise 就像财务界的“Notion for roommates”：不炫技，但好用到上头。它的厉害之处不是帮你管钱，而是让你“不再为钱尴尬”。未来，只要它能打通全球支付系统，把“分账”变成一种社交连接而非事务性动作，它就能成为“社交财务工具”的新物种范本。别忘了——“好的关系，从分账开始”。💸✨</p><hr><h2 id="Lensa-AI（AI头像生成与照片美化工具）">Lensa AI（AI头像生成与照片美化工具）</h2><h3 id="产品概述-18"><strong>产品概述</strong></h3><p>Lensa AI 是由 Prisma Labs 开发的一款图像处理应用，最早因“AI魔法头像”（Magic Avatars）功能爆红全球社交媒体。它利用 Stable Diffusion 和定制化图像模型生成独特的卡通风格头像，同时还提供美颜、滤镜、背景模糊等实用图像编辑工具，是近年来“生成式AI + 美图工具”融合的代表性产品之一。</p><h3 id="核心功能-18"><strong>核心功能</strong></h3><ol><li><strong>AI魔法头像生成</strong>：上传自拍后，通过AI建模生成几十种风格头像（如科幻、精灵、赛博朋克等）。</li><li><strong>一键美颜与磨皮</strong>：自动调整皮肤瑕疵、眼神光、脸部轮廓等，适合社交头像优化。</li><li><strong>图像背景编辑</strong>：实现背景虚化、替换、调色等功能，增强构图表现力。</li><li><strong>滤镜与风格调色</strong>：集成多种电影感、潮流感滤镜，快速美化照片。</li><li><strong>隐私控制与本地存储</strong>：处理过程用户可选择是否上传云端，强化数据安全性。</li></ol><h3 id="用户体验评估-18"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>用户界面极为简洁</strong>，操作路径直观，几乎零学习成本。</li><li><strong>输出图像质量极高</strong>，特别是AI头像部分具备“出圈”潜力。</li><li><strong>生成速度快</strong>，且效果多样，满足用户“发图即得赞”的即时满足感。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>免费额度极少</strong>，AI头像需付费打包生成，价格对部分用户略高。</li><li><strong>模型偶尔生成面部不对称或“AI混乱图”</strong>，且不可局部修改。</li><li><strong>长期留存能力弱</strong>，用户完成几次生成后容易卸载。</li></ul></li></ul><h3 id="商业模式解释-18"><strong>商业模式解释</strong></h3><ol><li><strong>一次性付费包（Magic Avatars）</strong>：用户需付费解锁特定数量风格头像包（通常为90~200张）。</li><li><strong>订阅会员</strong>：提供每月/年制订阅，解锁高级滤镜、无限修图、快速渲染等功能。</li><li><strong>企业合作授权</strong>：将 AI 生图能力授权给其他创意平台或内容生成方使用。</li><li><strong>社交平台联动曝光</strong>：引导用户分享生成结果至 TikTok、Instagram，获取病毒式流量。</li></ol><h3 id="竞争分析-18"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>Remini</strong>：主打照片高清修复，但缺乏个性风格生成。</li><li><strong>FaceApp</strong>：聚焦变老、换发型、性别转变等玩法，风格偏娱乐。</li><li><strong>Canva AI 图片模块</strong>：功能更全但专业偏设计方向，路径更长。</li></ul></li><li><strong>Lensa 优势</strong>：<ul><li>专注于“头像 + 风格生成”细分场景，快速打爆单点体验。</li><li>品牌美学统一，视觉风格现代，适合Z世代分享文化。</li></ul></li><li><strong>Lensa 劣势</strong>：<ul><li>容易陷入“玩一次就走”的内容消费型应用模式。</li><li>盈利模式过度依赖单次爆款，抗风险能力弱于平台型产品。</li></ul></li></ul><h3 id="运营策略-18"><strong>运营策略</strong></h3><ol><li><strong>打造“头像挑战”活动</strong>：结合社交平台趋势打造“年度最像AI我”、“赛博穿越”等互动话题。</li><li><strong>推出“生成故事片段”功能</strong>：通过多图+剧情配音生成小短剧形式，拓展娱乐属性。</li><li><strong>进军虚拟社交应用/元宇宙平台</strong>：打通 AI 头像至虚拟形象、直播形象的跨平台使用。</li><li><strong>开放插件SDK</strong>：嵌入 TikTok、Snapchat 等短视频平台实现“边拍边AI化”功能。</li></ol><h3 id="改进建议-18"><strong>改进建议</strong></h3><ol><li><strong>开发“人像AI微调”功能</strong>：允许用户对生成头像进行局部编辑，如修改发色、眼睛大小。</li><li><strong>引入个性偏好学习模型</strong>：用户标注喜欢的生成图后，AI 可按喜好调整输出风格。</li><li><strong>构建创作者社区</strong>：鼓励用户投稿最酷头像生成结果，逐步形成内容UGC循环。</li><li><strong>增加“图+文一体生成”</strong>：允许用户输入情境描述（如“宇宙猎人”），提升参与感与沉浸感。</li></ol><h3 id="总结-18"><strong>总结</strong></h3><p>Lensa AI 是AIGC“现象级单点应用”的缩影，它证明了：当AI创意遇上社交传播，哪怕只是一个头像，也能让人心甘情愿为“数字分身”买单。下一步，Lensa若能跳出“滤镜生意”的小天花板，进入“虚拟身份 + 可生成内容 + 个性表现”的组合场景，它可能就是全球最酷的“数字形象制造厂”。👩‍🎤🧠✨</p><hr><h2 id="Yubo（全球青少年社交直播平台）">Yubo（全球青少年社交直播平台）</h2><h3 id="产品概述-19"><strong>产品概述</strong></h3><p>Yubo 是一款面向青少年的全球社交直播应用，源自法国，定位为“下一代Z世代的数字朋友制造机”。与传统的图文社交不同，Yubo 主打实时视频群聊和兴趣标签匹配，鼓励年轻人在安全可控的环境下结识新朋友。它不是“刷脸交友”，更像是“数字校园聚会”，受到欧美及东南亚年轻用户的广泛欢迎。</p><h3 id="核心功能-19"><strong>核心功能</strong></h3><ol><li><strong>实时视频直播（Live）</strong>：最多可同时9人参与视频房间，用户可以围观、发言、互动。</li><li><strong>滑动交友机制（Swipe）</strong>：类似 Tinder 的右滑匹配，但用于寻找聊天或加入兴趣群组。</li><li><strong>兴趣标签与探索页</strong>：用户可通过兴趣进行匹配，系统推荐志同道合的人或房间。</li><li><strong>群组聊天室</strong>：基于兴趣、地区等主题的公共房间，适合找“同好圈子”。</li><li><strong>身份验证与内容审核</strong>：通过AI识别与自拍对比进行年龄验证，辅以内容安全管理。</li></ol><h3 id="用户体验评估-19"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>直播+群聊结构轻松</strong>，互动即时感强，沉浸感高。</li><li><strong>UI 设计色彩明快</strong>，极具年轻化风格，贴合Z世代审美。</li><li><strong>对用户身份和内容审核流程相对完善</strong>，减少“老年人混圈”现象。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>免费用户权限有限</strong>，功能解锁需升级VIP，付费点位略突兀。</li><li><strong>部分直播房间内容质量低</strong>，存在无效陪聊与低俗倾向。</li><li><strong>对国内用户不友好</strong>，未进入本地化运营，使用需 🪜。</li></ul></li></ul><h3 id="商业模式解释-19"><strong>商业模式解释</strong></h3><ol><li><strong>订阅会员（Yubo Power Pack）</strong>：解锁更多Swipe次数、显示谁看过你、提升曝光。</li><li><strong>虚拟道具与付费礼物系统</strong>：直播互动时可打赏送礼，形成主播变现模型。</li><li><strong>广告测试阶段</strong>：早期探索中，但仍以用户付费为主要盈利来源。</li><li><strong>数据与行为洞察（B2B潜能）</strong>：未来可能输出青少年社交偏好分析供品牌合作。</li></ol><h3 id="竞争分析-19"><strong>竞争分析</strong></h3><ul><li><strong>直接竞争者</strong>：<ul><li><strong>Snapchat</strong>：也是Z世代社交圣地，但核心在熟人+相机滤镜+快照。</li><li><strong>Twitch（青少年版直播）</strong>：偏游戏直播，社交互动次之。</li></ul></li><li><strong>间接竞争者</strong>：<ul><li><strong>Discord</strong>：构建深度社区关系，但偏向话题/游戏垂类。</li><li><strong>Instagram Threads</strong>：尝试构建“亲密社交圈”，但互动频率不如Yubo。</li></ul></li><li><strong>Yubo 优势</strong>：<ul><li>社交直播融合极佳，轻量又及时，满足孤独感+社交欲望双需求。</li><li>用户群体集中，避免代际冲突，社区氛围轻松友好。</li></ul></li><li><strong>Yubo 劣势</strong>：<ul><li>缺乏强内容创造机制，不具备TikTok式内容引擎。</li><li>安全与监管压力大，需投入大量资源维护社区秩序。</li></ul></li></ul><h3 id="运营策略-19"><strong>运营策略</strong></h3><ol><li><strong>Z世代社群建设者计划</strong>：选拔校园KOL担任房主，强化房间内容质量与氛围。</li><li><strong>与青少年心理健康组织合作</strong>：树立“正向社交”品牌形象。</li><li><strong>AI内容协管系统优化</strong>：利用AI自动识别敏感行为和潜在风险交互，提升信任感。</li><li><strong>进军南美、东南亚二线市场</strong>：通过本地化挑战和明星直播迅速扩圈。</li></ol><h3 id="改进建议-19"><strong>改进建议</strong></h3><ol><li><strong>推出“话题盲盒房”功能</strong>：用户可随机进入基于兴趣话题的直播讨论房，提升内容深度。</li><li><strong>引入AI虚拟社交角色</strong>：为社恐用户提供“暖场机器人”，降低进入门槛。</li><li><strong>设置“内容时光机”机制</strong>：直播可剪辑为短片并自动生成回顾故事，强化沉淀与传播力。</li><li><strong>开放“青少年社群运营工具箱”</strong>：让房主或KOC具备招募、管理、数据查看等轻后台能力。</li></ol><h3 id="总结-19"><strong>总结</strong></h3><p>Yubo 是“不是为打工人，而是为15岁社恐少年”设计的社交平台。它用轻直播替代重算法，用兴趣匹配对抗短视频焦虑。如果说Instagram是精致展示的剧场，那Yubo就是青春社交的练习场。下一步只要能用AI增强安全，用内容策划撑起深度，它就不只是“Z世代聊天室”，而是“下一代社交原型工厂”。🎥👯‍♂️🌐</p><hr><h2 id="Obsidian（全球-Markdown-知识管理工具）">Obsidian（全球 Markdown 知识管理工具）</h2><h3 id="产品概述-20"><strong>产品概述</strong></h3><p>Obsidian 是一款面向高阶知识工作者的本地 Markdown 笔记工具，主打“链接你的思维（Linking your thinking）”理念。它不像 Notion 那样在线协作，也不像 Evernote 那样做富文本收集，而是鼓励用户用纯文本文件构建“第二大脑”——一个非线性、可视化的知识图谱系统。特别适合科研人员、程序员、作家与信息整理癖。</p><h3 id="核心功能-20"><strong>核心功能</strong></h3><ol><li><strong>Markdown 文档编辑器</strong>：本地存储 + Markdown 标准语法，速度快、安全性高。</li><li><strong>双向链接 + Graph View</strong>：自动建立文档之间的“超链接”，形成知识网络图谱。</li><li><strong>插件系统开放</strong>：支持社区开发上百种插件，如日记、任务管理、GPT助手等。</li><li><strong>主题与自定义 CSS</strong>：高度可定制 UI，极客风用户可打造完全私有化体验。</li><li><strong>本地化数据管理</strong>：所有数据本地存储，可同步至 iCloud/Dropbox，确保掌控权。</li></ol><h3 id="用户体验评估-20"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>“写作即知识建模”</strong>，可视化双链图带来思维组织上的飞跃。</li><li><strong>离线使用</strong>，无广告、无干扰，极适合深度思考型用户。</li><li><strong>插件极为强大</strong>，可变身为任务系统、博客引擎、卡片盒系统等多种形态。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>上手门槛高</strong>，非技术用户初期会迷失在“文档之间”。</li><li><strong>移动端体验一般</strong>，输入效率低于桌面端。</li><li><strong>UI 对新手略显“冷感”</strong>，缺乏引导教程与内容范式。</li></ul></li></ul><h3 id="商业模式解释-20"><strong>商业模式解释</strong></h3><ol><li><strong>免费核心功能</strong>：基础编辑、双链图谱完全免费，无强制订阅。</li><li><strong>个人同步服务（Obsidian Sync）</strong>：提供加密云同步功能，月付/年付订阅。</li><li><strong>团队协作（Obsidian Publish）</strong>：将笔记发布为知识库网站，用于公司/博客/教程输出。</li><li><strong>一次性捐赠“Catalyst License”</strong>：用于支持开发并解锁高级测试功能。</li></ol><h3 id="竞争分析-20"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争者</strong>：<ul><li><strong>Notion</strong>：在线协作能力极强，但结构复杂、速度慢、数据非本地。</li><li><strong>Logseq</strong>：同为 Markdown + 双链结构，但更强调“卡片盒”式学习路径。</li><li><strong>Roam Research</strong>：理念更前卫，但付费昂贵、发展缓慢。</li></ul></li><li><strong>Obsidian 优势</strong>：<ul><li>离线本地 + 插件生态 = 极高的自由度与安全性。</li><li>对高阶用户极具粘性，是信息密集型职业的生产力核心工具。</li></ul></li><li><strong>Obsidian 劣势</strong>：<ul><li>入门难、生态不统一、不适合多人实时协作场景。</li><li>商业化路径依赖社区支持和边缘服务，不够可持续。</li></ul></li></ul><h3 id="运营策略-20"><strong>运营策略</strong></h3><ol><li><strong>打造“入门路径模板库”</strong>：围绕科研、写作、程序文档等构建场景预设，降低学习成本。</li><li><strong>联合硬件厂商（如 Remarkable、iPad Pro）打造深度写作工具包</strong>，推进软硬协同。</li><li><strong>支持 GPT 插件深度集成</strong>：通过语义索引/总结笔记/自动链接提升智能组织能力。</li><li><strong>推出 Obsidian 社区大学计划</strong>：扶持笔记教育者、视频博主，构建内容学习生态。</li></ol><h3 id="改进建议-20"><strong>改进建议</strong></h3><ol><li><strong>新增“智能引导模式”</strong>：首次启动时自动构建知识架构模板，帮助用户建立知识树。</li><li><strong>移动端输入体验优化</strong>：新增悬浮菜单、语音转录等输入方式。</li><li><strong>社区插件统一评级机制</strong>：为插件打标签和评分，降低用户试错成本。</li><li><strong>知识“复习+重组”机制</strong>：结合间隔重复与主题聚合功能，增强笔记再利用价值。</li></ol><h3 id="总结-20"><strong>总结</strong></h3><p>Obsidian 是不是最酷的笔记工具？不是——它是“最自由的思维锻炼器”。它更像是数字时代的莱布尼茨笔记法重构，是给“脑力生产者”的特种装备。如果 Notion 是知识宫殿，那 Obsidian 就是一个知识密林：没有规则，但你能走出自己的路。对于真正想“把脑子外包给文件夹”的人来说，Obsidian 是不二之选。🧠📎🕸️</p><hr>]]></content>
    
    
    <summary type="html">互联网产品分析笔记(三)</summary>
    
    
    
    <category term="产品分析" scheme="https://www.angfff.top/categories/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="互联网产品" scheme="https://www.angfff.top/tags/%E4%BA%92%E8%81%94%E7%BD%91%E4%BA%A7%E5%93%81/"/>
    
    <category term="产品分析" scheme="https://www.angfff.top/tags/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"/>
    
    <category term="PM" scheme="https://www.angfff.top/tags/PM/"/>
    
  </entry>
  
  <entry>
    <title>CPP-学习笔记(二)</title>
    <link href="https://www.angfff.top/posts/fc7ecaba.html"/>
    <id>https://www.angfff.top/posts/fc7ecaba.html</id>
    <published>2025-03-13T07:18:08.000Z</published>
    <updated>2025-05-22T04:31:09.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="遍历对象">遍历对象</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> &amp;a : A)&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C++ 中， 这种范围 for 循环适用于符合以下条件的对象 A：</p><h3 id="A-是一个标准容器或具有-begin-和-end-方法的对象">A 是一个标准容器或具有 begin() 和 end() 方法的对象</h3><p>如果 A 是一个 <strong>STL 容器</strong>（如 std::vector, std::list, std::map 等），或者是自定义类型但提供了 begin() 和 end() 方法，那么可以直接使用范围 for 循环：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; A = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : A) &#123;  <span class="comment">// 遍历 vector</span></span><br><span class="line">        std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 等效于:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = A.<span class="built_in">begin</span>(); it != A.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">auto</span> &amp;a = *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-是一个普通数组">A 是一个普通数组</h3><p>C++11 开始，范围 for 也支持 <strong>C-style 数组</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : A) &#123;  </span><br><span class="line">    std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-是一个自定义类，但必须实现-begin-和-end">A 是一个自定义类，但必须实现 begin() 和 end()</h3><p>如果 A 是一个 <strong>自定义类</strong>，必须提供 begin() 和 end() 方法，且返回的是可迭代对象（通常是迭代器）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data.<span class="built_in">begin</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> data.<span class="built_in">end</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;a : A) &#123;  <span class="comment">// 依赖自定义的 begin() 和 end()</span></span><br><span class="line">        std::cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="A-不是一个指针">A 不是一个指针</h3><p>如果 A 是一个指针，则不能直接用于 for(auto &amp;a : A)，因为指针本身并不是一个可迭代对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* A = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ❌ 错误，不能对指针使用 range-for</span></span><br><span class="line"><span class="comment">// for (auto &amp;a : A) &#123; std::cout &lt;&lt; a &lt;&lt; &quot; &quot;; &#125;</span></span><br></pre></td></tr></table></figure><p>但可以这样遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; A[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] A;</span><br></pre></td></tr></table></figure><blockquote><p><strong>总结</strong><br><strong>可以使用 for(auto &amp;a : A){} 的情况</strong>：<br>• A 是 <strong>STL 容器</strong>（如 vector，list，map 等）<br>• A 是 <strong>普通数组</strong><br>• A 是 <strong>实现了 begin() 和 end() 的自定义类</strong><br><strong>不能直接使用的情况</strong>：<br>• A 是 <strong>指针</strong>（但可以使用普通 for 循环）<br>• A 没有 begin() 和 end() 方法（如 POD 结构体）</p></blockquote><hr><h2 id="容器插入对象">容器插入对象</h2><h3 id="顺序容器（如-vector、deque、list）">顺序容器（如 <code>vector</code>、<code>deque</code>、<code>list</code>）</h3><ul><li><strong><code>push_back(value)</code></strong>：在容器尾部添加元素（适用于 <code>vector</code>、<code>deque</code>、<code>list</code>）。</li><li><strong><code>push_front(value)</code></strong>：在容器头部添加元素（适用于 <code>deque</code>、<code>list</code>）。</li><li><strong><code>insert(pos, value)</code></strong>：在指定迭代器 <code>pos</code> 位置插入元素（适用于 <code>vector</code>、<code>deque</code>、<code>list</code>）。</li><li><strong><code>emplace_back(value)</code></strong>：在尾部原地构造元素，避免不必要的拷贝（适用于 <code>vector</code>、<code>deque</code>）。</li><li><strong><code>emplace(pos, value)</code></strong>：在指定位置原地构造元素（适用于 <code>vector</code>、<code>deque</code>、<code>list</code>）。</li></ul><h3 id="关联容器（如-unordered-map、unordered-set、map、set）">关联容器（如 <code>unordered_map</code>、<code>unordered_set</code>、<code>map</code>、<code>set</code>）</h3><ul><li><strong><code>insert(value)</code></strong>：插入元素，若键已存在（对于 <code>map</code> 和 <code>set</code>），则不会覆盖原值。</li><li><strong><code>emplace(value)</code></strong>：类似 <code>insert()</code>，但直接在容器内部构造对象，避免额外拷贝。</li><li><strong><code>operator[]</code>（适用于 <code>map</code> 和 <code>unordered_map</code>）</strong>：<ul><li><code>M[key] = value;</code>：如果 <code>key</code> 存在，则更新值；如果 <code>key</code> 不存在，则创建新键并赋值。</li><li><code>M[key].push_back(value);</code>：适用于 <code>unordered_map&lt;int, vector&lt;int&gt;&gt;</code> 这种情况，直接向 <code>vector</code> 追加元素。</li></ul></li></ul><h3 id="适用于-unordered-map-int-vector-int-M-的插入方法">适用于 <code>unordered_map&lt;int, vector&lt;int&gt;&gt; M</code> 的插入方法</h3><table><thead><tr><th><strong>情况</strong></th><th><strong>方法</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td>插入新的 key-value 对</td><td><code>M.insert(&#123;key, &#123;value&#125;&#125;);</code></td><td><code>key</code> 不存在时插入</td></tr><tr><td>直接赋值</td><td><code>M[key] = &#123;value&#125;;</code></td><td>创建新 <code>key</code> 或覆盖旧值</td></tr><tr><td>向 <code>vector</code> 追加元素</td><td><code>M[key].push_back(value);</code></td><td><code>key</code> 存在时向 <code>vector</code> 追加</td></tr></tbody></table><hr><h2 id="容器中查找元素">容器中查找元素</h2><h3 id="顺序容器（如-vector、deque、list）-2"><strong>顺序容器（如 <code>vector</code>、<code>deque</code>、<code>list</code>）</strong></h3><p><strong><code>std::find</code></strong> 用于查找顺序容器中是否存在某个元素，返回一个迭代器：</p><ul><li>如果找到元素，返回指向该元素的迭代器。</li><li>如果没有找到，返回 <code>end()</code> 迭代器。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  <span class="comment">// std::find</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = std::<span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (it != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Found: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Not Found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关联容器（如-set、map、unordered-map、unordered-set）"><strong>关联容器（如 <code>set</code>、<code>map</code>、<code>unordered_map</code>、<code>unordered_set</code>）</strong></h3><ol><li><strong><code>find()</code></strong> 用于查找元素并返回指向该元素的迭代器。如果元素不存在，返回容器的 <code>end()</code> 迭代器<ul><li>在 <code>unordered_map</code> 或 <code>unordered_set</code> 中，<code>find()</code> 是基于哈希查找的，平均时间复杂度为 O(1)。</li><li>在 <code>map</code> 或 <code>set</code> 中，<code>find()</code> 是基于红黑树的，平均时间复杂度为 O(log n)。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::set&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it = s.<span class="built_in">find</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span> (it != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Found: &quot;</span> &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Not Found&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong><code>count()</code></strong> 用于检查容器中是否存在指定元素。它返回元素的个数（对于 <code>set</code> 和 <code>unordered_set</code>，最大值是 1，因为元素唯一；对于 <code>map</code> 和 <code>unordered_map</code>，返回的是键值对的个数）：<ul><li>对于 <code>unordered_map</code> 和 <code>unordered_set</code>，<code>count()</code> 的平均时间复杂度为 O(1)。</li><li>对于 <code>map</code> 和 <code>set</code>，<code>count()</code> 的时间复杂度为 O(log n)。</li></ul></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;<span class="type">int</span>, std::string&gt; m = &#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;two&quot;</span>&#125;&#125;;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Count of key 1: &quot;</span> &lt;&lt; m.<span class="built_in">count</span>(<span class="number">1</span>) &lt;&lt; std::endl;  <span class="comment">// 输出 1</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Count of key 3: &quot;</span> &lt;&lt; m.<span class="built_in">count</span>(<span class="number">3</span>) &lt;&lt; std::endl;  <span class="comment">// 输出 0</span></span><br></pre></td></tr></table></figure><h3 id="特定查找方法"><strong>特定查找方法</strong></h3><ul><li><strong><code>operator[]</code>（<code>map</code> 和 <code>unordered_map</code>）</strong><br>用于通过键直接访问元素。如果键不存在，会插入一个默认构造的元素（<code>map</code> 和 <code>unordered_map</code> 特有）：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::unordered_map&lt;<span class="type">int</span>, std::string&gt; umap;</span><br><span class="line">umap[<span class="number">1</span>] = <span class="string">&quot;one&quot;</span>;  <span class="comment">// 直接插入元素</span></span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Value for key 1: &quot;</span> &lt;&lt; umap[<span class="number">1</span>] &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><blockquote><p>注意，<code>operator[]</code> 不会告诉你元素是否存在，它直接返回对应的值。</p></blockquote><hr><h2 id="Lambda-表达式">Lambda 表达式</h2><h3 id="基本语法">基本语法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture-list](parameters) -&gt; return_type &#123; body &#125;</span><br></pre></td></tr></table></figure><p>各部分解释：</p><ul><li><strong>capture-list</strong>：捕获外部变量的列表</li><li><strong>parameters</strong>：参数列表（可选）</li><li><strong>return_type</strong>：返回类型（可选，通常由编译器推导）</li><li><strong>body</strong>：函数体</li></ul><h3 id="捕获列表的不同形式">捕获列表的不同形式</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[]        <span class="comment">// 不捕获任何外部变量</span></span><br><span class="line">[=]       <span class="comment">// 以值方式捕获所有外部变量</span></span><br><span class="line">[&amp;]       <span class="comment">// 以引用方式捕获所有外部变量</span></span><br><span class="line">[x, &amp;y]   <span class="comment">// 以值方式捕获x，以引用方式捕获y</span></span><br><span class="line">[=, &amp;x]   <span class="comment">// 以值方式捕获所有外部变量，但x以引用方式捕获</span></span><br><span class="line">[&amp;, x]    <span class="comment">// 以引用方式捕获所有外部变量，但x以值方式捕获</span></span><br><span class="line">[<span class="keyword">this</span>]    <span class="comment">// 捕获this指针</span></span><br><span class="line">[*<span class="keyword">this</span>]   <span class="comment">// 捕获当前对象的副本(C++17)</span></span><br></pre></td></tr></table></figure><h3 id="常见用法示例">常见用法示例</h3><h4 id="简单的Lambda函数">简单的Lambda函数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> add = [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// sum = 7</span></span><br></pre></td></tr></table></figure><h4 id="捕获外部变量">捕获外部变量</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> multiplier = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> multiply = [multiplier](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * multiplier; &#125;;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">multiply</span>(<span class="number">5</span>);  <span class="comment">// result = 50</span></span><br></pre></td></tr></table></figure><h4 id="修改捕获的值（使用mutable）">修改捕获的值（使用mutable）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> increment = [counter]() <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> ++counter; &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">increment</span>();  <span class="comment">// 输出1</span></span><br><span class="line">cout &lt;&lt; counter;      <span class="comment">// 输出0（原始counter不变）</span></span><br></pre></td></tr></table></figure><h4 id="捕获引用">捕获引用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> increment = [&amp;counter]() &#123; <span class="keyword">return</span> ++counter; &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">increment</span>();  <span class="comment">// 输出1</span></span><br><span class="line">cout &lt;&lt; counter;      <span class="comment">// 输出1（原始counter改变）</span></span><br></pre></td></tr></table></figure><h4 id="指定返回类型">指定返回类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> divide = [](<span class="type">double</span> a, <span class="type">double</span> b) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> a / b; &#125;;</span><br></pre></td></tr></table></figure><h3 id="进阶用法示例">进阶用法示例</h3><h4 id="Lambda作为函数参数">Lambda作为函数参数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将lambda作为算法参数</span></span><br><span class="line"><span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> a, <span class="type">int</span> b) &#123; <span class="keyword">return</span> a &gt; b; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用lambda进行条件筛选</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">find_if</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x &gt; <span class="number">3</span>; &#125;);</span><br></pre></td></tr></table></figure><h4 id="泛型Lambda（C-14及以后）">泛型Lambda（C++14及以后）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++14泛型lambda</span></span><br><span class="line"><span class="keyword">auto</span> add = [](<span class="keyword">auto</span> a, <span class="keyword">auto</span> b) &#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"><span class="type">int</span> sum1 = <span class="built_in">add</span>(<span class="number">3</span>, <span class="number">4</span>);       <span class="comment">// 整数加法</span></span><br><span class="line">string sum2 = <span class="built_in">add</span>(<span class="built_in">string</span>(<span class="string">&quot;Hello, &quot;</span>), <span class="built_in">string</span>(<span class="string">&quot;World&quot;</span>));  <span class="comment">// 字符串连接</span></span><br></pre></td></tr></table></figure><h4 id="Lambda自引用（C-20及以后）">Lambda自引用（C++20及以后）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++20自引用lambda</span></span><br><span class="line"><span class="keyword">auto</span> factorial = [](<span class="keyword">this</span> <span class="keyword">auto</span>&amp;&amp; self, <span class="type">int</span> n) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n * <span class="built_in">self</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">factorial</span>(<span class="number">5</span>);  <span class="comment">// 计算5! = 120</span></span><br></pre></td></tr></table></figure><p>语法解释：</p><ul><li><code>this auto&amp;&amp; self</code>：声明lambda自身的参数</li><li>使用<code>self</code>调用lambda本身，实现递归</li></ul><h4 id="Lambda模板（C-20）">Lambda模板（C++20）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> print = []&lt;<span class="keyword">typename</span> T&gt;(vector&lt;T&gt; <span class="type">const</span>&amp; v) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> <span class="type">const</span>&amp; element : v)</span><br><span class="line">        cout &lt;&lt; element &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Lambda与STL结合使用">Lambda与STL结合使用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// transform使用lambda</span></span><br><span class="line"><span class="built_in">transform</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), v.<span class="built_in">begin</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x * x; &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义accumulate</span></span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">accumulate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">0</span>, </span><br><span class="line">                    [](<span class="type">int</span> total, <span class="type">int</span> current) &#123; <span class="keyword">return</span> total + current * <span class="number">2</span>; &#125;);</span><br></pre></td></tr></table></figure><h4 id="捕获初始化（C-14）">捕获初始化（C++14）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> generator = [counter = <span class="number">0</span>]() <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> ++counter; &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">generator</span>();  <span class="comment">// 1</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">generator</span>();  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><h4 id="C-Lambda表达式语法总结表">C++ Lambda表达式语法总结表</h4><table><thead><tr><th>语法特性</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td><strong>基本语法</strong></td><td><code>[](int x) &#123; return x*x; &#125;</code></td><td>最简单的lambda表达式定义</td></tr><tr><td><strong>值捕获</strong></td><td><code>[x](int y) &#123; return x+y; &#125;</code></td><td>以值方式捕获变量x</td></tr><tr><td><strong>引用捕获</strong></td><td><code>[&amp;x](int y) &#123; x += y; &#125;</code></td><td>以引用方式捕获变量x</td></tr><tr><td><strong>隐式值捕获</strong></td><td><code>[=](int y) &#123; return val+y; &#125;</code></td><td>以值方式捕获所有使用的外部变量</td></tr><tr><td><strong>隐式引用捕获</strong></td><td><code>[&amp;](int y) &#123; val += y; &#125;</code></td><td>以引用方式捕获所有使用的外部变量</td></tr><tr><td><strong>混合捕获</strong></td><td><code>[=, &amp;x](int y) &#123; x = val+y; &#125;</code></td><td>默认值捕获，x以引用方式捕获</td></tr><tr><td><strong>this捕获</strong></td><td><code>[this]()&#123; this-&gt;value++; &#125;</code></td><td>捕获当前对象的this指针</td></tr><tr><td><strong>mutable关键字</strong></td><td><code>[x](int y) mutable &#123; x++; &#125;</code></td><td>允许修改值捕获的变量</td></tr><tr><td><strong>返回类型</strong></td><td><code>[](int x) -&gt; double &#123; return x/2.0; &#125;</code></td><td>明确指定返回类型</td></tr><tr><td><strong>泛型参数</strong></td><td><code>[](auto x) &#123; return x*x; &#125;</code></td><td>使用auto实现泛型lambda</td></tr><tr><td><strong>捕获初始化</strong></td><td><code>[sum = 0](int x) mutable &#123; return sum += x; &#125;</code></td><td>在捕获列表中初始化变量</td></tr><tr><td><strong>lambda模板</strong></td><td><code>[]&lt;typename T&gt;(T x) &#123; return x; &#125;</code></td><td>将lambda定义为模板</td></tr><tr><td><strong>lambda自引用</strong></td><td><code>[](this auto&amp;&amp; self, int n) &#123; return n &gt; 0 ? n * self(n-1) : 1; &#125;</code></td><td>lambda递归调用自身</td></tr><tr><td><strong>捕获*this</strong></td><td><code>[*this]() &#123; value++; &#125;</code></td><td>捕获当前对象的副本</td></tr><tr><td><strong>捕获结构化绑定</strong></td><td><code>auto [a, b] = p; [a, b]() &#123; return a+b; &#125;</code></td><td>捕获结构化绑定变量</td></tr></tbody></table><h4 id="常见应用场景">常见应用场景</h4><table><thead><tr><th>应用场景</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td><strong>STL算法</strong></td><td><code>sort(v.begin(), v.end(), [](int a, int b) &#123; return a &gt; b; &#125;);</code></td><td>自定义排序规则</td></tr><tr><td><strong>条件筛选</strong></td><td><code>auto it = find_if(v.begin(), v.end(), [](int x) &#123; return x &gt; 10; &#125;);</code></td><td>查找符合条件的元素</td></tr><tr><td><strong>转换操作</strong></td><td><code>transform(v1.begin(), v1.end(), v2.begin(), [](int x) &#123; return x*x; &#125;);</code></td><td>将元素进行转换</td></tr><tr><td><strong>事件处理</strong></td><td><code>button.onClick([&amp;](auto e) &#123; handleClick(); &#125;);</code></td><td>UI事件回调</td></tr><tr><td><strong>线程/异步</strong></td><td><code>std::thread t([&amp;]() &#123; processData(); &#125;);</code></td><td>线程函数</td></tr><tr><td><strong>递归算法</strong></td><td><code>std::function&lt;int(int)&gt; fib = [&amp;fib](int n) &#123; return n &lt;= 1 ? n : fib(n-1) + fib(n-2); &#125;;</code></td><td>使用std::function实现递归</td></tr><tr><td><strong>IIFE</strong></td><td><code>[]()&#123; setup(); return getValue(); &#125;()</code></td><td>立即调用的lambda表达式</td></tr></tbody></table><hr>]]></content>
    
    
    <summary type="html">C++ 高级特性</summary>
    
    
    
    <category term="开发" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="CPP" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/CPP/"/>
    
    
    <category term="开发" scheme="https://www.angfff.top/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="CPP" scheme="https://www.angfff.top/tags/CPP/"/>
    
    <category term="C++" scheme="https://www.angfff.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>CPP-学习笔记(一)</title>
    <link href="https://www.angfff.top/posts/534f51d8.html"/>
    <id>https://www.angfff.top/posts/534f51d8.html</id>
    <published>2025-03-13T07:14:29.000Z</published>
    <updated>2025-05-22T04:31:09.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-基本数据结构">C++ 基本数据结构</h2><p><a href="https://labuladong.online/algo/programming-language-basic/cpp/">C++ 基本数据结构</a></p><h3 id="动态数组-vector">动态数组 vector</h3><h4 id="初始化">初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n = <span class="number">7</span>, m = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个 int 型的空数组 nums</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个大小为 n 的数组 nums，数组中的值默认都为 0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个元素为 1, 3, 5 的数组 nums</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; nums&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个大小为 n 的数组 nums，其值全都为 2</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n, <span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个二维 int 数组 dp</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个大小为 m * n 的布尔数组 dp，</span></span><br><span class="line"><span class="comment">// 其中的值都初始化为 true</span></span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n, <span class="literal">true</span>));</span><br></pre></td></tr></table></figure><h4 id="常用操作">常用操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// 数组大小为 10，元素值都为 0</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="comment">// 输出 0 (false)</span></span><br><span class="line">    cout &lt;&lt; nums.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 输出：10</span></span><br><span class="line">    cout &lt;&lt; nums.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在数组尾部插入一个元素 20</span></span><br><span class="line">    nums.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 输出：11</span></span><br><span class="line">    cout &lt;&lt; nums.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到数组最后一个元素的引用</span></span><br><span class="line">    <span class="comment">// 输出：20</span></span><br><span class="line">    cout &lt;&lt; nums.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除数组的最后一个元素（无返回值）</span></span><br><span class="line">    nums.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="comment">// 输出：10</span></span><br><span class="line">    cout &lt;&lt; nums.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以通过方括号直接取值或修改</span></span><br><span class="line">    nums[<span class="number">0</span>] = <span class="number">11</span>;</span><br><span class="line">    <span class="comment">// 输出：11</span></span><br><span class="line">    cout &lt;&lt; nums[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在索引 3 处插入一个元素 99</span></span><br><span class="line">    nums.<span class="built_in">insert</span>(nums.<span class="built_in">begin</span>() + <span class="number">3</span>, <span class="number">99</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除索引 2 处的元素</span></span><br><span class="line">    nums.<span class="built_in">erase</span>(nums.<span class="built_in">begin</span>() + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换 nums[0] 和 nums[1]</span></span><br><span class="line">    <span class="built_in">swap</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组</span></span><br><span class="line">    <span class="comment">// 0 11 99 0 0 0 0 0 0 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链表-list">双链表 list</h3><h4 id="初始化-2">初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个空的双向链表 lst</span></span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; lst;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个大小为 n 的链表 lst，链表中的值默认都为 0</span></span><br><span class="line"><span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">lst</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个包含元素 1, 3, 5 的链表 lst</span></span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; lst&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个大小为 n 的链表 lst，其中值都为 2</span></span><br><span class="line"><span class="function">std::list&lt;<span class="type">int</span>&gt; <span class="title">lst</span><span class="params">(n, <span class="number">2</span>)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="常用操作-2">常用操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化链表</span></span><br><span class="line">    list&lt;<span class="type">int</span>&gt; lst&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查链表是否为空，输出：false</span></span><br><span class="line">    cout &lt;&lt; lst.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取链表的大小，输出：5</span></span><br><span class="line">    cout &lt;&lt; lst.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表头部插入元素 0</span></span><br><span class="line">    lst.<span class="built_in">push_front</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 在链表尾部插入元素 6</span></span><br><span class="line">    lst.<span class="built_in">push_back</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取链表头部和尾部元素，输出：0 6</span></span><br><span class="line">    cout &lt;&lt; lst.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; lst.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除链表头部元素</span></span><br><span class="line">    lst.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="comment">// 删除链表尾部元素</span></span><br><span class="line">    lst.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在链表中插入元素</span></span><br><span class="line">    <span class="keyword">auto</span> it = lst.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// 移动到第三个位置</span></span><br><span class="line">    <span class="built_in">advance</span>(it, <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 在第三个位置插入 99</span></span><br><span class="line">    lst.<span class="built_in">insert</span>(it, <span class="number">99</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除链表中某个元素</span></span><br><span class="line">    it = lst.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="comment">// 移动到第二个位置</span></span><br><span class="line">    <span class="built_in">advance</span>(it, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 删除第二个位置的元素</span></span><br><span class="line">    lst.<span class="built_in">erase</span>(it);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="comment">// 输出：1 99 3 4 5</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : lst) &#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列-queue">队列 queue</h3><h4 id="初始化-3">初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化一个空的整型队列 q</span></span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在队尾添加元素</span></span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查队列是否为空，输出：false</span></span><br><span class="line">    cout &lt;&lt; q.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列的大小，输出：3</span></span><br><span class="line">    cout &lt;&lt; q.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取队列的队头和队尾元素，输出：10 和 30</span></span><br><span class="line">    cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q.<span class="built_in">back</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除队头元素</span></span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出新的队头元素：20</span></span><br><span class="line">    cout &lt;&lt; q.<span class="built_in">front</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈-stack">栈 stack</h3><h4 id="初始化-4">初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个空的整型栈 s</span></span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向栈顶添加元素</span></span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">10</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">20</span>);</span><br><span class="line">    s.<span class="built_in">push</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查栈是否为空，输出：false</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈的大小，输出：3</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取栈顶元素，输出：30</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除栈顶元素</span></span><br><span class="line">    s.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出新的栈顶元素：20</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">top</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希表-unordered-map">哈希表 unordered_map</h3><h4 id="初始化-5">初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个空的哈希表 map</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, string&gt; hashmap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个包含一些键值对的哈希表 map</span></span><br><span class="line">unordered_map&lt;<span class="type">int</span>, string&gt; hashmap&#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="number">3</span>, <span class="string">&quot;three&quot;</span>&#125;&#125;;</span><br></pre></td></tr></table></figure><h4 id="常用操作-3">常用操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化哈希表</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, string&gt; hashmap&#123;&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;two&quot;</span>&#125;, &#123;<span class="number">3</span>, <span class="string">&quot;three&quot;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查哈希表是否为空，输出：0 (false)</span></span><br><span class="line">    cout &lt;&lt; hashmap.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取哈希表的大小，输出：3</span></span><br><span class="line">    cout &lt;&lt; hashmap.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找指定键是否存在</span></span><br><span class="line">    <span class="comment">// 注意 contains 方法是 C++20 新增的</span></span><br><span class="line">    <span class="comment">// 输出：Key 2 -&gt; two</span></span><br><span class="line">    <span class="keyword">if</span> (hashmap.<span class="built_in">contains</span>(<span class="number">2</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Key 2 -&gt; &quot;</span> &lt;&lt; hashmap[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Key 2 not found.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定键对应的值，若不存在会返回默认构造的值</span></span><br><span class="line">    <span class="comment">// 输出空字符串</span></span><br><span class="line">    cout &lt;&lt; hashmap[<span class="number">4</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入一个新的键值对</span></span><br><span class="line">    hashmap[<span class="number">4</span>] = <span class="string">&quot;four&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取新插入的值，输出：four</span></span><br><span class="line">    cout &lt;&lt; hashmap[<span class="number">4</span>] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除键值对</span></span><br><span class="line">    hashmap.<span class="built_in">erase</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查删除后键 3 是否存在</span></span><br><span class="line">    <span class="comment">// 输出：Key 3 not found.</span></span><br><span class="line">    <span class="keyword">if</span> (hashmap.<span class="built_in">contains</span>(<span class="number">3</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Key 3 -&gt; &quot;</span> &lt;&lt; hashmap[<span class="number">3</span>] &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Key 3 not found.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历哈希表</span></span><br><span class="line">    <span class="comment">// 输出（顺序可能不同）：</span></span><br><span class="line">    <span class="comment">// 4 -&gt; four</span></span><br><span class="line">    <span class="comment">// 2 -&gt; two</span></span><br><span class="line">    <span class="comment">// 1 -&gt; one</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;pair: hashmap) &#123;</span><br><span class="line">        cout &lt;&lt; pair.first &lt;&lt; <span class="string">&quot; -&gt; &quot;</span> &lt;&lt; pair.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 特别注意，访问不存在的键会自动创建这个键</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, string&gt; hashmap2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键值对的数量是 0</span></span><br><span class="line">    cout &lt;&lt; hashmap<span class="number">2.</span><span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问不存在的键，会自动创建这个键，对应的值是默认构造的值</span></span><br><span class="line">    cout &lt;&lt; hashmap2[<span class="number">1</span>] &lt;&lt; endl; <span class="comment">// empty string</span></span><br><span class="line">    cout &lt;&lt; hashmap2[<span class="number">2</span>] &lt;&lt; endl; <span class="comment">// empty string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 现在键值对的数量是 2</span></span><br><span class="line">    cout &lt;&lt; hashmap<span class="number">2.</span><span class="built_in">size</span>() &lt;&lt; endl; <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="哈希集合-unordered-set">哈希集合 unordered_set</h3><h4 id="初始化-6">初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个空的哈希集合 set</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; uset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一个包含一些元素的哈希集合 set</span></span><br><span class="line">unordered_set&lt;<span class="type">int</span>&gt; uset&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><h4 id="常用操作-4">常用操作</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化哈希集合</span></span><br><span class="line">    unordered_set&lt;<span class="type">int</span>&gt; hashset&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查哈希集合是否为空，输出：0 (false)</span></span><br><span class="line">    cout &lt;&lt; hashset.<span class="built_in">empty</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取哈希集合的大小，输出：4</span></span><br><span class="line">    cout &lt;&lt; hashset.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找指定元素是否存在</span></span><br><span class="line">    <span class="comment">// 输出：Element 3 found.</span></span><br><span class="line">    <span class="keyword">if</span> (hashset.<span class="built_in">contains</span>(<span class="number">3</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element 3 found.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element 3 not found.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入一个新的元素</span></span><br><span class="line">    hashset.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除一个元素</span></span><br><span class="line">    hashset.<span class="built_in">erase</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 输出：Element 2 not found.</span></span><br><span class="line">    <span class="keyword">if</span> (hashset.<span class="built_in">contains</span>(<span class="number">2</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element 2 found.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Element 2 not found.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历哈希集合</span></span><br><span class="line">    <span class="comment">// 输出（顺序可能不同）：</span></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;element : hashset) &#123;</span><br><span class="line">        cout &lt;&lt; element &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="树">树</h2><h3 id="二叉树结构">二叉树结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">TreeNode *left;</span><br><span class="line">TreeNode *right;</span><br><span class="line"></span><br><span class="line"><span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"><span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二叉树-DFS-深度优先搜索">二叉树 DFS 深度优先搜索</h3><h4 id="前序遍历（根-左-右）">前序遍历（根-&gt;左-&gt;右）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_Preorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 处理当前节点</span></span><br><span class="line">    <span class="built_in">DFS_Preorder</span>(root-&gt;left);  <span class="comment">// 遍历左子树</span></span><br><span class="line">    <span class="built_in">DFS_Preorder</span>(root-&gt;right); <span class="comment">// 遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历（左-根-右）">中序遍历（左-&gt;根-&gt;右）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_Inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">DFS_Inorder</span>(root-&gt;left);  <span class="comment">// 遍历左子树</span></span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 处理当前节点</span></span><br><span class="line">    <span class="built_in">DFS_Inorder</span>(root-&gt;right); <span class="comment">// 遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历（左-右-根）">后序遍历（左-&gt;右-&gt;根）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DFS_Postorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">DFS_Postorder</span>(root-&gt;left);  <span class="comment">// 遍历左子树</span></span><br><span class="line">    <span class="built_in">DFS_Postorder</span>(root-&gt;right); <span class="comment">// 遍历右子树</span></span><br><span class="line">    cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 处理当前节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树-BFS-广度优先搜索（层序遍历）">二叉树 BFS 广度优先搜索（层序遍历）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root) <span class="keyword">return</span>;  <span class="comment">// 如果根节点为空，则没有树，直接返回</span></span><br><span class="line">    </span><br><span class="line">    queue&lt;TreeNode*&gt; q;  <span class="comment">// 创建一个队列，用于存储树的节点</span></span><br><span class="line">    q.<span class="built_in">push</span>(root);  <span class="comment">// 将根节点入队</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 队列不为空时，继续遍历</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        TreeNode* node = q.<span class="built_in">front</span>();  <span class="comment">// 获取队列头部的节点</span></span><br><span class="line">        q.<span class="built_in">pop</span>();  <span class="comment">// 弹出队列头部的节点</span></span><br><span class="line">        </span><br><span class="line">        cout &lt;&lt; node-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// 访问当前节点，输出其值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果当前节点有左子节点，将左子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前节点有右子节点，将右子节点入队</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;  <span class="comment">// 输出换行，结束一层的遍历</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">C++ 数据结构</summary>
    
    
    
    <category term="开发" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="CPP" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/CPP/"/>
    
    
    <category term="开发" scheme="https://www.angfff.top/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="CPP" scheme="https://www.angfff.top/tags/CPP/"/>
    
    <category term="C++" scheme="https://www.angfff.top/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>互联网产品分析笔记(二)</title>
    <link href="https://www.angfff.top/posts/412c0b00.html"/>
    <id>https://www.angfff.top/posts/412c0b00.html</id>
    <published>2025-02-19T03:02:50.000Z</published>
    <updated>2025-05-22T04:31:09.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="飞猪（Fliggy）">飞猪（Fliggy）</h2><h3 id="产品概述"><strong>产品概述</strong></h3><p>飞猪（Fliggy）是阿里巴巴集团旗下的在线旅游平台，提供机票、酒店、火车票、度假套餐、签证办理等一站式旅行服务。作为国内OTA（在线旅游代理）市场的重要玩家，飞猪依托阿里生态，为用户提供个性化的旅行方案，并结合支付宝、小红书等平台打造社交化旅行体验。</p><h3 id="核心功能"><strong>核心功能</strong></h3><ol><li><strong>机票与酒店预订</strong>：提供国内外航班与酒店预订，支持多种支付方式和优惠补贴。</li><li><strong>旅行套餐</strong>：整合机票+酒店+景点门票，为用户提供一站式出行方案。</li><li><strong>信用住</strong>：依托芝麻信用，用户可“先住后付”，降低入住门槛。</li><li><strong>火车票与签证办理</strong>：支持12306购票，并提供全球签证办理服务。</li><li><strong>会员体系</strong>：飞猪F3/F4会员享受专属折扣、快速退改签等权益。</li><li><strong>旅游直播</strong>：与达人合作直播带货，推荐旅行产品，提高用户购买转化率。</li></ol><h3 id="用户体验评估"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>阿里生态整合</strong>：与支付宝、淘宝、小红书联动，实现无缝支付和社交分享。</li><li><strong>信用体系完善</strong>：芝麻信用体系降低用户预订成本，提高信任度。</li><li><strong>价格竞争力强</strong>：依托大数据动态定价，提供个性化优惠。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>品牌认知度相对较低</strong>，相比携程、美团在OTA市场仍有劣势。</li><li><strong>国际航班和酒店资源相对有限</strong>，在高端市场竞争力不足。</li><li><strong>客服响应速度偶尔较慢</strong>，影响用户体验。</li></ul></li></ul><h3 id="商业模式解释"><strong>商业模式解释</strong></h3><ol><li><strong>佣金收入</strong>：与航司、酒店、旅行社合作，收取交易佣金。</li><li><strong>会员付费</strong>：F4会员可获得更高折扣和专属权益，提高复购率。</li><li><strong>广告投放</strong>：品牌方可在飞猪进行搜索排名、定向投放，提高曝光率。</li><li><strong>供应链合作</strong>：与酒店、景区、航空公司联合推出专属产品。</li></ol><h3 id="竞争分析"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>携程（Ctrip）</strong>：行业龙头，资源丰富，覆盖高端市场。</li><li><strong>美团旅行</strong>：依托美团生态，主打本地化旅游与性价比。</li><li><strong>去哪儿</strong>：擅长机票比价，吸引价格敏感型用户。</li></ul></li><li><strong>优势</strong>：<ul><li><strong>阿里流量扶持</strong>，可直接转化淘宝/支付宝用户。</li><li><strong>信用住等创新产品</strong>，降低用户预订门槛，提高信任感。</li></ul></li><li><strong>劣势</strong>：<ul><li><strong>市场份额相对较低</strong>，用户心智仍主要集中在携程、美团等平台。</li><li><strong>缺乏差异化竞争力</strong>，在高端商旅市场吸引力较弱。</li></ul></li></ul><h3 id="运营策略"><strong>运营策略</strong></h3><ol><li><strong>强化品牌认知</strong>：增加营销推广，提高用户对飞猪的品牌认可度。</li><li><strong>优化国际化布局</strong>：拓展海外酒店、航司合作，提高全球覆盖率。</li><li><strong>提升服务体验</strong>：优化客服响应，增强售后保障，提高用户满意度。</li><li><strong>拓展年轻用户市场</strong>：通过直播、短视频等方式，加强年轻用户的互动体验。</li></ol><h3 id="改进建议"><strong>改进建议</strong></h3><ol><li><strong>优化搜索与推荐算法</strong>：提升个性化推荐能力，提高用户转化率。</li><li><strong>增强国际业务拓展</strong>：与更多国际酒店、航司合作，吸引海外用户。</li><li><strong>提升会员权益</strong>：增加F3/F4会员独家折扣，增强用户忠诚度。</li><li><strong>减少广告干扰</strong>：优化页面信息流，提高用户体验。</li></ol><h3 id="总结"><strong>总结</strong></h3><p>飞猪依托阿里生态，在OTA市场具备一定竞争力，但仍需进一步强化品牌认知、优化国际化布局，并提升用户体验，才能在竞争激烈的旅游市场中抢占更多份额。</p><hr><h2 id="网易云音乐（NetEase-Cloud-Music）">网易云音乐（NetEase Cloud Music）</h2><h3 id="产品概述-2"><strong>产品概述</strong></h3><p>网易云音乐是一款主打“情感社区+音乐内容”的音乐流媒体平台。相较于腾讯音乐系的QQ音乐、酷狗等，网易云音乐以“歌单+评论+社区”文化独树一帜，吸引了一大批Z世代年轻用户，成为中文互联网音乐体验的标杆之一。</p><h3 id="核心功能-2"><strong>核心功能</strong></h3><ol><li><strong>音乐播放与搜索</strong>：提供海量正版音乐资源，涵盖华语、欧美、日韩等多语言流派。</li><li><strong>歌单系统</strong>：用户可自定义歌单、收藏他人歌单，形成社区传播链。</li><li><strong>音乐评论区</strong>：每首歌配有强互动评论区，是平台最具特色的社交场所。</li><li><strong>个性化推荐</strong>：基于用户行为的推荐算法，提供每日歌曲推荐、私人FM等。</li><li><strong>Mlog（视频动态）与云村社区</strong>：鼓励音乐创作、翻唱、原创视频内容上传，增强社区氛围。</li><li><strong>听歌识曲</strong>：快速识别周围音乐，支持加入歌单或收藏。</li></ol><h3 id="用户体验评估-2"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>情感氛围浓厚，评论区“杀疯了”，提升用户粘性和情绪价值。</li><li>歌单推荐丰富且精细，符合不同场景和情绪需求。</li><li>UI设计文艺清爽，年轻化定位精准。</li></ul></li><li><strong>不足</strong>：<ul><li>曲库因版权问题长期不如腾讯音乐丰富。</li><li>音质选择限制多，部分高品质音乐需VIP。</li><li>推荐算法在小众音乐场景下有优化空间。</li></ul></li></ul><h3 id="商业模式解释-2"><strong>商业模式解释</strong></h3><ol><li><strong>会员订阅（黑胶VIP）</strong>：提供无损音质、跳过广告、个性皮肤等服务。</li><li><strong>广告收入</strong>：启动页广告、信息流广告等基础变现手段。</li><li><strong>内容创作者分成</strong>：平台与独立音乐人、UP主进行内容分成合作。</li><li><strong>音乐付费专辑/单曲</strong>：部分新歌或经典歌曲需单独付费解锁。</li><li><strong>社区内容激励与虚拟礼物</strong>：用户可为内容创作者打赏，平台抽成。</li></ol><h3 id="竞争分析-2"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>QQ音乐/酷狗音乐</strong>：曲库优势明显，版权资源丰富，商业化成熟。</li><li><strong>Apple Music / Spotify（境外）</strong>：产品体验一流，算法强，但在中国水土不服。</li></ul></li><li><strong>网易云优势</strong>：<ul><li>社区氛围强，评论区极具辨识度，用户忠诚度高。</li><li>用户UGC能力强，激发传播与讨论欲望。</li></ul></li><li><strong>网易云劣势</strong>：<ul><li>版权掣肘严重，曲库不完整是致命短板。</li><li>盈利能力一般，长期处于亏损状态。</li></ul></li></ul><h3 id="运营策略-2"><strong>运营策略</strong></h3><ol><li><strong>加强独立音乐人生态建设</strong>，通过云梯计划、创作工具吸引原创内容入驻。</li><li><strong>探索IP孵化机制</strong>，将优质UGC歌单/评论发展为衍生内容（如短剧、播客）。</li><li><strong>加大社区功能融合</strong>，整合短视频、弹幕、音乐圈子等，打造复合型社交空间。</li><li><strong>通过AI生成音乐/封面/评论摘要</strong>等技术，提升用户创作效率和趣味性。</li></ol><h3 id="改进建议-2"><strong>改进建议</strong></h3><ol><li><strong>版权谈判机制优化</strong>，考虑与腾讯音乐联合采购版权，缓解孤岛效应。</li><li><strong>推出听歌成就系统+个性化荣誉墙</strong>，激励用户日常使用频率和留存。</li><li><strong>海外市场扩张</strong>，主打华语音乐和“情绪评论”文化，打开东南亚及港澳台市场。</li><li><strong>提高AIGC应用率</strong>，尝试AI DJ、AI音乐讲解等新体验拉新用户。</li></ol><h3 id="总结-2"><strong>总结</strong></h3><p>网易云音乐是一款将“音乐”与“情感连接”做到极致的产品，它在社交氛围和用户黏性上具有独特优势。然而，版权短板和盈利压力仍是悬在头上的达摩克利斯之剑。未来若能通过技术创新与社区深化增强差异化竞争力，它仍有机会在音乐领域逆袭。</p><hr><h2 id="剪映（CapCut）">剪映（CapCut）</h2><h3 id="产品概述-3"><strong>产品概述</strong></h3><p>剪映（CapCut）是字节跳动推出的一款全能视频剪辑工具，支持移动端和PC端操作，主打“简单易用+强大功能”的剪辑体验。作为抖音官方推荐的视频编辑工具，剪映凭借强大的特效、AI功能和免费无水印优势，迅速成为短视频创作者的首选。</p><h3 id="核心功能-3"><strong>核心功能</strong></h3><ol><li><strong>多轨剪辑</strong>：支持视频、音频、文本多轨编辑，适合专业级剪辑需求。</li><li><strong>智能字幕</strong>：自动语音识别生成字幕，提高编辑效率。</li><li><strong>AI特效与滤镜</strong>：丰富的动态特效、滤镜、转场，降低创作门槛。</li><li><strong>音乐与音效库</strong>：提供海量版权音乐和音效，适用于不同场景。</li><li><strong>智能抠像</strong>：无需绿幕，一键去除背景，适用于短视频创作。</li><li><strong>一键成片</strong>：内置视频模板和智能生成工具，降低新手剪辑难度。</li><li><strong>云端存储</strong>：支持多设备协同编辑，提升工作流效率。</li></ol><h3 id="用户体验评估-3"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>界面简洁，功能强大，适合新手和专业用户。</li><li>AI自动化剪辑工具降低操作门槛，提高效率。</li><li>免费无水印，相比同类产品（如VN、KineMaster）竞争力更强。</li></ul></li><li><strong>不足</strong>：<ul><li>PC端功能相较于专业剪辑软件（如Premiere、Final Cut Pro）仍有差距。</li><li>云端存储需要优化，部分用户反馈同步速度较慢。</li><li>依赖字节跳动生态，海外市场拓展仍受竞争压力。</li></ul></li></ul><h3 id="商业模式解释-3"><strong>商业模式解释</strong></h3><ol><li><strong>免费基础功能</strong>：提供完整的基础剪辑功能，吸引用户规模。</li><li><strong>增值订阅</strong>：剪映专业版提供更高级的特效、模板、云存储空间等。</li><li><strong>企业服务</strong>：为品牌方、内容机构提供定制化剪辑工具和广告素材优化服务。</li><li><strong>与抖音/海外TikTok联动</strong>：引导用户在剪映编辑后直接分享到短视频平台，提高生态闭环变现能力。</li></ol><h3 id="竞争分析-3"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>CapCut（国际版剪映）</strong>：在海外市场与Adobe Rush、iMovie等竞争。</li><li><strong>VN、KineMaster</strong>（移动端剪辑工具，部分提供高级订阅功能）。</li><li><strong>Premiere、Final Cut Pro</strong>（高端专业剪辑软件，适用于电影级制作）。</li></ul></li><li><strong>优势</strong>：<ul><li>AI智能化剪辑工具，使小白用户也能轻松上手。</li><li>与抖音、TikTok生态紧密结合，形成用户增长飞轮。</li></ul></li><li><strong>劣势</strong>：<ul><li>在专业剪辑领域竞争力不足，难以吸引高端创作者。</li><li>变现路径仍在探索，部分高阶功能可能需要商业化支撑。</li></ul></li></ul><h3 id="运营策略-3"><strong>运营策略</strong></h3><ol><li><strong>强化AI智能剪辑</strong>：进一步优化智能字幕、自动特效，降低视频创作门槛。</li><li><strong>拓展B端市场</strong>：为品牌营销、MCN机构提供定制化剪辑方案，提高商业变现能力。</li><li><strong>国际化扩展</strong>：加大对CapCut的推广，争夺海外短视频市场。</li><li><strong>优化云服务</strong>：提升跨设备编辑体验，增强用户粘性。</li></ol><h3 id="改进建议-3"><strong>改进建议</strong></h3><ol><li><strong>增强PC端能力</strong>：增加更多专业功能，向高级视频编辑用户渗透。</li><li><strong>推出更丰富的订阅服务</strong>：增加更多高级滤镜、素材库，提高用户付费转化率。</li><li><strong>减少系统资源占用</strong>：优化软件性能，降低剪辑时的卡顿问题。</li><li><strong>提升社交分享能力</strong>：增加作品社区，提高用户互动与创作灵感交换。</li></ol><h3 id="总结-3"><strong>总结</strong></h3><p>剪映凭借其智能化、免费、易用的优势，已成为短视频时代的重要剪辑工具。但面对竞争压力，未来需要在专业剪辑、商业化路径、国际市场拓展等方面不断优化，才能确保长期竞争力。</p><hr><h2 id="石墨文档（Shimo-Docs）">石墨文档（Shimo Docs）</h2><h3 id="产品概述-4"><strong>产品概述</strong></h3><p>石墨文档是中国领先的在线协作文档工具，类似于 Google Docs，提供云端文档、表格、演示文稿等功能，支持多人实时协作编辑。它专注于提高团队办公效率，并在教育、科技、媒体等行业广泛应用。</p><h3 id="核心功能-4"><strong>核心功能</strong></h3><ol><li><strong>云端文档</strong>：支持多人实时编辑，自动保存，历史版本追溯。</li><li><strong>团队协作</strong>：提供权限管理、评论、任务指派，提高团队协作效率。</li><li><strong>表格与演示</strong>：支持类似 Excel 的在线表格、PPT 演示文稿制作。</li><li><strong>企业知识库</strong>：团队可创建共享文档库，方便知识沉淀与管理。</li><li><strong>Markdown 支持</strong>：方便开发者、技术人员撰写文档。</li><li><strong>API 集成</strong>：支持与企业内部系统对接，提高自动化办公能力。</li></ol><h3 id="用户体验评估-4"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>操作流畅</strong>，界面简洁，使用体验接近 Google Docs。</li><li><strong>多人协作能力强</strong>，适合远程办公和团队项目管理。</li><li><strong>本地化优势</strong>，相比 Google Docs 适应国内网络环境，无需翻墙。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>高级功能收费</strong>，部分企业版功能需要订阅。</li><li><strong>生态闭环较弱</strong>，缺乏完整的办公套件（如邮件、日历）。</li><li><strong>移动端体验有待优化</strong>，部分功能在手机端适配不佳。</li></ul></li></ul><h3 id="商业模式解释-4"><strong>商业模式解释</strong></h3><ol><li><strong>企业订阅</strong>：提供按月/年付费的企业版，增强管理功能。</li><li><strong>个人高级版</strong>：订阅会员可解锁更多存储空间、高级权限管理等功能。</li><li><strong>企业定制化</strong>：提供 API 接入、私有化部署，满足大企业需求。</li><li><strong>广告与合作</strong>：部分功能可与 SaaS 工具合作推广，实现流量变现。</li></ol><h3 id="竞争分析-4"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>腾讯文档</strong>（依托微信生态，用户增长快）。</li><li><strong>金山文档</strong>（WPS 旗下，集成度高）。</li><li><strong>飞书 Docs</strong>（字节跳动产品，与飞书深度融合）。</li><li><strong>Google Docs</strong>（在国际市场占据主导地位）。</li></ul></li><li><strong>优势</strong>：<ul><li>本地化适配优秀，符合国内用户需求。</li><li>功能丰富，协作体验优于传统 Office 软件。</li></ul></li><li><strong>劣势</strong>：<ul><li>生态整合能力不及大厂产品，如腾讯、字节等。</li><li>市场推广能力相对较弱，用户增长主要靠口碑传播。</li></ul></li></ul><h3 id="运营策略-4"><strong>运营策略</strong></h3><ol><li><strong>优化移动端体验</strong>：增强 APP 端的操作流畅性，提高移动办公能力。</li><li><strong>增强生态整合</strong>：与更多企业软件（如钉钉、企业微信）联动，提高市场渗透率。</li><li><strong>扩展教育市场</strong>：加强与高校、在线教育平台合作，提升品牌影响力。</li><li><strong>优化定价策略</strong>：推出更多灵活的套餐，降低中小企业使用门槛。</li></ol><h3 id="改进建议-4"><strong>改进建议</strong></h3><ol><li><strong>提升离线编辑功能</strong>，增强无网络环境下的使用体验。</li><li><strong>增加 AI 助手</strong>，提供智能写作、翻译、数据分析等功能。</li><li><strong>优化权限管理</strong>，为企业客户提供更细粒度的访问控制。</li><li><strong>加强安全性</strong>，推出更高级的加密与数据备份方案，吸引更多企业客户。</li></ol><h3 id="总结-4"><strong>总结</strong></h3><p>石墨文档凭借其本地化优势和优秀的协作能力，在国内文档市场占据一席之地。但面对腾讯、金山等强劲对手，未来需加强生态整合、优化产品体验，并探索更多商业化路径，以实现长期竞争力。</p><hr><h2 id="Keep">Keep</h2><h3 id="产品概述-5"><strong>产品概述</strong></h3><p>Keep 是中国领先的健身运动平台，提供在线健身课程、智能硬件、社交社区等功能，帮助用户在家或户外进行科学锻炼。作为国内最受欢迎的健身 APP 之一，Keep 通过“内容 + 硬件 + 社区 + 电商”形成了闭环生态，满足用户多样化的健身需求。</p><h3 id="核心功能-5"><strong>核心功能</strong></h3><ol><li><strong>在线健身课程</strong>：涵盖瑜伽、有氧、力量训练等，支持定制训练计划。</li><li><strong>运动数据追踪</strong>：记录跑步、骑行、步数等数据，并提供分析和激励机制。</li><li><strong>社交社区</strong>：用户可分享健身动态、打卡、参与挑战，提高运动动力。</li><li><strong>智能健身设备</strong>：与 Keep 自研硬件（如跑步机、跳绳）连接，实现数据同步。</li><li><strong>个性化推荐</strong>：基于用户身体数据和训练习惯，推荐适合的课程和饮食建议。</li><li><strong>Keep 商城</strong>：销售运动装备、健康食品、课程会员等，提高用户粘性。</li></ol><h3 id="用户体验评估-5"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>课程体系丰富，适合不同健身水平的用户。</li><li>界面简洁，操作流畅，用户体验良好。</li><li>社区氛围积极，增强用户长期坚持健身的动力。</li></ul></li><li><strong>不足</strong>：<ul><li>课程免费内容有限，高质量训练内容需会员付费。</li><li>设备与 APP 的联动体验仍需优化，如部分数据同步不稳定。</li><li>会员体系较复杂，部分用户认为付费权益不够吸引人。</li></ul></li></ul><h3 id="商业模式解释-5"><strong>商业模式解释</strong></h3><ol><li><strong>会员订阅</strong>：Keep 会员提供高级课程、个性化训练计划、去广告等权益。</li><li><strong>硬件销售</strong>：智能健身设备（如跑步机、动感单车、智能手环）成为重要收入来源。</li><li><strong>课程付费</strong>：部分高端训练计划、明星教练课程需要单独购买。</li><li><strong>电商变现</strong>：运动装备、营养品、服饰等商品销售贡献收入。</li><li><strong>品牌合作</strong>：与运动品牌、健康食品企业合作推广，实现广告收入。</li></ol><h3 id="竞争分析-5"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>咕咚</strong>（主打运动社交和智能设备）。</li><li><strong>乐刻运动</strong>（结合线上课程与线下健身房）。</li><li><strong>Peloton（国际）</strong>（智能硬件 + 订阅课程模式）。</li></ul></li><li><strong>优势</strong>：<ul><li>健身内容丰富，覆盖全场景需求（家庭、户外、健身房）。</li><li>生态闭环完善，涵盖软件、硬件、电商、社交等多个环节。</li></ul></li><li><strong>劣势</strong>：<ul><li>盈利模式依赖会员订阅，用户增长后期可能放缓。</li><li>运动硬件市场竞争激烈，产品创新和用户体验需持续优化。</li></ul></li></ul><h3 id="运营策略-5"><strong>运营策略</strong></h3><ol><li><strong>优化会员体系</strong>：调整定价策略，提高会员权益吸引力。</li><li><strong>增强智能设备体验</strong>：改进数据同步问题，优化硬件交互。</li><li><strong>拓展海外市场</strong>：借鉴 Peloton 模式，探索国际化增长机会。</li><li><strong>强化 AI 训练助手</strong>：结合 AI 提供个性化运动指导，提高用户粘性。</li></ol><h3 id="改进建议-5"><strong>改进建议</strong></h3><ol><li><strong>降低新用户门槛</strong>：提供更多免费基础课程，提高用户转化率。</li><li><strong>加强社交互动</strong>：增加线上 PK 赛、团队挑战，提高用户活跃度。</li><li><strong>优化硬件软件联动</strong>：提高设备数据精准度，提升智能化体验。</li><li><strong>增加线下体验店</strong>：结合智能健身房模式，提升品牌影响力。</li></ol><h3 id="总结-5"><strong>总结</strong></h3><p>Keep 通过“内容 + 硬件 + 电商”构建了完整的运动生态，用户粘性较强。但面临会员增长瓶颈和硬件竞争压力，需要优化商业模式、增强智能化体验，并探索更多变现渠道，以确保长期竞争力。</p><hr><h2 id="滴滴出行（DiDi）">滴滴出行（DiDi）</h2><h3 id="产品概述-6"><strong>产品概述</strong></h3><p>滴滴出行是中国最大的网约车平台，提供打车、顺风车、共享单车、代驾等多元化出行服务。作为全球领先的智能出行平台，滴滴通过大数据和AI优化调度，提高出行效率，并不断拓展国际市场。</p><h3 id="核心功能-6"><strong>核心功能</strong></h3><ol><li><strong>即时叫车</strong>：用户可通过APP快速叫车，支持快车、专车、出租车等多种车型。</li><li><strong>拼车服务</strong>：用户可选择拼车以降低费用，同时提高车辆利用率。</li><li><strong>顺风车</strong>：允许私家车主搭载顺路乘客，提供成本更低的出行方式（曾暂停，后部分城市试点恢复）。</li><li><strong>共享单车与电动车</strong>：整合青桔单车、电动车服务，满足短途出行需求。</li><li><strong>代驾服务</strong>：为酒后或不便驾驶的用户提供代驾服务。</li><li><strong>安全保障</strong>：提供行程录音、紧急联系人、一键报警等安全功能。</li></ol><h3 id="用户体验评估-6"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>覆盖范围广</strong>，一二线城市及部分海外市场均可使用。</li><li><strong>AI调度优化</strong>，减少用户等待时间，提高司机接单效率。</li><li><strong>多种出行选择</strong>，从经济型到高端车型，满足不同用户需求。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>动态定价机制争议</strong>，高峰期价格浮动较大，用户体验受影响。</li><li><strong>安全问题</strong>，尽管滴滴已加强安全措施，仍存在用户担忧。</li><li><strong>司机与用户匹配优化空间</strong>，部分司机接单后长时间不动或绕路问题仍存在。</li></ul></li></ul><h3 id="商业模式解释-6"><strong>商业模式解释</strong></h3><ol><li><strong>佣金收入</strong>：从每笔订单抽取固定比例的佣金（一般为10%-30%）。</li><li><strong>会员订阅</strong>：提供会员权益，如折扣、优先派单等，提高用户复购率。</li><li><strong>广告业务</strong>：APP内信息流广告、司机端广告位投放等。</li><li><strong>金融服务</strong>：滴滴金融提供车贷、保险等服务，为司机提供金融支持。</li><li><strong>企业用车</strong>：提供企业专属出行方案，优化企业差旅管理。</li></ol><h3 id="竞争分析-6"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>高德打车</strong>（聚合平台，整合多个网约车品牌，竞争力增强）。</li><li><strong>T3出行</strong>（车企主导，司机补贴力度较大）。</li><li><strong>美团打车</strong>（依托美团生态，整合本地生活服务）。</li><li><strong>Uber（国际）</strong>（在海外市场与滴滴竞争）。</li></ul></li><li><strong>优势</strong>：<ul><li><strong>市场占有率高</strong>，用户基数庞大，形成网络效应。</li><li><strong>技术能力强</strong>，AI调度、路线规划等领先。</li></ul></li><li><strong>劣势</strong>：<ul><li><strong>政策监管压力大</strong>，数据安全、司机资质等问题需持续优化。</li><li><strong>盈利挑战</strong>，补贴减少后，如何维持用户增长和司机供给仍是难题。</li></ul></li></ul><h3 id="运营策略-6"><strong>运营策略</strong></h3><ol><li><strong>优化定价策略</strong>：平衡司机收入与用户体验，减少高峰期过高溢价。</li><li><strong>增强司机管理</strong>：提升司机审核、培训机制，提高服务质量。</li><li><strong>拓展国际市场</strong>：深化在拉美、东南亚等市场的布局，提升海外竞争力。</li><li><strong>加码自动驾驶</strong>：推进Robotaxi（无人驾驶网约车）测试，抢占未来出行市场。</li></ol><h3 id="改进建议-6"><strong>改进建议</strong></h3><ol><li><strong>优化动态定价</strong>：提供更透明的价格机制，减少用户对价格波动的不满。</li><li><strong>提升安全措施</strong>：增加行程风险预警，提高女性及夜间出行的安全性。</li><li><strong>加强用户运营</strong>：提供更多会员权益，增加用户留存率。</li><li><strong>探索多元化盈利模式</strong>：如车载广告、智能车载硬件等，拓展收入来源。</li></ol><h3 id="总结-6"><strong>总结</strong></h3><p>滴滴出行在国内网约车市场占据主导地位，但面对竞争加剧、监管趋严等挑战，需要持续优化用户体验、提升安全性，并探索自动驾驶、国际市场等新增长点，以保持长期竞争力。</p><hr><h2 id="TapTap">TapTap</h2><h3 id="产品概述-7"><strong>产品概述</strong></h3><p>TapTap 是一个专注于手游推荐、下载与社区交流的平台，主打“发现好游戏”，避免传统应用商店的刷榜和劣质推广问题。其核心特点是“无广告、无联运、真实评价”，让用户能够获取更优质的游戏推荐，并与玩家、开发者互动。</p><h3 id="核心功能-7"><strong>核心功能</strong></h3><ol><li><strong>游戏推荐与下载</strong>：提供高质量游戏推荐，支持官方渠道安装，避免盗版与山寨游戏。</li><li><strong>玩家社区</strong>：用户可发表游戏评价、攻略、讨论，形成互动交流。</li><li><strong>排行榜与评分系统</strong>：基于用户评价的公平评分系统，推荐真正优质的游戏。</li><li><strong>开发者直连</strong>：开发者可直接发布游戏，与玩家交流，提高用户反馈效率。</li><li><strong>游戏预约与测试</strong>：支持新游戏的预约、封测、抢先体验，增强用户期待感。</li></ol><h3 id="用户体验评估-7"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>无广告、无诱导下载，推荐内容相对客观。</li><li>社区氛围较好，玩家互动活跃，评价较真实。</li><li>游戏更新及时，支持官方安装包，避免盗版风险。</li></ul></li><li><strong>不足</strong>：<ul><li>受限于国内政策，部分海外游戏无法上架，导致资源不够丰富。</li><li>作为独立平台，受限于安卓生态，iOS 端体验不如安卓端。</li><li>由于评分机制透明，部分游戏存在“恶意差评”现象，影响评分公正性。</li></ul></li></ul><h3 id="商业模式解释-7"><strong>商业模式解释</strong></h3><ol><li><strong>开发者服务</strong>：提供游戏分发、运营支持、社区互动等增值服务。</li><li><strong>游戏联运</strong>（部分尝试）：部分游戏可能会进行合作推广，但不影响公正性。</li><li><strong>社区变现</strong>：通过社区活跃度提升用户留存，带动游戏长尾效应，从而获取更多开发者合作。</li><li><strong>增值工具</strong>：提供游戏数据分析、市场洞察等付费服务，帮助开发者优化推广策略。</li></ol><h3 id="竞争分析-7"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>App Store &amp; Google Play</strong>（主流应用商店，但推荐算法不透明，游戏发现机制较弱）。</li><li><strong>腾讯应用宝</strong>（拥有海量腾讯系游戏资源，生态优势明显）。</li><li><strong>好游快爆</strong>（同样主打社区+游戏推荐，但用户粘性稍逊）。</li></ul></li><li><strong>优势</strong>：<ul><li>强调公平推荐，避免广告干扰，深受核心玩家喜爱。</li><li>社区互动强，玩家与开发者联系紧密，提高游戏生命周期。</li></ul></li><li><strong>劣势</strong>：<ul><li>资源受限，部分大厂游戏仍依赖官方商店，无法完全覆盖市场。</li><li>商业化探索仍处于初期阶段，盈利模式较弱。</li></ul></li></ul><h3 id="运营策略-7"><strong>运营策略</strong></h3><ol><li><strong>增强独家内容</strong>：争取更多独立游戏、精品手游的首发合作，提高吸引力。</li><li><strong>优化社区管理</strong>：提升评价审核机制，防止恶意评分和水军干扰。</li><li><strong>探索更多变现模式</strong>：如推出会员体系，提供数据分析、专属试玩等高级功能。</li><li><strong>拓展国际市场</strong>：借鉴 Steam 经验，吸引海外开发者入驻，提高全球影响力。</li></ol><h3 id="改进建议-7"><strong>改进建议</strong></h3><ol><li><strong>加强与开发者的合作</strong>，推出更多试玩、折扣活动，提高用户活跃度。</li><li><strong>优化推荐算法</strong>，提升个性化游戏推荐能力，减少用户探索成本。</li><li><strong>增加社交玩法</strong>，如游戏成就系统、好友互动，提高用户粘性。</li><li><strong>拓展云游戏功能</strong>，降低高配置游戏的设备门槛，吸引更多轻度用户。</li></ol><h3 id="总结-7"><strong>总结</strong></h3><p>TapTap 以公平、公正的游戏推荐和社区互动优势，在手游市场建立了独特的竞争力。然而，面对传统应用商店和大厂生态的挑战，其需要在内容独占性、商业化探索和国际化扩展方面进一步优化，以实现长期增长。</p><hr><h2 id="得物（Dewu）">得物（Dewu）</h2><h3 id="产品概述-8"><strong>产品概述</strong></h3><p>得物（Dewu）是一款潮流电商平台，最早以“毒APP”起家，专注于球鞋、潮牌服饰、电子产品等年轻用户喜爱的高端商品。平台主打“先鉴别，后发货”模式，确保商品真实性，满足消费者对正品潮流单品的需求。</p><h3 id="核心功能-8"><strong>核心功能</strong></h3><ol><li><strong>商品鉴别</strong>：平台提供专业的鉴别服务，防止假货流通，提升用户信任度。</li><li><strong>潮流电商</strong>：涵盖球鞋、潮牌服饰、奢侈品、电子数码等品类。</li><li><strong>社区互动</strong>：用户可以在APP内分享穿搭、晒单，形成社交氛围。</li><li><strong>拍卖与闪购</strong>：提供限量商品抢购、竞拍等模式，提高稀缺商品流通效率。</li><li><strong>二手交易</strong>：支持用户转售闲置潮流商品，实现商品流转。</li></ol><h3 id="用户体验评估-8"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>强大鉴别机制</strong>，有效降低假货风险，提高消费者信心。</li><li><strong>潮流属性突出</strong>，吸引年轻用户，社区氛围浓厚。</li><li><strong>多种购物模式</strong>（竞拍、预售等），提升用户购物体验。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>价格溢价高</strong>，部分商品因炒作导致价格远超市场价。</li><li><strong>鉴别服务争议</strong>，部分用户反馈鉴别结果不稳定。</li><li><strong>退换货体验一般</strong>，部分商品因鉴别流程影响退款效率。</li></ul></li></ul><h3 id="商业模式解释-8"><strong>商业模式解释</strong></h3><ol><li><strong>交易佣金</strong>：从买卖双方交易中抽取佣金（类似StockX模式）。</li><li><strong>鉴别服务费</strong>：部分商品需要额外支付鉴别费用。</li><li><strong>品牌合作</strong>：与潮牌、运动品牌合作推出独家联名款或营销推广。</li><li><strong>增值服务</strong>：如加速鉴别、VIP会员、竞拍等功能收费。</li></ol><h3 id="竞争分析-8"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>Nice</strong>（同样专注潮流交易，但社交氛围更强）。</li><li><strong>StockX</strong>（国际化平台，鉴别体系成熟）。</li><li><strong>闲鱼</strong>（二手市场庞大，但无专业鉴别服务）。</li></ul></li><li><strong>优势</strong>：<ul><li><strong>强社交属性</strong>，用户社区活跃，增强用户粘性。</li><li><strong>正品保障机制</strong>，提高用户信任，形成竞争壁垒。</li></ul></li><li><strong>劣势</strong>：<ul><li><strong>炒作氛围较浓</strong>，部分商品价格过高，影响长期市场稳定性。</li><li><strong>国际化能力较弱</strong>，相比 StockX 在全球市场的影响力有限。</li></ul></li></ul><h3 id="运营策略-8"><strong>运营策略</strong></h3><ol><li><strong>优化鉴别体系</strong>：提升鉴别准确度，减少争议，增强用户信任。</li><li><strong>拓展品类</strong>：增加更多高端电子产品、潮流玩具，提高用户消费频次。</li><li><strong>强化社交玩法</strong>：推出更多UGC互动玩法，如潮流挑战赛、达人推荐等。</li><li><strong>探索海外市场</strong>：与国际品牌合作，推动全球化扩张。</li></ol><h3 id="改进建议-8"><strong>改进建议</strong></h3><ol><li><strong>降低交易成本</strong>，减少溢价，提升用户长期留存率。</li><li><strong>优化物流效率</strong>，缩短鉴别与发货时间，提高用户体验。</li><li><strong>推出个性化推荐</strong>，基于AI算法优化商品推荐，提高转化率。</li><li><strong>增强线下体验</strong>，结合实体店提供鉴别、试穿等增值服务。</li></ol><h3 id="总结-8"><strong>总结</strong></h3><p>得物凭借“鉴别+潮流电商”模式，在年轻消费者群体中形成较强影响力。但面对市场竞争与用户信任问题，平台需要优化鉴别机制、拓展国际化布局，并平衡炒作与稳定增长之间的关系，以保持长期竞争力。</p><hr><h2 id="饿了么（Ele-me）">饿了么（<a href="http://Ele.me">Ele.me</a>）</h2><h3 id="产品概述-9"><strong>产品概述</strong></h3><p>饿了么是中国领先的本地生活服务平台，主打外卖配送，同时涵盖生鲜、商超、药品等即时配送业务。作为阿里巴巴旗下的核心本地生活业务之一，饿了么与支付宝、高德、美团等生态产品形成协同，为用户提供便捷的到家服务。</p><h3 id="核心功能-9"><strong>核心功能</strong></h3><ol><li><strong>外卖配送</strong>：提供全国范围的餐饮外卖服务，支持定时送达、夜宵、团餐等模式。</li><li><strong>即时零售</strong>：涵盖超市、生鲜、药品、鲜花等品类，满足日常消费需求。</li><li><strong>会员体系</strong>：“饿了么超级会员”提供免配送费、折扣红包等专属权益。</li><li><strong>智能推荐</strong>：基于用户偏好、时间、天气等因素推荐个性化餐饮选择。</li><li><strong>骑手调度</strong>：智能分单系统优化配送路径，提高送餐效率。</li><li><strong>品牌营销</strong>：支持商家投放满减折扣、红包、广告推广，提高曝光率和订单转化。</li></ol><h3 id="用户体验评估-9"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>阿里生态整合</strong>，支持支付宝支付、88VIP会员联动，提升用户粘性。</li><li><strong>即时配送体系完善</strong>，外卖准时率较高，服务范围广泛。</li><li><strong>优惠力度大</strong>，相比美团，饿了么常有较大补贴，价格优势明显。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>市场份额落后于美团</strong>，部分区域商家覆盖率相对较低。</li><li><strong>配送体验依赖第三方骑手</strong>，部分区域配送服务质量不稳定。</li><li><strong>商家端运营成本较高</strong>，部分小商家因佣金压力降低入驻积极性。</li></ul></li></ul><h3 id="商业模式解释-9"><strong>商业模式解释</strong></h3><ol><li><strong>商家佣金</strong>：从订单中抽取一定比例作为平台服务费（通常 10%-20%）。</li><li><strong>会员订阅</strong>：用户购买“超级会员”享受折扣和免配送费权益，提高复购率。</li><li><strong>广告推广</strong>：商家投放搜索排名、首页推荐等广告，提升曝光量。</li><li><strong>即时零售抽成</strong>：药品、生鲜等非餐饮品类的佣金和服务费。</li><li><strong>物流服务费</strong>：部分订单由平台自营配送，收取额外物流费。</li></ol><h3 id="竞争分析-9"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>美团外卖</strong>（市场占有率更高，骑手团队更完善）。</li><li><strong>京东到家</strong>（主打超市、生鲜配送，与饿了么即时零售业务重叠）。</li><li><strong>达达快送</strong>（专注即时配送，与商家深度合作）。</li></ul></li><li><strong>优势</strong>：<ul><li><strong>阿里生态加持</strong>，流量入口广，支付体验流畅。</li><li><strong>大额补贴</strong>，在价格竞争上更具优势。</li></ul></li><li><strong>劣势</strong>：<ul><li><strong>商家资源不及美团</strong>，部分城市餐厅入驻率较低。</li><li><strong>用户心智弱于美团</strong>，习惯性使用率有待提升。</li></ul></li></ul><h3 id="运营策略-9"><strong>运营策略</strong></h3><ol><li><strong>强化本地商家覆盖</strong>，增加优质品牌合作，提高用户选择范围。</li><li><strong>优化配送体验</strong>，加强骑手管理，提升服务稳定性和时效性。</li><li><strong>增强会员权益</strong>，提高超级会员的独特价值，提高用户留存率。</li><li><strong>拓展即时零售</strong>，加强与超市、生鲜、药店的合作，提高客单价和订单频次。</li></ol><h3 id="改进建议-9"><strong>改进建议</strong></h3><ol><li><strong>提升商家支持政策</strong>，降低佣金压力，提高商家入驻积极性。</li><li><strong>优化用户体验</strong>，减少应用内广告和不必要的促销弹窗，提升界面清爽度。</li><li><strong>增强配送可视化</strong>，提升订单追踪系统，让用户更清晰地了解送餐进度。</li><li><strong>加强品牌营销</strong>，利用短视频、社交媒体增加品牌曝光，提高年轻用户群体认知度。</li></ol><h3 id="总结-9"><strong>总结</strong></h3><p>饿了么凭借阿里生态和补贴策略在市场上占据重要地位，但面临美团的强势竞争。未来需强化本地商家资源、优化配送体验，并拓展即时零售业务，以提升市场竞争力和用户粘性。</p><hr><h2 id="快看漫画（Kuaikan-Manhua）">快看漫画（Kuaikan Manhua）</h2><h3 id="产品概述-10"><strong>产品概述</strong></h3><p>快看漫画是中国领先的漫画内容平台，专注于正版国漫、条漫（竖屏漫画）和社区互动。平台以“轻量级、碎片化阅读”吸引年轻用户群体，并通过IP孵化、会员订阅和衍生品销售形成完整的商业生态。</p><h3 id="核心功能-10"><strong>核心功能</strong></h3><ol><li><strong>海量漫画库</strong>：涵盖原创漫画、国漫、韩漫、日漫等多种类型，满足不同用户需求。</li><li><strong>条漫模式</strong>：采用竖屏滚动阅读，适配手机端，优化用户体验。</li><li><strong>会员与付费章节</strong>：提供VIP会员模式，解锁付费章节，提高内容变现能力。</li><li><strong>互动社区</strong>：用户可以点赞、评论、发弹幕，与作者互动，增强社交属性。</li><li><strong>IP孵化与动画化</strong>：部分热门漫画改编为动画、影视作品，拓展产业链。</li><li><strong>周边商城</strong>：售卖漫画相关的周边、实体书、手办等，提升粉丝经济变现能力。</li></ol><h3 id="用户体验评估-10"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>竖屏漫画适合移动阅读，降低阅读门槛。</li><li>内容更新快，原创漫画质量较高。</li><li>互动性强，社区氛围活跃，增加用户粘性。</li></ul></li><li><strong>不足</strong>：<ul><li>部分热门漫画付费比例较高，影响免费用户体验。</li><li>版权拓展仍有待加强，日漫、欧美漫画资源相对有限。</li><li>社交功能相较于B站、微博等平台仍有提升空间。</li></ul></li></ul><h3 id="商业模式解释-10"><strong>商业模式解释</strong></h3><ol><li><strong>会员订阅</strong>：用户支付VIP费用，享受提前解锁章节、去广告等权益。</li><li><strong>章节付费</strong>：部分热门漫画采用单话或整卷付费模式，提高内容变现能力。</li><li><strong>广告投放</strong>：品牌方在漫画阅读页、社区等位置投放广告。</li><li><strong>IP孵化与授权</strong>：热门漫画改编为动画、影视作品，授权至其他平台。</li><li><strong>周边电商</strong>：销售漫画衍生产品，如手办、服饰、实体书等。</li></ol><h3 id="竞争分析-10"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>腾讯动漫</strong>（版权资源丰富，依托腾讯生态，市场份额较大）。</li><li><strong>哔哩哔哩漫画</strong>（结合B站社区，流量转化能力强）。</li><li><strong>Webtoon（韩国）</strong>（国际化运营，全球市场占有率高）。</li></ul></li><li><strong>优势</strong>：<ul><li>深耕原创国漫，培养优质创作者，内容差异化明显。</li><li>社区氛围浓厚，用户互动性高，形成独特的二次元社群。</li></ul></li><li><strong>劣势</strong>：<ul><li>付费模式仍需优化，用户对部分高价章节存有争议。</li><li>海外市场拓展较慢，相较于Webtoon等国际平台影响力较弱。</li></ul></li></ul><h3 id="运营策略-10"><strong>运营策略</strong></h3><ol><li><strong>加强版权合作</strong>：拓展日漫、欧美漫画版权，提高内容多样性。</li><li><strong>优化会员体系</strong>：调整VIP权益，提高用户付费意愿。</li><li><strong>深耕IP孵化</strong>：推动热门漫画动画化、影视化，提高品牌影响力。</li><li><strong>拓展海外市场</strong>：推出多语言版本，进军东南亚、欧美市场。</li></ol><h3 id="改进建议-10"><strong>改进建议</strong></h3><ol><li><strong>降低部分章节付费门槛</strong>，通过广告收益补贴，提高用户留存率。</li><li><strong>增加社交玩法</strong>，如漫画二创比赛、角色扮演互动，提高社区活跃度。</li><li><strong>优化推荐算法</strong>，基于用户偏好提供个性化漫画推荐，提高阅读时长。</li><li><strong>增强作者扶持计划</strong>，提供更多流量、收益分成，吸引优质创作者入驻。</li></ol><h3 id="总结-10"><strong>总结</strong></h3><p>快看漫画凭借竖屏条漫、原创内容和活跃社区，在国漫市场占据重要地位。但面对腾讯动漫、B站漫画等强势对手，需进一步优化内容策略、提升用户体验，并加速海外市场拓展，以保持竞争优势。</p><hr><h2 id="Fanbook">Fanbook</h2><h3 id="产品概述-11"><strong>产品概述</strong></h3><p>Fanbook 是一款专注于游戏玩家和兴趣社群的即时通讯平台，类似于海外的 Discord。它为游戏公会、兴趣社群、品牌社群等提供聊天、语音频道、直播、活动管理等功能，旨在帮助用户建立高粘性的互动社区。</p><h3 id="核心功能-11"><strong>核心功能</strong></h3><ol><li><strong>语音与文字聊天</strong>：支持群组聊天、语音频道、视频通话，提高社交互动体验。</li><li><strong>社群管理</strong>：提供频道分类、权限管理、机器人插件，提高社群运营效率。</li><li><strong>游戏集成</strong>：部分游戏支持官方社群，与玩家互动，提供攻略、赛事信息等。</li><li><strong>多媒体分享</strong>：支持图片、视频、文件共享，适用于游戏内容创作者。</li><li><strong>活动与日程</strong>：可设置社群活动，支持提醒、报名功能，增强社区互动。</li><li><strong>虚拟道具与奖励系统</strong>：部分社群支持积分、勋章等玩法，增强用户粘性。</li></ol><h3 id="用户体验评估-11"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>界面清爽，类 Discord 设计，易上手。</li><li>语音质量稳定，适合游戏玩家长时间使用。</li><li>机器人插件丰富，可实现自动管理、任务提醒等功能。</li></ul></li><li><strong>不足</strong>：<ul><li>生态相对封闭，国际化程度较低，主要面向国内用户。</li><li>服务器管理工具仍有优化空间，部分功能不够灵活。</li><li>用户基数不及 QQ 群、微信群等传统社交工具，增长面临挑战。</li></ul></li></ul><h3 id="商业模式解释-11"><strong>商业模式解释</strong></h3><ol><li><strong>会员订阅</strong>：提供高级会员，享受更高质量音视频、个性化装扮等功能。</li><li><strong>社群增值服务</strong>：部分社群可开通付费入群、专属内容订阅模式。</li><li><strong>品牌合作</strong>：为游戏厂商、电竞战队等提供官方社群支持，获取 B 端收益。</li><li><strong>虚拟商品</strong>：销售徽章、主题装扮、道具等，提高用户付费意愿。</li></ol><h3 id="竞争分析-11"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>Discord</strong>（国际主流，生态成熟，但在国内受限）。</li><li><strong>QQ 频道</strong>（腾讯推出的竞品，依托 QQ 生态，用户基数庞大）。</li><li><strong>微信群、贴吧、B站动态</strong>（用户已形成习惯，社交迁移成本较高）。</li></ul></li><li><strong>优势</strong>：<ul><li>目标用户精准，聚焦游戏社群，互动体验优于传统社交平台。</li><li>语音与社群功能结合紧密，适合高粘性用户运营。</li></ul></li><li><strong>劣势</strong>：<ul><li>市场认知度较低，需要更多品牌推广。</li><li>生态封闭，缺少第三方应用接入，扩展性受限。</li></ul></li></ul><h3 id="运营策略-11"><strong>运营策略</strong></h3><ol><li><strong>加强游戏合作</strong>：与热门游戏、电竞战队合作，推广官方社群，提高品牌曝光。</li><li><strong>优化社群管理工具</strong>：提供更智能的管理插件，吸引公会、公会主积极运营。</li><li><strong>拓展内容创作者市场</strong>：吸引游戏主播、KOL 入驻，打造高质量社群内容。</li><li><strong>探索海外市场</strong>：学习 Discord 经验，布局东南亚等游戏活跃市场。</li></ol><h3 id="改进建议-11"><strong>改进建议</strong></h3><ol><li><strong>增加 API 开放能力</strong>，支持开发者接入更多插件，提高扩展性。</li><li><strong>优化移动端体验</strong>，提升推送机制，增强用户活跃度。</li><li><strong>加强 AI 管理功能</strong>，提供自动过滤、关键词检测等，优化社群质量。</li><li><strong>推出激励机制</strong>，如活跃积分、任务奖励，提高用户贡献度。</li></ol><h3 id="总结-11"><strong>总结</strong></h3><p>Fanbook 作为国内版 Discord，具备较强的游戏社群运营能力，但面临用户增长和市场认知挑战。未来需要通过游戏厂商合作、优化社群体验、拓展国际市场等方式提升竞争力。</p><hr><h2 id="腾讯会议（VooV-Meeting）">腾讯会议（VooV Meeting）</h2><h3 id="产品概述-12"><strong>产品概述</strong></h3><p>腾讯会议（VooV Meeting）是腾讯推出的云视频会议平台，支持远程办公、线上教育、企业协作等场景。凭借腾讯云的强大技术支持，腾讯会议在稳定性、易用性和智能化方面具有明显优势，是国内市场上最受欢迎的视频会议软件之一。</p><h3 id="核心功能-12"><strong>核心功能</strong></h3><ol><li><strong>高清视频会议</strong>：支持1080P高清画质，提供智能降噪、虚拟背景等增强体验功能。</li><li><strong>屏幕共享</strong>：支持多人实时共享屏幕，适用于演示、教学和远程协作。</li><li><strong>AI智能功能</strong>：提供智能会议纪要、自动生成字幕，提高会议效率。</li><li><strong>多终端适配</strong>：支持Windows、Mac、iOS、Android及Web端，兼容性强。</li><li><strong>会议管理</strong>：支持主持人权限管理、会议锁定、录制存档等功能。</li><li><strong>企业级安全保障</strong>：提供端到端加密、企业专属会议链接，保障数据安全。</li></ol><h3 id="用户体验评估-12"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>会议稳定性高，音视频质量优越。</li><li>操作简单，界面清爽，适合各类用户。</li><li>结合微信、企业微信，可实现无缝协同，提高工作效率。</li></ul></li><li><strong>不足</strong>：<ul><li>免费版会议时间有限，部分高级功能需付费解锁。</li><li>会议录制存储受限，需要额外购买云存储空间。</li><li>相较于Zoom等国际产品，海外市场影响力较低。</li></ul></li></ul><h3 id="商业模式解释-12"><strong>商业模式解释</strong></h3><ol><li><strong>基础版免费</strong>：个人用户可免费使用基本会议功能，但有时长和人数限制。</li><li><strong>企业版订阅</strong>：企业用户可付费解锁更长会议时长、更多参会人数及高级功能。</li><li><strong>云存储与增值服务</strong>：提供会议录制存储、AI会议纪要等增值服务。</li><li><strong>SaaS集成</strong>：与企业微信、腾讯文档等协同办公工具深度集成，提升企业用户粘性。</li></ol><h3 id="竞争分析-12"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>钉钉会议</strong>（阿里系，深度绑定钉钉生态，企业客户多）。</li><li><strong>飞书会议</strong>（字节跳动旗下，国际化能力较强）。</li><li><strong>Zoom</strong>（全球领先的视频会议软件，海外市场占有率高）。</li></ul></li><li><strong>优势</strong>：<ul><li>依托腾讯云和微信生态，用户获取成本低，市场渗透率高。</li><li>会议稳定性和音视频质量优于多数竞品，适合大规模会议。</li></ul></li><li><strong>劣势</strong>：<ul><li>付费商业化模式仍在探索，盈利能力需进一步提升。</li><li>在国际市场的竞争力较弱，难以对抗Zoom等成熟产品。</li></ul></li></ul><h3 id="运营策略-12"><strong>运营策略</strong></h3><ol><li><strong>优化商业化路径</strong>：推出更多细分订阅方案，满足不同企业用户需求。</li><li><strong>强化AI智能功能</strong>：优化自动会议纪要、语音转录，提高会议效率。</li><li><strong>拓展海外市场</strong>：提升多语言支持能力，加强与国际企业的合作。</li><li><strong>深度整合腾讯生态</strong>：增强与企业微信、腾讯文档的协同，提高产品粘性。</li></ol><h3 id="改进建议-12"><strong>改进建议</strong></h3><ol><li><strong>增加免费版权益</strong>，提高用户转化率，如适度延长免费会议时长。</li><li><strong>优化海外体验</strong>，提升跨国会议的网络稳定性和多语言支持。</li><li><strong>加强互动功能</strong>，如虚拟白板、投票系统，提高会议的互动性。</li><li><strong>推出行业定制版</strong>，为教育、医疗、金融等行业提供专属优化方案。</li></ol><h3 id="总结-12"><strong>总结</strong></h3><p>腾讯会议凭借稳定的技术、流畅的体验和腾讯生态支持，在国内视频会议市场占据领先地位。未来需持续优化商业化模式、增强AI智能功能，并积极拓展海外市场，以提升全球竞争力。</p><hr><h2 id="淘宝逛逛">淘宝逛逛</h2><h3 id="产品概述-13"><strong>产品概述</strong></h3><p>淘宝逛逛是阿里巴巴旗下淘宝平台推出的内容种草社区，类似于小红书，旨在通过短视频、图文笔记等内容吸引用户，并促进电商转化。淘宝逛逛不仅是一个信息流内容平台，还结合了淘宝购物场景，打通了“内容种草—兴趣探索—下单购买”的闭环。</p><h3 id="核心功能-13"><strong>核心功能</strong></h3><ol><li><strong>短视频+图文种草</strong>：商家、达人、普通用户可以发布产品测评、穿搭、美妆等内容。</li><li><strong>一键购买</strong>：用户在浏览种草内容时，可直接跳转至商品详情页并完成购买。</li><li><strong>个性化推荐</strong>：基于用户浏览、收藏、购买行为，推荐相关内容。</li><li><strong>社交互动</strong>：用户可以点赞、评论、关注达人，并加入话题讨论。</li><li><strong>创作者激励</strong>：提供流量扶持和佣金机制，吸引内容创作者加入。</li></ol><h3 id="用户体验评估-13"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>电商与内容深度融合</strong>，降低购物决策成本，增强购买冲动。</li><li><strong>淘宝生态流量支持</strong>，与淘宝首页、搜索等入口联动，流量充足。</li><li><strong>推荐算法精准</strong>，基于用户购买行为优化内容分发，提高转化率。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>社区氛围较弱</strong>，相比小红书，用户主要以购买为目的，互动性偏低。</li><li><strong>内容创作者质量参差不齐</strong>，部分内容过度营销，影响用户信任度。</li><li><strong>独立品牌认知度较低</strong>，部分用户对淘宝逛逛的认知度不及抖音、小红书等内容平台。</li></ul></li></ul><h3 id="商业模式解释-13"><strong>商业模式解释</strong></h3><ol><li><strong>商品转化佣金</strong>：商家为推广内容提供佣金，内容创作者可获得分成。</li><li><strong>品牌广告投放</strong>：品牌可投放信息流广告，提高曝光率。</li><li><strong>达人带货</strong>：KOL 通过种草内容带货，淘宝收取平台服务费。</li><li><strong>会员权益</strong>：未来可能探索会员订阅模式，如提供独家折扣、专属内容等。</li></ol><h3 id="竞争分析-13"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>小红书</strong>（主打UGC种草，社区氛围更强，用户信任度较高）。</li><li><strong>抖音种草+电商</strong>（短视频带货更具吸引力，算法分发能力更强）。</li><li><strong>京东种草社区</strong>（主要面向高性价比消费人群，适合3C、家电类商品）。</li></ul></li><li><strong>优势</strong>：<ul><li>依托淘宝生态，流量和供应链优势明显。</li><li>内容转化效率高，减少购买路径，提高下单率。</li></ul></li><li><strong>劣势</strong>：<ul><li>缺乏社交属性，用户停留时间短，复购率较依赖商品本身。</li><li>过度商业化内容影响社区信任度，需优化内容审核机制。</li></ul></li></ul><h3 id="运营策略-13"><strong>运营策略</strong></h3><ol><li><strong>增强社区互动</strong>：鼓励用户分享购物心得，推出“购物问答”“达人挑战”等玩法。</li><li><strong>优化内容推荐</strong>：减少低质量广告内容，提高真实用户体验分享的权重。</li><li><strong>提升创作者激励</strong>：推出达人分级体系，给予优质创作者更多流量扶持。</li><li><strong>探索多元变现</strong>：如推出直播带货、品牌联合营销，提高收入来源。</li></ol><h3 id="改进建议-13"><strong>改进建议</strong></h3><ol><li><strong>提升内容质量</strong>，加强KOL审核机制，防止过度营销和虚假宣传。</li><li><strong>优化购物体验</strong>，推出“真实买家评价”功能，增强用户信任感。</li><li><strong>增加社交属性</strong>，鼓励用户之间的讨论和分享，提高社区活跃度。</li><li><strong>打破淘宝体系封闭性</strong>，尝试与微信、微博等社交平台联动，提高品牌曝光。</li></ol><h3 id="总结-13"><strong>总结</strong></h3><p>淘宝逛逛作为淘宝内容电商的一部分，具备强大的供应链和流量支持，但仍需优化社区氛围，提高用户互动性，并完善创作者体系，以增强用户粘性和平台竞争力。</p><hr><h2 id="哔哩哔哩漫画（Bilibili-Manga）">哔哩哔哩漫画（Bilibili Manga）</h2><h3 id="产品概述-14"><strong>产品概述</strong></h3><p>哔哩哔哩漫画是 B 站旗下的正版在线漫画平台，专注于提供高质量的日漫、国漫、韩漫等多元内容。作为 B 站二次元生态的一部分，B 站漫画通过动画、漫画、游戏（ACG）联动，吸引核心二次元用户，同时探索付费阅读模式，提高内容变现能力。</p><h3 id="核心功能-14"><strong>核心功能</strong></h3><ol><li><strong>正版漫画阅读</strong>：涵盖日漫（如《鬼灭之刃》）、国漫（如《镇魂街》）、韩漫等丰富作品。</li><li><strong>付费章节与会员模式</strong>：提供单话购买、VIP 畅读、限免等模式，满足不同用户需求。</li><li><strong>弹幕互动</strong>：支持漫画阅读时发送弹幕，增强社交体验。</li><li><strong>个性化推荐</strong>：基于用户阅读偏好推荐相关漫画，提高用户粘性。</li><li><strong>多端同步</strong>：支持 PC、移动端同步阅读，提升用户体验。</li></ol><h3 id="用户体验评估-14"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>正版资源丰富</strong>，尤其在日漫授权方面比国内其他平台更具优势。</li><li><strong>与 B 站生态结合</strong>，二次元用户基础稳固，转化率较高。</li><li><strong>弹幕+社区互动</strong>，增强用户沉浸感，提高讨论氛围。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>付费模式较复杂</strong>，部分用户反馈单话付费成本较高。</li><li><strong>功能较单一</strong>，缺乏如 Webtoon（条漫）或 AI 语音朗读等创新玩法。</li><li><strong>推广力度有限</strong>，知名度仍逊色于腾讯动漫、快看漫画等头部平台。</li></ul></li></ul><h3 id="商业模式解释-14"><strong>商业模式解释</strong></h3><ol><li><strong>会员订阅</strong>：付费会员可解锁特定漫画、享受折扣等权益。</li><li><strong>单话购买</strong>：用户可按章节或整卷购买漫画，提高付费灵活度。</li><li><strong>广告收入</strong>：包括信息流广告、品牌合作推广等模式。</li><li><strong>IP 授权与周边衍生</strong>：通过动画、周边产品、游戏联动，形成完整商业闭环。</li></ol><h3 id="竞争分析-14"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>腾讯动漫</strong>（IP 储备丰富，用户基数庞大，付费用户转化率高）。</li><li><strong>快看漫画</strong>（主打条漫，社区运营强，用户互动活跃）。</li><li><strong>哔哩哔哩本体</strong>（部分动画党更倾向于看动画而非漫画）。</li></ul></li><li><strong>优势</strong>：<ul><li>强调正版授权，尤其在日漫领域具备较强竞争力。</li><li>依托 B 站生态，用户更易接受二次元付费模式。</li></ul></li><li><strong>劣势</strong>：<ul><li>商业化程度仍在探索，盈利模式有待优化。</li><li>缺乏创新互动玩法，相比快看漫画等，用户参与感较低。</li></ul></li></ul><h3 id="运营策略-14"><strong>运营策略</strong></h3><ol><li><strong>优化付费模式</strong>：推出更灵活的订阅方案，如按月无限阅读等，提升用户留存率。</li><li><strong>加强社区运营</strong>：利用 B 站弹幕文化，鼓励用户讨论、创作漫画相关内容。</li><li><strong>拓展国际市场</strong>：吸引海外二次元用户，提升全球影响力。</li><li><strong>增加 AI 互动功能</strong>：如 AI 配音、个性化漫画推荐，提升用户体验。</li></ol><h3 id="改进建议-14"><strong>改进建议</strong></h3><ol><li><strong>降低新用户门槛</strong>，提供更多限免阅读机会，提高转化率。</li><li><strong>推出 Webtoon 版块</strong>，迎合短篇快读的移动端用户需求。</li><li><strong>增强 IP 生态联动</strong>，推动热门漫画动画化、游戏化，提高用户粘性。</li><li><strong>优化推荐算法</strong>，让用户更精准找到符合口味的漫画，提高阅读时长。</li></ol><h3 id="总结-14"><strong>总结</strong></h3><p>哔哩哔哩漫画凭借 B 站生态和正版日漫资源，在国内漫画市场具备竞争力。但要在腾讯动漫、快看漫画等对手环伺的市场中突围，需要优化付费模式、增强互动玩法，并探索 IP 变现的新可能性，以提升长期市场竞争力。</p><hr><h2 id="Soul">Soul</h2><h3 id="产品概述-15"><strong>产品概述</strong></h3><p>Soul 是一款主打“灵魂社交”的陌生人社交应用，区别于传统基于颜值或熟人关系的社交软件。Soul 采用兴趣匹配、性格测试和 AI 算法推荐，为用户提供轻松、无压力的社交体验。目标群体以 90 后、00 后的年轻用户为主，强调情感交流和精神共鸣，而非单纯的约会或熟人社交。</p><h3 id="核心功能-15"><strong>核心功能</strong></h3><ol><li><strong>灵魂匹配</strong>：基于兴趣、性格测试和 AI 推荐，匹配志同道合的用户。</li><li><strong>瞬间广场</strong>：用户可发布短内容（文字、图片、语音），与陌生人互动。</li><li><strong>语音群聊</strong>：提供多人实时语音房间，增强沉浸式社交体验。</li><li><strong>3D Avatar 捏脸</strong>：用户可创建个性化虚拟形象，降低真人社交的焦虑感。</li><li><strong>游戏互动</strong>：提供小游戏，如你画我猜、真心话大冒险等，提高互动率。</li><li><strong>匿名社交</strong>：用户可以不透露真实信息，在安全的环境中自由表达。</li></ol><h3 id="用户体验评估-15"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>低压力社交</strong>，降低了颜值焦虑和现实社交负担。</li><li><strong>兴趣匹配精准</strong>，基于 AI 推荐，匹配度较高，提高用户留存率。</li><li><strong>互动形式多样</strong>，涵盖文字、语音、游戏等多种交流方式。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>虚假身份风险</strong>，匿名社交易被部分用户滥用，可能涉及欺诈或不良内容。</li><li><strong>变现能力有限</strong>，相较于传统社交软件，商业化模式仍在探索。</li><li><strong>用户粘性挑战</strong>，陌生人社交的生命周期短，如何提升长期留存是难题。</li></ul></li></ul><h3 id="商业模式解释-15"><strong>商业模式解释</strong></h3><ol><li><strong>会员订阅</strong>：提供 VIP 会员，解锁更多匹配机会、高级聊天功能等。</li><li><strong>虚拟道具</strong>：用户可购买虚拟礼物、Avatar 服饰等，增加个性化体验。</li><li><strong>品牌广告</strong>：部分品牌可在 Soul 内投放广告，如主题语音房、品牌 IP 合作等。</li><li><strong>语音打赏</strong>：用户在语音房互动时可进行打赏，平台抽取分成。</li></ol><h3 id="竞争分析-15"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>探探</strong>（基于颜值匹配，偏向恋爱社交）。</li><li><strong>陌陌</strong>（主打附近人+直播打赏，商业化能力强）。</li><li><strong>Zepeto</strong>（全球虚拟形象社交，3D Avatar 玩法领先）。</li></ul></li><li><strong>优势</strong>：<ul><li><strong>“灵魂匹配”差异化定位</strong>，吸引年轻用户追求情感共鸣。</li><li><strong>虚拟形象与游戏互动</strong>，降低传统社交压力，增强趣味性。</li></ul></li><li><strong>劣势</strong>：<ul><li><strong>市场认知度仍需提升</strong>，与探探、陌陌等成熟社交软件相比，渗透率较低。</li><li><strong>商业化能力较弱</strong>，用户愿意为虚拟社交付费的意愿仍需培养。</li></ul></li></ul><h3 id="运营策略-15"><strong>运营策略</strong></h3><ol><li><strong>优化匹配算法</strong>：提升 AI 推荐精准度，提高用户匹配成功率和聊天转化率。</li><li><strong>强化内容审核</strong>：防止虚假身份和不良内容，提升用户信任度。</li><li><strong>拓展海外市场</strong>：借鉴 Zepeto 模式，针对日韩市场推出本地化版本。</li><li><strong>探索直播+电商</strong>：引入直播带货、虚拟 KOL 等商业化模式，提高变现能力。</li></ol><h3 id="改进建议-15"><strong>改进建议</strong></h3><ol><li><strong>提升用户粘性</strong>，增加签到、连续匹配奖励等机制，鼓励长期使用。</li><li><strong>优化虚拟形象玩法</strong>，推出 AI 捏脸、个性化 Avatar 互动，提高趣味性。</li><li><strong>拓展线下社交</strong>，与活动品牌合作，举办线下见面会，增强真实社交转化。</li><li><strong>增强 AI 互动体验</strong>，推出智能聊天助手，引导新用户快速融入社群。</li></ol><h3 id="总结-15"><strong>总结</strong></h3><p>Soul 在陌生人社交市场中占据独特定位，强调兴趣匹配和低压力社交体验。然而，其面临用户粘性低、商业化能力不足等挑战，未来需优化推荐算法、拓展海外市场，并引入更多变现手段，以提升长期竞争力。</p><hr><h2 id="番茄小说（Tomato-Novel）">番茄小说（Tomato Novel）</h2><h3 id="产品概述-16"><strong>产品概述</strong></h3><p>番茄小说是字节跳动旗下的一款免费网络小说阅读平台，采用“免费阅读+广告变现”模式，依托字节的算法推荐技术，为用户提供个性化阅读体验。与传统付费小说平台不同，番茄小说通过广告收益为作者和平台创收，降低用户的阅读成本，吸引大量下沉市场用户。</p><h3 id="核心功能-16"><strong>核心功能</strong></h3><ol><li><strong>免费小说阅读</strong>：全站小说免费，用户通过观看广告解锁章节。</li><li><strong>个性化推荐</strong>：基于字节跳动的推荐算法，提供精准的内容推荐，提高用户留存率。</li><li><strong>听书模式</strong>：支持AI朗读，为用户提供更便捷的阅读方式。</li><li><strong>作者平台</strong>：开放创作平台，提供流量扶持、收益分成，鼓励更多创作者加入。</li><li><strong>社区互动</strong>：用户可在书评区发表评论、点赞、讨论，提高社群氛围。</li><li><strong>任务奖励体系</strong>：用户通过签到、阅读时长等任务获得金币奖励，可兑换现金或用于小说解锁。</li></ol><h3 id="用户体验评估-16"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>免费模式降低阅读门槛</strong>，吸引更多用户，尤其是下沉市场用户。</li><li><strong>推荐算法精准</strong>，有效提升用户阅读体验和留存率。</li><li><strong>广告形式相对克制</strong>，不会过度干扰阅读体验。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>内容质量参差不齐</strong>，部分作品质量较低，缺乏优质IP。</li><li><strong>广告依赖较重</strong>，长时间阅读需要频繁观看广告，可能影响体验。</li><li><strong>与传统付费阅读用户群体存在割裂</strong>，难以吸引高消费意愿用户。</li></ul></li></ul><h3 id="商业模式解释-16"><strong>商业模式解释</strong></h3><ol><li><strong>广告变现</strong>：通过信息流广告、激励视频广告、小说插页广告等方式盈利。</li><li><strong>VIP 订阅</strong>：部分高级功能或去广告服务可能通过会员订阅提供。</li><li><strong>打赏与付费内容</strong>：用户可对作者进行打赏，部分小说可能采用付费解锁模式。</li><li><strong>IP 授权</strong>：优秀小说可能孵化为影视、动漫、游戏等，形成IP变现。</li></ol><h3 id="竞争分析-16"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>阅文集团（QQ 阅读、起点）</strong>：传统付费小说模式，IP资源丰富，用户忠诚度高。</li><li><strong>米读小说</strong>：与番茄小说类似，采用免费+广告模式，但市场份额较小。</li><li><strong>掌阅、七猫小说</strong>：各具特色，掌阅偏向中高端用户，七猫主攻免费市场。</li></ul></li><li><strong>优势</strong>：<ul><li>依托字节跳动的流量和算法优势，获客成本较低，用户增长迅速。</li><li>免费模式适应下沉市场需求，降低用户进入门槛。</li></ul></li><li><strong>劣势</strong>：<ul><li>缺乏头部IP，难以形成长期稳定的付费生态。</li><li>主要依赖广告盈利，模式相对单一，面临政策和市场风险。</li></ul></li></ul><h3 id="运营策略-16"><strong>运营策略</strong></h3><ol><li><strong>优化内容生态</strong>：加大对优质原创内容的扶持，提高整体小说质量。</li><li><strong>提升广告体验</strong>：减少低质量广告，优化广告展示频率，提高用户接受度。</li><li><strong>加强IP孵化</strong>：与影视、动漫行业合作，打造番茄小说的原创IP，提高品牌影响力。</li><li><strong>拓展海外市场</strong>：学习Webnovel模式，尝试进军东南亚、欧美市场。</li></ol><h3 id="改进建议-16"><strong>改进建议</strong></h3><ol><li><strong>增加更多高质量原创作品</strong>，吸引更广泛的用户群体。</li><li><strong>提供更多个性化阅读模式</strong>，如夜间模式、个性化字体调整等，提高用户体验。</li><li><strong>引入社交玩法</strong>，如读书会、PK 排行榜，提高用户互动性和粘性。</li><li><strong>探索新的商业模式</strong>，如会员增值服务、付费去广告模式，提高收入多样性。</li></ol><h3 id="总结-16"><strong>总结</strong></h3><p>番茄小说凭借免费模式和精准推荐，在网络小说市场占据了一席之地，但仍需优化内容质量、拓展盈利模式，并加强IP孵化，才能实现长期可持续发展。</p><hr><h2 id="菜鸟裹裹（Cainiao-Guoguo）">菜鸟裹裹（Cainiao Guoguo）</h2><h3 id="产品概述-17"><strong>产品概述</strong></h3><p>菜鸟裹裹是阿里巴巴集团旗下的智能物流平台，专注于快递寄件、包裹查询、物流服务优化等功能。作为中国领先的快递管理应用，菜鸟裹裹与各大快递公司合作，为用户提供一站式的快递管理体验，提升物流透明度和便捷性。</p><h3 id="核心功能-17"><strong>核心功能</strong></h3><ol><li><strong>快递寄件</strong>：支持上门取件，用户可一键下单，选择快递公司，享受优惠价格。</li><li><strong>包裹查询</strong>：自动同步淘宝、天猫、京东等购物平台订单，实时追踪物流信息。</li><li><strong>智能通知</strong>：支持快递状态推送，包括发货、派送、签收等提醒。</li><li><strong>退换货便捷寄件</strong>：集成电商退货流程，提供便捷的逆向物流解决方案。</li><li><strong>菜鸟驿站服务</strong>：支持快递代收点查询，提供包裹存放、代取服务。</li><li><strong>会员权益</strong>：开通会员可享受寄件折扣、运费险、优先客服等增值服务。</li></ol><h3 id="用户体验评估-17"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>全网快递整合</strong>，用户可统一管理多个快递公司的包裹信息。</li><li><strong>上门取件服务便捷</strong>，解决传统快递点排队寄件的痛点。</li><li><strong>深度整合阿里生态</strong>，淘宝、天猫订单可自动同步，减少手动录入操作。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>快递价格波动较大</strong>，不同地区、不同时间价格不够稳定。</li><li><strong>对非阿里系电商的适配性较弱</strong>，部分非淘宝用户的体验不够流畅。</li><li><strong>部分地区寄件覆盖不足</strong>，特别是县城、乡村的快递上门服务仍需优化。</li></ul></li></ul><h3 id="商业模式解释-17"><strong>商业模式解释</strong></h3><ol><li><strong>快递佣金</strong>：与各大快递公司合作，通过寄件订单抽取佣金。</li><li><strong>会员订阅</strong>：推出菜鸟会员，提供运费折扣、专属客服、保险等增值服务。</li><li><strong>广告收入</strong>：快递详情页、订单页展示物流公司推广、快递优惠券等广告。</li><li><strong>企业物流解决方案</strong>：为电商、商家提供批量寄件、仓储管理、供应链优化等服务。</li></ol><h3 id="竞争分析-17"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>顺丰速运</strong>（主打高端快递服务，速度快但价格高）。</li><li><strong>京东物流</strong>（整合京东自营电商体系，履约时效性强）。</li><li><strong>多多买菜</strong>（社区团购+物流整合）（针对下沉市场，形成强竞争力）。</li></ul></li><li><strong>优势</strong>：<ul><li>阿里生态支撑，淘宝、天猫订单可无缝衔接，提高用户粘性。</li><li>全网快递覆盖，用户可选择不同快递公司，灵活性更强。</li></ul></li><li><strong>劣势</strong>：<ul><li>快递体验受制于第三方物流公司，难以做到像顺丰、京东物流那样的强控制力。</li><li>商业化模式仍有优化空间，相比顺丰、京东的直营模式，菜鸟裹裹的盈利模式较分散。</li></ul></li></ul><h3 id="运营策略-17"><strong>运营策略</strong></h3><ol><li><strong>优化快递价格体系</strong>：与各大快递公司协商统一的折扣定价，提高用户留存。</li><li><strong>提升非淘宝电商适配性</strong>：加强与拼多多、京东等平台的合作，拓展用户覆盖面。</li><li><strong>强化下沉市场布局</strong>：在乡镇地区增加快递服务站，提高寄件覆盖率。</li><li><strong>增强智能推荐</strong>：基于用户订单习惯推荐最优快递方案，提高转化率。</li></ol><h3 id="改进建议-17"><strong>改进建议</strong></h3><ol><li><strong>优化快递时效预测</strong>，提高物流信息准确度，减少用户等待焦虑。</li><li><strong>增加AI客服功能</strong>，提升用户咨询、问题处理效率。</li><li><strong>推出个性化物流保险</strong>，如针对贵重物品的特别保障，提高用户信任度。</li><li><strong>强化跨境物流能力</strong>，优化国际寄件服务，拓展全球用户群。</li></ol><h3 id="总结-17"><strong>总结</strong></h3><p>菜鸟裹裹凭借阿里生态和全网快递整合能力，在物流管理领域占据领先地位。未来可通过优化价格策略、提升用户体验、强化下沉市场布局和拓展国际化业务，进一步增强市场竞争力。</p><hr><h2 id="BOSS-直聘">BOSS 直聘</h2><h3 id="产品概述-18"><strong>产品概述</strong></h3><p>BOSS 直聘是一款创新的招聘平台，主打“求职者与企业BOSS直接沟通”模式，颠覆了传统招聘网站需要经过HR筛选再安排面试的流程。通过即时聊天、智能匹配和简历推荐，提高招聘效率，尤其受到互联网、科技公司及初创企业的青睐。</p><h3 id="核心功能-18"><strong>核心功能</strong></h3><ol><li><strong>直接聊天</strong>：求职者可直接与企业招聘负责人（甚至是CEO）交流，提高信息对称性。</li><li><strong>智能匹配</strong>：基于 AI 推荐职位和人才，提高岗位匹配精准度。</li><li><strong>极速入职</strong>：简化投递、筛选、面试流程，缩短招聘周期。</li><li><strong>企业认证</strong>：通过企业资质审核，提升招聘岗位的可信度。</li><li><strong>隐私保护</strong>：求职者可隐藏当前公司，防止被现公司 HR 发现。</li></ol><h3 id="用户体验评估-18"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>沟通链路短</strong>，求职者可直接与招聘方对话，提高效率。</li><li><strong>推荐精准</strong>，智能匹配减少无效投递，提高转化率。</li><li><strong>适合互联网和新兴行业</strong>，更契合快速招聘需求的公司。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>刷量和虚假岗位问题</strong>，部分企业或中介滥用平台资源，影响用户体验。</li><li><strong>传统行业覆盖度较低</strong>，部分大型企业仍倾向于使用猎头或传统招聘平台。</li><li><strong>求职者质量参差不齐</strong>，部分岗位匹配的候选人能力与岗位需求存在较大差距。</li></ul></li></ul><h3 id="商业模式解释-18"><strong>商业模式解释</strong></h3><ol><li><strong>企业会员收费</strong>：企业购买招聘套餐，解锁更多简历浏览、沟通次数。</li><li><strong>广告推广</strong>：企业可付费提升职位曝光度，吸引更多求职者。</li><li><strong>增值服务</strong>：如人才测评、简历优化、职位精准推荐等，提高招聘效率。</li></ol><h3 id="竞争分析-18"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>前程无忧（51Job）</strong>：传统招聘网站，覆盖行业广但响应速度较慢。</li><li><strong>智联招聘</strong>：主流招聘网站，求职者基数大，但企业沟通效率较低。</li><li><strong>猎聘</strong>：专注中高端人才招聘，但收费较高，主要针对管理层岗位。</li><li><strong>拉勾网</strong>：专注互联网行业，但市场份额不及 BOSS 直聘。</li></ul></li><li><strong>优势</strong>：<ul><li>直接沟通机制提升招聘效率，符合互联网公司快节奏需求。</li><li>AI 匹配精准度较高，减少 HR 和求职者的时间成本。</li></ul></li><li><strong>劣势</strong>：<ul><li>传统行业、大型企业接受度较低，市场拓展受限。</li><li>仍存在较多低质量职位，影响平台公信力。</li></ul></li></ul><h3 id="运营策略-18"><strong>运营策略</strong></h3><ol><li><strong>加强职位审核</strong>：提升企业入驻门槛，减少虚假岗位，提高求职体验。</li><li><strong>拓展中高端市场</strong>：针对中高端岗位提供猎头服务，提高付费企业用户量。</li><li><strong>优化 AI 匹配系统</strong>：减少低质量推荐，提高企业和求职者的匹配精准度。</li><li><strong>加强品牌建设</strong>：通过行业案例宣传，提高传统行业对 BOSS 直聘模式的接受度。</li></ol><h3 id="改进建议-18"><strong>改进建议</strong></h3><ol><li><strong>优化用户筛选机制</strong>，提高职位与候选人匹配的精准度。</li><li><strong>推出行业专场招聘会</strong>，针对金融、制造业等传统行业提高渗透率。</li><li><strong>加强求职者职业成长服务</strong>，如在线课程、职业规划咨询，提高用户粘性。</li><li><strong>提供企业评级系统</strong>，让求职者更直观了解公司的真实情况，提高平台透明度。</li></ol><h3 id="总结-18"><strong>总结</strong></h3><p>BOSS 直聘通过“直接沟通+智能匹配”的模式改变了传统招聘流程，在互联网行业具有明显优势。但未来需优化企业审核、扩展行业覆盖面，并提高职位与人才匹配精准度，以保持市场竞争力。</p><hr><h2 id="夸克扫描王（Quark-Scanner）">夸克扫描王（Quark Scanner）</h2><h3 id="产品概述-19"><strong>产品概述</strong></h3><p>夸克扫描王是夸克推出的一款移动端文档扫描工具，定位为高效办公、学习辅助工具，功能包括拍照扫描、文档识别、文字提取、PDF转换等。它依托阿里系 AI 能力，主打“无广告、极简高效”，是夸克在生产力工具领域布局的重要一环。</p><h3 id="核心功能-19"><strong>核心功能</strong></h3><ol><li><strong>文档扫描与拍照识别</strong>：支持自动识别纸质文档边缘，进行清晰扫描。</li><li><strong>OCR文字识别</strong>：支持中英日韩等多语种文字识别，准确率高。</li><li><strong>PDF 生成与转换</strong>：可将图片、扫描件一键导出为PDF或图片格式。</li><li><strong>批量扫描 &amp; 文件管理</strong>：支持批量扫描和文档分类管理，适合学生与职场用户。</li><li><strong>AI增强模式</strong>：支持去阴影、增强清晰度等功能，提高阅读和打印体验。</li><li><strong>云同步</strong>：与夸克网盘打通，支持文件云端同步与备份。</li></ol><h3 id="用户体验评估-19"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>界面极简无广告</strong>，对比主流竞品更加干净清爽。</li><li><strong>OCR 准确率高</strong>，识别速度快，适合文字较多或复杂的文档。</li><li><strong>文件导出灵活</strong>，支持多格式分享，使用便捷。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>高级功能需登录夸克账号</strong>，用户门槛稍高。</li><li><strong>功能较轻量化</strong>，对比有道、扫描全能王在企业场景下功能深度不足。</li><li><strong>平台依赖阿里生态</strong>，对非阿里用户黏性较低。</li></ul></li></ul><h3 id="商业模式解释-19"><strong>商业模式解释</strong></h3><ol><li><strong>免费+会员制</strong>：基础功能免费，高级功能（如批量OCR、PDF合并）需开通会员。</li><li><strong>夸克生态导流</strong>：通过扫描工具引导用户使用夸克搜索、云盘等服务，形成生态闭环。</li><li><strong>教育合作</strong>：为学生群体提供作业扫描、错题整理服务，与教育产品联动变现。</li><li><strong>企业场景延伸</strong>：未来可能接入阿里云文档、钉钉，实现To B 服务变现。</li></ol><h3 id="竞争分析-19"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>扫描全能王</strong>（功能全面但广告多，收费较高）。</li><li><strong>WPS 扫描</strong>（强办公属性，依赖WPS生态）。</li><li><strong>有道云笔记扫描</strong>（学习场景更强，但办公场景薄弱）。</li></ul></li><li><strong>优势</strong>：<ul><li>体验极简、无广告，用户好感度高。</li><li>与夸克搜索、网盘联动紧密，适合轻度办公和学生人群。</li></ul></li><li><strong>劣势</strong>：<ul><li>高级功能较少，缺乏企业级文档流程整合。</li><li>商业化模式不够丰富，营收潜力尚未完全释放。</li></ul></li></ul><h3 id="运营策略-19"><strong>运营策略</strong></h3><ol><li><strong>强化学生市场</strong>：推出作业整理、错题扫描、一键打印等工具，扩大教育场景使用率。</li><li><strong>整合B端协作场景</strong>：接入钉钉、阿里云文档，拓展企业用户。</li><li><strong>优化会员体验</strong>：增加OCR语言支持、手写识别、PDF编辑等高阶功能，提升付费意愿。</li><li><strong>布局海外市场</strong>：推出国际版本，扩展OCR多语种能力，对标 Adobe Scan、CamScanner。</li></ol><h3 id="改进建议-19"><strong>改进建议</strong></h3><ol><li><strong>引入AI学习助手</strong>，实现扫描→识别→理解的自动化流程。</li><li><strong>增强文档安全与加密功能</strong>，满足政企级用户的合规需求。</li><li><strong>提升PDF编辑能力</strong>，如加签名、批注、合并等，拓展专业用户群。</li><li><strong>社交分享一键分发</strong>，提升协作效率，例如扫码导出到微信群/钉钉群。</li></ol><h3 id="总结-19"><strong>总结</strong></h3><p>夸克扫描王在极简、无广告、AI识别准确度方面表现亮眼，是阿里在信息工具类产品中的一颗潜力股。若能进一步打磨功能、深化生态协同并完善商业化路径，有望成为中国用户最喜爱的文档扫描工具之一。</p><hr><h2 id="灵感岛（InspIsland）">灵感岛（InspIsland）</h2><h3 id="产品概述-20"><strong>产品概述</strong></h3><p>灵感岛是一款主打“灵感收集与创意管理”的轻量级笔记/知识管理类应用，主要服务于创意工作者、学生以及内容创作者群体。它试图在效率工具泛滥的当下，以“极简但有趣”的方式，重新定义灵感捕捉，帮助用户随时记录、沉淀并触发创意。</p><h3 id="核心功能-20"><strong>核心功能</strong></h3><ol><li><strong>灵感卡片系统</strong>：每条笔记以卡片形式呈现，支持图文、链接、标签等元素。</li><li><strong>灵感瀑布流</strong>：采用时间轴+随机卡片展示机制，打破线性记录，刺激回忆与联想。</li><li><strong>标签与分组系统</strong>：提供灵感归类、关键词组织功能，支持多维度管理。</li><li><strong>跨设备同步</strong>：支持 iOS、Android、Web，确保灵感在多平台无缝同步。</li><li><strong>灵感探索区</strong>：推荐他人公开卡片、每日灵感主题，引导用户主动探索创意触发点。</li></ol><h3 id="用户体验评估-20"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>极简清爽的 UI，操作流畅，记录门槛极低，真正做到了“想到即写”。</li><li>卡片式思维契合现代创作习惯，便于碎片整合与灵感重组。</li><li>鼓励用户“乱记录、慢整理”，打破对完美笔记的执念。</li></ul></li><li><strong>不足</strong>：<ul><li>缺少结构化笔记工具（如大纲视图、多级标题），不适合深度写作场景。</li><li>知识管理功能偏弱，适合“灵感收集”，不适合“系统整理”。</li><li>搜索功能有待增强，长时间使用后查找灵感存在挑战。</li></ul></li></ul><h3 id="商业模式解释-20"><strong>商业模式解释</strong></h3><ol><li><strong>Freemium 模式</strong>：基础功能永久免费，限制存储空间和同步设备数。</li><li><strong>订阅会员（Pro）</strong>：提供无限卡片、全文搜索、数据导出、深色模式等功能。</li><li><strong>内容联动合作</strong>：未来可能接入创意课程、电台、设计素材包等轻教育或资源工具包。</li></ol><h3 id="竞争分析-20"><strong>竞争分析</strong></h3><ul><li><strong>竞争对手</strong>：<ul><li><strong>Notion、Obsidian、Bear</strong>：更注重系统化、知识整理的重工具选手。</li><li><strong>Flomo、Effie、语雀轻笔记</strong>：也走轻量化、灵感导向路线，直接对标灵感岛。</li></ul></li><li><strong>灵感岛的差异化优势</strong>：<ul><li>更加感性、随机和“反常规”的灵感设计哲学。</li><li>强化了“创意脑图”的体验而非“任务清单”的效率焦虑。</li></ul></li><li><strong>主要挑战</strong>：<ul><li>用户忠诚度难以持续，长期缺乏“效率成果感”可能流失。</li><li>内容生态薄弱，UGC 灵感卡片尚未形成高质量正循环。</li></ul></li></ul><h3 id="运营策略-20"><strong>运营策略</strong></h3><ol><li><strong>引导内容创作者使用</strong>，并输出“我的灵感岛”系列作品，提升品牌调性。</li><li><strong>推出每日灵感挑战计划</strong>，激发日更动力，制造社群话题和使用场景。</li><li><strong>和设计类产品（如Figma、Canva）联动</strong>，引导设计师群体迁移使用。</li><li><strong>建立灵感市集</strong>，用户可共享/交易自己的卡片合集，实现社区商业化。</li></ol><h3 id="改进建议-20"><strong>改进建议</strong></h3><ol><li><strong>开发灵感串联工具</strong>，如“灵感地图”功能，让卡片间产生链接与路径。</li><li><strong>增加语音记录+语义识别</strong>，提升移动端记录效率。</li><li><strong>引入AI总结</strong>，自动归纳卡片主题、生成灵感分类建议，减少用户整理负担。</li><li><strong>强化分享机制</strong>，支持导出为精美图卡或网页，提高灵感传播力。</li></ol><h3 id="总结-20"><strong>总结</strong></h3><p>灵感岛是一款真正为“创意流”而设计的灵感记录工具，它不像传统效率工具那样以“完成任务”为目标，而更像一座为灵魂栖息预留的“灵感缓冲区”。适合想法多、节奏快但又拒绝被结构桎梏的创作者们。下一步，它需要从“灵感容器”变成“创意起点”，在社群和AI的加持下，变得更可持续、更强连接。</p><hr>]]></content>
    
    
    <summary type="html">互联网产品分析笔记(二)</summary>
    
    
    
    <category term="产品分析" scheme="https://www.angfff.top/categories/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="互联网产品" scheme="https://www.angfff.top/tags/%E4%BA%92%E8%81%94%E7%BD%91%E4%BA%A7%E5%93%81/"/>
    
    <category term="产品分析" scheme="https://www.angfff.top/tags/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"/>
    
    <category term="PM" scheme="https://www.angfff.top/tags/PM/"/>
    
  </entry>
  
  <entry>
    <title>互联网产品分析笔记(一)</title>
    <link href="https://www.angfff.top/posts/a1cb95bf.html"/>
    <id>https://www.angfff.top/posts/a1cb95bf.html</id>
    <published>2025-02-09T05:01:48.000Z</published>
    <updated>2025-05-22T04:31:09.393Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微信（Wechat）">微信（Wechat）</h2><h3 id="产品概述">产品概述</h3><p>微信是由腾讯公司于2011年推出的一款集即时通讯、社交、支付和多种服务功能于一体的移动应用程序。它不仅是中国用户数量最多的通讯工具，还延伸成为一个“超级应用”，涵盖了社交、支付、购物、内容消费等多个领域。</p><h3 id="核心功能">核心功能</h3><ol><li><strong>即时通讯</strong>：支持文本、语音、视频、表情、图片和文件的多媒体交流。</li><li><strong>朋友圈</strong>：提供用户分享生活动态的社交平台，支持文字、图片和短视频内容的发布。</li><li><strong>微信支付</strong>：包括转账、消费支付和小额理财功能，与二维码深度结合，支持线上和线下场景。</li><li><strong>公众号</strong>：为企业和个人提供内容分发渠道，包括订阅号和服务号。</li><li><strong>小程序</strong>：轻量化应用生态，无需下载即可使用的多功能平台。</li><li><strong>视频号</strong>：短视频内容创作与分享，进一步强化内容生态。</li><li><strong>企业微信</strong>：专为企业设计的内部沟通和外部服务工具。</li></ol><h3 id="用户体验评估">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>界面简洁直观，功能布局合理，用户上手容易。</li><li>通讯功能高效稳定，支持语音、视频通话等多场景需求。</li><li>生态闭环强大，用户可一站式完成社交、支付、购物等多项任务。</li></ul></li><li><strong>不足</strong>：<ul><li>功能过于繁杂，部分用户可能面临信息过载问题。</li><li>隐私政策和数据保护问题受到一定质疑。</li></ul></li></ul><h3 id="商业模式解释">商业模式解释</h3><ol><li><strong>广告收入</strong>：通过公众号广告、朋友圈广告以及小程序流量分发实现收入。</li><li><strong>支付分成</strong>：微信支付在交易过程中抽取一定比例作为手续费。</li><li><strong>增值服务</strong>：如表情包商店、视频号直播打赏等。</li><li><strong>企业服务</strong>：企业微信及相关功能的订阅费或服务费。</li></ol><h3 id="竞争分析">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li>国内：阿里巴巴的支付宝（在支付领域竞争），抖音（在短视频和社交娱乐领域）。</li><li>国际：WhatsApp（即时通讯），Facebook Messenger（社交）。</li></ul></li><li><strong>优势</strong>：<ul><li>生态闭环完整，用户粘性极高。</li><li>庞大的用户基数（超过12亿月活跃用户）。</li></ul></li><li><strong>劣势</strong>：<ul><li>创新速度可能不足以应对快速变化的市场需求。</li><li>面临反垄断监管压力。</li></ul></li></ul><h3 id="运营策略">运营策略</h3><ol><li><strong>内容生态</strong>：强化视频号、公众号等内容生态，吸引更多内容创作者和消费者。</li><li><strong>支付场景拓展</strong>：挖掘更多线下支付场景，并增强跨境支付能力。</li><li><strong>国际化发展</strong>：针对东南亚等新兴市场推广微信生态系统。</li><li><strong>用户教育</strong>：通过活动和教程引导用户使用更多高级功能（如小程序）。</li></ol><h3 id="改进建议">改进建议</h3><ol><li><strong>优化用户界面</strong>：简化功能入口，为用户提供定制化的界面选择。</li><li><strong>提升隐私保护</strong>：加强数据保护和隐私政策透明度，赢得用户信任。</li><li><strong>加强AI能力</strong>：利用人工智能技术改进内容推荐和用户交互体验。</li><li><strong>支持个性化需求</strong>：允许用户对常用功能模块进行自由配置。</li></ol><h3 id="总结">总结</h3><p>微信作为一款超级应用，其强大的生态系统和功能集成功能使其在中国市场占据主导地位。但在激烈竞争和监管压力下，需要不断优化用户体验并加速创新，以保持长期竞争力。</p><hr><h2 id="知乎（Zhihu）">知乎（Zhihu）</h2><h3 id="产品概述-2">产品概述</h3><p>知乎是中国知名的问答类社交平台，于2011年推出。它最初以知识分享和专业讨论为核心定位，吸引了大量高质量用户参与，后来逐步扩展为一个综合性的内容平台，覆盖了问答、文章、直播、视频等多种内容形式。</p><h3 id="核心功能-2">核心功能</h3><ol><li><strong>问答社区</strong>：用户可以提问或回答，优质内容通过点赞和评论机制被推送到更广的用户群体。</li><li><strong>文章与专栏</strong>：用户可以发布深度内容，通过专栏形式吸引粉丝订阅。</li><li><strong>视频与直播</strong>：支持短视频和知识类直播，满足用户多样化内容消费需求。</li><li><strong>想法（轻量化动态）</strong>：提供快速表达观点的平台，类似微博或朋友圈功能。</li><li><strong>盐选会员</strong>：提供付费阅读优质内容的功能，包括电子书、课程和独家问答等。</li><li><strong>好物推荐</strong>：结合用户信任机制，鼓励KOL通过内容带货，实现知识电商化。</li><li><strong>机构号与付费咨询</strong>：企业和专业人士可通过平台提供咨询、推广和知识变现。</li></ol><h3 id="用户体验评估-2">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>内容质量普遍较高，适合希望获取专业知识和见解的用户。</li><li>社区氛围相对理性，用户之间互动性强。</li><li>内容形式多样化，从长文到短视频，满足不同消费偏好。</li></ul></li><li><strong>不足</strong>：<ul><li>部分领域内容质量下降，营销软文增多，影响用户体验。</li><li>社区讨论氛围有所下降，争议性话题易引发对立情绪。</li><li>会员内容价值感不够突出，部分用户认为付费内容质量参差不齐。</li></ul></li></ul><h3 id="商业模式解释-2">商业模式解释</h3><ol><li><strong>会员订阅</strong>：盐选会员通过提供优质内容和权益，带来持续收入。</li><li><strong>广告收入</strong>：以信息流广告、品牌合作等形式为主。</li><li><strong>付费问答</strong>：用户可以支付费用向专家提问，平台收取分成。</li><li><strong>教育产品</strong>：知识付费类课程与电子书销售。</li><li><strong>电商与带货</strong>：通过知乎好物推荐、直播带货等方式变现。</li></ol><h3 id="竞争分析-2">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li>百度知道（问答领域）：内容广度强但深度不足。</li><li>今日头条（内容分发领域）：算法推荐机制更强大。</li><li>B站、喜马拉雅（知识分享领域）：更注重多媒体形式。</li></ul></li><li><strong>优势</strong>：<ul><li>社区生态相对成熟，优质内容和用户粘性高。</li><li>用户群体定位清晰，覆盖年轻、有消费能力的人群。</li></ul></li><li><strong>劣势</strong>：<ul><li>新用户获取难度增加，社区增长速度放缓。</li><li>部分高质量创作者向其他平台流失。</li></ul></li></ul><h3 id="运营策略-2">运营策略</h3><ol><li><strong>内容引导</strong>：加强对优质内容的扶持，优化激励机制吸引内容创作者。</li><li><strong>多样化内容形式</strong>：进一步扩展短视频、音频课程等内容供给，增加用户留存率。</li><li><strong>社区运营</strong>：举办主题活动或知识竞赛，提升用户活跃度和参与感。</li><li><strong>国际化发展</strong>：探索海外市场，通过语言本地化运营扩展用户基础。</li></ol><h3 id="改进建议-2">改进建议</h3><ol><li><strong>优化内容质量</strong>：引入更精细的内容审核机制，遏制低质量内容和营销行为。</li><li><strong>提升算法推荐</strong>：通过AI优化推荐算法，减少用户的信息过载，精准推送符合兴趣的内容。</li><li><strong>创新会员权益</strong>：扩展盐选会员的服务范围，比如独家线下活动或与其他平台合作的跨界权益。</li><li><strong>社交功能改进</strong>：增加更丰富的互动形式，例如讨论组或话题标签页，增强用户间的联系。</li><li><strong>提高用户互动</strong>：通过问答激励、社区活动等方式增强用户粘性。</li><li><strong>加强垂直领域深耕</strong>：针对科技、财经、法律、医学等领域建立更专业的知识社区。</li></ol><h3 id="总结-2">总结</h3><p>知乎作为知识型社区的代表，凭借高质量内容和良好的用户体验在市场中占有重要地位。但在流量竞争加剧和用户增长放缓的情况下，需要通过技术和运营创新，保持平台的长期活力与竞争力。</p><hr><h2 id="豆瓣（Douban）">豆瓣（Douban）</h2><h3 id="产品概述-3">产品概述</h3><p>豆瓣是一个于2005年上线的社交媒体和文化内容平台，主要服务于对书籍、电影、音乐等文化内容感兴趣的用户。它提供了丰富的用户生成内容，包括评分、评论、讨论小组和推荐列表，被视为中国文化圈的重要内容社区。</p><h3 id="核心功能-3">核心功能</h3><ol><li><strong>评分与评论</strong>：用户可为电影、书籍、音乐等内容评分并撰写评论，形成权威的用户口碑参考。</li><li><strong>兴趣小组</strong>：基于主题的讨论社区，用户可加入喜欢的圈子交流观点。</li><li><strong>豆瓣FM</strong>：音乐推荐与流媒体播放功能，通过个性化算法推送歌曲。</li><li><strong>豆瓣阅读</strong>：提供电子书购买与阅读服务，同时支持作者投稿原创作品。</li><li><strong>个人主页</strong>：用户可以展示收藏、愿望清单及文化消费记录。</li></ol><h3 id="用户体验评估-3">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>界面设计简洁清晰，功能聚焦于文化内容，契合目标用户需求。</li><li>社区氛围浓厚，讨论质量较高，特别是在文艺和独立文化领域具有独特吸引力。</li><li>评分系统公信力强，是用户选择电影、书籍等的重要参考依据。</li></ul></li><li><strong>不足</strong>：<ul><li>新用户引导较弱，部分功能对新人不够友好。</li><li>交互设计相对陈旧，与现代审美和使用习惯有一定差距。</li><li>兴趣小组内存在一些低质量或广告内容，影响用户体验。</li></ul></li></ul><h3 id="商业模式解释-3">商业模式解释</h3><ol><li><strong>广告收入</strong>：通过内容页面、评分页以及社区的广告投放获取收入。</li><li><strong>电子书销售</strong>：通过豆瓣阅读平台销售电子书和订阅服务。</li><li><strong>付费增值服务</strong>：如豆瓣FM高级账户和豆瓣阅读的VIP权益。</li><li><strong>品牌合作</strong>：与电影、出版物等文化品牌的联动推广活动。</li></ol><h3 id="竞争分析-3">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li>电影领域：猫眼、淘票票（在票务与影评方面竞争）。</li><li>阅读领域：掌阅、微信读书（在电子书销售与阅读体验上竞争）。</li><li>音乐领域：网易云音乐、QQ音乐（流媒体播放和音乐推荐）。</li></ul></li><li><strong>优势</strong>：<ul><li>强大的UGC社区，用户对评分与评论具有较高信任度。</li><li>在文艺爱好者和知识型用户中具有良好口碑。</li></ul></li><li><strong>劣势</strong>：<ul><li>缺乏内容变现的强大能力，营收模式单一。</li><li>用户增长有限，社区活跃度有下滑风险。</li></ul></li></ul><h3 id="运营策略-3">运营策略</h3><ol><li><strong>优化社区生态</strong>：强化内容审核机制，打击低质量内容，提升用户讨论的质量和参与感。</li><li><strong>内容推荐升级</strong>：利用大数据和AI技术改进内容推荐算法，为用户提供更精准的兴趣匹配。</li><li><strong>品牌联动</strong>：加强与影视、出版和音乐厂商的合作，推出更多联动推广活动。</li><li><strong>国际化发展</strong>：探索海外市场，特别是在华人文化圈内扩大影响力。</li></ol><h3 id="改进建议-3">改进建议</h3><ol><li><strong>改进界面设计</strong>：更新UI/UX设计，提升视觉效果与交互体验，吸引年轻用户。</li><li><strong>增强社交功能</strong>：增加用户间互动方式，例如点赞、即时聊天或语音讨论功能，增强社交属性。</li><li><strong>探索多元化收入模式</strong>：尝试引入更多变现手段，如内容电商、知识付费等。</li><li><strong>扶持原创内容创作者</strong>：通过奖励机制或流量扶持，吸引更多优质用户分享原创内容，增强社区活力。</li></ol><h3 id="总结-3">总结</h3><p>豆瓣作为中国文化类社区的代表，凭借其评分系统和优质讨论氛围占据独特市场地位。然而，面对日益激烈的市场竞争与用户需求的变化，它需要通过技术和运营创新，进一步释放商业潜力并保持用户黏性。</p><hr><h2 id="哔哩哔哩（Bilibili）">哔哩哔哩（Bilibili）</h2><h3 id="产品概述-4">产品概述</h3><p>哔哩哔哩（B站）是中国领先的年轻人文化社区和视频平台，成立于2009年。最初以二次元和弹幕文化为核心吸引用户，现已扩展至泛娱乐、教育、直播、电商等多个领域，成为年轻人获取内容、互动和消费的重要平台。</p><h3 id="核心功能-4">核心功能</h3><ol><li><strong>弹幕视频播放</strong>：提供独特的实时弹幕互动功能，增强观看体验和社区氛围。</li><li><strong>内容创作与分发</strong>：支持用户上传原创视频，涵盖多个领域，如动画、游戏、科技、生活等。</li><li><strong>直播服务</strong>：涵盖游戏、音乐、二次元等直播内容，同时支持观众与主播互动。</li><li><strong>知识分享</strong>：教育类内容逐渐增加，如课程视频、科普内容等，满足用户学习需求。</li><li><strong>会员与权益</strong>：大会员提供高清画质、免广告、独占内容等多项特权。</li><li><strong>电商与周边</strong>：销售与内容相关的周边产品以及合作商品。</li></ol><h3 id="用户体验评估-4">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>弹幕互动增强用户参与感，形成了鲜明的社区特色。</li><li>内容形式丰富，覆盖了广泛的兴趣领域，吸引多样化的用户群体。</li><li>推荐算法较为精准，满足个性化需求。</li><li>社区氛围强，UGC 内容丰富，用户粘性高。</li></ul></li><li><strong>不足</strong>：<ul><li>商业化难度大，用户对广告接受度低，会员转化率有限。</li><li>审核压力大，内容管理难度高，面临监管风险。</li><li>带宽与服务器成本高，影响盈利能力。</li><li>新手用户的引导不够完善，功能入口稍显复杂。</li></ul></li></ul><h3 id="商业模式解释-4">商业模式解释</h3><ol><li><strong>会员订阅</strong>：通过大会员服务提供增值功能，如高清画质、独占内容、弹幕特权等。</li><li><strong>广告收入</strong>：信息流广告、视频前贴片广告和内容合作推广。</li><li><strong>直播打赏</strong>：用户通过购买虚拟礼物支持主播，平台抽成获利。</li><li><strong>电商业务</strong>：销售与内容相关的周边商品、IP合作款等。</li><li><strong>游戏分发</strong>：与游戏厂商合作进行推广和分发，获取分成收入。</li></ol><h3 id="竞争分析-4">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li>视频领域：抖音、快手（短视频领域竞争），腾讯视频、爱奇艺（长视频、影视内容竞争）。</li><li>直播领域：虎牙、斗鱼（电竞直播竞争）。</li><li>知识类平台：知乎、网易云课堂（在教育内容方面竞争）。</li></ul></li><li><strong>优势</strong>：<ul><li>强社区属性，用户粘性和忠诚度高。</li><li>品牌定位鲜明，深受年轻用户青睐。</li><li>用户生成内容（UGC）和专业生成内容（PGC）并存，丰富平台生态。</li></ul></li><li><strong>劣势</strong>：<ul><li>内容成本较高，特别是版权内容采购和原创补贴。</li><li>变现能力不足，相较于短视频平台，广告投放吸引力较低。</li><li>面临短视频平台的流量挤压，用户增长可能放缓。</li></ul></li></ul><h3 id="运营策略-4">运营策略</h3><ol><li><strong>扶持内容创作者</strong>：通过创作者激励计划，吸引更多优质视频创作者，提升内容多样性。</li><li><strong>扩展知识领域</strong>：增加教育和职业发展类内容，满足用户在学习方面的需求。</li><li><strong>品牌合作</strong>：加强与IP方的合作，推出更多主题活动和周边商品，增强变现能力。</li><li><strong>海外拓展</strong>：继续加大国际化步伐，探索东南亚和欧美市场用户需求。</li></ol><h3 id="改进建议-4">改进建议</h3><ol><li><strong>优化广告体验</strong>：通过智能广告分发和广告形式创新，尽量减少对用户观看体验的干扰。</li><li><strong>增强社区管理</strong>：加强内容审核机制，确保社区氛围和内容质量。</li><li><strong>优化新用户引导</strong>：提供更直观的功能介绍和社区规则教育，帮助新人快速融入平台。</li><li><strong>提升推荐算法</strong>：进一步优化视频推荐，减少同质化内容，增加用户探索新领域的机会。</li></ol><h3 id="总结-4">总结</h3><p>哔哩哔哩作为中国领先的年轻人文化社区，通过独特的弹幕互动和多元化内容，成功吸引了大批忠实用户。但在激烈的市场竞争中，需要通过内容生态优化、社区运营创新和商业模式拓展来保持其竞争力和长远发展潜力。</p><hr><h2 id="飞书（Feishu）">飞书（Feishu）</h2><h3 id="产品概述-5">产品概述</h3><p>飞书是字节跳动推出的一款企业协作工具，集即时通讯、在线文档、日程管理、音视频会议和知识管理等功能于一体。作为中国企业数字化转型的重要工具，飞书定位为一站式高效办公平台，旨在帮助团队提升协作效率和生产力。</p><h3 id="核心功能-5">核心功能</h3><ol><li><strong>即时通讯</strong>：支持群聊、点对点消息传递、智能搜索、已读未读标记以及消息撤回等功能。</li><li><strong>在线文档</strong>：多用户实时协作编辑文档与表格，内嵌评论功能，支持多种格式导出。</li><li><strong>日程管理</strong>：团队共享日历，集成会议安排与提醒功能，提高时间管理效率。</li><li><strong>音视频会议</strong>：高清音视频通话，支持屏幕共享和会议录制，满足远程会议需求。</li><li><strong>知识管理</strong>：企业内知识库功能，方便员工整理和查找文档资源。</li><li><strong>集成与开放平台</strong>：与其他企业工具（如HR系统、CRM）深度集成，提供API支持个性化开发。</li></ol><h3 id="用户体验评估-5">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>界面设计简洁现代，符合年轻化用户审美。</li><li>功能深度集成，用户无需频繁切换应用。</li><li>高效的实时协作体验，特别是文档与日程功能在国内市场具有竞争力。</li></ul></li><li><strong>不足</strong>：<ul><li>部分中小企业可能难以承受高端功能的费用。</li><li>功能学习曲线较陡，新用户可能需要一定时间适应。</li></ul></li></ul><h3 id="商业模式解释-5">商业模式解释</h3><ol><li><strong>免费增值（Freemium）</strong>：核心功能免费提供，高级版本收取订阅费，包括更大存储空间、更强管理功能和定制化服务。</li><li><strong>企业服务</strong>：为大中型企业提供专属服务，如定制化解决方案和企业培训。</li><li><strong>生态收入</strong>：通过飞书开放平台收取第三方应用集成费用或分成。</li></ol><h3 id="竞争分析-5">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li>钉钉（DingTalk）：阿里巴巴旗下产品，以轻量化管理工具见长。</li><li>企业微信（WeCom）：腾讯旗下产品，优势在于与微信生态的无缝连接。</li><li>国际：Slack、Microsoft Teams（在多语言、跨国企业市场中竞争）。</li></ul></li><li><strong>优势</strong>：<ul><li>强大的产品设计能力和体验优化，实时协作性能优越。</li><li>背靠字节跳动的资源优势，在数据分析与AI技术上具备前沿能力。</li></ul></li><li><strong>劣势</strong>：<ul><li>市场认知度相对钉钉和企业微信稍弱，特别是在中小企业市场。</li><li>用户获取成本较高，需要较大的市场推广投入。</li></ul></li></ul><h3 id="运营策略-5">运营策略</h3><ol><li><strong>市场教育</strong>：通过案例分享、行业解决方案展示等形式，提高目标客户对产品的认知。</li><li><strong>生态建设</strong>：扩大与第三方工具和平台的集成合作，形成闭环生态体系。</li><li><strong>中小企业扶持</strong>：提供针对小微企业的优惠套餐，降低其使用门槛。</li><li><strong>国际化拓展</strong>：以东南亚和欧美市场为重点，推出本地化产品和服务。</li></ol><h3 id="改进建议-5">改进建议</h3><ol><li><strong>优化入门体验</strong>：为新用户设计更直观的引导流程，简化产品学习曲线。</li><li><strong>增强安全性</strong>：特别针对大型企业需求，提供更全面的数据隐私保护方案。</li><li><strong>个性化功能定制</strong>：支持企业根据需求选择功能模块，灵活配置产品。</li><li><strong>丰富插件与API</strong>：吸引更多开发者为平台提供创新功能，扩大用户选择范围。</li></ol><h3 id="总结-5">总结</h3><p>飞书凭借高效的协作功能和优秀的用户体验，在国内企业服务市场具有较大潜力。然而，在强敌环伺的竞争环境中，飞书需要加大市场推广力度、丰富功能生态，并不断优化服务策略，以实现更大规模的市场渗透和用户增长。</p><hr><h2 id="小红书（RED）">小红书（RED）</h2><h3 id="产品概述-6">产品概述</h3><p>小红书是中国领先的生活方式社区与电商平台，于2013年上线。它以UGC（用户生成内容）为核心，用户可以分享购物心得、美妆评测、旅行体验等内容。近年来，小红书逐渐发展为一个综合性的内容与消费平台，吸引了大量年轻用户。</p><h3 id="核心功能-6">核心功能</h3><ol><li><strong>内容社区</strong>：用户可以发布图文或视频笔记，内容涵盖美妆、时尚、健身、旅行等多种领域。</li><li><strong>搜索与推荐</strong>：通过AI算法实现精准内容推荐和搜索，满足用户个性化需求。</li><li><strong>电商平台</strong>：整合社区与电商，用户可以直接购买与笔记相关的商品。</li><li><strong>品牌合作</strong>：为品牌提供营销工具，如投放广告、种草内容及KOL（关键意见领袖）合作。</li><li><strong>社交功能</strong>：支持点赞、评论、收藏以及私信互动，增强用户黏性。</li></ol><h3 id="用户体验评估-6">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>界面设计简洁美观，操作直观，符合年轻用户审美。</li><li>内容丰富，尤其在时尚、美妆等领域具有较强专业性和实用性。</li><li>搜索与推荐功能强大，帮助用户快速找到感兴趣的内容。</li></ul></li><li><strong>不足</strong>：<ul><li>商业化内容较多，用户可能对过度营销感到反感。</li><li>社区管理存在挑战，偶尔出现低质量或虚假内容。</li></ul></li></ul><h3 id="商业模式解释-6">商业模式解释</h3><ol><li><strong>广告收入</strong>：通过品牌广告、原生内容广告以及达人种草推广获得收入。</li><li><strong>电商佣金</strong>：用户在平台内完成购物交易，小红书从中抽取一定比例的佣金。</li><li><strong>会员服务</strong>：提供增值服务（如更高曝光度或高级搜索功能）以获取订阅收入。</li><li><strong>数据服务</strong>：为品牌方提供消费洞察报告，支持其精准营销。</li></ol><h3 id="竞争分析-6">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li>抖音与快手：短视频内容生态竞争，覆盖相似人群。</li><li>淘宝、京东：在电商领域的流量竞争更为激烈。</li><li>知乎：在知识型分享和问答领域具有竞争性。</li></ul></li><li><strong>优势</strong>：<ul><li>用户粘性强，内容生态与电商结合紧密。</li><li>深耕“种草”经济，对女性用户和年轻人具有强吸引力。</li></ul></li><li><strong>劣势</strong>：<ul><li>内容门槛较低，部分领域存在低质量内容。</li><li>商业化转型中，如何平衡用户体验与广告压力成为难题。</li></ul></li></ul><h3 id="运营策略-6">运营策略</h3><ol><li><strong>内容优化</strong>：引入内容激励计划，扶持高质量创作者，规范内容审核机制。</li><li><strong>增强电商体验</strong>：提高购物路径的便捷性，完善物流与售后服务。</li><li><strong>品牌合作升级</strong>：推出更多创新营销工具，帮助品牌更高效地触达目标用户。</li><li><strong>国际化扩展</strong>：进入海外市场，通过多语言支持与本地化运营吸引更多用户。</li></ol><h3 id="改进建议-6">改进建议</h3><ol><li><strong>减少广告干扰</strong>：优化广告展示逻辑，避免影响用户体验。</li><li><strong>提升社区氛围</strong>：建立更严格的内容审核与推荐机制，维护社区优质内容的输出。</li><li><strong>个性化推荐</strong>：进一步优化算法，提升用户对推荐内容的满意度。</li><li><strong>电商升级</strong>：加强商品质量把控和售后服务，提升用户信任度。</li></ol><h3 id="总结-6">总结</h3><p>小红书通过“社区+电商”的模式成功建立了自己的核心竞争力。未来需要在内容质量提升、商业化转型和用户体验之间找到平衡，以巩固其市场地位并实现长远发展。</p><hr><h2 id="百度网盘（Baidu-Cloud）">百度网盘（Baidu Cloud）</h2><h3 id="产品概述-7">产品概述</h3><p>百度网盘是百度公司推出的云存储服务，提供用户个人数据的在线存储、同步、备份和分享功能。自2012年推出以来，已成为中国市场上最受欢迎的云存储服务之一，特别适用于大文件存储和跨设备访问。</p><h3 id="核心功能-7">核心功能</h3><ol><li><strong>云存储</strong>：支持用户上传、下载和管理各种格式的文件，如图片、视频、文档等。</li><li><strong>文件分享</strong>：可通过链接分享文件，并支持加密、限时下载等权限设置。</li><li><strong>多设备同步</strong>：PC、移动端和网页端无缝同步数据，方便随时访问。</li><li><strong>在线播放</strong>：支持视频、音乐等媒体文件的在线预览和播放，无需下载。</li><li><strong>自动备份</strong>：提供手机相册自动备份、文档同步等功能，防止数据丢失。</li><li><strong>企业版</strong>：提供团队协作、共享云盘等企业级功能。</li></ol><h3 id="用户体验评估-7">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li><strong>存储空间大</strong>：免费用户可获得较大初始空间，付费用户享受更大存储额度。</li><li><strong>多终端支持</strong>：支持Windows、macOS、iOS、Android等多个平台。</li><li><strong>文件管理便捷</strong>：支持批量操作、智能分类、搜索等功能，提高管理效率。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>下载速度限制</strong>：非会员用户的下载速度较慢，影响体验。</li><li><strong>广告与推广较多</strong>：免费用户在使用过程中可能遇到较多的会员推广弹窗。</li><li><strong>隐私问题</strong>：部分用户担忧数据安全与隐私保护问题。</li></ul></li></ul><h3 id="商业模式解释-7">商业模式解释</h3><ol><li><strong>会员订阅</strong>：提供普通会员、超级会员等付费套餐，提升存储空间和下载速度。</li><li><strong>增值服务</strong>：包括离线下载、视频倍速播放、高速传输等功能，需额外付费。</li><li><strong>企业服务</strong>：百度网盘企业版提供团队共享、权限管理等功能，按年收费。</li><li><strong>广告收入</strong>：部分页面和功能入口包含广告投放，增加变现能力。</li></ol><h3 id="竞争分析-7">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>阿里云盘</strong>：阿里巴巴推出的云存储服务，主打无下载限速和用户体验优化。</li><li><strong>腾讯微云</strong>：腾讯旗下云存储产品，依托微信和QQ生态提供便捷的文件共享功能。</li><li><strong>海外竞争对手</strong>：Google Drive、Dropbox（但在中国市场影响有限）。</li></ul></li><li><strong>优势</strong>：<ul><li>市场占有率高，用户群体庞大。</li><li>百度搜索和AI技术支持，提供更强的智能化体验。</li></ul></li><li><strong>劣势</strong>：<ul><li>口碑受到下载限速问题影响，部分用户流向阿里云盘等竞品。</li><li>用户体验有待提升，广告较多可能影响使用感受。</li></ul></li></ul><h3 id="运营策略-7">运营策略</h3><ol><li><strong>优化用户体验</strong>：改进免费用户的基础体验，如适当提高非会员下载速度。</li><li><strong>加强安全性</strong>：提升隐私保护机制，增强数据加密和访问权限管理。</li><li><strong>丰富企业服务</strong>：针对企业级用户推出更多协作功能，提高B端市场占有率。</li><li><strong>加强内容生态</strong>：与视频、办公软件等产品深度结合，提升用户粘性。</li></ol><h3 id="改进建议-7">改进建议</h3><ol><li><strong>优化限速机制</strong>：提供更合理的非会员下载速度策略，提升整体用户口碑。</li><li><strong>减少广告干扰</strong>：减少推广弹窗，提高用户体验满意度。</li><li><strong>增强智能推荐</strong>：利用AI技术优化文件分类、搜索推荐等功能。</li><li><strong>推出更多增值服务</strong>：如AI自动整理、智能识别、协作文档等，提高会员吸引力。</li></ol><h3 id="总结-7">总结</h3><p>百度网盘凭借强大的云存储能力和百度生态支持，占据了中国云存储市场的重要位置。但在用户体验优化、隐私安全和商业模式创新方面仍有改进空间，未来需通过优化基础服务、增强企业市场拓展和智能化升级，进一步巩固市场地位。</p><hr><h2 id="携程旅行（Ctrip）">携程旅行（Ctrip）</h2><h3 id="产品概述-8">产品概述</h3><p>携程旅行（Ctrip）是中国领先的在线旅游服务平台，提供机票、酒店、火车票、旅游度假、租车、签证等全方位的旅行服务。作为国内在线旅游市场的龙头企业，携程通过技术和供应链整合，为用户提供一站式旅行解决方案。</p><h3 id="核心功能-8">核心功能</h3><ol><li><strong>机票预订</strong>：支持国内、国际航班查询和预订，提供价格对比、航班提醒等增值服务。</li><li><strong>酒店预订</strong>：涵盖全球各类酒店，提供用户评价、图片、地图定位及会员专享优惠。</li><li><strong>火车票/汽车票</strong>：支持高铁、动车和长途汽车票的在线预订，并提供抢票服务。</li><li><strong>旅游度假</strong>：提供自由行、跟团游、定制游等产品，覆盖国内外目的地。</li><li><strong>租车与接送机</strong>：提供全球租车服务，并支持机场接送、包车游等特色服务。</li><li><strong>签证与保险</strong>：支持在线办理签证，并提供旅行保险产品，提高用户便利性。</li><li><strong>会员体系</strong>：通过携程会员计划（如钻石、白金会员），提供专属折扣和服务。</li></ol><h3 id="用户体验评估-8">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>界面设计清晰，搜索和预订流程流畅，用户体验较好。</li><li>供应链资源丰富，提供广泛的旅行产品选择。</li><li>会员体系较完善，老用户粘性较高。</li></ul></li><li><strong>不足</strong>：<ul><li>价格波动较大，部分用户对价格透明度有疑虑。</li><li>订单改签、退款流程相对复杂，客服体验有待优化。</li><li>广告和推送较多，可能影响部分用户体验。</li></ul></li></ul><h3 id="商业模式解释-8">商业模式解释</h3><ol><li><strong>佣金收入</strong>：与航空公司、酒店、旅行社等合作，通过订单抽佣获利。</li><li><strong>增值服务</strong>：包括保险、签证办理、贵宾休息室等附加服务。</li><li><strong>广告收入</strong>：向酒店、旅游供应商提供广告推广服务。</li><li><strong>金融服务</strong>：提供分期付款、携程信用支付等金融产品。</li></ol><h3 id="竞争分析-8">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>国内</strong>：同程旅行、飞猪（阿里巴巴旗下）、马蜂窝（社交+旅游模式）。</li><li><strong>国际</strong>：<a href="http://Booking.com">Booking.com</a>、Expedia（在国际酒店预订和机票市场竞争）。</li></ul></li><li><strong>优势</strong>：<ul><li>供应链强大，与大量航司、酒店建立长期合作关系。</li><li>具有较强的品牌信任度和较高市场占有率。</li></ul></li><li><strong>劣势</strong>：<ul><li>竞争对手（如飞猪）依托阿里生态流量，市场竞争压力大。</li><li>用户对价格和服务的敏感度较高，易受竞争平台影响。</li></ul></li></ul><h3 id="运营策略-8">运营策略</h3><ol><li><strong>优化服务体验</strong>：简化订单改签、退票流程，提高用户服务满意度。</li><li><strong>深耕国际市场</strong>：加大海外市场拓展力度，提升全球竞争力。</li><li><strong>强化智能推荐</strong>：利用AI技术优化个性化推荐，提高用户留存率。</li><li><strong>拓展会员权益</strong>：增加高端会员专属权益，提升忠诚度。</li></ol><h3 id="改进建议-8">改进建议</h3><ol><li><strong>提升客服体验</strong>：优化人工客服响应速度，增加智能客服能力。</li><li><strong>增强价格透明度</strong>：减少隐藏费用，提高用户信任感。</li><li><strong>减少无关推送</strong>：优化个性化推荐逻辑，减少对用户造成困扰的消息推送。</li><li><strong>加强用户评价体系</strong>：提升用户对商家的信任度，改善服务质量。</li></ol><h3 id="总结-8">总结</h3><p>携程旅行作为中国最大的在线旅游平台，在供应链整合、品牌信任度和用户规模上占据优势。但面对激烈的市场竞争和用户体验的高要求，携程需要持续优化产品服务，提升用户体验，并加强国际市场布局，以保持市场领先地位。</p><hr><h2 id="美团（Meituan）">美团（Meituan）</h2><h3 id="产品概述-9">产品概述</h3><p>美团是一款综合性的本地生活服务平台，提供外卖、酒店预订、电影票、休闲娱乐、出行等多种服务。作为中国领先的O2O（Online to Offline）平台，美团通过技术和数据驱动，为用户提供便捷的生活消费服务，同时帮助商家提升运营效率。</p><h3 id="核心功能-9">核心功能</h3><ol><li><strong>外卖配送</strong>：美团外卖覆盖全国多个城市，提供餐饮、超市、生鲜、药品等配送服务。</li><li><strong>酒店预订</strong>：用户可以通过美团预订国内外酒店，并享受优惠折扣和会员特权。</li><li><strong>电影票预订</strong>：支持全国电影院的在线选座购票，并提供优惠券和会员折扣。</li><li><strong>本地服务</strong>：涵盖KTV、按摩、美容、健身、亲子等消费场景，用户可在线购买团购或预约服务。</li><li><strong>美团打车</strong>：提供网约车服务，与滴滴等平台竞争，主打高性价比出行体验。</li><li><strong>美团买菜</strong>：支持生鲜食品的即时配送，满足家庭用户的日常采购需求。</li><li><strong>商家服务</strong>：提供流量推广、用户运营、数据分析等工具，帮助商家提升销量。</li></ol><h3 id="用户体验评估-9">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li><strong>一站式服务</strong>，涵盖多种本地消费需求，提升用户便利性。</li><li><strong>界面设计简洁</strong>，操作流程流畅，支持个性化推荐。</li><li><strong>配送效率高</strong>，特别是在大城市，外卖和买菜服务体验较佳。</li></ul></li><li><strong>不足</strong>：<ul><li>部分服务商的质量不稳定，用户体验受限于商家能力。</li><li>广告和促销信息较多，可能对用户造成一定干扰。</li><li>会员体系的权益不够清晰，部分用户对订阅付费持观望态度。</li></ul></li></ul><h3 id="商业模式解释-9">商业模式解释</h3><ol><li><strong>佣金收入</strong>：向入驻商家收取交易佣金，如外卖商家、酒店、餐厅等。</li><li><strong>广告推广</strong>：提供商家流量推广、竞价排名等广告营销服务。</li><li><strong>会员订阅</strong>：美团推出“超级会员”计划，提供专属折扣、红包等增值权益。</li><li><strong>配送服务费</strong>：美团外卖和买菜业务收取一定的配送服务费。</li><li><strong>金融服务</strong>：通过美团支付、美团信用等金融产品获得额外收益。</li></ol><h3 id="竞争分析-9">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>饿了么</strong>（外卖业务）：阿里巴巴旗下平台，主打会员折扣和补贴竞争。</li><li><strong>携程、飞猪</strong>（酒店业务）：旅游住宿预订领域竞争激烈。</li><li><strong>滴滴</strong>（网约车业务）：美团打车在市场份额上仍与滴滴有较大差距。</li></ul></li><li><strong>优势</strong>：<ul><li>强大的地推和商家合作能力，市场覆盖广泛。</li><li>生态闭环完整，从餐饮到出行，用户粘性较高。</li></ul></li><li><strong>劣势</strong>：<ul><li>业务线多，运营成本较高，盈利能力面临挑战。</li><li>在部分业务（如网约车）上，与主要竞争对手仍存在差距。</li></ul></li></ul><h3 id="运营策略-9">运营策略</h3><ol><li><strong>强化外卖生态</strong>：提高商家质量，优化配送服务，增强用户体验。</li><li><strong>拓展本地生活</strong>：增加更多生活服务，如家政、维修、医疗等领域。</li><li><strong>增强会员权益</strong>：优化超级会员体系，提高用户留存率和付费转化率。</li><li><strong>国际化探索</strong>：尝试在东南亚市场复制中国模式，拓展海外市场。</li></ol><h3 id="改进建议-9">改进建议</h3><ol><li><strong>优化广告展示</strong>：减少无关推送，增强个性化推荐机制，提高用户满意度。</li><li><strong>提升商家管理</strong>：加强对低质量商家的监管，提高用户消费体验。</li><li><strong>完善售后服务</strong>：特别是在外卖和酒店业务上，提高投诉处理效率。</li><li><strong>技术创新</strong>：运用AI优化配送路线、智能客服等，提高运营效率。</li></ol><h3 id="总结-9">总结</h3><p>美团凭借其强大的本地服务生态，在外卖、酒店、本地娱乐等领域占据领先地位。但面对竞争和高运营成本压力，美团需要持续优化用户体验、提升商家质量，并探索新的增长点，以保持长期竞争力。</p><hr><h2 id="快手（Kuaishou）">快手（Kuaishou）</h2><h3 id="产品概述-10">产品概述</h3><p>快手是中国领先的短视频和直播平台，成立于2011年，最初是一款GIF制作工具，后逐步发展为短视频社交平台。快手的核心特点是去中心化推荐机制，鼓励普通用户创作内容，并形成强互动的社交氛围。</p><h3 id="核心功能-10">核心功能</h3><ol><li><strong>短视频发布与观看</strong>：用户可上传短视频，平台通过AI推荐内容，增强用户粘性。</li><li><strong>直播互动</strong>：支持主播打赏、连麦互动、PK等多种直播玩法，提高用户活跃度。</li><li><strong>社交功能</strong>：用户可关注、评论、点赞、分享，并建立私信联系，增强社交属性。</li><li><strong>电商带货</strong>：平台内嵌电商系统，主播和用户可在视频或直播中推广商品。</li><li><strong>本地生活</strong>：提供到店优惠、团购、外卖等本地消费服务，与短视频结合提高转化率。</li></ol><h3 id="用户体验评估-10">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>以“老铁”文化为核心，社交氛围浓厚，用户互动性强。</li><li>内容覆盖广泛，从乡村生活到城市潮流，满足不同人群需求。</li><li>短视频与直播结合紧密，增强用户留存。</li></ul></li><li><strong>不足</strong>：<ul><li>相较于抖音，品牌影响力稍弱，在高端市场吸引力不足。</li><li>平台内容质量参差不齐，部分低俗或重复内容影响用户体验。</li></ul></li></ul><h3 id="商业模式解释-10">商业模式解释</h3><ol><li><strong>广告收入</strong>：信息流广告、品牌合作投放。</li><li><strong>直播打赏</strong>：用户可向主播赠送虚拟礼物，平台抽取分成。</li><li><strong>电商佣金</strong>：直播带货、短视频种草，快手在交易中收取佣金。</li><li><strong>本地生活与服务</strong>：与商家合作提供团购、优惠券等服务，赚取佣金或推广费。</li></ol><h3 id="竞争分析-10">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>抖音</strong>：市场最大竞争者，流量更大，品牌影响力更强。</li><li><strong>小红书</strong>：在种草、内容电商方面竞争激烈。</li><li><strong>B站</strong>：在年轻人市场，二次元、长视频方向有较大竞争。</li></ul></li><li><strong>优势</strong>：<ul><li>用户互动高，社区氛围较强。</li><li>下沉市场占有率较高，覆盖大量三四线及农村用户。</li></ul></li><li><strong>劣势</strong>：<ul><li>品牌调性不够高端，在白领用户群体渗透较慢。</li><li>直播变现模式依赖度高，电商与广告的盈利能力仍需提升。</li></ul></li></ul><h3 id="运营策略-10">运营策略</h3><ol><li><strong>提升品牌形象</strong>：加强优质内容创作，吸引更多专业用户和品牌方。</li><li><strong>优化内容推荐</strong>：加强AI推荐算法，提高内容质量，减少低俗内容曝光。</li><li><strong>拓展电商生态</strong>：强化供应链整合，优化直播带货体验，提高用户购物满意度。</li><li><strong>国际化发展</strong>：继续开拓东南亚、南美等市场，提升全球竞争力。</li></ol><h3 id="改进建议-10">改进建议</h3><ol><li><strong>减少低质量内容</strong>：加强内容审核，提高优质创作者的激励力度。</li><li><strong>增强短视频变现能力</strong>：优化短视频广告、电商变现能力，降低对直播打赏的依赖。</li><li><strong>提升商业合作深度</strong>：与更多品牌商家合作，提高广告、电商、线下服务的综合变现能力。</li><li><strong>优化用户增长策略</strong>：在一二线城市增加推广，吸引更多年轻和高端用户。</li></ol><h3 id="总结-10">总结</h3><p>快手凭借独特的社区文化和强互动性，在短视频和直播市场占据重要地位。但面对抖音的竞争压力，它需要不断优化内容质量、拓展商业模式，并提升品牌影响力，以保持竞争优势。</p><hr><h2 id="微博（Weibo）">微博（Weibo）</h2><h3 id="产品概述-11">产品概述</h3><p>微博（Weibo）是中国最大的社交媒体平台之一，类似于Twitter，用户可以发布短内容（微博）、关注热点话题，并与公众人物、品牌或普通用户互动。作为信息传播和社交互动的重要工具，微博在新闻、娱乐、营销等领域具有广泛影响力。</p><h3 id="核心功能-11">核心功能</h3><ol><li><strong>信息流</strong>：用户可以关注感兴趣的博主，并通过信息流获取实时动态。</li><li><strong>热搜与话题</strong>：微博的热搜榜和话题广场帮助用户快速了解热点新闻和趋势。</li><li><strong>互动功能</strong>：包括评论、转发、点赞、私信等社交互动形式。</li><li><strong>短视频与直播</strong>：支持用户上传短视频、开设直播，增强内容丰富度。</li><li><strong>微博会员</strong>：提供VIP用户专属权益，如个性化主页、评论置顶等。</li><li><strong>广告与电商</strong>：品牌方可通过广告推广、KOL合作、直播带货等方式实现营销转化。</li></ol><h3 id="用户体验评估-11">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>信息获取及时，适合作为新闻和热点追踪工具。</li><li>互动性强，普通用户可与明星、品牌、KOL直接互动。</li><li>话题运营机制较成熟，用户可以围绕兴趣进行内容消费。</li></ul></li><li><strong>不足</strong>：<ul><li>信息流广告较多，影响阅读体验。</li><li>低质量内容和营销号泛滥，影响平台公信力。</li><li>用户增长趋于饱和，活跃度面临挑战。</li></ul></li></ul><h3 id="商业模式解释-11">商业模式解释</h3><ol><li><strong>广告收入</strong>：信息流广告、品牌推广、KOL合作等形式。</li><li><strong>会员订阅</strong>：微博会员提供增值功能，如专属标识、优先曝光等。</li><li><strong>电商与直播带货</strong>：用户可通过微博进行商品推广，平台抽取佣金。</li><li><strong>数据服务</strong>：提供企业级数据分析和营销解决方案。</li></ol><h3 id="竞争分析-11">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>微信</strong>：在社交和私域流量方面更具优势。</li><li><strong>抖音、快手</strong>：短视频平台分流了大量用户的内容消费时间。</li><li><strong>小红书</strong>：在内容社区和种草电商领域对微博形成竞争。</li></ul></li><li><strong>优势</strong>：<ul><li>具有较强的社交属性，用户粘性较高。</li><li>作为公共舆论场，仍是众多品牌、媒体和公众人物的重要阵地。</li></ul></li><li><strong>劣势</strong>：<ul><li>受短视频平台冲击，用户活跃度下降。</li><li>过度商业化导致部分用户体验下降。</li></ul></li></ul><h3 id="运营策略-11">运营策略</h3><ol><li><strong>优化内容推荐</strong>：提升算法推荐精度，减少低质量内容曝光。</li><li><strong>增强用户互动</strong>：鼓励用户生产优质内容，提高社区氛围。</li><li><strong>拓展电商生态</strong>：强化微博电商能力，与更多品牌、KOL深度合作。</li><li><strong>降低广告干扰</strong>：优化广告展示方式，提高用户体验。</li></ol><h3 id="改进建议-11">改进建议</h3><ol><li><strong>加强内容治理</strong>：减少营销号和低质内容，提升信息可信度。</li><li><strong>优化社交功能</strong>：增强私信、社群等互动功能，提升用户粘性。</li><li><strong>提升视频内容比重</strong>：加大短视频和直播投入，迎合用户内容消费趋势。</li><li><strong>国际化发展</strong>：拓展海外市场，吸引更多全球用户。</li></ol><h3 id="总结-11">总结</h3><p>微博作为中国最大的社交媒体平台之一，在新闻传播和品牌营销方面具有重要影响力。但面对短视频平台的冲击，其用户增长和活跃度面临挑战。未来需要优化内容生态、提升用户体验，并探索新的商业模式，以保持市场竞争力。</p><hr><h2 id="得到（Dedao）">得到（Dedao）</h2><h3 id="产品概述-12">产品概述</h3><p>得到是一款专注于知识付费的应用，提供音频课程、电子书、直播讲座和知识社群。其核心目标是为用户提供高质量的学习内容，涵盖商业、管理、科技、人文等多个领域，帮助用户系统化学习和提升认知能力。</p><h3 id="核心功能-12">核心功能</h3><ol><li><strong>付费专栏</strong>：知名讲师开设长期专栏，每日更新知识点，如李翔商业内参、薛兆丰经济学课等。</li><li><strong>精品课</strong>：提供深度知识课程，涵盖多个领域，帮助用户快速掌握某一主题。</li><li><strong>电子书</strong>：精选优质书籍，结合讲解和精华提炼，提升阅读效率。</li><li><strong>听书服务</strong>：将经典书籍拆解为音频内容，用户可在碎片时间内学习。</li><li><strong>社群互动</strong>：用户可在课程下交流，或参与得到社区，促进学习氛围。</li></ol><h3 id="用户体验评估-12">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>内容深度高，适合有系统学习需求的用户。</li><li>课程讲解清晰，音频和文本结合，方便用户多场景学习。</li><li>课程质量较高，主讲人多为行业专家或知名学者。</li></ul></li><li><strong>不足</strong>：<ul><li>付费门槛较高，部分用户可能难以接受长期订阅模式。</li><li>知识体系偏向商业和管理，对其他专业领域的覆盖度较弱。</li><li>社区互动功能相对较弱，用户粘性较依赖内容而非社交关系。</li></ul></li></ul><h3 id="商业模式解释-12">商业模式解释</h3><ol><li><strong>订阅制</strong>：用户购买年度会员，解锁部分课程或享受折扣。</li><li><strong>单次付费</strong>：用户可购买单个专栏、课程或电子书。</li><li><strong>企业培训</strong>：为企业提供团队学习方案，批量订阅课程。</li><li><strong>直播付费</strong>：知识分享直播，用户可付费观看或购买回放内容。</li></ol><h3 id="竞争分析-12">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>喜马拉雅</strong>：音频平台，涵盖更多泛娱乐内容，吸引更广泛用户群体。</li><li><strong>樊登读书</strong>：专注于书籍解读，针对中高端职场人士。</li><li><strong>知乎盐选</strong>：知乎的付费内容体系，结合问答社区增强互动性。</li></ul></li><li><strong>优势</strong>：<ul><li>课程质量高，内容体系化，适合深度学习用户。</li><li>品牌定位清晰，目标用户群体精准。</li></ul></li><li><strong>劣势</strong>：<ul><li>受众相对较窄，主要吸引职场人士，对年轻群体吸引力有限。</li><li>竞争对手在社交互动、内容丰富度方面更具优势。</li></ul></li></ul><h3 id="运营策略-12">运营策略</h3><ol><li><strong>扩展内容类别</strong>：增加科技、心理学、艺术等领域的知识课程，覆盖更广用户群体。</li><li><strong>优化社群互动</strong>：增强用户间的学习交流功能，提高用户粘性。</li><li><strong>提升会员价值</strong>：增加更多增值权益，如线下活动、专属咨询等，提升会员留存率。</li><li><strong>拓展企业市场</strong>：加强B端业务，推广企业学习方案，提升商业化能力。</li></ol><h3 id="改进建议-12">改进建议</h3><ol><li><strong>降低学习门槛</strong>：推出更多短期体验课，吸引新用户尝试。</li><li><strong>优化推荐系统</strong>：基于用户兴趣和学习进度，精准推送个性化内容。</li><li><strong>提升社交属性</strong>：推出小组学习模式，让用户在团队环境中共同成长。</li><li><strong>增加免费优质内容</strong>：通过免费试听或限时活动，提高用户转化率。</li></ol><h3 id="总结-12">总结</h3><p>得到在知识付费市场占据重要地位，凭借高质量内容和专业讲师体系吸引了大量职场用户。然而，在市场竞争加剧的情况下，需要不断优化产品体验、拓展内容品类，并增强社群互动，以提高用户粘性和商业价值。</p><hr><h2 id="夸克（Quark）">夸克（Quark）</h2><h3 id="产品概述-13">产品概述</h3><p>夸克是一款由阿里巴巴旗下的UC团队推出的智能搜索引擎和浏览器应用，主打极简设计、AI驱动的搜索体验，并结合了云存储、文档扫描等工具，成为年轻用户群体中的热门工具类应用。</p><h3 id="核心功能-13">核心功能</h3><ol><li><strong>智能搜索</strong>：基于AI算法优化搜索结果，提供精准的知识问答、图像搜索、学术搜索等功能。</li><li><strong>云盘存储</strong>：夸克网盘提供文件存储、智能分类、在线预览等功能，与夸克搜索深度集成。</li><li><strong>文档扫描</strong>：内置OCR文字识别技术，支持文档扫描、拍照翻译等功能。</li><li><strong>广告拦截</strong>：内置广告过滤功能，为用户提供更清爽的浏览体验。</li><li><strong>AI助手</strong>：智能摘要、AI问答、学习助手等功能，提升用户的信息获取效率。</li></ol><h3 id="用户体验评估-13">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>界面极简，浏览体验流畅，广告干扰较少。</li><li>搜索结果精准度较高，尤其在学术和专业知识领域有一定优势。</li><li>夸克网盘功能强大，适合学生和职场人士存储学习资料。</li></ul></li><li><strong>不足</strong>：<ul><li>市场认知度相较于百度、Google等搜索引擎较低，用户基数有限。</li><li>夸克网盘的免费存储空间较小，付费门槛较高。</li><li>生态体系不够完善，缺乏对其他阿里系产品的深度整合。</li></ul></li></ul><h3 id="商业模式解释-13">商业模式解释</h3><ol><li><strong>会员订阅</strong>：提供夸克网盘VIP，包含更大存储空间、加速下载等增值功能。</li><li><strong>搜索广告</strong>：与电商、信息流广告结合，在搜索结果中插入广告。</li><li><strong>增值工具</strong>：OCR扫描、AI翻译等高级功能可通过单次购买或订阅解锁。</li></ol><h3 id="竞争分析-13">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>百度</strong>（在中文搜索市场占据主导地位）。</li><li><strong>Google</strong>（在海外市场搜索体验更优，但在中国无法使用）。</li><li><strong>讯飞扫描王</strong>（在OCR识别、文档管理领域竞争）。</li><li><strong>阿里云盘、百度网盘</strong>（在云存储市场竞争）。</li></ul></li><li><strong>优势</strong>：<ul><li>无广告干扰的极简体验，吸引追求效率的用户。</li><li>AI功能较强，智能摘要、翻译等特色功能提高用户留存率。</li></ul></li><li><strong>劣势</strong>：<ul><li>市场份额相对较小，用户习惯尚未养成。</li><li>变现能力较弱，相较于百度的广告模式仍需探索更多盈利点。</li></ul></li></ul><h3 id="运营策略-13">运营策略</h3><ol><li><strong>增强用户教育</strong>：推广夸克的搜索、网盘等特色功能，提高用户认知度。</li><li><strong>优化会员权益</strong>：提升付费用户的独享功能，如更大存储、个性化搜索推荐等。</li><li><strong>拓展B端市场</strong>：与教育、科研机构合作，提供学术搜索、智能办公等解决方案。</li><li><strong>加强生态整合</strong>：与阿里云、支付宝、钉钉等产品联动，提高用户触达率。</li></ol><h3 id="改进建议-13">改进建议</h3><ol><li><strong>提升搜索精准度</strong>：进一步优化AI搜索能力，提高与竞品的核心差异化。</li><li><strong>优化网盘体验</strong>：增加免费用户存储空间，提高存储扩展的灵活性。</li><li><strong>增强用户增长策略</strong>：推出联合推广、邀请返利等活动，提升市场渗透率。</li><li><strong>拓展内容生态</strong>：引入更多知识类、专业类内容，提高平台信息质量。</li></ol><h3 id="总结-13">总结</h3><p>夸克凭借极简设计和AI搜索能力，在搜索引擎和工具应用市场中形成了一定的竞争力。然而，面对百度的市场垄断和用户习惯的固化，夸克需要进一步提升搜索能力、优化商业模式，并加强品牌推广，以提升市场占有率和用户忠诚度。</p><hr><h2 id="喜马拉雅（Ximalaya）">喜马拉雅（Ximalaya）</h2><h3 id="产品概述-14">产品概述</h3><p>喜马拉雅是中国领先的音频内容平台，提供有声书、播客、新闻、相声、音乐等多种音频内容。自2012年成立以来，喜马拉雅逐步构建了内容创作者生态，吸引了大量用户在通勤、学习、休闲时使用，形成了“耳朵经济”领域的领导品牌。</p><h3 id="核心功能-14">核心功能</h3><ol><li><strong>有声书</strong>：涵盖文学、历史、科幻等多类型书籍，用户可在线收听或下载离线播放。</li><li><strong>播客节目</strong>：提供新闻、访谈、财经、科技等丰富的播客内容，满足不同用户需求。</li><li><strong>知识付费</strong>：名人讲座、课程订阅、学术讲解等内容，适合提升个人技能。</li><li><strong>睡眠与冥想</strong>：助眠音乐、白噪音、冥想课程，帮助用户放松和改善睡眠质量。</li><li><strong>儿童专区</strong>：专门为儿童提供寓教于乐的音频内容，如故事、英语启蒙等。</li><li><strong>主播互动</strong>：用户可以关注喜爱的主播，点赞、评论、打赏，提高社区互动性。</li></ol><h3 id="用户体验评估-14">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>内容种类丰富，适合不同人群的需求。</li><li>界面简洁，播放体验流畅，支持多设备同步。</li><li>知识付费体系完善，用户可以系统化学习。</li></ul></li><li><strong>不足</strong>：<ul><li>免费用户广告较多，影响听觉体验。</li><li>付费会员权益较为分散，用户可能对订阅模式的价值感知不足。</li><li>播客与部分内容的个性化推荐有待优化。</li></ul></li></ul><h3 id="商业模式解释-14">商业模式解释</h3><ol><li><strong>会员订阅</strong>：提供VIP会员，解锁付费内容、去广告、音质提升等权益。</li><li><strong>知识付费</strong>：用户可以单独购买课程、有声书、讲座等内容。</li><li><strong>广告收入</strong>：平台在音频内容、开屏广告、信息流广告等位置投放广告。</li><li><strong>主播打赏与直播</strong>：用户可向喜爱的主播赠送虚拟礼物，平台抽取分成。</li><li><strong>品牌合作</strong>：与企业、出版社、教育机构合作，推广优质内容。</li></ol><h3 id="竞争分析-14">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>蜻蜓FM</strong>（另一家音频平台，主打电台节目）。</li><li><strong>得到</strong>（专注知识付费，竞争力较强）。</li><li><strong>Apple Podcasts / Spotify</strong>（在国际市场占有优势，但在国内影响有限）。</li></ul></li><li><strong>优势</strong>：<ul><li>内容生态丰富，涵盖免费与付费内容，满足不同用户需求。</li><li>头部主播与独家内容多，具有较强用户粘性。</li></ul></li><li><strong>劣势</strong>：<ul><li>过度依赖知识付费，商业模式单一化风险较高。</li><li>在播客领域的国际化竞争中，相比Spotify等平台存在差距。</li></ul></li></ul><h3 id="运营策略-14">运营策略</h3><ol><li><strong>优化会员体系</strong>：加强会员权益整合，提高用户订阅意愿。</li><li><strong>提升AI推荐能力</strong>：利用算法优化个性化推荐，提升用户留存率。</li><li><strong>拓展海外市场</strong>：开发海外中文听众市场，提高国际影响力。</li><li><strong>加强社区互动</strong>：引入更多社交元素，如听友群、讨论区，提高用户活跃度。</li></ol><h3 id="改进建议-14">改进建议</h3><ol><li><strong>减少广告干扰</strong>：优化广告展示方式，降低对免费用户的影响。</li><li><strong>增强免费内容</strong>：提供更多高质量免费节目，提高新用户转化率。</li><li><strong>提升音频体验</strong>：引入3D音效、沉浸式播放，提高高端用户体验。</li><li><strong>扩展内容品类</strong>：加强财经、科技、创业等垂直领域的音频内容，提高专业性。</li></ol><h3 id="总结-14">总结</h3><p>喜马拉雅凭借其丰富的音频内容和强大的用户生态，在中国音频市场占据领先地位。未来需优化会员权益、提升内容推荐精准度，并拓展国际市场，以保持长期竞争力。</p><hr><h2 id="探探（Tantan）">探探（Tantan）</h2><h3 id="产品概述-15">产品概述</h3><p>探探是中国领先的社交交友应用，主打“滑动匹配”模式，帮助年轻人基于兴趣、地理位置找到潜在朋友或约会对象。探探的核心特色在于匿名、轻量化交互，让用户可以自由选择是否与对方建立联系。</p><h3 id="核心功能-15">核心功能</h3><ol><li><strong>滑动匹配</strong>：用户向右滑动喜欢的人，向左滑动跳过，只有双方都喜欢才可聊天。</li><li><strong>即时聊天</strong>：匹配成功后可进入私聊，支持文字、图片、语音等多种交流方式。</li><li><strong>个性化推荐</strong>：基于AI算法推荐可能感兴趣的用户，提高匹配成功率。</li><li><strong>附近的人</strong>：基于地理位置，展示周边活跃用户，增强本地社交体验。</li><li><strong>超级喜欢 &amp; 反悔功能</strong>：用户可发送超级喜欢，提高被匹配概率，或撤销误操作的滑动。</li></ol><h3 id="用户体验评估-15">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li><strong>界面简洁直观</strong>，滑动匹配降低社交压力，提高互动率。</li><li><strong>AI推荐较精准</strong>，基于兴趣和行为优化匹配结果。</li><li><strong>匿名机制保护隐私</strong>，降低用户初次交流的心理负担。</li></ul></li><li><strong>不足</strong>：<ul><li>机器人账号和虚假信息较多，影响用户信任度。</li><li>付费门槛较高，非会员用户匹配效率较低。</li><li>部分用户抱怨社交目的单一，缺乏深度关系建立的功能。</li></ul></li></ul><h3 id="商业模式解释-15">商业模式解释</h3><ol><li><strong>会员订阅（VIP）</strong>：提供无限滑动、查看谁喜欢你等高级功能，提升匹配效率。</li><li><strong>付费道具</strong>：如超级喜欢、反悔、增加曝光等，提高用户的互动机会。</li><li><strong>广告收入</strong>：通过信息流广告、品牌合作推广等方式变现。</li><li><strong>增值服务</strong>：推出类似“探探约会”等高端社交活动，提高用户付费意愿。</li></ol><h3 id="竞争分析-15">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>陌陌</strong>（主打陌生人社交，直播带货收入较高）。</li><li><strong>Soul</strong>（强调兴趣社交和社群互动，弱化颜值匹配）。</li><li><strong>Tinder</strong>（国际化社交软件，在海外市场具有较强竞争力）。</li></ul></li><li><strong>优势</strong>：<ul><li>产品模式成熟，匹配机制易上手，用户粘性较高。</li><li>在国内年轻人市场有较高的品牌认知度。</li></ul></li><li><strong>劣势</strong>：<ul><li>用户增长趋缓，市场竞争激烈，存在用户流失风险。</li><li>社交质量不稳定，部分用户体验较差，影响口碑。</li></ul></li></ul><h3 id="运营策略-15">运营策略</h3><ol><li><strong>优化匹配质量</strong>：加强身份认证机制，减少机器人和虚假账户，提高用户信任感。</li><li><strong>拓展社交场景</strong>：增加兴趣小组、在线活动，提高用户互动深度。</li><li><strong>优化会员权益</strong>：提供更多差异化功能，如语音匹配、视频聊天等，提高付费转化率。</li><li><strong>国际化探索</strong>：借鉴Tinder经验，拓展东南亚等社交市场，增加用户增长点。</li></ol><h3 id="改进建议-15">改进建议</h3><ol><li><strong>打击虚假用户</strong>：加强审核机制，提升用户体验和平台安全性。</li><li><strong>优化女性用户体验</strong>：增加更多社交互动机制，提高女性用户留存率。</li><li><strong>增强内容生态</strong>：支持短视频社交，提升用户之间的互动深度。</li><li><strong>降低付费门槛</strong>：推出更多灵活订阅方案，提高普通用户的参与度。</li></ol><h3 id="总结-15">总结</h3><p>探探作为中国市场上的领先社交应用，凭借“滑动匹配”模式吸引了大量年轻用户。但面对激烈的竞争和用户需求变化，探探需要优化匹配质量、提升用户体验，并探索更多社交场景，以确保长期增长和市场领先地位。</p><hr><h2 id="叮咚买菜（Dingdong-Maicai）">叮咚买菜（Dingdong Maicai）</h2><h3 id="产品概述-16">产品概述</h3><p>叮咚买菜是中国领先的生鲜电商平台，提供即时配送的生鲜食品服务。平台主要通过前置仓模式，在用户下单后提供最快30分钟到1小时的配送服务，满足城市用户对生鲜食品的即时需求。</p><h3 id="核心功能-16">核心功能</h3><ol><li><strong>生鲜品类</strong>：涵盖蔬菜、水果、肉禽、海鲜、乳制品等日常食品。</li><li><strong>极速配送</strong>：依托前置仓模式，实现1小时内送达的即时配送服务。</li><li><strong>智能推荐</strong>：基于用户购买习惯，AI推荐个性化商品。</li><li><strong>会员服务</strong>：提供折扣、专属优惠券等会员权益，提高用户复购率。</li><li><strong>食品溯源</strong>：部分产品支持可追溯体系，确保食品安全。</li></ol><h3 id="用户体验评估-16">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>配送速度快，满足即时生鲜需求。</li><li>商品品类丰富，基本可覆盖家庭日常采购需求。</li><li>界面简洁，购物流程流畅，用户体验友好。</li></ul></li><li><strong>不足</strong>：<ul><li>价格相对传统菜市场和超市偏高，性价比不足。</li><li>受限于前置仓布局，部分区域可能配送不到。</li><li>供应链成本高，盈利模式仍需优化。</li></ul></li></ul><h3 id="商业模式解释-16">商业模式解释</h3><ol><li><strong>商品销售</strong>：通过销售生鲜食品赚取利润。</li><li><strong>会员订阅</strong>：提供VIP会员服务，享受折扣和专属权益。</li><li><strong>品牌合作</strong>：与食品供应商合作，推广品牌商品。</li><li><strong>数据增值服务</strong>：通过大数据分析优化供应链，提高运营效率。</li></ol><h3 id="竞争分析-16">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>美团买菜</strong>（同样采用前置仓模式，依托美团生态流量）。</li><li><strong>盒马鲜生</strong>（线上+线下结合模式，门店体验更强）。</li><li><strong>多多买菜</strong>（拼多多旗下，社区团购模式，价格更具优势）。</li></ul></li><li><strong>优势</strong>：<ul><li>专注生鲜即时配送，供应链能力较强。</li><li>在一线城市用户基础稳固，品牌认知度较高。</li></ul></li><li><strong>劣势</strong>：<ul><li>运营成本高，盈利能力受限。</li><li>竞争激烈，市场份额容易受价格战影响。</li></ul></li></ul><h3 id="运营策略-16">运营策略</h3><ol><li><strong>优化供应链</strong>：提高仓储管理和物流效率，降低配送成本。</li><li><strong>提升用户粘性</strong>：丰富会员权益，提高用户复购率。</li><li><strong>拓展市场</strong>：进入二三线城市，增加市场渗透率。</li><li><strong>加强食品安全监管</strong>：提高食品质量管控，增强用户信任感。</li></ol><h3 id="改进建议-16">改进建议</h3><ol><li><strong>优化定价策略</strong>：提供更多促销和套餐，提高性价比。</li><li><strong>加强区域覆盖</strong>：拓展前置仓布局，覆盖更多城市。</li><li><strong>提升智能推荐</strong>：优化AI算法，提高用户个性化购物体验。</li><li><strong>探索多元化服务</strong>：引入半成品预制菜、即食食品等，提高客单价。</li></ol><h3 id="总结-16">总结</h3><p>叮咚买菜凭借即时配送和强供应链管理，在生鲜电商领域占据重要位置。但面对竞争激烈的市场环境，需要优化成本结构、提升用户粘性，并拓展更多增长点，以实现长期可持续发展。</p><hr><h2 id="美图秀秀（Meitu-Xiuxiu）">美图秀秀（Meitu Xiuxiu）</h2><h3 id="产品概述-17">产品概述</h3><p>美图秀秀是中国领先的图片编辑与美颜软件，提供强大的修图、美颜、滤镜、AI特效等功能，深受年轻用户尤其是女性用户喜爱。美图秀秀不仅是国内修图软件的代表，还在短视频、社交、美妆AI等领域不断拓展，形成独特的产品生态。</p><h3 id="核心功能-17">核心功能</h3><ol><li><strong>智能美颜</strong>：支持自拍美颜、瘦脸、磨皮、美白、五官调整等。</li><li><strong>滤镜与特效</strong>：提供多种风格滤镜和AI特效，增强照片艺术感。</li><li><strong>AI绘画</strong>：基于AI技术，将照片转换成漫画风、二次元风等。</li><li><strong>视频美化</strong>：支持短视频美颜、特效、字幕添加等功能。</li><li><strong>社交分享</strong>：用户可将编辑后的图片分享到美图社区或其他社交平台。</li><li><strong>美妆与穿搭推荐</strong>：结合AI分析，为用户提供个性化美妆和穿搭建议。</li></ol><h3 id="用户体验评估-17">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>界面简洁易用，新手用户可快速上手。</li><li>美颜与修图功能强大，满足不同用户需求。</li><li>AI特效持续创新，提高用户新鲜感。</li></ul></li><li><strong>不足</strong>：<ul><li>部分高级功能需付费，非会员用户体验受限。</li><li>过度美颜可能影响照片真实性，引发审美焦虑争议。</li><li>广告较多，影响部分用户使用体验。</li></ul></li></ul><h3 id="商业模式解释-17">商业模式解释</h3><ol><li><strong>会员订阅</strong>：美图VIP提供高级滤镜、无水印、AI特效等增值功能。</li><li><strong>广告收入</strong>：在应用内展示品牌广告，或与美妆、时尚品牌合作推广。</li><li><strong>AI美妆与电商</strong>：结合AI技术，推出个性化美妆推荐，并与品牌电商合作。</li><li><strong>授权技术</strong>：向第三方平台提供AI美颜、图像处理技术服务。</li></ol><h3 id="竞争分析-17">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>FaceU、B612</strong>（主打拍照美颜，竞争美颜自拍市场）。</li><li><strong>Snapchat、Instagram</strong>（在短视频、滤镜社交领域形成竞争）。</li><li><strong>剪映、VN</strong>（在短视频编辑市场有一定替代性）。</li></ul></li><li><strong>优势</strong>：<ul><li>深耕修图市场多年，品牌认知度高，用户群体忠诚度强。</li><li>AI技术创新持续推进，拓展美妆、社交等领域。</li></ul></li><li><strong>劣势</strong>：<ul><li>变现方式较单一，仍依赖会员订阅和广告收入。</li><li>海外市场拓展有限，国际竞争力有待提升。</li></ul></li></ul><h3 id="运营策略-17">运营策略</h3><ol><li><strong>优化会员体系</strong>：提升VIP会员权益，增加独家滤镜和AI功能，提高付费转化率。</li><li><strong>增强社交属性</strong>：推动美图社区互动，提升用户留存和分享欲望。</li><li><strong>深化AI技术应用</strong>：扩展至更多AI智能美妆、智能穿搭功能，提高用户价值。</li><li><strong>拓展国际市场</strong>：加强海外推广，针对欧美、日本等市场推出本地化版本。</li></ol><h3 id="改进建议-17">改进建议</h3><ol><li><strong>减少广告干扰</strong>：优化广告展示逻辑，避免影响用户体验。</li><li><strong>推出个性化推荐</strong>：基于用户行为优化滤镜、特效推荐，提高用户粘性。</li><li><strong>增加短视频功能</strong>：增强视频剪辑、美颜能力，提升用户对短视频创作的兴趣。</li><li><strong>探索更多商业化模式</strong>：如推出AI虚拟形象、NFT头像生成等创新产品，扩大营收来源。</li></ol><h3 id="总结-17">总结</h3><p>美图秀秀凭借其强大的修图与美颜功能，在市场中占据重要地位。然而，面对短视频、社交产品的竞争，美图秀秀需要持续创新，优化用户体验，并探索更多商业化模式，以保持长期竞争力。</p><hr><h2 id="微信读书（WeChat-Reading）">微信读书（WeChat Reading）</h2><h3 id="产品概述-18">产品概述</h3><p>微信读书是腾讯旗下的数字阅读平台，依托微信生态，为用户提供电子书、听书、笔记分享、社交阅读等功能。其核心特色是“社交+阅读”模式，用户可以与微信好友互动，查看好友的阅读动态，增强阅读体验。</p><h3 id="核心功能-18">核心功能</h3><ol><li><strong>电子书阅读</strong>：提供海量书籍，涵盖文学、商业、科技等多个类别。</li><li><strong>听书功能</strong>：部分书籍支持音频朗读，适合碎片化学习。</li><li><strong>社交阅读</strong>：用户可查看好友书架、阅读时长、笔记等，增强互动感。</li><li><strong>无限卡会员</strong>：订阅会员可畅读大部分书籍，提升阅读自由度。</li><li><strong>阅读挑战</strong>：鼓励用户参与读书打卡，提高阅读动力。</li><li><strong>跨设备同步</strong>：支持手机、平板、电脑端同步阅读进度。</li></ol><h3 id="用户体验评估-18">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>依托微信社交关系链，提升用户阅读动力。</li><li>书籍种类丰富，界面简洁，阅读体验优良。</li><li>无限卡模式降低单本书购买成本，适合高频阅读用户。</li></ul></li><li><strong>不足</strong>：<ul><li>对非微信用户吸引力有限，依赖微信生态较强。</li><li>部分优质书籍仍需单独购买，影响会员体验。</li><li>听书功能相较于专业平台（如喜马拉雅）仍有提升空间。</li></ul></li></ul><h3 id="商业模式解释-18">商业模式解释</h3><ol><li><strong>会员订阅</strong>：无限卡提供畅读权限，用户按月/年付费。</li><li><strong>单本购买</strong>：部分热门书籍需要单独购买或租赁。</li><li><strong>广告与推广</strong>：与出版社、品牌合作，进行书籍推广和营销。</li><li><strong>社交裂变</strong>：通过好友邀请、阅读挑战等提高用户活跃度和续订率。</li></ol><h3 id="竞争分析-18">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>Kindle中国</strong>（亚马逊旗下，书籍资源丰富，但生态封闭）。</li><li><strong>掌阅、QQ阅读</strong>（传统数字阅读平台，市场份额较大）。</li><li><strong>喜马拉雅、得到</strong>（专注于知识付费和听书市场）。</li></ul></li><li><strong>优势</strong>：<ul><li>微信生态加持，社交阅读模式独特。</li><li>订阅模式降低购书成本，提高用户黏性。</li></ul></li><li><strong>劣势</strong>：<ul><li>受限于微信生态，独立性较弱，难以吸引非微信用户。</li><li>内容与出版资源仍需拓展，部分专业书籍覆盖不足。</li></ul></li></ul><h3 id="运营策略-18">运营策略</h3><ol><li><strong>优化听书体验</strong>：引入更多专业主播朗读，增强有声书吸引力。</li><li><strong>提升会员权益</strong>：扩展会员专属书库，提高无限卡吸引力。</li><li><strong>拓展企业市场</strong>：为公司、学校提供阅读订阅方案，扩大B端业务。</li><li><strong>国际化探索</strong>：推出适配海外用户的版本，拓展全球华人市场。</li></ol><h3 id="改进建议-18">改进建议</h3><ol><li><strong>增强社交互动</strong>：增加书友社群、读书会功能，提高用户参与度。</li><li><strong>优化内容推荐</strong>：基于AI分析用户兴趣，推送个性化阅读书单。</li><li><strong>提升电子书排版</strong>：优化阅读排版和笔记功能，提供更专业的阅读体验。</li><li><strong>探索知识付费模式</strong>：推出深度解读、课程等增值内容，提高用户价值。</li></ol><h3 id="总结-18">总结</h3><p>微信读书凭借社交+阅读模式，在数字阅读市场中形成差异化竞争优势。但要进一步扩大市场份额，需要优化听书体验、强化会员价值，并探索新的商业化模式，以实现长期增长。</p><hr><h2 id="即刻（Jike）">即刻（Jike）</h2><h3 id="产品概述-19">产品概述</h3><p>即刻是一款主打兴趣社区与信息聚合的社交应用，最初以“信息订阅”功能闻名，后逐步转型为年轻人兴趣社交平台。即刻的核心理念是让用户基于兴趣发现内容、建立社群，并围绕共同话题进行交流。</p><h3 id="核心功能-19">核心功能</h3><ol><li><strong>兴趣话题</strong>：用户可以关注自己感兴趣的话题（如科技、游戏、电影），获取个性化信息流。</li><li><strong>社区互动</strong>：支持用户在话题下发布动态、评论、点赞，提高社交参与度。</li><li><strong>即时热点</strong>：基于算法推荐最新的网络热点，帮助用户及时获取热门信息。</li><li><strong>小组功能</strong>：类似论坛，用户可以加入或创建兴趣小组，进行更深入的交流。</li><li><strong>内容创作与分发</strong>：支持用户发布短文、长文、图片、视频，增强内容生态。</li></ol><h3 id="用户体验评估-19">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>界面设计清爽，信息流逻辑清晰，使用体验良好。</li><li>关注兴趣点而非社交关系，降低信息冗余，提高内容质量。</li><li>社区氛围较好，适合优质内容生产者和深度讨论。</li></ul></li><li><strong>不足</strong>：<ul><li>用户规模相对较小，部分兴趣小组活跃度不高。</li><li>变现模式尚未完全成熟，盈利能力受限。</li><li>相较于微博、豆瓣等竞争对手，内容丰富度仍需加强。</li></ul></li></ul><h3 id="商业模式解释-19">商业模式解释</h3><ol><li><strong>广告投放</strong>：品牌可在兴趣话题、社区推荐位等进行精准广告投放。</li><li><strong>会员订阅</strong>：提供额外权益，如无广告、高级功能等，提高用户付费转化。</li><li><strong>内容电商</strong>：基于兴趣社群，结合KOL推荐，尝试社交电商变现。</li><li><strong>品牌合作</strong>：与媒体、出版机构等合作，提供独家内容或推广服务。</li></ol><h3 id="竞争分析-19">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>微博</strong>（信息流+社交，但信息噪音较多）。</li><li><strong>豆瓣</strong>（兴趣社群，但社区氛围相对封闭）。</li><li><strong>小红书</strong>（基于内容的社交推荐，偏种草方向）。</li></ul></li><li><strong>优势</strong>：<ul><li>关注兴趣，而非社交关系，降低社交压力，提高内容质量。</li><li>社区互动性较强，讨论深度优于微博等泛社交平台。</li></ul></li><li><strong>劣势</strong>：<ul><li>用户基数较小，难以形成大规模影响力。</li><li>变现模式探索中，商业化能力仍需加强。</li></ul></li></ul><h3 id="运营策略-19">运营策略</h3><ol><li><strong>提升用户增长</strong>：通过精准营销、口碑传播，吸引更多高质量用户。</li><li><strong>优化推荐算法</strong>：提升兴趣匹配精准度，提高用户粘性和活跃度。</li><li><strong>增强商业化探索</strong>：尝试知识付费、电商带货等变现方式，提升收入能力。</li><li><strong>拓展内容生态</strong>：引入更多优质创作者，增加原创内容供给，提高用户留存率。</li></ol><h3 id="改进建议-19">改进建议</h3><ol><li><strong>优化用户推荐机制</strong>：减少无关内容，提高兴趣匹配的精准度。</li><li><strong>增强社群互动工具</strong>：推出更多互动玩法，如直播、语音聊天室等，提升用户体验。</li><li><strong>提升商业化能力</strong>：探索品牌合作、电商、知识付费等多元盈利模式。</li><li><strong>加速用户增长</strong>：通过与高校、KOL合作，吸引更多年轻用户进入平台。</li></ol><h3 id="总结-19">总结</h3><p>即刻凭借兴趣社交模式，在信息聚合与社区互动方面具有一定竞争力。但要进一步扩大影响力，需要加强用户增长、优化内容生态，并探索更多商业化模式，以确保平台的可持续发展。</p><hr><h2 id="百度地图（Baidu-Maps）">百度地图（Baidu Maps）</h2><h3 id="产品概述-20">产品概述</h3><p>百度地图是中国领先的地图导航服务，提供精准的地点搜索、实时交通、公交换乘、步行导航等功能。作为百度 AI 战略的重要组成部分，百度地图近年来不断升级 AI 算法，优化导航体验，并扩展至自动驾驶、智慧出行等领域。</p><h3 id="核心功能-20">核心功能</h3><ol><li><strong>智能导航</strong>：提供实时路况信息，支持驾车、步行、骑行、公交等多种出行方式。</li><li><strong>实时交通</strong>：基于大数据分析，提供精准的拥堵预测和动态路线优化。</li><li><strong>室内地图</strong>：覆盖商场、机场、车站等室内场景，支持 AR 导航。</li><li><strong>自动驾驶支持</strong>：百度 Apollo 自动驾驶技术在百度地图上已有部分落地。</li><li><strong>语音助手</strong>：智能语音交互，支持语音导航、地点查询，提高驾驶安全性。</li><li><strong>生活服务</strong>：集成酒店预订、美食推荐、加油站查询等本地生活功能。</li></ol><h3 id="用户体验评估-20">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>地图数据精准，适用于国内各种出行场景。</li><li>AI 算法优化路径规划，提升出行效率。</li><li>语音助手和 AR 导航增强了智能化体验。</li></ul></li><li><strong>不足</strong>：<ul><li>广告较多，部分推广内容影响用户体验。</li><li>海外地图数据不如 Google Maps 完善，限制国际化使用。</li><li>个人隐私数据安全问题仍需加强透明度和用户控制权限。</li></ul></li></ul><h3 id="商业模式解释-20">商业模式解释</h3><ol><li><strong>广告业务</strong>：通过信息流广告、商家标注、POI（兴趣点）推广等形式盈利。</li><li><strong>企业服务</strong>：提供 API、企业地图解决方案，涵盖物流、零售、旅游等行业。</li><li><strong>自动驾驶生态</strong>：与百度 Apollo 结合，布局智能驾驶商业化。</li><li><strong>本地生活变现</strong>：与酒店、餐饮、出行等服务商合作，实现交易分成。</li></ol><h3 id="竞争分析-20">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>高德地图</strong>（阿里巴巴旗下，数据精准，用户体验较强）。</li><li><strong>腾讯地图</strong>（微信生态加持，但市场占有率较低）。</li><li><strong>Google Maps</strong>（全球覆盖度广，但在国内无法使用）。</li></ul></li><li><strong>优势</strong>：<ul><li>强大的 AI 算法优化导航和搜索体验。</li><li>百度生态支持，与搜索、Apollo 业务形成协同效应。</li></ul></li><li><strong>劣势</strong>：<ul><li>用户体验因广告和信息冗余受到一定影响。</li><li>在高端导航市场（如智能驾驶、海外数据）尚未形成绝对优势。</li></ul></li></ul><h3 id="运营策略-20">运营策略</h3><ol><li><strong>优化用户体验</strong>：减少广告干扰，提高导航界面清晰度和交互体验。</li><li><strong>强化智慧出行</strong>：增加智能驾驶支持，推动百度 Apollo 生态落地。</li><li><strong>扩展企业市场</strong>：提供更强大的 API 能力，拓展 B 端客户。</li><li><strong>国际化布局</strong>：加强海外地图数据建设，提升全球导航能力。</li></ol><h3 id="改进建议-20">改进建议</h3><ol><li><strong>降低广告占比</strong>：优化商业模式，减少对普通用户的广告干扰。</li><li><strong>增强隐私保护</strong>：提升用户数据管理权限，提高透明度。</li><li><strong>提升 AR 导航体验</strong>：优化 AR 导航精度，提高在复杂场景下的实用性。</li><li><strong>拓展 AI 语音助手能力</strong>：增加个性化语音指令，提高智能化水平。</li></ol><h3 id="总结-20">总结</h3><p>百度地图凭借 AI 能力和百度生态，在中国市场具备较强竞争力。但面对高德地图的市场主导地位，百度地图需要进一步优化用户体验、增强自动驾驶能力，并拓展国际市场，以提升长期竞争力。</p><hr>]]></content>
    
    
    <summary type="html">互联网产品分析笔记(一)</summary>
    
    
    
    <category term="产品分析" scheme="https://www.angfff.top/categories/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="互联网产品" scheme="https://www.angfff.top/tags/%E4%BA%92%E8%81%94%E7%BD%91%E4%BA%A7%E5%93%81/"/>
    
    <category term="产品分析" scheme="https://www.angfff.top/tags/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"/>
    
    <category term="PM" scheme="https://www.angfff.top/tags/PM/"/>
    
  </entry>
  
  <entry>
    <title>MLX-学习笔记</title>
    <link href="https://www.angfff.top/posts/d37068c6.html"/>
    <id>https://www.angfff.top/posts/d37068c6.html</id>
    <published>2025-02-09T03:23:37.000Z</published>
    <updated>2025-05-22T04:31:09.393Z</updated>
    
    <content type="html"><![CDATA[<h1>一、框架文档 <a href="https://ml-explore.github.io/mlx/build/html/index.html">MLX</a></h1><hr><h1>二、框架安装</h1><h2 id="（一）创建并使用环境">（一）创建并使用环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">% python &gt;= 3.10 %%</span></span><br><span class="line">conda create -n mlx python=3.10</span><br><span class="line"></span><br><span class="line">conda activate mlx</span><br></pre></td></tr></table></figure><h2 id="（二）安装框架">（二）安装框架</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mlx</span><br></pre></td></tr></table></figure><hr><h1>三、LLM</h1><h2 id="（一）相关链接">（一）相关链接</h2><ul><li><a href="https://github.com/ml-explore/mlx-examples">mlx-examples</a></li><li><a href="https://github.com/ml-explore/mlx-examples/tree/main/llms">mlx-llms</a></li><li><a href="https://huggingface.co/mlx-community?message=You've%20joined%20MLX%20Community!">mlx-community</a></li></ul><h2 id="（二）安装-mlx-lm-库">（二）安装 mlx_lm 库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mlx-lm</span><br></pre></td></tr></table></figure><h2 id="（三）拉取-mlx-examples">（三）拉取 mlx-examples</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">% 官方示例库，方便学习参考 %%</span></span><br><span class="line">git clone https://github.com/ml-explore/mlx-examples.git</span><br></pre></td></tr></table></figure><h2 id="（四）Hugging-Face-模型下载">（四）Hugging Face 模型下载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">% 安装 git-lfs 方便拉取大文件 %%</span></span><br><span class="line">brew install git-lfs</span><br><span class="line">git lfs install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">% 拉取模型文件 %%</span></span><br><span class="line">git clone https://huggingface.co/Qwen/Qwen2.5-0.5B-Instruct</span><br></pre></td></tr></table></figure><h2 id="（五）模型推理-Generate">（五）模型推理 Generate</h2><h3 id="5-1-Generate-from-a-model">5.1 Generate from a model</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mlx_lm.generate \</span><br><span class="line">--model &lt;path&gt; \</span><br><span class="line">--prompt &quot;&lt;prompt&gt;&quot;</span><br></pre></td></tr></table></figure><h3 id="5-2-Generate-from-a-model-after-finetuning-with-adapter">5.2 Generate from a model after finetuning with adapter</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mlx_lm.generate \</span><br><span class="line">--model &lt;path&gt; \</span><br><span class="line">--adapter-path &lt;path&gt; \</span><br><span class="line">--prompt &quot;&lt;prompt&gt;&quot;</span><br></pre></td></tr></table></figure><h2 id="（六）模型微调">（六）模型微调</h2><h3 id="6-1-Finetune-Lora">6.1 Finetune --Lora</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mlx_lm.lora \</span><br><span class="line">--model &lt;path&gt; \</span><br><span class="line">--train \</span><br><span class="line">--data &lt;path&gt; \</span><br><span class="line">--iters 600</span><br></pre></td></tr></table></figure><h3 id="6-2-Fuse-整合">6.2 Fuse 整合</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mlx_lm.fuse \</span><br><span class="line">--model &lt;path&gt; \</span><br><span class="line">--adapter-path &lt;path&gt; \</span><br><span class="line">--save-path &lt;path&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">MLX 学习笔记</summary>
    
    
    
    <category term="AI" scheme="https://www.angfff.top/categories/AI/"/>
    
    <category term="LLM" scheme="https://www.angfff.top/categories/AI/LLM/"/>
    
    
    <category term="MLX" scheme="https://www.angfff.top/tags/MLX/"/>
    
    <category term="AI" scheme="https://www.angfff.top/tags/AI/"/>
    
    <category term="LLM" scheme="https://www.angfff.top/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>实战项目——股票分析系统</title>
    <link href="https://www.angfff.top/posts/82f46f22.html"/>
    <id>https://www.angfff.top/posts/82f46f22.html</id>
    <published>2025-01-03T06:55:23.000Z</published>
    <updated>2025-05-22T04:31:09.393Z</updated>
    
    
    <summary type="html">基于 Flask 和 Vuetify 框架的股票分析系统，结合 LLM 与 LSTM 模型，实现股票基本面、技术面及市场情绪分析等功能。</summary>
    
    
    
    <category term="实战项目" scheme="https://www.angfff.top/categories/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="股票分析系统" scheme="https://www.angfff.top/categories/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/%E8%82%A1%E7%A5%A8%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Python" scheme="https://www.angfff.top/tags/Python/"/>
    
    <category term="实战项目" scheme="https://www.angfff.top/tags/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="Flask" scheme="https://www.angfff.top/tags/Flask/"/>
    
    <category term="Node.js" scheme="https://www.angfff.top/tags/Node-js/"/>
    
    <category term="Vuetify" scheme="https://www.angfff.top/tags/Vuetify/"/>
    
    <category term="前后端分离" scheme="https://www.angfff.top/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>Python 学习笔记</title>
    <link href="https://www.angfff.top/posts/7db8c537.html"/>
    <id>https://www.angfff.top/posts/7db8c537.html</id>
    <published>2024-09-29T11:37:59.000Z</published>
    <updated>2025-05-22T04:31:09.392Z</updated>
    
    <content type="html"><![CDATA[<h1>1. 基础</h1><h2 id="1-1-编码-标识符-保留字">1.1 编码 / 标识符 / 保留字</h2><ol><li>默认情况下，Python 3 源码文件以 <strong>UTF-8</strong> 编码，所有字符串都是 unicode 字符串；</li><li>标识符<ul><li>第一个字符必须是字母表中字母或下划线_</li><li>标识符的其他的部分由字母、数字和下划线组成</li><li>标识符对大小写敏感</li></ul></li><li>保留字即关键字，不能把它们用作任何标识符名称。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line"><span class="built_in">print</span>(keyword.kwlist)</span><br></pre></td></tr></table></figure></li></ol><h2 id="1-2-注释">1.2 注释</h2><ol><li>单行注释以 <strong>#</strong> 开头</li><li>多行注释可以用多个#号，或者三个单 / 双引号 ‘’’ 和 “”&quot;</li><li>多行注释中不能再嵌套多行注释，但可以使用单行注释 #</li><li>输出函数的注释<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;函数注释&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.__doc__)</span><br></pre></td></tr></table></figure></li></ol><h2 id="1-3-多行语句">1.3 多行语句</h2><ol><li>Python 通常是一行写完一条语句，但如果语句很长，可以使用反斜杠来实现多行语句<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure></li><li>在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 \<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total = [<span class="string">&#x27;item_one&#x27;</span>, <span class="string">&#x27;item_two&#x27;</span>, <span class="string">&#x27;item_three&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;item_four&#x27;</span>, <span class="string">&#x27;item_five&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ol><h2 id="1-4-输出">1.4 输出</h2><h3 id="1-4-1-基本输出">1.4.1 基本输出</h3><ol><li>Python 使用 print 输出内容，默认输出是换行的；</li><li>要实现不换行，则需要在变量末尾加上 <code>end=&quot;&quot;</code>；<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 换行输出 </span></span><br><span class="line"><span class="built_in">print</span>( x ) </span><br><span class="line"><span class="comment"># 不换行输出 </span></span><br><span class="line"><span class="built_in">print</span>( x, end=<span class="string">&quot;&quot;</span> )</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-4-2-输出格式调整">1.4.2 输出格式调整</h3><ol><li><p>转为字符串</p><ul><li>str()：函数返回一个用户易读的表达形式；</li><li>repr()：产生一个解释器易读的表达形式；</li></ul></li><li><p>zfill( )</p><ul><li>该函数会在数字的左边填充 0；</li></ul></li><li><p>str.format()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 参数替换</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;网址： &quot;&#123;&#125;!&quot;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;AngFff&#x27;</span>, <span class="string">&#x27;www.angfff.top&#x27;</span>)) </span><br><span class="line"><span class="comment"># 输出： AngFff网址： &quot;www.angfff.top!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 数字标明位置</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125; 和 &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>))  </span><br><span class="line"><span class="comment"># 输出：Google 和 Apple</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 关键字指定参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;name&#125;网址：&#123;site&#125;&#x27;</span>.<span class="built_in">format</span>(name=<span class="string">&#x27;AngFff&#x27;</span>, site=<span class="string">&#x27;123&#x27;</span>))  </span><br><span class="line"><span class="comment"># AngFff网址：123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 可选项，进一步控制格式</span></span><br><span class="line"><span class="comment"># 将 Pi 保留到小数点后三位</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;常量 PI 的值近似为 &#123;0:.3f&#125;。&#x27;</span>.<span class="built_in">format</span>(math.pi)) </span><br><span class="line"><span class="comment"># 输出：常量 PI 的值近似为 3.142。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 控制宽度</span></span><br><span class="line">table = &#123;<span class="string">&#x27;Google&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;Runoob&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;Taobao&#x27;</span>: <span class="number">3</span>&#125;  </span><br><span class="line"><span class="keyword">for</span> name, number <span class="keyword">in</span> table.items():  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;0:10&#125; ==&gt; &#123;1:10d&#125;&#x27;</span>.<span class="built_in">format</span>(name, number))  </span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># Google     ==&gt;          1  </span></span><br><span class="line"><span class="comment"># Runoob     ==&gt;          2  </span></span><br><span class="line"><span class="comment"># Taobao     ==&gt;          3  </span></span><br></pre></td></tr></table></figure><ul><li>括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换；</li><li>在括号中的数字用于指向传入对象在 format() 中的位置；</li><li>如果在 format() 中使用了关键字参数, 那么它们的值会指向使用该名字的参数，位置及关键字参数可以任意的结合；</li><li>!a (使用 <strong>ascii()</strong>),  !s (使用 <strong>str()</strong>) 和  !r (使用 <strong>repr()</strong>) 可以用于在格式化某个值之前对其进行转化；</li><li>可选项 : 和格式标识符可以跟着字段名，允许对值进行更好的格式化；</li><li>在 : 后传入一个整数, 可以保证该域至少有这么多的宽度；</li></ul></li></ol><h2 id="1-5-输入">1.5 输入</h2><h3 id="1-5-1-标准输入">1.5.1 标准输入</h3><ol><li><p>input( ) 内置函数 从标准输入读入一行文本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;请输入：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入内容为：&quot;</span>, <span class="built_in">str</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-5-2-文件读写">1.5.2 文件读写</h3><ol><li><p>创建文件对象</p><ul><li>open() 将会返回一个 file 对象 <code>open(filename, mode)</code></li><li>filename：要打开的文件名</li><li>mode：决定了打开文件的模式，只读 ‘r’，写入 ‘w’，追加 ‘a’ 等。该参数是非强制的，默认文件访问模式为只读 ‘r’</li><li>每次打开文件后，都需要关闭文件对象，调用 <code>f.close()</code></li></ul><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Python%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%A8%A1%E5%BC%8F.png" alt="Python文件读写模式.png"></p></li><li><p>针对文件对象进行读取</p><ul><li>在已创建 文件对象 的情况下 f = open()</li><li>f.read()<ul><li>调用 f.read(size)，将读取一定数目的数据，然后作为字符串或字节对象返回</li><li>size 是一个可选的数字类型的参数，当 size 为空或者负，则该文件的所有内容都将被读取并且返回</li></ul></li><li>f.readline()<ul><li>f.readline() 会从文件中读取单独的一行，换行符为 ‘\n’</li><li>如果返回一个空字符串，说明已经已经读取到最后一行</li></ul></li><li>f.readlines()<ul><li>f.readlines() 将返回该文件中包含的所有行</li><li>如果设置可选参数 sizehint，则读取指定长度的字节，并且将这些字节按行分割</li></ul></li></ul></li><li><p>针对文件对象进行写入</p><ul><li>在已创建 文件对象 的情况下 f = open()</li><li>f.write()<ul><li>f.write(string) 将 string 写入到文件中，然后返回写入的字符数</li></ul></li><li>f.tell()<ul><li>f.tell() 用于返回文件当前的读/写位置（即文件指针的位置）</li><li>文件指针表示从文件开头开始的字节数偏移量</li></ul></li><li>f.seek()<ul><li>要改变文件指针的位置，可以用 f.seek(offset, whence)</li><li>offset 表示相对于 whence 参数的偏移量，whence 如果是 0 表示开头，如果是 1 表示当前位置, 2 表示文件的结尾<ul><li>seek(x,0)：从起始位置即文件首行首字符开始移动 x 个字</li><li>seek(x,1)：表示从当前位置往后移动 x 个字符</li><li>seek(-x,2)：表示从文件的结尾往前移动 x 个字符</li></ul></li></ul></li></ul></li><li><p>关闭文件</p><ul><li>在已创建 文件对象 的情况下 f = open()</li><li>f.close()<ul><li>调用 f.close() 来关闭文件并释放系统的资源</li></ul></li><li>with 关键字用于简化文件操作并确保文件在使用完后自动关闭，避免手动调用 close() 方法。它会在代码块执行结束后自动管理资源的释放，即使代码中发生异常，也能保证文件被正确关闭<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/test.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    read_data = f.read()</span><br><span class="line"><span class="comment"># 运行结束后，会自动关闭 f 对象，释放资源</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="1-6-运算符">1.6 运算符</h2><ol><li><p>算数运算符</p><blockquote><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>加 - 两个对象相加</td></tr><tr><td>-</td><td>减 - 得到负数或是一个数减去另一个数</td></tr><tr><td>*</td><td>乘 - 两个数相乘或是返回一个被重复若干次的字符串</td></tr><tr><td>/</td><td>除 - x 除以 y</td></tr><tr><td>%</td><td>取模 - 返回除法的余数</td></tr><tr><td>**</td><td>幂 - 返回x的y次幂</td></tr><tr><td>//</td><td>取整除 - 向下 / 左取整</td></tr></tbody></table></blockquote></li><li><p>比较（关系）运算符</p><blockquote><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>==</td><td>等于 - 比较对象是否相等</td></tr><tr><td>!=</td><td>不等于 - 比较两个对象是否不相等</td></tr><tr><td>&gt;</td><td>大于 - 返回x是否大于y</td></tr><tr><td>&lt;</td><td>小于 - 返回x是否小于y</td></tr><tr><td>&gt;=</td><td>大于等于 - 返回x是否大于等于y</td></tr><tr><td>&lt;=</td><td>小于等于 - 返回x是否小于等于y</td></tr></tbody></table></blockquote></li><li><p>赋值运算符</p><blockquote><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符</td></tr><tr><td>+=</td><td>加法赋值运算符</td></tr><tr><td>-=</td><td>减法赋值运算符</td></tr><tr><td>*=</td><td>乘法赋值运算符</td></tr><tr><td>/=</td><td>除法赋值运算符</td></tr><tr><td>%=</td><td>取模赋值运算符</td></tr><tr><td>**=</td><td>幂赋值运算符</td></tr><tr><td>//=</td><td>取整除赋值运算符</td></tr><tr><td>:=</td><td>海象运算符，这个运算符的主要目的是在表达式中同时进行赋值和返回赋值的值。<strong>Python3.8 版本新增运算符</strong></td></tr></tbody></table></blockquote></li><li><p>位运算符</p><blockquote><table><thead><tr><th>运算符</th><th>描述</th><th>实例(a=12 / b=13)</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td><td>(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td></tr><tr><td>|</td><td>按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td><td>(a | b) 输出结果 61 ，二进制解释： 0011 1101</td></tr><tr><td>^</td><td>按位异或运算符：当两对应的二进位相异时，结果为1</td><td>(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td></tr><tr><td>~</td><td>按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1</td><td>(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。</td></tr><tr><td>&lt;&lt;</td><td>左移动运算符：运算数的各二进位全部左移若干位，由&quot;&lt;&lt;&quot;右边的数指定移动的位数，高位丢弃，低位补0。</td><td>a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>右移动运算符：把&quot;&gt;&gt;“左边的运算数的各二进位全部右移若干位，”&gt;&gt;&quot;右边的数指定移动的位数</td><td>a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td></tr></tbody></table></blockquote></li><li><p>逻辑运算符</p><blockquote><table><thead><tr><th>运算符</th><th>逻辑表达式</th><th>描述</th></tr></thead><tbody><tr><td>and</td><td>x and y</td><td>布尔&quot;与&quot; - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。</td></tr><tr><td>or</td><td>x or y</td><td>布尔&quot;或&quot; - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td></tr><tr><td>not</td><td>not x</td><td>布尔&quot;非&quot; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td></tr></tbody></table></blockquote></li><li><p>成员运算符</p><blockquote><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>in</td><td>如果在指定的序列中找到值返回 True，否则返回 False。</td></tr><tr><td>not in</td><td>如果在指定的序列中没有找到值返回 True，否则返回 False。</td></tr></tbody></table></blockquote></li><li><p>身份运算符</p><blockquote><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>is</td><td>is 是判断两个标识符是不是引用自一个对象</td></tr><tr><td>is not</td><td>is not 是判断两个标识符是不是引用自不同对象</td></tr></tbody></table></blockquote></li></ol><h1>2. 基本数据类型</h1><h2 id="2-1-数字-Number">2.1 数字(Number)</h2><ol><li><strong>int</strong> (整数)<ul><li>只有一种整数类型 int，表示为长整型，没有 Long</li></ul></li><li><strong>bool</strong> (布尔)<ul><li>bool 是 int 的子类，True / 1 和 False / 0 可以和数字相加</li></ul></li><li><strong>float</strong> (浮点数)<ul><li>如 1.23、3E-2</li></ul></li><li><strong>complex</strong> (复数)<ul><li>如 1 + 2j、 1.1 + 2.2j</li></ul></li></ol><blockquote><table><thead><tr><th>函数</th><th>返回值 ( 描述 )</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/python3/python3-func-number-abs.html">abs(x)</a></td><td>返回数字的绝对值，如abs(-10) 返回 10</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-ceil.html">ceil(x)</a></td><td>返回数字的上入整数，如math.ceil(4.1) 返回 5</td></tr><tr><td>cmp(x, y)</td><td>如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 <strong>Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换</strong>。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-exp.html">exp(x)</a></td><td>返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-fabs.html">fabs(x)</a></td><td>以浮点数形式返回数字的绝对值，如math.fabs(-10) 返回10.0</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-floor.html">floor(x)</a></td><td>返回数字的下舍整数，如math.floor(4.9)返回 4</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-log.html">log(x)</a></td><td>如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-log10.html">log10(x)</a></td><td>返回以10为基数的x的对数，如math.log10(100)返回 2.0</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-max.html">max(x1, x2,…)</a></td><td>返回给定参数的最大值，参数可以为序列。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-min.html">min(x1, x2,…)</a></td><td>返回给定参数的最小值，参数可以为序列。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-modf.html">modf(x)</a></td><td>返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-pow.html">pow(x, y)</a></td><td>x**y 运算后的值。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-round.html">round(x [,n])</a></td><td>返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。<br><br><strong>其实准确的说是保留值将保留到离上一位更近的一端。</strong></td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-sqrt.html">sqrt(x)</a></td><td>返回数字x的平方根。</td></tr></tbody></table></blockquote><h2 id="2-2-字符串-String">2.2 字符串(String)</h2><ol><li>字符串用单引号 ’ 或双引号 &quot; 括起来，单引号 ’ 和双引号 &quot; 的使用完全相同，使用三引号(‘’’ 或 “”&quot;)可以指定一个多行字符串；</li><li>使用反斜杠 \ 转义特殊字符，使用 r 可以让反斜杠不发生转义。 如 <strong>r&quot;this is a line with \n&quot;</strong> 则 \n 会显示，并不是换行；</li><li>字符串的截取 / 切片<ul><li><code>字符串[start:end:step]</code>，左含右不含、步长参数 step，step 为负数时表示逆向；</li><li>索引值以 0 为开始值，-1 为从末尾的开始位置；</li><li>加号 + 是字符串的连接符， 星号 * 表示复制当前字符串；</li></ul></li><li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串；</li><li>字符串不能通过索引赋值、修改元素值；</li></ol><h2 id="2-3-布尔-Bool">2.3 布尔(Bool)</h2><ol><li>布尔类型只有两个值：True 和 False，等价于 1 和 0；</li><li>布尔类型可以转换成其他数据类型；</li><li>使用 <code>bool()</code> 函数将其他类型的值转换为布尔值；</li><li>布尔类型可以和逻辑运算符一起使用，包括 and、or 和 not；</li></ol><h2 id="2-4-列表-List">2.4 列表(List)</h2><ol><li>列表写在方括号 [] 之间、用逗号分隔元素；</li><li>列表中的元素类型可以互不相同；</li><li>列表可以通过索引赋值、修改元素值；</li><li>列表的截取 / 切片<ul><li><code>列表[start:end:step]</code>，左含右不含、步长参数 step，step 为负数时表示逆向；</li><li>索引值以 0 为开始值，-1 为从末尾的开始位置；</li><li>加号 + 是列表的连接符， 星号 * 表示复制当前列表；</li></ul></li></ol><h2 id="2-5-元组-Tuple">2.5 元组(Tuple)</h2><ol><li>元组写在小括号 () 之间、用逗号分隔元素；</li><li>元组中的元素类型可以互不相同；</li><li>元组不能通过索引赋值、修改元素值；</li><li>元组的截取 / 切片<ul><li><code>元组[start:end:step]</code>，左含右不含、步长参数 step，step 为负数时表示逆向；</li><li>索引值以 0 为开始值，-1 为从末尾的开始位置；</li><li>加号 + 是元组的连接符， 星号 * 表示复制当前元组；</li></ul></li><li>构造包含 0 个或 1 个元素的元组比较特殊<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup1 = () <span class="comment"># 空元组</span></span><br><span class="line">tup2 = (<span class="number">20</span>,) <span class="comment"># 一个元素，需要在元素后添加逗号</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="2-6-集合-Set">2.6 集合(Set)</h2><ol><li>集合写在大括号 {} 之间、用逗号分隔元素，另外也可以使用 <code>set()</code> 函数创建集合；</li><li>创建一个空集合必须用 <code>set()</code> 而不是 <code>&#123; &#125;</code>， <code>&#123; &#125;</code> 用于创建空字典；</li><li>集合是一种无序、可变的数据类型，其中的元素不会重复；</li><li>集合运算<ul><li>交集 &amp;</li><li>并集 |</li><li>差集 -</li><li>两集合中不同时存在的元素 ^</li></ul></li></ol><h2 id="2-7-字典-Dictionary">2.7 字典(Dictionary)</h2><ol><li>字典是一种映射类型，字典用 <code>&#123; &#125;</code> 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合；</li><li>在同一个字典中，键必须是唯一的，且键必须使用不可变类型；</li><li>字典的创建<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dict1 = &#123;&#125;</span><br><span class="line">dict1[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&quot;1 A&quot;</span></span><br><span class="line">dict1[<span class="number">2</span>] = <span class="string">&quot;2 F&quot;</span></span><br><span class="line"></span><br><span class="line">dict2 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Ang&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;18&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典推导式</span></span><br><span class="line">dict3 = &#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)&#125;</span><br><span class="line"></span><br><span class="line">x = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">y = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">dict4 = &#123;i:j <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(x,y)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># dict 函数</span></span><br><span class="line">dict5 = <span class="built_in">dict</span>(Runoob=<span class="number">1</span>, Google=<span class="number">2</span>, Taobao=<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li>键值对输出<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dic1 = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="keyword">for</span> k,v. <span class="keyword">in</span> dict1.items():</span><br><span class="line">    <span class="built_in">print</span>(k, <span class="string">&#x27;:&#x27;</span>, v)</span><br></pre></td></tr></table></figure></li></ol><h1>3. 基本数据类型的转换</h1><h2 id="3-1-隐式类型转换">3.1 隐式类型转换</h2><ol><li>对两种不同类型的数据进行运算时，较低数据类型会转换为较高数据类型以避免数据丢失；<ul><li>当整数与浮点数进行运算时，整数会被自动转换为浮点数；</li><li>布尔值在与数字进行运算时会被自动转换为整数，<code>True</code> 被视为 <code>1</code>，<code>False</code> 被视为 <code>0</code>；</li></ul></li><li>数据类型的高低：bool &lt; int &lt; float &lt; complex</li></ol><h2 id="3-2-显式类型转换">3.2 显式类型转换</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>int(x [,base])</td><td>将x转换为一个整数</td></tr><tr><td>float(x)</td><td>将x转换到一个浮点数</td></tr><tr><td>complex(real [,imag])</td><td>创建一个复数</td></tr><tr><td>str(x)</td><td>将对象 x 转换为字符串</td></tr><tr><td>repr(x)</td><td>将对象 x 转换为表达式字符串</td></tr><tr><td>eval(str)</td><td>用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td>tuple(s)</td><td>将序列 s 转换为一个元组</td></tr><tr><td>list(s)</td><td>将序列 s 转换为一个列表</td></tr><tr><td>set(s)</td><td>转换为可变集合</td></tr><tr><td>dict(d)</td><td>创建一个字典。d 必须是一个 (key, value)元组序列。</td></tr><tr><td>frozenset(s)</td><td>转换为不可变集合</td></tr><tr><td>chr(x)</td><td>将一个整数转换为一个字符</td></tr><tr><td>ord(x)</td><td>将一个字符转换为它的整数值</td></tr><tr><td>hex(x)</td><td>将一个整数转换为一个十六进制字符串</td></tr><tr><td>oct(x)</td><td>将一个整数转换为一个八进制字符串</td></tr></tbody></table><h1>4. 条件控制</h1><h2 id="4-1-if-elif-else">4.1 if-elif-else</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_block_3</span><br></pre></td></tr></table></figure><ul><li>每个条件后面要使用冒号，表示接下来是满足条件后要执行的语句块。</li><li>如果 if 的执行语句只有一句，可以写在 if 的同一行。</li></ul><h2 id="4-2-match-case">4.2 match-case</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> subject:</span><br><span class="line">    <span class="keyword">case</span> &lt;pattern_1&gt;:</span><br><span class="line">        &lt;action_1&gt;</span><br><span class="line">    <span class="keyword">case</span> &lt;pattern_2&gt;:</span><br><span class="line">        &lt;action_2&gt;</span><br><span class="line">    <span class="keyword">case</span> &lt;pattern_3&gt;:</span><br><span class="line">        &lt;action_3&gt;</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        &lt;action_wildcard&gt;</span><br></pre></td></tr></table></figure><ul><li>case _: 类似于 C 和 Java 中的 <strong>default:</strong>，当其他 case 都无法匹配时，匹配这条，保证永远会匹配成功。</li></ul><h1>5. 循环语句</h1><h2 id="5-1-while">5.1 while</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;expr&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;additional_statement(s)&gt;</span><br></pre></td></tr></table></figure><ul><li>如果 while 的执行语句只有一句，可以写在 while 的同一行。</li></ul><h2 id="5-2-for">5.2 for</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> iterable:</span><br><span class="line">    <span class="comment"># 循环主体</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 循环结束后执行的代码</span></span><br></pre></td></tr></table></figure><h2 id="5-3-break-continue-pass">5.3 break &amp; continue &amp; pass</h2><ul><li><strong>break</strong> 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。</li><li><strong>continue</strong> 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮循环。</li><li><strong>pass</strong> 不做任何事情，一般用做占位语句。</li></ul><h1>6. 推导式</h1><h2 id="6-1-列表推导式">6.1 列表推导式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表]</span><br><span class="line"></span><br><span class="line">或者 </span><br><span class="line"></span><br><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表 <span class="keyword">if</span> 条件]</span><br></pre></td></tr></table></figure><p>e.g. 过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;alice&#x27;</span>,<span class="string">&#x27;Jerry&#x27;</span>,<span class="string">&#x27;Wendy&#x27;</span>,<span class="string">&#x27;Smith&#x27;</span>]</span><br><span class="line">new_names = [name.upper()<span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> <span class="built_in">len</span>(name)&gt;<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(new_names)</span><br></pre></td></tr></table></figure><h2 id="6-2-字典推导式">6.2 字典推导式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection &#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition &#125;</span><br></pre></td></tr></table></figure><p>e.g. 将列表中各字符串值为键，各字符串的长度为值，组成键值对</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listdemo = [<span class="string">&#x27;Google&#x27;</span>,<span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line">newdict = &#123;key:<span class="built_in">len</span>(key) <span class="keyword">for</span> key <span class="keyword">in</span> listdemo&#125;</span><br><span class="line"><span class="built_in">print</span>(newdict)</span><br></pre></td></tr></table></figure><h2 id="6-3-集合推导式">6.3 集合推导式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> &#125;</span><br><span class="line">或</span><br><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional &#125;</span><br></pre></td></tr></table></figure><p>e.g. 判断不是 abc 的字母并输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abracadabra&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><h2 id="6-4-元组推导式">6.4 元组推导式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> )</span><br><span class="line">或</span><br><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional )</span><br></pre></td></tr></table></figure><ul><li>元组推导式返回的结果是一个生成器对象，使用 tuple() 函数，可以直接将生成器对象转换成元组；</li></ul><p>e.g. 生成一个包含数字 1~9 的元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(t) <span class="comment"># 输出 &lt;generator object &lt;genexpr&gt; at 0x104b0e890&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(t)) <span class="comment"># 输出 (1, 2, 3, 4, 5, 6, 7, 8, 9)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># range() 返回的是一个可迭代对象，而不是一个列表</span></span><br><span class="line"><span class="comment"># 如果需要列表，可以使用 list() 函数将其转换</span></span><br></pre></td></tr></table></figure><h1>7. 迭代器 &amp; 生成器</h1><h2 id="7-1-迭代器">7.1 迭代器</h2><h3 id="（1）概念">（1）概念</h3><blockquote><p>在 Python 中，迭代器（Iterator）是一种用于遍历集合（如列表、元组、字典等）元素的对象。迭代器遵循迭代协议，主要包括两个方法：<code>__iter__()</code> 和 <code>__next__()</code>。下面是对迭代器的详细解释：</p><ol><li>迭代器的基本概念</li></ol><ul><li><strong>迭代器对象</strong>：实现了 <code>__iter__()</code> 和 <code>__next__()</code> 方法的对象。</li><li><strong>可迭代对象</strong>：实现了 <code>__iter__()</code> 方法的对象，可以返回一个迭代器。</li></ul><ol start="2"><li>迭代器的工作原理</li></ol><ul><li><strong><code>__iter__()</code> 方法</strong>：返回迭代器对象本身。通常在可迭代对象上调用时会返回一个迭代器。</li><li><strong><code>__next__()</code> 方法</strong>：返回序列中的下一个值。如果没有更多的值可返回，应该抛出 <code>StopIteration</code> 异常。</li></ul></blockquote><h3 id="（2）从集合生成迭代器">（2）从集合生成迭代器</h3><ul><li>可迭代对象：可以使用 <code>for</code> 循环遍历的对象，如列表、元组、字典、集合等。可迭代对象实现了 <code>__iter__()</code> 方法。</li><li>基本方法：iter()；next()</li></ul><p>e.g. 从列表生成迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原列表</span></span><br><span class="line">list_a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代器对象</span></span><br><span class="line">it = <span class="built_in">iter</span>(list_a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出单个元素，使用 next() 方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环输出剩余元素，使用 for/while 循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line"><span class="built_in">print</span>(i, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># while 循环注意结束条件</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">sys.exit()</span><br></pre></td></tr></table></figure><h3 id="（3）创建自定义迭代器">（3）创建自定义迭代器</h3><ul><li>通过定义一个类并实现 _<em>iter</em>_\ 和 _<em>next</em>_\ 两个方法来创建自定义迭代器。例如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建迭代器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyIterator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">max</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">max</span> = <span class="built_in">max</span></span><br><span class="line">        <span class="variable language_">self</span>.current = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.current &lt; <span class="variable language_">self</span>.<span class="built_in">max</span>:</span><br><span class="line">            result = <span class="variable language_">self</span>.current</span><br><span class="line">            <span class="variable language_">self</span>.current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义迭代器</span></span><br><span class="line">my_iter = MyIterator(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> my_iter:</span><br><span class="line">    <span class="built_in">print</span>(num) <span class="comment"># 输出 0 1 2 3 4</span></span><br></pre></td></tr></table></figure><h3 id="（4）迭代器与可迭代对象的区别">（4）迭代器与可迭代对象的区别</h3><ul><li><strong>可迭代对象</strong>：可以使用 <code>for</code> 循环遍历的对象，如列表、元组、字典、集合等。可迭代对象实现了 <code>__iter__()</code> 方法。</li><li><strong>迭代器</strong>：是可迭代对象的一个实现，具有 <code>__iter__()</code> 和 <code>__next__()</code> 方法。迭代器可以在遍历时保持状态。</li></ul><h2 id="7-2-生成器">7.2 生成器</h2><h3 id="（1）概念-2">（1）概念</h3><blockquote><p>在 Python 中，生成器（Generator）是一种特殊类型的迭代器，用于创建可迭代的序列。生成器的主要特点是它们使用 <code>yield</code> 语句来返回值，而不是使用 <code>return</code> 语句。生成器在每次调用时会记住上一次的状态，从而实现惰性求值。</p><ul><li><strong>生成器函数</strong>：使用 <code>yield</code> 语句定义的函数。调用生成器函数不会立即执行，而是返回一个生成器对象。</li><li><strong>生成器对象</strong>：可以被迭代的对象，支持 <code>__iter__()</code> 和 <code>__next__()</code> 方法。</li></ul></blockquote><h3 id="（2）创建生成器">（2）创建生成器</h3><ul><li>生成器函数的定义与普通函数类似，但使用 <code>yield</code> 语句来返回值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a  <span class="comment"># 当运行到这里时，就会停止，直到再次调用 next，会接着从这里继续生成 a</span></span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出值</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(f), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure><h3 id="（3）生成器的工作原理">（3）生成器的工作原理</h3><ul><li>当调用生成器函数时，函数体不会立即执行，而是返回一个生成器对象。</li><li>每次调用生成器对象的 <code>__next__()</code> 方法时，函数会从上次 <code>yield</code> 语句停止的地方继续执行，直到遇到下一个 <code>yield</code> 语句。</li><li>当没有更多的 <code>yield</code> 语句可执行时，生成器会抛出 <code>StopIteration</code> 异常，表示迭代结束。</li></ul><h1>8. 函数</h1><h2 id="8-1-定义-调用函数">8.1 定义 / 调用函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>（参数列表）:</span><br><span class="line"><span class="comment"># 函数说明</span></span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">返回值 = 函数名(参数)</span><br></pre></td></tr></table></figure><p>python 函数的参数传递：</p><ul><li><p><strong>不可变类型</strong>：类似 C++ 的值传递，不可变类型对象包括 整数、字符串、元组。对于不可变类型对象 a，调用 fun(a) 时，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象，函数外部的 a 不会受影响。</p></li><li><p><strong>可变类型</strong>：类似 C++ 的引用传递，可变类型对象包括 列表，字典。对于可变类型对象 b，调用 fun(b) 时，则是将 b 真正的传过去，修改后 fun 外部的 b 也会受影响。</p></li></ul><h2 id="8-2-函数参数">8.2 函数参数</h2><h3 id="（1）必需参数">（1）必需参数</h3><ul><li>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样，否则会因缺少参数而报错。</li></ul><h3 id="（2）关键字参数">（2）关键字参数</h3><ul><li>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</li><li>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</li></ul><p>e.g.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> name, age </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">&quot;runoob&quot;</span> )</span><br></pre></td></tr></table></figure><h3 id="（3）默认参数">（3）默认参数</h3><ul><li>调用函数时，如果没有传递参数，则会使用默认参数</li></ul><h3 id="（4）不定长参数">（4）不定长参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个 * 的参数会以元组形式导入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">functionname</span>(<span class="params">[formal_args,] *var_args_tuple </span>):</span><br><span class="line">   <span class="string">&quot;函数_文档字符串&quot;</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 两个 * 的参数会以字典形式导入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> arg1, **vardict </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">   <span class="built_in">print</span> (arg1)</span><br><span class="line">   <span class="built_in">print</span> (vardict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单独出现 *，则 * 以后的所有参数都需要带上参数名称再传入</span></span><br><span class="line"><span class="comment"># 函数定义</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a,b,*,c</span>):</span><br><span class="line"><span class="keyword">return</span> a+b+c</span><br><span class="line"><span class="comment"># 函数调用</span></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,c=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制位置参数 /</span></span><br><span class="line"><span class="comment"># 函数定义</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b, /, c, d, *, e, f</span>):</span><br><span class="line"><span class="built_in">print</span>(a, b, c, d, e, f)</span><br><span class="line"><span class="comment"># 函数调用</span></span><br><span class="line">f(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, d=<span class="number">40</span>, e=<span class="number">50</span>, f=<span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 和 f 要求为关键字形参</span></span><br></pre></td></tr></table></figure><ul><li>加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数</li><li>可以不向函数传递未命名的变量，如果在函数调用时没有指定参数，它就是一个空元组</li><li>加了两个星号 ** 的参数会以字典的形式导入</li><li>如果单独出现星号 * ，则星号 * 后的参数必须用关键字传入</li><li>强制位置参数：Python3.8 新增了一个函数形参语法 / 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。</li></ul><h2 id="8-3-lambda-匿名函数">8.3 lambda 匿名函数</h2><h3 id="（1）概念-3">（1）概念</h3><p>在 Python 中，<code>lambda</code> 函数是一种小型、匿名的、内联函数，它可以具有任意数量的参数，但只能有一个表达式。与常规的函数定义（使用 <code>def</code> 关键字）相比，<code>lambda</code> 函数通常用于需要快速定义简单函数的场景。</p><p>① <code>lambda</code> 函数的基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arguments: expression</span><br></pre></td></tr></table></figure><ul><li><strong>arguments</strong>: 输入参数，可以是多个，用逗号分隔。</li><li><strong>expression</strong>: 一个表达式，返回值是这个表达式的计算结果。</li></ul><p>② 示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个简单的 lambda 函数</span></span><br><span class="line">add = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 lambda 函数</span></span><br><span class="line">result = add(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: 8</span></span><br></pre></td></tr></table></figure><h3 id="（2）应用（使用-lambda-函数作为参数）">（2）应用（使用 <code>lambda</code> 函数作为参数）</h3><p><code>lambda</code> 函数常用于需要函数作为参数的场景，例如在 <code>map()</code>, <code>filter()</code>, 和 <code>sorted()</code> 函数中。<br>① <code>map()</code></p><ul><li><code>map()</code> 函数用于将指定函数应用于给定可迭代对象的每个元素，并返回一个迭代器<ul><li><code>map(function, iterable)</code></li><li>function: 要应用的函数（可以是 <code>lambda</code> 函数）</li><li>iterable: 要处理的可迭代对象（如列表、元组等）</li></ul></li><li>示例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, numbers)) <span class="comment"># map 会遍历 numbers 中的每个元素，并将每个元素传递给 lambda 函数，计算完成后作为 map 迭代器的结果，需要时输出</span></span><br><span class="line"><span class="built_in">print</span>(squared)  <span class="comment"># 输出: [1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure><p>② <code>filter()</code></p><ul><li><code>filter()</code> 函数用于过滤可迭代对象中的元素，返回满足条件的元素<ul><li><code>filter(function, iterable)</code></li><li>遍历每个元素，如果满足 function 中的条件(返回 True)，则保留该元素；否则，丢弃该元素</li></ul></li><li>示例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">even_numbers = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, numbers)) <span class="comment"># filter 会遍历 numbers 中的每个元素，并将每个元素传递给 lambda 函数，判断元素是否为偶数，是偶数则保留，否则丢弃该元素</span></span><br><span class="line"><span class="built_in">print</span>(even_numbers)  <span class="comment"># 输出: [2, 4]</span></span><br></pre></td></tr></table></figure><p>③ <code>sorted()</code></p><ul><li><code>sorted()</code> 函数用于对可迭代对象进行排序，可以使用 <code>lambda</code> 函数自定义排序规则。<ul><li><code>sorted(iterable, key=None, reverse=False)</code></li><li>key 是一个函数，用于从每个元素中提取比较键</li><li>默认升序排列，reverse=True，则调整为降序</li></ul></li><li>示例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">points = [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">5</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">3</span>)]</span><br><span class="line">sorted_points = <span class="built_in">sorted</span>(points, key=<span class="keyword">lambda</span> point: point[<span class="number">1</span>])  <span class="comment"># sorted 会遍历 points 中的每个元组，并将每个元组传递给 lambda 函数，lambda 会提取每个元组的第二个元素（y 坐标）作为排序的依据，最终按 key（y坐标）排序</span></span><br><span class="line"><span class="built_in">print</span>(sorted_points)  <span class="comment"># 输出: [(5, 0), (3, 1), (1, 2), (0, 3)]</span></span><br></pre></td></tr></table></figure><h3 id="（3）注意">（3）注意</h3><ul><li><strong>单行表达式</strong>：<code>lambda</code> 函数只能包含一个表达式，不能包含多个语句或复杂的逻辑。</li><li><strong>可读性</strong>：虽然 <code>lambda</code> 函数可以使代码更简洁，但在复杂的情况下，使用常规的 <code>def</code> 函数可能会提高代码的可读性。</li><li><strong>命名</strong>：<code>lambda</code> 函数是匿名的，但可以赋值给变量以便后续使用。</li></ul><h1>9. 装饰器</h1><h2 id="9-1-概念">9.1 概念</h2><h3 id="（1）定义">（1）定义</h3><p>在 Python 中，装饰器（decorator）是一种用于修改或增强函数或方法行为的设计模式。装饰器本质上是一个函数，它接受另一个函数作为参数，并返回一个新的函数。通过使用装饰器，可以在不修改原始函数代码的情况下，添加额外的功能或行为。</p><h3 id="（2）常见用途">（2）常见用途</h3><ul><li><strong>日志记录</strong>：记录函数的调用信息。</li><li><strong>权限检查</strong>：在执行函数之前检查用户权限。</li><li><strong>缓存</strong>：缓存函数的返回值以提高性能。</li><li><strong>输入验证</strong>：验证函数参数的有效性。</li></ul><h2 id="9-2-装饰器的基本语法">9.2 装饰器的基本语法</h2><ul><li>装饰器通常使用 <code>@decorator_name</code> 语法来应用，放在被装饰函数的定义上方</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义 装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something is happening before the function is called.&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something is happening after the function is called.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用 装饰器</span></span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line">say_hello() <span class="comment"># 输出三行句子</span></span><br></pre></td></tr></table></figure><h2 id="9-3-带参数的装饰器">9.3 带参数的装饰器</h2><ul><li>装饰器也可以接受参数。为了实现这一点，通常需要在最外层再嵌套一层函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义 含参数的装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">repeat</span>(<span class="params">num_times</span>):</span><br><span class="line"><span class="comment"># 最外层用于定义参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator_repeat</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_times):</span><br><span class="line">                func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator_repeat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用 装饰器</span></span><br><span class="line"><span class="meta">@repeat(<span class="params">num_times=<span class="number">3</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&quot;Alice&quot;</span>) <span class="comment"># 重复输出三次 Hello, Alice!</span></span><br></pre></td></tr></table></figure><h1>10. 数据结构</h1><h2 id="10-1-将列表当作栈使用">10.1 将列表当作栈使用</h2><ul><li>在 Python 中，可以使用列表（list）来实现栈的功能。栈是一种后进先出（LIFO, Last-In-First-Out）数据结构，意味着最后添加的元素最先被移除。</li><li>用 append() 方法可以把一个元素添加到栈顶，用不指定索引的 pop() 方法可以把一个元素从栈顶释放出来。</li></ul><blockquote><ul><li><strong>压入（Push）</strong>: 将一个元素添加到栈的顶端。</li><li><strong>弹出（Pop）</strong>: 移除并返回栈顶元素。</li><li><strong>查看栈顶元素（Peek/Top）</strong>: 返回栈顶元素而不移除它。</li><li><strong>检查是否为空（IsEmpty）</strong>: 检查栈是否为空。</li><li><strong>获取栈的大小（Size）</strong>: 获取栈中元素的数量。</li></ul><p>1、创建一个空栈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack = []  </span><br></pre></td></tr></table></figure><p>2、压入（Push）操作</p><ul><li>使用 append() 方法将元素添加到栈的顶端</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack.append(<span class="number">1</span>)  </span><br><span class="line">stack.append(<span class="number">2</span>)  </span><br><span class="line">stack.append(<span class="number">3</span>)  </span><br><span class="line"><span class="built_in">print</span>(stack)  <span class="comment"># 输出: [1, 2, 3]  </span></span><br></pre></td></tr></table></figure><p>3、弹出（Pop）操作</p><ul><li>使用 pop() 方法移除并返回栈顶元素</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">top_element = stack.pop()  </span><br><span class="line"><span class="built_in">print</span>(top_element)  <span class="comment"># 输出: 3  </span></span><br><span class="line"><span class="built_in">print</span>(stack)        <span class="comment"># 输出: [1, 2]  </span></span><br></pre></td></tr></table></figure><p>4、查看栈顶元素（Peek/Top）</p><ul><li>直接访问列表的最后一个元素（不移除）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top_element = stack[-<span class="number">1</span>]  </span><br><span class="line"><span class="built_in">print</span>(top_element)  <span class="comment"># 输出: 2  </span></span><br></pre></td></tr></table></figure><p>5、检查是否为空（IsEmpty）</p><ul><li>检查列表是否为空</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">is_empty = <span class="built_in">len</span>(stack) == <span class="number">0</span>  </span><br><span class="line"><span class="built_in">print</span>(is_empty)  <span class="comment"># 输出: False  </span></span><br></pre></td></tr></table></figure><p>6、获取栈的大小（Size）</p><ul><li>使用 len() 函数获取栈中元素的数量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size = <span class="built_in">len</span>(stack)  </span><br><span class="line"><span class="built_in">print</span>(size)  <span class="comment"># 输出: 2</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="10-2-将列表当作队列使用">10.2 将列表当作队列使用</h2><ul><li>在 Python 中，列表（list）可以用作队列（queue），但由于列表的特点，直接使用列表来实现队列并不是最优的选择。</li><li>队列是一种先进先出（FIFO, First-In-First-Out）的数据结构，意味着最早添加的元素最先被移除。</li><li>使用列表时，如果频繁地在列表的开头插入或删除元素，性能会受到影响，因为这些操作的时间复杂度是 O(n)。为了解决这个问题，Python 提供了 collections.deque，它是双端队列，可以在两端高效地添加和删除元素。</li></ul><blockquote><ul><li>collections.deque 是 Python 标准库的一部分，非常适合用于实现队列。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 创建一个空队列  </span></span><br><span class="line">queue = deque()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 向队尾添加元素  </span></span><br><span class="line">queue.append(<span class="string">&#x27;a&#x27;</span>)  </span><br><span class="line">queue.append(<span class="string">&#x27;b&#x27;</span>)  </span><br><span class="line">queue.append(<span class="string">&#x27;c&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列状态:&quot;</span>, queue)  <span class="comment"># 输出: 队列状态: deque([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 从队首移除元素  </span></span><br><span class="line">first_element = queue.popleft()  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;移除的元素:&quot;</span>, first_element)  <span class="comment"># 输出: 移除的元素: a  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列状态:&quot;</span>, queue)            <span class="comment"># 输出: 队列状态: deque([&#x27;b&#x27;, &#x27;c&#x27;])  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 查看队首元素（不移除）  </span></span><br><span class="line">front_element = queue[<span class="number">0</span>]  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队首元素:&quot;</span>, front_element)    <span class="comment"># 输出: 队首元素: b  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 检查队列是否为空  </span></span><br><span class="line">is_empty = <span class="built_in">len</span>(queue) == <span class="number">0</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列是否为空:&quot;</span>, is_empty)     <span class="comment"># 输出: 队列是否为空: False  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 获取队列大小  </span></span><br><span class="line">size = <span class="built_in">len</span>(queue)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列大小:&quot;</span>, size)            <span class="comment"># 输出: 队列大小: 2  </span></span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li>虽然 deque更高效，但如果坚持使用列表来实现队列，也可以这么做。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建队列</span></span><br><span class="line">queue = []  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 向队尾添加元素，使用 append() 方法将元素添加到队尾</span></span><br><span class="line">queue.append(<span class="string">&#x27;a&#x27;</span>)  </span><br><span class="line">queue.append(<span class="string">&#x27;b&#x27;</span>)  </span><br><span class="line">queue.append(<span class="string">&#x27;c&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列状态:&quot;</span>, queue)  <span class="comment"># 输出: 队列状态: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 从队首移除元素，使用 pop(0) 方法从队首移除元素</span></span><br><span class="line">first_element = queue.pop(<span class="number">0</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;移除的元素:&quot;</span>, first_element)  <span class="comment"># 输出: 移除的元素: a  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列状态:&quot;</span>, queue)            <span class="comment"># 输出: 队列状态: [&#x27;b&#x27;, &#x27;c&#x27;]  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 查看队首元素，直接访问列表的第一个元素</span></span><br><span class="line">front_element = queue[<span class="number">0</span>]  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队首元素:&quot;</span>, front_element)    <span class="comment"># 输出: 队首元素: b  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 检查队列是否为空</span></span><br><span class="line">is_empty = <span class="built_in">len</span>(queue) == <span class="number">0</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列是否为空:&quot;</span>, is_empty)     <span class="comment"># 输出: 队列是否为空: False  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 获取队列大小，使用 len() 函数获取队列的大小</span></span><br><span class="line">size = <span class="built_in">len</span>(queue)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列大小:&quot;</span>, size)            <span class="comment"># 输出: 队列大小: 2  </span></span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <summary type="html">Python 学习笔记</summary>
    
    
    
    <category term="开发" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Python" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/Python/"/>
    
    
    <category term="开发" scheme="https://www.angfff.top/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Python" scheme="https://www.angfff.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Java SE 学习笔记 2️⃣</title>
    <link href="https://www.angfff.top/posts/c3baad0f.html"/>
    <id>https://www.angfff.top/posts/c3baad0f.html</id>
    <published>2024-02-02T03:55:17.000Z</published>
    <updated>2025-05-22T04:31:09.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类与对象">类与对象</h2><h3 id="类的定义与对象创建">类的定义与对象创建</h3><p>前面我们介绍了什么是类，什么是对象，首先我们就来看看如何去定义一个类。</p><p>比如现在我们想要定义一个人类，我们可以右键<code>src</code>目录，点击创建新的类：</p><p><img src="https://s2.loli.net/2022/09/19/alOtdE1JNcbpxM8.png" alt="image-20220919204004526"></p><p>我们在对类进行命名时，一般使用英文单词，并且首字母大写，跟变量命名一样，不能出现任何的特殊字符。</p><p><img src="https://s2.loli.net/2022/09/19/n1WuVYRiPeOfHqZ.png" alt="image-20220919204159248"></p><p>可以看到，现在我们的目录下有了两个<code>.java</code>源文件，其中一个是默认创建的Main.java，还有一个是我们刚刚创建的类。</p><p>我们来看看创建好之后，一个类写了哪些内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，这不是跟一开始创建的Main中写的格式一模一样吗？没错，Main也是一个类，只不过我们一直都将其当做主类在使用，也就是编写主方法的类，关于方法我们会在后面进行介绍。</p><p>现在我们就创建好了一个类，既然是人类，那么肯定有人相关的一些属性，比如名字、性别、年龄等等，那么怎么才能给这个类添加一些属性呢？</p><p>我们可以将这些属性直接作为类的成员变量（成员变量相当于是这个类所具有的属性，每个实例创建出来之后，这些属性都可能会各不相同）定义到类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;   <span class="comment">//这里定义的人类具有三个属性，名字、年龄、性别</span></span><br><span class="line">    String name;   <span class="comment">//直接在类中定义变量，表示类具有的属性</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能会有小伙伴疑问，这些变量啥时候被赋值呢？实际上这些变量只有在一个具体的对象中才可以使用。</p><p>那么现在人类的属性都规定好了，我们就可以尝试创建一个实例对象了，实例对应的应该是一个具体的人：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 类名();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Person</span>();   <span class="comment">//我们可以使用new关键字来创建某个类的对象，注意new后面需要跟上 类名()</span></span><br><span class="line">  <span class="comment">//这里创建出来的，就是一个具体的人了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象的使用">对象的使用</h3><p>既然现在我们知道如何创建对象，那么我们怎么去访问这个对象呢，比如我现在想要去查看或是修改它的名字。</p><p>我们同样可以使用一个变量来指代某个对象，只不过引用类型的变量，存储的是对象的引用，而不是对象本身：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//这里的a存放的是具体的某个值</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">  <span class="comment">//创建一个变量指代我们刚刚创建好的对象，变量的类型就是对应的类名</span></span><br><span class="line">  <span class="comment">//这里的p存放的是对象的引用，而不是本体，我们可以通过对象的引用来间接操作对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为什么对象类型的变量存放的是对象的引用，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们将变量p2赋值为p1的值，那么实际上只是传递了对象的引用，而不是对象本身的复制，这跟我们前面的基本数据类型有些不同，p2和p1都指向的是同一个对象（如果你学习过C语言，它就类似于指针一样的存在）</p><p><img src="https://s2.loli.net/2022/09/19/GBPaNZsr2MSKvCq.png" alt="image-20220919211443657"></p><p>我们可以来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> p1;</span><br><span class="line">    System.out.println(p1 == p2);    <span class="comment">//使用 == 可以判断两个变量引用的是不是同一个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果我们像这样去编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();   <span class="comment">//这两个变量分别引用的是不同的两个对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    System.out.println(p1 == p2);   <span class="comment">//如果两个变量存放的是不同对象的引用，那么肯定就是不一样的了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上我们之前使用的String类型，也是一个引用类型，我们会在下一章详细讨论。我们在上一章介绍的都是基本类型，而类使用的都是引用类型。</p><p>现在我们有了对象的引用之后，我们就可以进行操作了：</p><p><img src="https://s2.loli.net/2022/09/19/cEJ1CWshtQFbZzy.png" alt="image-20220919210058797"></p><p>我们可以直接访问对象的一些属性，也就是我们在类中定义好的那些，对于不同的对象，这些属性都具体存放值也会不同。</p><p>比如我们可以修改对象的名字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    p.name = <span class="string">&quot;小明&quot;</span>;   <span class="comment">//要访问对象的属性，我们需要使用 . 运算符</span></span><br><span class="line">    System.out.println(p.name);   <span class="comment">//直接打印对象的名字，就是我们刚刚修改好的结果了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，不同对象的属性是分开独立存放的，每个对象都有一个自己的空间，修改一个对象的属性并不会影响到其他对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    p1.name = <span class="string">&quot;小明&quot;</span>;   <span class="comment">//这个修改的是第一个对象的属性</span></span><br><span class="line">    p2.name = <span class="string">&quot;大明&quot;</span>;   <span class="comment">//这里修改的是第二个对象的属性</span></span><br><span class="line">    System.out.println(p1.name);  <span class="comment">//这里我们获取的是第一个对象的属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于对象类型的变量，我们也可以不对任何对象进行引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="literal">null</span>;  <span class="comment">//null是一个特殊的值，它表示空，也就是不引用任何的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果不引用任何的对象，那肯定是不应该去通过这个变量去操作所引用的对象的（都没有引用对象，我操作谁啊我）</p><p>虽然这样可以编译通过，但是在运行时会出现问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="literal">null</span>;   <span class="comment">//此时变量没有引用任何对象</span></span><br><span class="line">    p.name = <span class="string">&quot;小红&quot;</span>;   <span class="comment">//我任性，就是要操作</span></span><br><span class="line">    System.out.println(p.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来尝试运行一下这段代码：</p><p><img src="https://s2.loli.net/2022/09/19/hkME1wf58aSdWGZ.png" alt="image-20220919213732810"></p><p>此时程序在运行的过程中，出现了异常，虽然我们还没有学习到异常，但是各位可以将异常理解为程序在运行过程中出现了问题，此时不得不终止程序退出。</p><p>这里出现的是空指针异常，很明显是因为我们去操作一个值为null的变量导致的。在我们以后的学习中，这个异常是出现频率最高的。</p><p>我们来看最后一个问题，对象创建成功之后，它的属性没有进行赋值，但是我们前面说了，变量使用之前需要先赋值，那么创建对象之后能否直接访问呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span>+p.name);</span><br><span class="line">    System.out.println(<span class="string">&quot;age = &quot;</span>+p.age);</span><br><span class="line">    System.out.println(<span class="string">&quot;sex = &quot;</span>+p.sex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看运行结果：</p><p><img src="https://s2.loli.net/2022/09/19/zDRdFwhm6nebSJU.png" alt="image-20220919214248053"></p><p>我们可以看到，如果直接创建对象，那么对象的属性都会存在初始值，如果是基本类型，那么默认是统一为<code>0</code>（如果是boolean的话，默认值为false）如果是引用类型，那么默认是<code>null</code>。</p><h3 id="方法创建与使用">方法创建与使用</h3><p>前面我们介绍了类的定义以及对象的创建和使用。</p><p>现在我们的类有了属性，我们可以为创建的这些对象设定不同的属性值，比如每个人的名字都不一样，性别不一样，年龄不一样等等。只不过光有属性还不行，对象还需要具有一定的行为，就像我们人可以行走，可以跳跃，可以思考一样。</p><p>而对象也可以做出一些行为，我们可以通过定义方法来实现（在C语言中叫做函数）</p><p>方法是语句的集合，是为了完成某件事情而存在的。完成某件事情，可以有结果，也可以做了就做了，不返回结果。比如计算两个数字的和，我们需要得到计算后的结果，所以说方法需要有返回值；又比如，我们只想吧数字打印在控制台，只需要打印就行，不用给我结果，所以说方法不需要有返回值。</p><p>方法的定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 方法名称() &#123;</span><br><span class="line">方法体...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是返回值类型，也就是说这个方法完成任务之后，得到的结果的数据类型（可以是基本类型，也可以是引用类型）当然，如果没有返回值，只是完成任务，那么可以使用<code>void</code>表示没有返回值，比如我们现在给人类编写一个自我介绍的行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//自我介绍只需要完成就行，没有返回值，所以说使用void</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="comment">//完成自我介绍需要执行的所有代码就在这个花括号中编写</span></span><br><span class="line">      <span class="comment">//这里编写代码跟我们之前在main中是一样的（实际上main就是一个函数）</span></span><br><span class="line">      <span class="comment">//自我介绍需要用到当前对象的名字和年龄，我们直接使用成员变量即可，变量的值就是当前对象的存放值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我叫 &quot;</span>+name+<span class="string">&quot; 今年 &quot;</span>+age+<span class="string">&quot; 岁了！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，方法名称同样可以随便起，但是规则跟变量的命名差不多，也是尽量使用小写字母开头的单词，如果是多个单词，一般使用驼峰命名法最规范。</p><p><img src="https://s2.loli.net/2022/09/20/2vmhsCRXpPzojiD.png" alt="image-20220920101033325"></p><p>现在我们给人类定义好了一个方法（行为）那么怎么才能让对象执行这个行为呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    p.name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    p.age = <span class="number">18</span>;</span><br><span class="line">    p.hello();    <span class="comment">//我们只需要使用 . 运算符，就可以执行定义好的方法了，只需要 .方法名称() 即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样执行定义好的方法，我们一般称为<strong>方法的调用</strong>，我们来看看效果：</p><p><img src="https://s2.loli.net/2022/09/19/bR2PAWoJ8qUzCfh.png" alt="image-20220919220837991"></p><p>比如现在我们要让人类学会加法运算，我们也可以通过定义一个方法的形式来完成，只不过，要完成加法运算，我们需要别人给人类提供两个参与加法运算的值才可以，所以我们这里就要用到参数了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们的方法需要别人提供参与运算的值才可以</span></span><br><span class="line"><span class="comment">//我们可以为方法设定参数，在调用方法时，需要外部传入参数才可以</span></span><br><span class="line"><span class="comment">//参数的定义需要在小括号内部编写，类似于变量定义，需要填写 类型和参数名称，多个参数用逗号隔开</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;   <span class="comment">//这里需要两个int类型的参数进行计算</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么现在参数从外部传入之后，我们怎么使用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;   <span class="comment">//这里的参数，相当于我们在函数中定义了两个局部变量，我们可以直接在方法中使用</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;   <span class="comment">//直接c = a + b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么现在计算完成了，我们该怎么将结果传递到外面呢？首先函数的返回值是int类型，我们只需要使用<code>return</code>关键字来返回一个int类型的结果就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">    <span class="keyword">return</span> c;   <span class="comment">//return后面紧跟需要返回的结果，这样就可以将计算结果丢出去了</span></span><br><span class="line">  <span class="comment">//带返回值的方法，是一定要有一个返回结果的！否则无法通过编译！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    p.name = <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    p.age = <span class="number">18</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> p.sum(<span class="number">10</span>, <span class="number">20</span>);    <span class="comment">//现在我们要让这个对象帮我们计算10 + 20的结果</span></span><br><span class="line">    System.out.println(result);    <span class="comment">//成功得到30，实际上这里的println也是在调用方法进行打印操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 方法定义时编写的参数，我们一般称为形式参数，而调用方法实际传入的参数，我们成为实际参数。</p><p>是不是越来越感觉我们真的在跟一个对象进行交互？只要各位有了这样的体验，基本上就已经摸到面向对象的门路了。</p><p>关于<code>return</code>关键字，我们还需要进行进一步的介绍。</p><p>在我们使用<code>return</code>关键字之后，方法就会直接结束并返回结果，所以说在这之后编写的任何代码，都是不可到达的：</p><p><img src="https://s2.loli.net/2022/09/19/UCcAb9L8lfOzXMZ.png" alt="image-20220919222813469"></p><p>在<code>return</code>后编写代码，会导致编译不通过，因为存在不可达语句。</p><p>如果我们的程序中出现了分支语句，那么必须保证每一个分支都有返回值才可以：</p><p><img src="https://s2.loli.net/2022/09/19/WjUlRrPwA9EXThV.png" alt="image-20220919223037197"></p><p>只要有任何一个分支缺少了<code>return</code>语句，都无法正常通过编译，总之就是必须考虑到所有的情况，任何情况下都必须要有返回值。</p><p>当然，如果方法没有返回值，我们也可以使用<code>return</code>语句，不需要跟上任何内容，只不过这种情况下使用，仅仅是为了快速结束方法的执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">10</span>) <span class="keyword">return</span>;    <span class="comment">//当a等于10时直接结束方法，后面无论有没有代码都不会执行了</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World!&quot;</span>);   <span class="comment">//不是的情况就正常执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们来讨论一下参数的传递问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span>&#123;   <span class="comment">//我们可以设置参数来让外部的数据传入到函数内部</span></span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上参数的传递，会在调用方法的时候，对参数的值进行复制，方法中的参数变量，不是我们传入的变量本身，我们来下面的这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;   <span class="comment">//这个函数的目的很明显，就是为了交换a和b的值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>, b = <span class="number">9</span>;   <span class="comment">//外面也叫a和b</span></span><br><span class="line">    p.swap(a, b);</span><br><span class="line">    System.out.println(<span class="string">&quot;a = &quot;</span>+a+<span class="string">&quot;, b = &quot;</span>+b);   <span class="comment">//最后的结果会变成什么样子呢？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看结果是什么：</p><p><img src="https://s2.loli.net/2022/09/19/wJrLaT7YBeQipNV.png" alt="image-20220919224219071"></p><p>我们发现a和b的值并没有发生交换，但是按照我们的方法逻辑来说，应该是会交换才对，这是为什么呢？实际上这里仅仅是将值复制给了函数里面的变量而已（相当于是变量的赋值）</p><p><img src="https://s2.loli.net/2022/09/19/WdiDToucsCvySNf.png" alt="image-20220919224623727"></p><p>所以说我们交换的仅仅是方法中的a和b，参数传递仅仅是值传递，我们是没有办法直接操作到外面的a和b的。</p><p>那么各位小伙伴看看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">modify</span><span class="params">(Person person)</span>&#123;</span><br><span class="line">    person.name = <span class="string">&quot;lbwnb&quot;</span>;   <span class="comment">//修改对象的名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    p.name = <span class="string">&quot;小明&quot;</span>;     <span class="comment">//先在外面修改一次</span></span><br><span class="line">    p.modify(p);        <span class="comment">//调用方法再修改一次</span></span><br><span class="line">    System.out.println(p.name);    <span class="comment">//请问最后name会是什么？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看结果：</p><p><img src="https://s2.loli.net/2022/09/19/sNLjlYP6g3yxpe1.png" alt="image-20220919224957971"></p><p>不对啊，前面不是说只是值传递吗，怎么这里又可以修改成功呢？</p><p>确实，这里同样是进行的值传递，只不过各位小伙伴别忘了，我们前面可是说的清清楚楚，引用类型的变量，仅仅存放的是对象的引用，而不是对象本身。那么这里进行了值传递，相当于将对象的引用复制到了方法内部的变量中，而这个内部的变量，依然是引用的同一个对象，所以说这里在方法内操作，相当于直接操作外面的定义对象。</p><p><img src="https://s2.loli.net/2022/09/19/aXf6AsdLneKxi9V.png" alt="image-20220919225455752"></p><h3 id="方法进阶使用">方法进阶使用</h3><p>有时候我们的方法中可能会出现一些与成员变量重名的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们希望使用这个方法，来为当前对象设定名字</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时类中定义的变量名称也是<code>name</code>，那么我们是否可以这样编写呢：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    name = name;    <span class="comment">//出现重名时，优先使用作用域最接近的，这里实际上是将方法参数的局部变量name赋值为本身</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    p.setName(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    System.out.println(p.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，似乎这样做并没有任何的效果，name依然是没有修改的状态。那么当出现重名的时候，因为默认情况下会优先使用作用域最近的变量，我们怎么才能表示要使用的变量是类的成员变量呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.name = <span class="string">&quot;小明&quot;</span>;    <span class="comment">//我们之前在外面使用时，可以直接通过对象.属性的形式访问到</span></span><br></pre></td></tr></table></figure><p>同样的，我们如果想要在方法中访问到当前对象的属性，那么可以使用<code>this</code>关键字，来明确表示当前类的示例对象本身：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;   <span class="comment">//让当前对象的name变量值等于参数传入的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以修改成功了，当然，如果方法内没有变量出现重名的情况，那么默认情况下可以不使用<code>this</code>关键字来明确表示当前对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name;    <span class="comment">//这里没有使用this，但是当前作用域下只有对象属性的name变量，所以说直接就使用了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们接着来看方法的重载。</p><p>有些时候，参数类型可能会多种多样，我们的方法需要能够同时应对多种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    System.out.println(p.sum(<span class="number">10</span>, <span class="number">20</span>));    <span class="comment">//这里可以正常计算两个整数的和</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是要是我们现在不仅要让人类会计算整数，还要会计算小数呢？</p><p><img src="https://s2.loli.net/2022/09/20/m7BvM1RctLznhrA.png" alt="image-20220920102347110"></p><p>当我们使用小数时，可以看到，参数要求的是int类型，那么肯定会出现错误，这个方法只能用于计算整数。此时，为了让这个方法支持使用小数进行计算，我们可以将这个方法进行重载。</p><p>一个类中可以包含多个同名的方法，但是需要的形式参数不一样，方法的返回类型，可以相同，也可以不同，但是仅返回类型不同，是不允许的！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="title function_">sum</span><span class="params">(<span class="type">double</span> a, <span class="type">double</span> b)</span>&#123;    <span class="comment">//为了支持小数加法，我们可以进行一次重载</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以正常使用了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">  <span class="comment">//当方法出现多个重载的情况，在调用时会自动进行匹配，选择合适的方法进行调用</span></span><br><span class="line">    System.out.println(p.sum(<span class="number">1.5</span>, <span class="number">2.2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包括我们之前一直在使用的<code>println</code>方法，其实也是重载了很多次的，因为要支持各种值的打印。</p><p>注意，如果仅仅是返回值的不同，是不支持重载的：</p><p><img src="https://s2.loli.net/2022/09/20/N2TRuqEnxrKbpc8.png" alt="image-20220920102933047"></p><p>当然，方法之间是可以相互调用的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是test&quot;</span>);   <span class="comment">//实际上这里也是调用另一个方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">    test();   <span class="comment">//在一个方法内调用另一个方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们这样写的话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    say();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>各位猜猜看会出现什么情况？</p><p><img src="https://s2.loli.net/2022/09/21/XPMVa3pdBcFICTE.png" alt="image-20220921001914601"></p><p>此时又出现了一个我们不认识的异常，实际上什么原因导致的我们自己都很清楚，方法之间一直在相互调用，没有一个出口。</p><p>方法自己也可以调用自己：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像这样自己调用自己的行为，我们称为递归调用，如果直接这样编写，会跟上面一样，出现栈溢出错误。但是如果我们给其合理地设置出口，就不会出现这种问题，比如我们想要计算从1加到n的和：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> test(n - <span class="number">1</span>) + n;    <span class="comment">//返回的结果是下一层返回的结果+当前这一层的n</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉很巧妙？实际上递归调用在很多情况下能够快速解决一些很麻烦的问题，我们会在后面继续了解。</p><h3 id="构造方法">构造方法</h3><p>我们接着来看一种比较特殊的方法，构造方法。</p><p>我们前面创建对象，都是直接使用<code>new</code>关键字就能直接搞定了，但是我们发现，对象在创建之后，各种属性都是默认值，那么能否实现在对象创建时就为其指定名字、年龄、性别呢？要在对象创建时进行处理，我们可以使用构造方法（构造器）来完成。</p><p>实际上每个类都有一个默认的构造方法，我们可以来看看反编译的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> &#123;    <span class="comment">//反编译中，多出来了这样一个方法，这其实就是构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法不需要填写返回值，并且方法名称与类名相同，默认情况下每个类都会自带一个没有任何参数的无参构造方法（只是不用我们去写，编译出来就自带）当然，我们也可以手动声明，对其进行修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">    Person()&#123;    <span class="comment">//构造方法不需要指定返回值，并且方法名称与类名相同</span></span><br><span class="line">        name = <span class="string">&quot;小明&quot;</span>;   <span class="comment">//构造方法会在对象创建时执行，我们可以将各种需要初始化的操作都在这里进行处理</span></span><br><span class="line">        age = <span class="number">18</span>;</span><br><span class="line">        sex = <span class="string">&quot;男&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法会在new的时候自动执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();   <span class="comment">//这里的new Person()其实就是在调用无参构造方法</span></span><br><span class="line">    System.out.println(p.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，我们也可以为构造方法设定参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="type">int</span> age, String sex)&#123;   <span class="comment">//跟普通方法是一样的</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，在我们自己定义一个构造方法之后，会覆盖掉默认的那一个无参构造方法，除非我们手动重载一个无参构造，否则要创建这个类的对象，必须调用我们自己定义的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);   <span class="comment">//调用自己定义的带三个参数的构造方法</span></span><br><span class="line">    System.out.println(p.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以去看看反编译的结果，会发现此时没有无参构造了，而是只剩下我们自己编写的。</p><p>当然，要给成员变量设定初始值，我们不仅可以通过构造方法，也可以直接在定义时赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;未知&quot;</span>;   <span class="comment">//直接赋值，那么对象构造好之后，属性默认就是这个值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sex</span> <span class="operator">=</span> <span class="string">&quot;男&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要特别注意，成员变量的初始化，并不是在构造方法之前之后，而是在这之前就已经完成了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person(String name, <span class="type">int</span> age, String sex)&#123;</span><br><span class="line">    System.out.println(age);    <span class="comment">//在赋值之前看看是否有初始值</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以在类中添加代码块，代码块同样会在对象构造之前进行，在成员变量初始化之后执行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是代码块&quot;</span>);   <span class="comment">//代码块中的内容会在对象创建时仅执行一次</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person(String name, <span class="type">int</span> age, String sex)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我被构造了&quot;</span>);</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过一般情况下使用代码块的频率比较低，标准情况下还是通过构造方法进行进行对象初始化工作，所以说这里做了解就行了。</p><h3 id="静态变量和静态方法">静态变量和静态方法</h3><p>前面我们已经了解了类的大部分特性，一个类可以具有多种属性、行为，包括对象该如何创建，我们可以通过构造方法进行设定，我们可以通过类创建对象，每个对象都会具有我们在类中设定好的属性，包括我们设定好的行为，所以说类就像是一个模板，我们可以通过这个模板快速捏造出一个又一个的对象。我们接着来看比较特殊的静态特性。</p><p>静态的内容，我们可以理解为是属于这个类的，也可以理解为是所有对象共享的内容。我们通过使用<code>static</code>关键字来声明一个变量或一个方法为静态的，一旦被声明为静态，那么通过这个类创建的所有对象，操作的都是同一个目标，也就是说，对象再多，也只有这一个静态的变量或方法。一个对象改变了静态变量的值，那么其他的对象读取的就是被改变的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line">    <span class="keyword">static</span> String info;    <span class="comment">//这里我们定义一个info静态变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    p1.info = <span class="string">&quot;杰哥你干嘛&quot;</span>;</span><br><span class="line">    System.out.println(p2.info);   <span class="comment">//可以看到，由于静态属性是属于类的，因此无论通过什么方式改变，都改变的是同一个目标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说一般情况下，我们并不会通过一个具体的对象去修改和使用静态属性，而是通过这个类去使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Person.info = <span class="string">&quot;让我看看&quot;</span>;</span><br><span class="line">    System.out.println(Person.info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，我们可以将方法标记为静态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是静态方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态方法同样是属于类的，而不是具体的某个对象，所以说，就像下面这样：</p><p><img src="https://s2.loli.net/2022/09/20/cWCrJgnkXFL63y2.png" alt="image-20220920234401275"></p><p>因为静态方法属于类的，所以说我们在静态方法中，无法获取成员变量的值：</p><p><img src="https://s2.loli.net/2022/09/20/XvPjtLm2wOMh4ZK.png" alt="image-20220920235418115"></p><p>成员变量是某个具体对象拥有的属性，就像小明这个具体的人的名字才叫小明，而静态方法是类具有的，并不是具体对象的，肯定是没办法访问到的。同样的，在静态方法中，无法使用<code>this</code>关键字，因为this关键字代表的是当前的对象本身。</p><p>但是静态方法是可以访问到静态变量的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String info;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;静态变量的值为：&quot;</span>+info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为他们都属于类，所以说肯定是可以访问到的。</p><p>我们也可以将代码块变成静态的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String info;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;   <span class="comment">//静态代码块可以用于初始化静态变量</span></span><br><span class="line">    info = <span class="string">&quot;测试&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，静态变量，是在什么时候进行初始化的呢？</p><p>我们在一开始介绍了，我们实际上是将<code>.class</code>文件丢给JVM去执行的，而每一个<code>.class</code>文件其实就是我们编写的一个类，我们在Java中使用一个类之前，JVM并不会在一开始就去加载它，而是在需要时才会去加载（优化）一般遇到以下情况时才会会加载类：</p><ul><li>访问类的静态变量，或者为静态变量赋值</li><li>new 创建类的实例（隐式加载）</li><li>调用类的静态方法</li><li>子类初始化时</li><li>其他的情况会在讲到反射时介绍</li></ul><p>所有被标记为静态的内容，会在类刚加载的时候就分配，而不是在对象创建的时候分配，所以说静态内容一定会在第一个对象初始化之前完成加载。</p><p>我们可以来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> test();  <span class="comment">//这里我们用test方法的返回值作为变量的初始值，便于观察</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Person()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是成员变量初始化&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">String</span> <span class="variable">info</span> <span class="operator">=</span> init();   <span class="comment">//这里我们用init静态方法的返回值作为变量的初始值，便于观察</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是静态变量初始化&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们在主方法中创建一个对象，观察这几步是怎么在执行的：</p><p><img src="https://s2.loli.net/2022/09/21/JxTPk8SWtDmK6IX.png" alt="image-20220921000953525"></p><p>可以看到，确实是静态内容在对象构造之前的就完成了初始化，实际上就是类初始化时完成的。</p><p>当然，如果我们直接访问类的静态变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(Person.info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么此时同样会使得类初始化，进行加载：</p><p><img src="https://s2.loli.net/2022/09/21/auMJOvNfx9K3mzd.png" alt="image-20220921001222465"></p><p>可以看到，在使用时，确实是先将静态内容初始化之后，才得到值的。当然，如果我们压根就没有去使用这个类，那么也不会被初始化了。</p><p>有关类与对象的基本内容，我们就全部讲解完毕了。</p><hr><h2 id="包和访问控制">包和访问控制</h2><p>通过前面的学习，我们知道该如何创建和使用类。</p><h3 id="包声明和导入">包声明和导入</h3><p>包其实就是用来区分类位置的东西，也可以用来将我们的类进行分类（类似于C++中的namespace）随着我们的程序不断变大，可能会创建各种各样的类，他们可能会做不同的事情，那么这些类如果都放在一起的话，有点混乱，我们可以通过包的形式将这些类进行分类存放。</p><p>包的命名规则同样是英文和数字的组合，最好是一个域名的格式，比如我们经常访问的<code>www.baidu.com</code>，后面的baidu.com就是域名，我们的包就可以命名为<code>com.baidu</code>，当然，各位小伙伴现在还没有自己的域名，所以说我们随便起一个名称就可以了。其中的<code>.</code>就是用于分割的，对应多个文件夹，比如<code>com.test</code>：</p><p><img src="https://s2.loli.net/2022/09/21/OZdDi1sGluyjbgr.png" alt="image-20220921120040350"></p><p>我们可以将类放入到包中：</p><p><img src="https://s2.loli.net/2022/09/21/e3GvFsHDhMAtBWR.png" alt="image-20220921115055000"></p><p>我们之前都是直接创建的类，所以说没有包这个概念，但是现在，我们将类放到包中，就需要注意了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;   <span class="comment">//在放入包中，需要在类的最上面添加package关键字来指明当前类所处的包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;   <span class="comment">//将Main类放到com.test这个包中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里又是一个新的关键字<code>package</code>，这个是用于指定当前类所处的包的，注意，所处的包和对应的目录是一一对应的。</p><p>不同的类可以放在不同的包下：</p><p><img src="https://s2.loli.net/2022/09/21/stOGnxaPirZvjLF.png" alt="image-20220921120241184"></p><p>当我们使用同一个包中的类时，直接使用即可（之前就是直接使用的，因为都直接在一个缺省的包中）而当我们需要使用其他包中的类时，需要先进行导入才可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.test.entity.Person;   <span class="comment">//使用import关键字导入其他包中的类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();   <span class="comment">//只有导入之后才可以使用，否则编译器不知道这个类从哪来的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了<code>import</code>关键字导入我们需要使用的类，当然，只有在类不在同一个包下时才需要进行导入，如果一个包中有多个类，我们可以使用<code>*</code>表示导入这个包中全部的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.test.entity.*;</span><br></pre></td></tr></table></figure><p>实际上我们之前一直在使用的<code>System</code>类，也是在一个包中的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Executable;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.security.AccessControlContext;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.PropertyPermission;</span><br><span class="line"><span class="keyword">import</span> java.util.StringTokenizer;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.security.AccessController;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivilegedAction;</span><br><span class="line"><span class="keyword">import</span> java.security.AllPermission;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Channel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.spi.SelectorProvider;</span><br><span class="line"><span class="keyword">import</span> sun.nio.ch.Interruptible;</span><br><span class="line"><span class="keyword">import</span> sun.reflect.CallerSensitive;</span><br><span class="line"><span class="keyword">import</span> sun.reflect.Reflection;</span><br><span class="line"><span class="keyword">import</span> sun.security.util.SecurityConstants;</span><br><span class="line"><span class="keyword">import</span> sun.reflect.annotation.AnnotationType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jdk.internal.util.StaticProperty;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The &lt;code&gt;System&lt;/code&gt; class contains several useful class fields</span></span><br><span class="line"><span class="comment"> * and methods. It cannot be instantiated.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Among the facilities provided by the &lt;code&gt;System&lt;/code&gt; class</span></span><br><span class="line"><span class="comment"> * are standard input, standard output, and error output streams;</span></span><br><span class="line"><span class="comment"> * access to externally defined properties and environment</span></span><br><span class="line"><span class="comment"> * variables; a means of loading files and libraries; and a utility</span></span><br><span class="line"><span class="comment"> * method for quickly copying a portion of an array.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>  unascribed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span>   JDK1.0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">System</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到它是属于<code>java.lang</code>这个包下的类，并且这个类也导入了很多其他包中的类在进行使用。那么，为什么我们在使用这个类时，没有导入呢？实际上Java中会默认导入<code>java.lang</code>这个包下的所有类，因此我们不需要手动指定。</p><p>IDEA非常智能，我们在使用项目中定义的类时，会自动帮我们将导入补全，所以说代码写起来非常高效。</p><p>注意，在不同包下的类，即使类名相同，也是不同的两个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;    <span class="comment">//我们在自己的包中也建一个名为String的类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在使用时，由于默认导入了系统自带的String类，并且也导入了我们自己定义的String类，那么此时就出现了歧义，编译器不知道到底我们想用的是哪一个String类，所以说我们需要明确指定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[] args)</span> &#123;   <span class="comment">//主方法的String参数是java.lang包下的，我们需要明确指定一下，只需要在类名前面添加包名就行了</span></span><br><span class="line">com.test.entity.<span class="type">String</span> <span class="variable">string</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">com</span>.test.entity.String();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要在类名前面把完整的包名也给写上，就可以表示这个是哪一个包里的类了，当然，如果没有出现歧义，默认情况下包名是可以省略的，可写可不写。</p><p>可能各位小伙伴会发现一个问题，为什么对象的属性访问不了了？</p><p><img src="https://s2.loli.net/2022/09/21/UaqMihmIQkzHFtG.png" alt="image-20220921122514457"></p><p>编译器说name属性在这个类中不是public，无法在外部进行访问，这是什么情况呢？这里我们就要介绍的到Java的访问权限控制了。</p><h3 id="访问权限控制">访问权限控制</h3><p>实际上Java中是有访问权限控制的，就是我们个人的隐私的一样，我不允许别人随便来查看我们的隐私，只有我们自己同意的情况下，才能告诉别人我们的名字、年龄等隐私信息。</p><p>所以说Java中引入了访问权限控制（可见性），我们可以为成员变量、成员方法、静态变量、静态方法甚至是类指定访问权限，不同的访问权限，有着不同程度的访问限制：</p><ul><li><code>private</code>   -   私有，标记为私有的内容无法被除当前类以外的任何位置访问。</li><li><code>什么都不写</code>   -   默认，默认情况下，只能被类本身和同包中的其他类访问。</li><li><code>protected</code>   -   受保护，标记为受保护的内容可以能被类本身和同包中的其他类访问，也可以被子类访问（子类我们会在下一章介绍）</li><li><code>public</code>    -   公共，标记为公共的内容，允许在任何地方被访问。</li></ul><p>这四种访问权限，总结如下表：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">当前类</th><th style="text-align:center">同一个包下的类</th><th style="text-align:center">不同包下的子类</th><th style="text-align:center">不同包下的类</th></tr></thead><tbody><tr><td style="text-align:center">public</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td></tr><tr><td style="text-align:center">protected</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">❌</td></tr><tr><td style="text-align:center">默认</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td></tr><tr><td style="text-align:center">private</td><td style="text-align:center">✅</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td><td style="text-align:center">❌</td></tr></tbody></table><p>比如我们刚刚出现的情况，就是因为是默认的访问权限，所以说在当前包以外的其他包中无法访问，但是我们可以提升它的访问权限，来使得外部也可以访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;   <span class="comment">//在name变量前添加public关键字，将其可见性提升为公共等级</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以在外部正常使用这个属性了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    System.out.println(person.name);   <span class="comment">//正常访问到成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上如果各位小伙伴观察仔细的话，会发现我们创建出来的类自带的访问等级就是<code>public</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;   <span class="comment">//class前面有public关键字</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说这个类实际上可以在任何地方使用，但是我们也可以将其修改为默认的访问等级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;    <span class="comment">//去掉public变成默认等级</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是默认等级的话，那么在外部同样是无法访问的：</p><p><img src="https://s2.loli.net/2022/09/21/ZTRAEItQY6UcqvP.png" alt="image-20220921142724239"></p><p>但是注意，我们创建的普通类不能是<code>protected</code>或是<code>private</code>权限，因为我们目前所使用的普通类要么就是只给当前的包内使用，要么就是给外面都用，如果是<code>private</code>谁都不能用，那这个类定义出来干嘛呢？</p><p>如果某个类中存在静态方法或是静态变量，那么我们可以通过静态导入的方式将其中的静态方法或是静态变量直接导入使用，但是同样需要有访问权限的情况下才可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是静态方法！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来尝试一下静态导入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.test.entity.Person.test;    <span class="comment">//静态导入test方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        test();    <span class="comment">//直接使用就可以，就像在这个类定义的方法一样</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，有关包相关的内容，我们就讲解到这里。</p><hr><h2 id="封装、继承和多态">封装、继承和多态</h2><p>封装、继承和多态是面向对象编程的三大特性。</p><blockquote><p>封装，把对象的属性和方法结合成一个独立的整体，隐藏实现细节，并提供对外访问的接口。</p><p>继承，从已知的一个类中派生出一个新的类，叫子类。子类实现了父类所有非私有化的属性和方法，并根据实际需求扩展出新的行为。</p><p>多态，多个不同的对象对同一消息作出响应，同一消息根据不同的对象而采用各种不同的方法。</p></blockquote><p>正是这三大特性，让我们的Java程序更加生动形象。</p><h3 id="类的封装">类的封装</h3><p>封装的目的是为了保证变量的安全性，使用者不必在意具体实现细节，而只是通过外部接口即可访问类的成员，如果不进行封装，类中的实例变量可以直接查看和修改，可能给整个代码带来不好的影响，因此在编写类时一般将成员变量私有化，外部类需要使用Getter和Setter方法来查看和设置变量。</p><p>我们可以将之前的类进行改进：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;    <span class="comment">//现在类的属性只能被自己直接访问</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;   <span class="comment">//构造方法也要声明为公共，否则对象都构造不了</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;    <span class="comment">//想要知道这个对象的名字，必须通过getName()方法来获取，并且得到的只是名字值，外部无法修改</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getSex</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以来试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    System.out.println(person.getName());    <span class="comment">//只能通过调用getName()方法来获取名字</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，外部现在只能通过调用我定义的方法来获取成员属性，而我们可以在这个方法中进行一些额外的操作，比如小明可以修改名字，但是名字中不能包含&quot;小&quot;这个字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(name.contains(<span class="string">&quot;小&quot;</span>)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们甚至还可以将构造方法改成私有的，需要通过我们的内部的方式来构造对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Person</span><span class="params">()</span>&#123;&#125;   <span class="comment">//不允许外部使用new关键字创建对象</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Person <span class="title function_">getInstance</span><span class="params">()</span> &#123;   <span class="comment">//而是需要使用我们的独特方法来生成对象并返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，我们可以实现单例模式：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Test instance;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Test</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Test <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>) </span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单例模式就是全局只能使用这一个对象，不能创建更多的对象，我们就可以封装成这样，关于单例模式的详细介绍，还请各位小伙伴在《Java设计模式》视频教程中再进行学习。</p></blockquote><p>封装思想其实就是把实现细节给隐藏了，外部只需知道这个方法是什么作用，而无需关心实现，要用什么由类自己来做，不需要外面来操作类内部的东西去完成，封装就是通过访问权限控制来实现的。</p><h3 id="类的继承">类的继承</h3><p>前面我们介绍了类的封装，我们接着来看一个非常重要特性：继承。</p><p>在定义不同类的时候存在一些相同属性，为了方便使用可以将这些共同属性抽象成一个父类，在定义其他子类时可以继承自该父类，减少代码的重复定义，子类可以使用父类中<strong>非私有</strong>的成员。</p><p>比如说我们一开始使用的人类，那么实际上人类根据职业划分，所掌握的技能也会不同，比如画家会画画，歌手会唱，舞者会跳，Rapper会rap，运动员会篮球，我们可以将人类这个大类根据职业进一步地细分出来：</p><p><img src="https://s2.loli.net/2022/09/21/zlZ9JXAjvxpawPF.png" alt="image-20220921150139125"></p><p>实际上这些划分出来的类，本质上还是人类，也就是说人类具有的属性，这些划分出来的类同样具有，但是，这些划分出来的类同时也会拥有他们自己独特的技能。在Java中，我们可以创建一个类的子类来实现上面的这种效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;   <span class="comment">//先定义一个父类</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们可以创建各种各样的子类，想要继承一个类，我们只需要使用<code>extends</code>关键字即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;    <span class="comment">//工人类</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;   <span class="comment">//学生类</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类的继承可以不断向下，但是同时只能继承一个类，同时，标记为<code>final</code>的类不允许被继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;  <span class="comment">//class前面添加final关键字表示这个类已经是最终形态，不能继承</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个类继承另一个类时，属性会被继承，可以直接访问父类中定义的属性，除非父类中将属性的访问权限修改为<code>private</code>，那么子类将无法访问（但是依然是继承了这个属性的）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的名字是 &quot;</span>+name+<span class="string">&quot;，我在学习！&quot;</span>);   <span class="comment">//可以直接访问父类中定义的name属性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，在父类中定义的方法同样会被子类继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我叫 &quot;</span>+name+<span class="string">&quot;，今年 &quot;</span>+age+<span class="string">&quot; 岁了!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>子类直接获得了此方法，当我们创建一个子类对象时就可以直接使用这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    student.study();    <span class="comment">//子类不仅有自己的独特技能</span></span><br><span class="line">    student.hello();    <span class="comment">//还继承了父类的全部技能</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉非常人性化，子类继承了父类的全部能力，同时还可以扩展自己的独特能力，就像一句话说的： 龙生龙凤生凤，老鼠儿子会打洞。</p><p>如果父类存在一个有参构造方法，子类必须在构造方法中调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;   <span class="comment">//因为子类需要用这些属性，所以说我们就将这些变成protected，外部不允许访问</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">protected</span> String sex;</span><br><span class="line">    <span class="keyword">protected</span> String profession;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造方法也改成protected，只能子类用</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, String sex, String profession)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.profession = profession;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[&quot;</span>+profession+<span class="string">&quot;] 我叫 &quot;</span>+name+<span class="string">&quot;，今年 &quot;</span>+age+<span class="string">&quot; 岁了!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，此时两个子类都报错了：</p><p><img src="https://s2.loli.net/2022/09/21/SgPjRtUN64bmWrX.png" alt="image-20220921153512798"></p><p>因为子类在构造时，不仅要初始化子类的属性，还需要初始化父类的属性，所以说在默认情况下，子类其实是调用了父类的构造方法的，只是在无参的情况下可以省略，但是现在父类构造方法需要参数，那么我们就需要手动指定了：</p><p>既然现在父类需要三个参数才能构造，那么子类需要按照同样的方式调用父类的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;    <span class="comment">//因为学生职业已经确定，所以说学生直接填写就可以了</span></span><br><span class="line">        <span class="built_in">super</span>(name, age, sex, <span class="string">&quot;学生&quot;</span>);   <span class="comment">//使用super代表父类，父类的构造方法就是super()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的名字是 &quot;</span>+name+<span class="string">&quot;，我在学习！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age, sex, <span class="string">&quot;工人&quot;</span>);    <span class="comment">//父类构造调用必须在最前面</span></span><br><span class="line">        System.out.println(<span class="string">&quot;工人构造成功！&quot;</span>);    <span class="comment">//注意，在调用父类构造方法之前，不允许执行任何代码，只能在之后执行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在使用子类时，可以将其当做父类来使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);    <span class="comment">//这里使用父类类型的变量，去引用一个子类对象（向上转型）</span></span><br><span class="line">    person.hello();    <span class="comment">//父类对象的引用相当于当做父类来使用，只能访问父类对象的内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然我们这里使用的是父类类型引用的对象，但是这并不代表子类就彻底变成父类了，这里仅仅只是当做父类使用而已。</p><p>我们也可以使用强制类型转换，将一个被当做父类使用的子类对象，转换回子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) person;   <span class="comment">//使用强制类型转换（向下转型）</span></span><br><span class="line">    student.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是注意，这种方式只适用于这个对象本身就是对应的子类才可以，如果本身都不是这个子类，或者说就是父类，那么会出现问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);   <span class="comment">//实际创建的是Work类型的对象</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> (Student) person;</span><br><span class="line">    student.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/21/JdMLt19Yq6KQz4v.png" alt="image-20220921160309835"></p><p>此时直接出现了类型转换异常，因为本身不是这个类型，强转也没用。</p><p>那么如果我们想要判断一下某个变量所引用的对象到底是什么类，那么该怎么办呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(person <span class="keyword">instanceof</span> Student) &#123;   <span class="comment">//我们可以使用instanceof关键字来对类型进行判断</span></span><br><span class="line">        System.out.println(<span class="string">&quot;对象是 Student 类型的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(person <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;对象是 Person 类型的&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果变量所引用的对象是对应类型或是对应类型的子类，那么<code>instanceof</code>都会返回<code>true</code>，否则返回<code>false</code>。</p><p>最后我们需要来特别说明一下，子类是可以定义和父类同名的属性的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;   <span class="comment">//子类中同样可以定义name属性</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age, sex, <span class="string">&quot;工人&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时父类的name属性和子类的name属性是同时存在的，那么当我们在子类中直接使用时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是 &quot;</span>+name+<span class="string">&quot;，我在工作！&quot;</span>);   <span class="comment">//这里的name，依然是作用域最近的哪一个，也就是在当前子类中定义的name属性，而不是父类的name属性</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说，我们在使用时，实际上这里得到的结果为<code>null</code>：</p><p><img src="https://s2.loli.net/2022/09/21/nKDaTJZ2LhEX3Hs.png" alt="image-20220921160742714"></p><p>那么，在子类存在同名变量的情况下，怎么去访问父类的呢？我们同样可以使用<code>super</code>关键字来表示父类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">work</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是 &quot;</span>+<span class="built_in">super</span>.name+<span class="string">&quot;，我在工作！&quot;</span>);   <span class="comment">//这里使用super.name来表示需要的是父类的name变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样得到的结果就不一样了：</p><p><img src="https://s2.loli.net/2022/09/21/DobHL2CWRMIif3z.png" alt="image-20220921160851193"></p><p>但是注意，没有<code>super.super</code>这种用法，也就是说如果存在多级继承的话，那么最多只能通过这种方法访问到父类的属性（包括继承下来的属性）</p><h3 id="顶层Object类">顶层Object类</h3><p>实际上所有类都默认继承自Object类，除非手动指定继承的类型，但是依然改变不了最顶层的父类是Object类。所有类都包含Object类中的方法，比如：</p><p><img src="https://s2.loli.net/2022/09/21/FCHDEI4rTAQquas.png" alt="image-20220921214642969"></p><p>我们发现，除了我们自己在类中编写的方法之外，还可以调用一些其他的方法，那么这些方法不可能无缘无故地出现，肯定同样是因为继承得到的，那么这些方法是继承谁得到的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">Object</span>&#123;   </span><br><span class="line"><span class="comment">//除非我们手动指定要继承的类是什么，实际上默认情况下所有的类都是继承自Object的，只是可以省略</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说我们的继承结构差不多就是：</p><p><img src="https://s2.loli.net/2022/09/21/hkapOYVHBrjy7UC.png" alt="image-20220921214944267"></p><p>既然所有的类都默认继承自Object，我们来看看这个类里面有哪些内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Object</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">registerNatives</span><span class="params">()</span>;   <span class="comment">//标记为native的方法是本地方法，底层是由C++实现的</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        registerNatives();   <span class="comment">//这个类在初始化时会对类中其他本地方法进行注册，本地方法不是我们SE中需要学习的内容，我们会在JVM篇视频教程中进行介绍</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取当前的类型Class对象，这个我们会在最后一章的反射中进行讲解，目前暂时不会用到</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取对象的哈希值，我们会在第五章集合类中使用到，目前各位小伙伴就暂时理解为会返回对象存放的内存地址</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断当前对象和给定对象是否相等，默认实现是直接用等号判断，也就是直接判断是否为同一个对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//克隆当前对象，可以将复制一个完全一样的对象出来，包括对象的各个属性</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将当前对象转换为String的形式，默认情况下格式为 完整类名@十六进制哈希值</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//唤醒一个等待当前对象锁的线程，有关锁的内容，我们会在第六章多线程部分中讲解，目前暂时不会用到</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notify</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//唤醒所有等待当前对象锁的线程，同上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">notifyAll</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使得持有当前对象锁的线程进入等待状态，同上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">long</span> timeout, <span class="type">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当对象被判定为已经不再使用的“垃圾”时，在回收之前，会由JVM来调用一次此方法进行资源释放之类的操作，这同样不是SE中需要学习的内容，这个方法我们会在JVM篇视频教程中详细介绍，目前暂时不会用到</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们可以尝试调用一下Object为我们提供的<code>toString()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> person.toString();</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是按照上面说的格式进行打印：</p><p><img src="https://s2.loli.net/2022/09/21/hpBOjqf4iwJW1Pr.png" alt="image-20220921221053801"></p><p>当然，我们直接可以给<code>println</code>传入一个Object类型的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">println</span><span class="params">(Object x)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(x);   <span class="comment">//这里同样会调用对象的toString方法，所以说跟上面效果是一样的</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        print(s);</span><br><span class="line">        newLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有小伙伴肯定会好奇，这里不是接受的一个Object类型的值的，为什么任意类型都可以传入呢？因为所有类型都是继承自Object，如果方法接受的参数是一个引用类型的值，那只要是这个类的对象或是这个类的子类的对象，都可以作为参数传入。</p><p>我们也可以试试看默认提供的<code>equals</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    System.out.println(p1.equals(p2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为默认比较的是两个对象是否为同一个对象，所以说这里得到的肯定是false，但是有些情况下，实际上我们所希望的情况是如果名字、年龄、性别都完全相同，那么这肯定是同一个人，但是这里却做不到这样的判断，我们需要修改一下<code>equals</code>方法的默认实现来完成，这就要用到方法的重写了。</p><h3 id="方法的重写">方法的重写</h3><p>注意，方法的重写不同于之前的方法重载，不要搞混了，方法的重载是为某个方法提供更多种类，而方法的重写是覆盖原有的方法实现，比如我们现在不希望使用Object类中提供的<code>equals</code>方法，那么我们就可以将其重写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//重写方法可以添加 @Override 注解，有关注解我们会在最后一章进行介绍，这个注解默认情况下可以省略</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;   <span class="comment">//重写方法要求与父类的定义完全一致</span></span><br><span class="line">        <span class="keyword">if</span>(obj == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//如果传入的对象为null，那肯定不相等</span></span><br><span class="line">        <span class="keyword">if</span>(obj <span class="keyword">instanceof</span> Person) &#123;     <span class="comment">//只有是当前类型的对象，才能进行比较，要是都不是这个类型还比什么</span></span><br><span class="line">            <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> (Person) obj;   <span class="comment">//先转换为当前类型，接着我们对三个属性挨个进行比较</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name.equals(person.name) &amp;&amp;    <span class="comment">//字符串内容的比较，不能使用==，必须使用equals方法</span></span><br><span class="line">                    <span class="built_in">this</span>.age == person.age &amp;&amp;       <span class="comment">//基本类型的比较跟之前一样，直接==</span></span><br><span class="line">                    <span class="built_in">this</span>.sex.equals(person.sex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在重写Object提供的<code>equals</code>方法之后，就会按照我们的方式进行判断了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    System.out.println(p1.equals(p2));   <span class="comment">//此时由于三个属性完全一致，所以说判断结果为真，即使是两个不同的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候为了方便查看对象的各个属性，我们可以将Object类提供的<code>toString</code>方法重写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;    <span class="comment">//使用IDEA可以快速生成</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">            <span class="string">&quot;, sex=&#x27;&quot;</span> + sex + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&quot;, profession=&#x27;&quot;</span> + profession + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，我们直接打印对象时，就会打印出对象的各个属性值了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    System.out.println(person);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/21/FCAnxSUjhaLuXW8.png" alt="image-20220921223249343"></p><p>注意，静态方法不支持重写，因为它是属于类本身的，但是它可以被继承。</p><p>基于这种方法可以重写的特性，对于一个类定义的行为，不同的子类可以出现不同的行为，比如考试，学生考试可以得到A，而工人去考试只能得到D：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是考试方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是学生，我就是小镇做题家，拿个 A 轻轻松松&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是工人，做题我并不擅长，只能得到 D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，不同的子类，对于同一个方法会产生不同的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    person.exam();</span><br><span class="line"></span><br><span class="line">    person = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;小强&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    person.exam();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/21/zogT67B91tJaHLD.png" alt="image-20220921224525855"></p><p>这其实就是面向对象编程中多态特性的一种体现。</p><p>注意，我们如果不希望子类重写某个方法，我们可以在方法前添加<code>final</code>关键字，表示这个方法已经是最终形态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是考试方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/21/zpKfDlGTLwx5iy8.png" alt="image-20220921224907373"></p><p>或者，如果父类中方法的可见性为<code>private</code>，那么子类同样无法访问，也就不能重写，但是可以定义同名方法：</p><p><img src="https://s2.loli.net/2022/09/21/d9k21hyGL6WExZ3.png" alt="image-20220921225651487"></p><p>虽然这里可以编译通过，但是并不是对父类方法的重写，仅仅是子类自己创建的一个新方法。</p><p>还有，我们在重写父类方法时，如果希望调用父类原本的方法实现，那么同样可以使用<code>super</code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>.exam();   <span class="comment">//调用父类的实现</span></span><br><span class="line">    System.out.println(<span class="string">&quot;我是工人，做题我并不擅长，只能得到 D&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是访问权限的问题，子类在重写父类方法时，不能降低父类方法中的可见性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是考试方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/21/zfhZ3YdFeCgJu89.png" alt="image-20220921225234226"></p><p>因为子类实际上可以当做父类使用，如果子类的访问权限比父类还低，那么在被当做父类使用时，就可能出现无视访问权限调用的情况，这样肯定是不行的，但是相反的，我们可以在子类中提升权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是考试方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span> &#123;   <span class="comment">//将可见性提升为public </span></span><br><span class="line">    System.out.println(<span class="string">&quot;我是工人，做题我并不擅长，只能得到 D&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/21/igvGNTQs2xKOZrI.png" alt="image-20220921225840122"></p><p>可以看到作为子类时就可以正常调用，但是如果将其作为父类使用，因为访问权限不足所有就无法使用，总之，子类重写的方法权限不能比父类还低。</p><h3 id="抽象类">抽象类</h3><p>在我们学习了类的继承之后，实际上我们会发现，越是处于顶层定义的类，实际上可以进一步地进行抽象，比如我们前面编写的考试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;我是考试方法&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法再子类中一定会被重写，所以说除非子类中调用父类的实现，否则一般情况下永远都不会被调用，就像我们说一个人会不会考试一样，实际上人怎么考试是一个抽象的概念，而学生怎么考试和工人怎么考试，才是具体的一个实现，所以说，我们可以将人类进行进一步的抽象，让某些方法完全由子类来实现，父类中不需要提供实现。</p><p>要实现这样的操作，我们可以将人类变成抽象类，抽象类比类还要抽象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;   <span class="comment">//通过添加abstract关键字，表示这个类是一个抽象类</span></span><br><span class="line">    <span class="keyword">protected</span> String name;   <span class="comment">//大体内容其实普通类差不多</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">protected</span> String sex;</span><br><span class="line">    <span class="keyword">protected</span> String profession;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Person</span><span class="params">(String name, <span class="type">int</span> age, String sex, String profession)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.sex = sex;</span><br><span class="line">        <span class="built_in">this</span>.profession = profession;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span>;   <span class="comment">//抽象类中可以具有抽象方法，也就是说这个方法只有定义，没有方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而具体的实现，需要由子类来完成，而且如果是子类，必须要实现抽象类中所有抽象方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age, sex, <span class="string">&quot;工人&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span> &#123;   <span class="comment">//子类必须要实现抽象类所有的抽象方法，这是强制要求的，否则会无法通过编译</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我是工人，做题我并不擅长，只能得到 D&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类由于不是具体的类定义（它是类的抽象）可能会存在某些方法没有实现，因此无法直接通过new关键字来直接创建对象：</p><p><img src="https://s2.loli.net/2022/09/21/GLQU8hANw36P5J7.png" alt="image-20220921231744420"></p><p>要使用抽象类，我们只能去创建它的子类对象。</p><p>抽象类一般只用作继承使用，当然，抽象类的子类也可以是一个抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span>&#123;   <span class="comment">//如果抽象类的子类也是抽象类，那么可以不用实现父类中的抽象方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age, sex, <span class="string">&quot;学生&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>   <span class="comment">//抽象类中并不是只能有抽象方法，抽象类中也可以有正常方法的实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">exam</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是学生，我就是小镇做题家，拿个 A 轻轻松松&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，抽象方法的访问权限不能为<code>private</code>：</p><p><img src="https://s2.loli.net/2022/09/21/1ZJSRU2Aj5K9Ikv.png" alt="image-20220921232435056"></p><p>因为抽象方法一定要由子类实现，如果子类都访问不了，那么还有什么意义呢？所以说不能为私有。</p><h3 id="接口">接口</h3><p>接口甚至比抽象类还抽象，他只代表某个确切的功能！也就是只包含方法的定义，甚至都不是一个类！接口一般只代表某些功能的抽象，接口包含了一些列方法的定义，类可以实现这个接口，表示类支持接口代表的功能（类似于一个插件，只能作为一个附属功能加在主体上，同时具体实现还需要由主体来实现）</p><p>咋一看，这啥意思啊，什么叫支持接口代表的功能？实际上接口的目标就是将类所具有某些的行为抽象出来。</p><p>比如说，对于人类的不同子类，学生和老师来说，他们都具有学习这个能力，既然都有，那么我们就可以将学习这个能力，抽象成接口来进行使用，只要是实现这个接口的类，都有学习的能力：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Study</span> &#123;    <span class="comment">//使用interface表示这是一个接口</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>;    <span class="comment">//接口中只能定义访问权限为public抽象方法，其中public和abstract关键字可以省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以让类实现这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Study</span> &#123;   <span class="comment">//使用implements关键字来实现接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age, sex, <span class="string">&quot;学生&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;    <span class="comment">//实现接口时，同样需要将接口中所有的抽象方法全部实现</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我会学习！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="title function_">Teacher</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age, sex, <span class="string">&quot;教师&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我会加倍学习！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口不同于继承，接口可以同时实现多个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Study</span>, A, B, C &#123;  <span class="comment">//多个接口的实现使用逗号隔开</span></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说有些人说接口其实就是Java中的多继承，但是我个人认为这种说法是错的，实际上实现接口更像是一个类的功能列表，作为附加功能存在，一个类可以附加很多个功能，接口的使用和继承的概念有一定的出入，顶多说是多继承的一种替代方案。</p><p>接口跟抽象类一样，不能直接创建对象，但是我们也可以将接口实现类的对象以接口的形式去使用：</p><p><img src="https://s2.loli.net/2022/09/21/VJfhzYKuF38tRq4.png" alt="image-20220921234735828"></p><p>当做接口使用时，只有接口中定义的方法和Object类的方法，无法使用类本身的方法和父类的方法。</p><p>接口同样支持向下转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Teacher</span>(<span class="string">&quot;小王&quot;</span>, <span class="number">27</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(study <span class="keyword">instanceof</span> Teacher) &#123;   <span class="comment">//直接判断引用的对象是不是Teacher类型</span></span><br><span class="line">        <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> (Teacher) study;   <span class="comment">//强制类型转换</span></span><br><span class="line">        teacher.study();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的使用其实跟之前的父类是差不多的。</p><p>从Java8开始，接口中可以存在方法的默认实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;   <span class="comment">//使用default关键字为接口中的方法添加默认实现</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我是默认实现&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果方法在接口中存在默认实现，那么实现类中不强制要求进行实现。</p><p>接口不同于类，接口中不允许存在成员变量和成员方法，但是可以存在静态变量和静态方法，在接口中定义的变量只能是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;   <span class="comment">//接口中定义的静态变量只能是public static final的</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;    <span class="comment">//接口中定义的静态方法也只能是public的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;我是静态方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟普通的类一样，我们可以直接通过接口名.的方式使用静态内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(Study.a);</span><br><span class="line">    Study.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口是可以继承自其他接口的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> exetnds B &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且接口没有继承数量限制，接口支持多继承：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">A</span> exetnds B, C, D &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口的继承相当于是对接口功能的融合罢了。</p><p>最后我们来介绍一下Object类中提供的克隆方法，为啥要留到这里才来讲呢？因为它需要实现接口才可以使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Cloneable</span> &#123;    <span class="comment">//这个接口中什么都没定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现接口后，我们还需要将克隆方法的可见性提升一下，不然还用不了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Study</span>, Cloneable &#123;   <span class="comment">//首先实现Cloneable接口，表示这个类具有克隆的功能</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String name, <span class="type">int</span> age, String sex)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, age, sex, <span class="string">&quot;学生&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;   <span class="comment">//提升clone方法的访问权限</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.clone();   <span class="comment">//因为底层是C++实现，我们直接调用父类的实现就可以了</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我会学习！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着我们来尝试一下，看看是不是会得到一个一模一样的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;  <span class="comment">//这里向上抛出一下异常，还没学异常，所以说照着写就行了</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">clone</span> <span class="operator">=</span> (Student) student.clone();   <span class="comment">//调用clone方法，得到一个克隆的对象</span></span><br><span class="line">    System.out.println(student);</span><br><span class="line">    System.out.println(clone);</span><br><span class="line">    System.out.println(student == clone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，原对象和克隆对象，是两个不同的对象，但是他们的各种属性都是完全一样的：</p><p><img src="https://s2.loli.net/2022/09/22/E3dNFYT5sWaS8Rx.png" alt="image-20220922110044636"></p><p>通过实现接口，我们就可以很轻松地完成对象的克隆了，在我们之后的学习中，还会经常遇到接口的使用。</p><p><strong>注意：</strong> 以下内容为选学内容，在设计模式篇视频教程中有详细介绍。</p><blockquote><p>克隆操作可以完全复制一个对象的所有属性，但是像这样的拷贝操作其实也分为浅拷贝和深拷贝。</p><ul><li><strong>浅拷贝：</strong> 对于类中基本数据类型，会直接复制值给拷贝对象；对于引用类型，只会复制对象的地址，而实际上指向的还是原来的那个对象，拷贝个基莫。</li><li><strong>深拷贝：</strong> 无论是基本类型还是引用类型，深拷贝会将引用类型的所有内容，全部拷贝为一个新的对象，包括对象内部的所有成员变量，也会进行拷贝。</li></ul><p>那么clone方法出来的克隆对象，是深拷贝的结果还是浅拷贝的结果呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    <span class="type">Student</span> <span class="variable">clone</span> <span class="operator">=</span> (Student) student.clone();</span><br><span class="line">    System.out.println(student.name == clone.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/22/gpM1iukyoSdn2RE.png" alt="image-20220922110750697"></p><p>可以看到，虽然Student对象成功拷贝，但是其内层对象并没有进行拷贝，依然只是对象引用的复制，所以Java为我们提供的<code>clone</code>方法只会进行浅拷贝。</p></blockquote><hr><h2 id="枚举类">枚举类</h2><p>假设现在我们想给小明添加一个状态（跑步、学习、睡觉），外部可以实时获取小明的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_">Person</span> <span class="keyword">implements</span> <span class="title class_">Study</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String status;   <span class="comment">//状态，可以是跑步、学习、睡觉这三个之中的其中一种</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getStatus</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(String status)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.status = status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样会出现一个问题，如果我们仅仅是存储字符串，似乎外部可以不按照我们规则，传入一些其他的字符串。这显然是不够严谨的，有没有一种办法，能够更好地去实现这样的状态标记呢？我们希望开发者拿到使用的就是我们预先定义好的状态，所以，我们可以使用枚举类来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;   <span class="comment">//enum表示这是一个枚举类，枚举类的语法稍微有一些不一样</span></span><br><span class="line">    RUNNING, STUDY, SLEEP;    <span class="comment">//直接写每个状态的名字即可，最后面分号可以不打，但是推荐打上</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举类也非常方便，就像使用普通类型那样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Status status;   <span class="comment">//类型变成刚刚定义的枚举类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Status <span class="title function_">getStatus</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setStatus</span><span class="params">(Status status)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.status = status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，别人在使用时，就能很清楚地知道我们支持哪些了：</p><p><img src="https://s2.loli.net/2022/09/22/6SDXckyIfFoCZWg.png" alt="image-20220922111426974"></p><p>枚举类型使用起来就非常方便了，其实枚举类型的本质就是一个普通的类，但是它继承自<code>Enum</code>类，我们定义的每一个状态其实就是一个<code>public static final</code>的Status类型成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里使用javap命令对class文件进行反编译得到 Compiled from &quot;Status.java&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">com</span>.test.Status <span class="keyword">extends</span> <span class="title class_">java</span>.lang.Enum&lt;com.test.Status&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.test.Status RUNNING;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.test.Status STUDY;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> com.test.Status SLEEP;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.test.Status[] values();</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> com.test.Status <span class="title function_">valueOf</span><span class="params">(java.lang.String)</span>;</span><br><span class="line">  <span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然枚举类型是普通的类，那么我们也可以给枚举类型添加独有的成员方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    RUNNING(<span class="string">&quot;睡觉&quot;</span>), STUDY(<span class="string">&quot;学习&quot;</span>), SLEEP(<span class="string">&quot;睡觉&quot;</span>);   <span class="comment">//无参构造方法被覆盖，创建枚举需要添加参数（本质就是调用的构造方法）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;    <span class="comment">//枚举的成员变量</span></span><br><span class="line">    Status(String name)&#123;    <span class="comment">//覆盖原有构造方法（默认private，只能内部使用！）</span></span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;   <span class="comment">//获取封装的成员变量</span></span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，枚举就可以按照我们想要的中文名称打印了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;小明&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line">    student.setStatus(Status.RUNNING);</span><br><span class="line">    System.out.println(student.getStatus().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基本类型包装类">基本类型包装类</h2><p>Java并不是纯面向对象的语言，虽然Java语言是一个面向对象的语言，但是Java中的基本数据类型却不是面向对象的。Java中的基本类型，如果想通过对象的形式去使用他们，Java提供的基本类型包装类，使得Java能够更好的体现面向对象的思想，同时也使得基本类型能够支持对象操作！</p><h3 id="包装类介绍">包装类介绍</h3><p>所有的包装类层次结构如下：</p><p><img src="https://s2.loli.net/2022/09/22/mulb5VdvBLiWNe2.png" alt="5c3a6a27-6370-4c60-9bbc-8039e11e752d"></p><p>其中能够表示数字的基本类型包装类，继承自Number类，对应关系如下表：</p><ul><li>byte  -&gt;  Byte</li><li>boolean  -&gt;  Boolean</li><li>short  -&gt;  Short</li><li>char  -&gt;  Character</li><li>int -&gt; Integer</li><li>long -&gt;  Long</li><li>float -&gt; Float</li><li>double -&gt; Double</li></ul><p>我们可以直接使用，这里我们以Integer类为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);    <span class="comment">//将10包装为一个Integer类型的变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包装类实际上就是将我们的基本数据类型，封装成一个类（运用了封装的思想）我们可以来看看Integer类中是怎么写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;  <span class="comment">//类中实际上就靠这个变量在存储包装的值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Integer</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包装类型支持自动装箱，我们可以直接将一个对应的基本类型值作为对应包装类型引用变量的值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="comment">//将int类型值作为包装类型使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是怎么做到的？为什么一个对象类型的值可以直接接收一个基本类类型的值？实际上这里就是自动装箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="number">10</span>);    <span class="comment">//上面的写法跟这里是等价的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里本质上就是被自动包装成了一个Integer类型的对象，只是语法上为了简单，就支持像这样编写。既然能装箱，也是支持拆箱的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上上面的写法本质上就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i.intValue();   <span class="comment">//通过此方法变成基本类型int值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是自动拆箱，得益于包装类型的自动装箱和拆箱机制，我们可以让包装类型轻松地参与到基本类型的运算中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a * b;    <span class="comment">//直接自动拆箱成基本类型参与到计算中</span></span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为包装类是一个类，不是基本类型，所以说两个不同的对象，那么是不相等的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(a == b);    <span class="comment">//虽然a和b的值相同，但是并不是同一个对象，所以说==判断为假</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么自动装箱的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>, b = <span class="number">10</span>;</span><br><span class="line">    System.out.println(a == b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，通过自动装箱转换的Integer对象，如果值相同，得到的会是同一个对象，这是因为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)   <span class="comment">//这里会有一个IntegerCache，如果在范围内，那么会直接返回已经提前创建好的对象</span></span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IntegerCache会默认缓存-128~127之间的所有值，将这些值提前做成包装类放在数组中存放，虽然我们目前还没有学习数组，但是各位小伙伴只需要知道，我们如果直接让 -128~127之间的值自动装箱为Integer类型的对象，那么始终都会得到同一个对象，这是为了提升效率，因为小的数使用频率非常高，有些时候并不需要创建那么多对象，创建对象越多，内存也会消耗更多。</p><p>但是如果超出这个缓存范围的话，就会得到不同的对象了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">128</span>, b = <span class="number">128</span>;</span><br><span class="line">    System.out.println(a == b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就不会得到同一个对象了，因为超出了缓存的范围。同样的，Long、Short、Byte类型的包装类也有类似的机制，感兴趣的小伙伴可以自己点进去看看。</p><p>我们来看看包装类中提供了哪些其他的方法，包装类支持字符串直接转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="string">&quot;666&quot;</span>);   <span class="comment">//直接将字符串的666，转换为数字666</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，字符串转Integer有多个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.valueOf(<span class="string">&quot;5555&quot;</span>);</span><br><span class="line">    <span class="comment">//Integer i = Integer.parseInt(&quot;5555&quot;);</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们甚至可以对十六进制和八进制的字符串进行解码，得到对应的int值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> Integer.decode(<span class="string">&quot;0xA6&quot;</span>);</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以将十进制的整数转换为其他进制的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(Integer.toHexString(<span class="number">166</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，Integer中提供的方法还有很多，这里就不一一列出了。</p><h3 id="特殊包装类">特殊包装类</h3><p>除了我们上面认识的这几种基本类型包装类之外，还有两个比较特殊的包装类型。</p><p>其中第一个是用于计算超大数字的BigInteger，我们知道，即使是最大的long类型，也只能表示64bit的数据，无法表示一个非常大的数，但是BigInteger没有这些限制，我们可以让他等于一个非常大的数字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> BigInteger.valueOf(Long.MAX_VALUE);    <span class="comment">//表示Long的最大值，轻轻松松</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过调用类中的方法，进行运算操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> BigInteger.valueOf(Long.MAX_VALUE);</span><br><span class="line">    i = i.multiply(BigInteger.valueOf(Long.MAX_VALUE));   <span class="comment">//即使是long的最大值乘以long的最大值，也能给你算出来</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看看结果：</p><p><img src="https://s2.loli.net/2022/09/22/FTPGhgnAEm1QKkV.png" alt="image-20220922211414392"></p><p>可以看到，此时数值已经非常大了，也可以轻松计算出来。咱们来点更刺激的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BigInteger</span> <span class="variable">i</span> <span class="operator">=</span> BigInteger.valueOf(Long.MAX_VALUE);</span><br><span class="line">    i = i.pow(<span class="number">100</span>);   <span class="comment">//long的最大值来个100次方吧</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个数字已经大到一排显示不下了：</p><p><img src="https://s2.loli.net/2022/09/22/w1OoFmbLiJ4rlcV.png" alt="image-20220922211651719"></p><p>一般情况，对于非常大的整数计算，我们就可以使用BigInteger来完成。</p><p>我们接着来看第二种，前面我们说了，浮点类型精度有限，对于需要精确计算的场景，就没办法了，而BigDecimal可以实现小数的精确计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">BigDecimal</span> <span class="variable">i</span> <span class="operator">=</span> BigDecimal.valueOf(<span class="number">10</span>);</span><br><span class="line">    i = i.divide(BigDecimal.valueOf(<span class="number">3</span>), <span class="number">100</span>, RoundingMode.CEILING);</span><br><span class="line">  <span class="comment">//计算10/3的结果，精确到小数点后100位</span></span><br><span class="line">  <span class="comment">//RoundingMode是舍入模式，就是精确到最后一位时，该怎么处理，这里CEILING表示向上取整</span></span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，确实可以精确到这种程度：</p><p><img src="https://s2.loli.net/2022/09/22/IUJ5rwzxonCBMT4.png" alt="image-20220922212222762"></p><p>但是注意，对于这种结果没有终点的，无限循环的小数，我们必须要限制长度，否则会出现异常。</p><hr><h2 id="数组">数组</h2><p>我们接着来看一个比较特殊的类型，数组。</p><p>假设出现一种情况，我们想记录100个数字，要是采用定义100个变量的方式可以吗？是不是有点太累了？这种情况我们就可以使用数组来存放一组相同类型的数据。</p><p><img src="https://s2.loli.net/2022/09/22/y4ISWZLrYE3Pdig.png" alt="image-20220922214604430"></p><h3 id="一维数组">一维数组</h3><p>数组是相同类型数据的有序集合，数组可以代表任何相同类型的一组内容（包括引用类型和基本类型）其中存放的每一个数据称为数组的一个元素，我们来看看如何去定义一个数组变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array;   <span class="comment">//类型[]就表示这个是一个数组类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，数组类型比较特殊，它本身也是类，但是编程不可见（底层C++写的，在运行时动态创建）即使是基本类型的数组，也是以对象的形式存在的，并不是基本数据类型。所以，我们要创建一个数组，同样需要使用<code>new </code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];   <span class="comment">//在创建数组时，需要指定数组长度，也就是可以容纳多个int变量的值</span></span><br><span class="line">  <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> array;   <span class="comment">//因为同样是类，肯定是继承自Object的，所以说可以直接向上转型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了上面这种方式之外，我们也可以使用其他方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">类型[] 变量名称 = <span class="keyword">new</span> 类型[数组大小];</span><br><span class="line">类型 变量名称[] = <span class="keyword">new</span> 类型[数组大小];  <span class="comment">//支持C语言样式，但不推荐！</span></span><br><span class="line"></span><br><span class="line">类型[] 变量名称 = <span class="keyword">new</span> 类型[]&#123;...&#125;;  <span class="comment">//静态初始化（直接指定值和大小）</span></span><br><span class="line">类型[] 变量名称 = &#123;...&#125;;   <span class="comment">//同上，但是只能在定义时赋值</span></span><br></pre></td></tr></table></figure><p>创建出来的数组每个位置上都有默认值，如果是引用类型，就是null，如果是基本数据类型，就是0，或者是false，跟对象成员变量的默认值是一样的，要访问数组的某一个元素，我们可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    System.out.println(<span class="string">&quot;数组的第一个元素为：&quot;</span>+array[<span class="number">0</span>]);  <span class="comment">//使用 变量名[下标] 的方式访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，数组的下标是从0开始的，不是从1开始的，所以说第一个元素的下标就是0，我们要访问第一个元素，那么直接输入0就行了，但是注意千万别写成负数或是超出范围了，否则会出现异常。</p><p>我们也可以使用这种方式为数组的元素赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    array[<span class="number">0</span>] = <span class="number">888</span>;   <span class="comment">//就像使用变量一样，是可以放在赋值运算符左边的，我们可以直接给对应下标位置的元素赋值</span></span><br><span class="line">    System.out.println(<span class="string">&quot;数组的第一个元素为：&quot;</span>+array[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为数组本身也是一个对象，数组对象也是具有属性的，比如长度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    System.out.println(<span class="string">&quot;当前数组长度为：&quot;</span>+array.length);   <span class="comment">//length属性是int类型的值，表示当前数组长度，长度是在一开始创建数组的时候就确定好的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这个<code>length</code>是在一开始就确定的，而且是<code>final</code>类型的，不允许进行修改，也就是说数组的长度一旦确定，不能随便进行修改，如果需要使用更大的数组，只能重新创建。</p><p>当然，既然是类型，那么肯定也是继承自Object类的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    System.out.println(array.toString());</span><br><span class="line">    System.out.println(array.equals(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，很遗憾，除了clone()之外，这些方法并没有被重写，也就是说依然是采用的Object中的默认实现：</p><p><img src="https://s2.loli.net/2022/09/22/UfTGu9sZheW21jB.png" alt="image-20220922220403391"></p><p>所以说通过<code>toString()</code>打印出来的结果，好丑，只不过我们可以发现，数组类型的类名很奇怪，是<code>[</code>开头的。</p><p>因此，如果我们要打印整个数组中所有的元素，得一个一个访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        System.out.print(array[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时候为了方便，我们可以使用简化版的for语句<code>foreach</code>语法来遍历数组中的每一个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i : array) &#123;    <span class="comment">//int i就是每一个数组中的元素，array就是我们要遍历的数组</span></span><br><span class="line">        System.out.print(i+<span class="string">&quot; &quot;</span>);   <span class="comment">//每一轮循环，i都会更新成数组中下一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是感觉这种写法更加简洁？只不过这仅仅是语法糖而已，编译之后依然是跟上面一样老老实实在遍历的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;   <span class="comment">//反编译的结果</span></span><br><span class="line">    <span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span>[] var2 = array;</span><br><span class="line">    <span class="type">int</span> <span class="variable">var3</span> <span class="operator">=</span> array.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="number">0</span>; var4 &lt; var3; ++var4) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> var2[var4];</span><br><span class="line">        System.out.print(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于这种普通的数组，其实使用还是挺简单的。这里需要特别说一下，对于基本类型的数组来说，是不支持自动装箱和拆箱的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    Integer[] test = arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有，由于基本数据类型和引用类型不同，所以说int类型的数组时不能被Object类型的数组变量接收的：</p><p><img src="https://s2.loli.net/2022/09/24/XbfZ9YHkqjv7613.png" alt="image-20220924114859252"></p><p>但是如果是引用类型的话，是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">10</span>];</span><br><span class="line">    Object[] array = arr;    <span class="comment">//数组同样支持向上转型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Object[] arr = <span class="keyword">new</span> <span class="title class_">Object</span>[<span class="number">10</span>];</span><br><span class="line">    String[] array = (String[]) arr;   <span class="comment">//也支持向下转型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多维数组">多维数组</h3><p>前面我们介绍了简单的数组（一维数组）既然数组可以是任何类型的，那么我们能否创建数组类型的数组呢？答案是可以的，套娃嘛，谁不会：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">10</span>];    <span class="comment">//数组类型数组那么就要写两个[]了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存放数组的数组，相当于将维度进行了提升，比如上面的就是一个2x10的数组：</p><p><img src="https://s2.loli.net/2022/09/22/kRcO1aGY6fMBiu9.png" alt="image-20220922221557130"></p><p>这个中数组一共有2个元素，每个元素都是一个存放10个元素的数组，所以说最后看起来就像一个矩阵一样。甚至可以继续套娃，将其变成一个三维数组，也就是存放数组的数组的数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] arr = &#123; &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                    &#123;<span class="number">5</span>, <span class="number">6</span>&#125;&#125;;   <span class="comment">//一个三行两列的数组</span></span><br><span class="line">    System.out.println(arr[<span class="number">2</span>][<span class="number">1</span>]);   <span class="comment">//访问第三行第二列的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在访问多维数组时，我们需要使用多次<code>[]</code>运算符来得到对应位置的元素。如果我们要遍历多维数组话，那么就需要多次嵌套循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>, <span class="number">6</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;    <span class="comment">//要遍历一个二维数组，那么我们得一列一列一行一行地来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">            System.out.println(arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可变长参数">可变长参数</h3><p>我们接着来看数组的延伸应用，实际上我们的方法是支持可变长参数的，什么是可变长参数？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    String sex;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String... strings)</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在使用时，可以传入0 - N个对应类型的实参：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">    person.test(<span class="string">&quot;1！&quot;</span>, <span class="string">&quot;5！&quot;</span>, <span class="string">&quot;哥们在这跟你说唱&quot;</span>); <span class="comment">//这里我们可以自由传入任意数量的字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么我们在方法中怎么才能得到这些传入的参数呢，实际上可变长参数本质就是一个数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String... strings)</span>&#123;   <span class="comment">//strings这个变量就是一个String[]类型的</span></span><br><span class="line">    <span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">        System.out.println(string);   <span class="comment">//遍历打印数组中每一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果同时存在其他参数，那么可变长参数只能放在最后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, String... strings)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里最后我们再来说一个从开始到现在一直都没有说的东西：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;   <span class="comment">//这个String[] args到底是个啥？？？</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上这个是我们在执行Java程序时，输入的命令行参数，我们可以来打印一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">        System.out.println(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，默认情况下直接运行什么都没有，但是如果我们在运行时，添加点内容的话：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java com/test/Main lbwnb aaaa xxxxx   <span class="comment">#放在包中需要携带主类完整路径才能运行</span></span><br></pre></td></tr></table></figure><p>可以看到，我们在后面随意添加的三个参数，都放到数组中了：</p><p><img src="https://s2.loli.net/2022/09/22/DL3WTMdRwrSYJIl.png" alt="image-20220922223152648"></p><p>这个东西我们作为新手一般也不会用到，只做了解就行了。</p><hr><h2 id="字符串">字符串</h2><p>字符串类是一个比较特殊的类，它用于保存字符串。我们知道，基本类型<code>char</code>可以保存一个2字节的Unicode字符，而字符串则是一系列字符的序列（在C中就是一个字符数组）Java中没有字符串这种基本类型，因此只能使用类来进行定义。注意，字符串中的字符一旦确定，无法进行修改，只能重新创建。</p><h3 id="String类">String类</h3><p>String本身也是一个类，只不过它比较特殊，每个用双引号括起来的字符串，都是String类型的一个实例对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以象征性地使用一下new关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World!&quot;</span>);  <span class="comment">//这种方式就是创建一个新的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果是直接使用双引号创建的字符串，如果内容相同，为了优化效率，那么始终都是同一个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    System.out.println(str1 == str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果我们使用构造方法主动创建两个新的对象，那么就是不同的对象了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    System.out.println(str1 == str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于为什么会出现这种情况，我们在JVM篇视频教程中会进行详细的介绍，这里各位小伙伴只需要记住就行了。因此，如果我们仅仅是想要判断两个字符串的内容是否相同，不要使用<code>==</code>，String类重载了<code>equals</code>方法用于判断和比较内容是否相同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    System.out.println(str1.equals(str2));   <span class="comment">//字符串的内容比较，一定要用equals</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然String也是一个类，那么肯定是具有一些方法的，我们可以来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    System.out.println(str.length());   <span class="comment">//length方法可以求字符串长度，这个长度是字符的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为双引号括起来的字符串本身就是一个实例对象，所以说我们也可以直接用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello World&quot;</span>.length());   <span class="comment">//虽然看起来挺奇怪的，但是确实支持这种写法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串类中提供了很多方便我们操作的方法，比如字符串的裁剪、分割操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> str.substring(<span class="number">0</span>, <span class="number">3</span>);   <span class="comment">//分割字符串，并返回一个新的子串对象</span></span><br><span class="line">    System.out.println(sub);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    String[] strings = str.split(<span class="string">&quot; &quot;</span>);   <span class="comment">//使用split方法进行字符串分割，比如这里就是通过空格分隔，得到一个字符串数组</span></span><br><span class="line">    <span class="keyword">for</span> (String string : strings) &#123;</span><br><span class="line">        System.out.println(string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符数组和字符串之间是可以快速进行相互转换的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">    System.out.println(chars);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">char</span>[] chars = <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;奥&#x27;</span>, <span class="string">&#x27;利&#x27;</span>, <span class="string">&#x27;给&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，String类还有很多其他的一些方法，这里就不一一介绍了。</p><h3 id="StringBuilder类">StringBuilder类</h3><p>我们在之前的学习中已经了解，字符串支持使用<code>+</code>和<code>+=</code>进行拼接操作。</p><p>但是拼接字符串实际上底层需要进行很多操作，如果程序中大量进行字符串的拼接似乎不太好，编译器是很聪明的，String的拼接会在编译时进行各种优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;杰哥&quot;</span> + <span class="string">&quot;你干嘛&quot;</span>;    <span class="comment">//我们在写代码时使用的是拼接的形式</span></span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译之后就变成这样了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;杰哥你干嘛&quot;</span>;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于变量来说，也有优化，比如下面这种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;你看&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;这&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;汉堡&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;做滴&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;行不行&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> str1 + str2 + str3 + str4 + str5;   <span class="comment">//5个变量连续加</span></span><br><span class="line">    System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果直接使用加的话，每次运算都会生成一个新的对象，这里进行4次加法运算，那么中间就需要产生4个字符串对象出来，是不是有点太浪费了？这种情况实际上会被优化为下面的写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;你看&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;这&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;汉堡&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="string">&quot;做滴&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str5</span> <span class="operator">=</span> <span class="string">&quot;行不行&quot;</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    builder.append(str1).append(str2).append(str3).append(str4).append(str5);</span><br><span class="line">    System.out.println(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里创建了一个StringBuilder的类型，这个类型是干嘛的呢？实际上它就是专门用于构造字符串的，我们可以使用它来对字符串进行拼接、裁剪等操作，它就像一个字符串编辑器，弥补了字符串不能修改的不足：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();   <span class="comment">//一开始创建时，内部什么都没有</span></span><br><span class="line">    builder.append(<span class="string">&quot;AAA&quot;</span>);   <span class="comment">//我们可以使用append方法来讲字符串拼接到后面</span></span><br><span class="line">    builder.append(<span class="string">&quot;BBB&quot;</span>);</span><br><span class="line">    System.out.println(builder.toString());   <span class="comment">//当我们字符串编辑完成之后，就可以使用toString转换为字符串了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它还支持裁剪等操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;AAABBB&quot;</span>);   <span class="comment">//在构造时也可以指定初始字符串</span></span><br><span class="line">    builder.delete(<span class="number">2</span>, <span class="number">4</span>);   <span class="comment">//删除2到4这个范围内的字符</span></span><br><span class="line">    System.out.println(builder.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，StringBuilder类的编辑操作也非常多，这里就不一一列出了。</p><h3 id="正则表达式">正则表达式</h3><p>我们现在想要实现这样一个功能，对于给定的字符串进行判断，如果字符串符合我们的规则，那么就返回真，否则返回假，比如现在我们想要判断字符串是不是邮箱的格式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;aaaa731341@163.com&quot;</span>;</span><br><span class="line">  <span class="comment">//假设邮箱格式为 数字/字母@数字/字母.com</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么现在请你设计一个Java程序用于判断，你该怎么做？是不是感觉很麻烦，但是我们使用正则表达式就可以很轻松解决这种字符串格式匹配问题。</p><blockquote><p>正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。</p></blockquote><p>我们先来看看下面的这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;oooo&quot;</span>;</span><br><span class="line">  <span class="comment">//matches方法用于对给定正则表达式进行匹配，匹配成功返回true，否则返回false</span></span><br><span class="line">    System.out.println(str.matches(<span class="string">&quot;o+&quot;</span>));   <span class="comment">//+表示对前面这个字符匹配一次或多次，这里字符串是oooo，正好可以匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用于规定给定组件必须要出现多少次才能满足匹配的，我们一般称为限定符，限定符表如下：</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">匹配前面的子表达式零次或多次。例如，<strong>zo*</strong> 能匹配 <strong>“z”</strong> 以及 <strong>“zoo”</strong>。***** 等价于 <strong>{0,}</strong>。</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">匹配前面的子表达式一次或多次。例如，<strong>zo+</strong> 能匹配 <strong>“zo”</strong> 以及 &quot;<strong>zoo&quot;</strong>，但不能匹配 <strong>“z”</strong>。<strong>+</strong> 等价于 <strong>{1,}</strong>。</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">匹配前面的子表达式零次或一次。例如，<strong>do(es)?</strong> 可以匹配 <strong>“do”</strong> 、 <strong>“does”</strong>、 <strong>“doxy”</strong> 中的 <strong>“do”</strong> 。<strong>?</strong> 等价于 <strong>{0,1}</strong>。</td></tr><tr><td style="text-align:center">{n}</td><td style="text-align:center">n 是一个非负整数。匹配确定的 <strong>n</strong> 次。例如，<strong>o{2}</strong> 不能匹配 <strong>“Bob”</strong> 中的 <strong>o</strong>，但是能匹配 <strong>“food”</strong> 中的两个 <strong>o</strong>。</td></tr><tr><td style="text-align:center">{n,}</td><td style="text-align:center">n 是一个非负整数。至少匹配n 次。例如，<strong>o{2,}</strong> 不能匹配 <strong>“Bob”</strong> 中的 <strong>o</strong>，但能匹配 <strong>“foooood”</strong> 中的所有 <strong>o</strong>。<strong>o{1,}</strong> 等价于 <strong>o+</strong>。<strong>o{0,}</strong> 则等价于 <strong>o*</strong>。</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:center">m 和 n 均为非负整数，其中 n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，<strong>o{1,3}</strong> 将匹配 <strong>“fooooood”</strong> 中的前三个 <strong>o</strong>。<strong>o{0,1}</strong> 等价于 <strong>o?</strong>。请注意在逗号和两个数之间不能有空格。</td></tr></tbody></table><p>如果我们想要表示一个范围内的字符，可以使用方括号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abcabccaa&quot;</span>;</span><br><span class="line">    System.out.println(str.matches(<span class="string">&quot;[abc]*&quot;</span>));   <span class="comment">//表示abc这几个字符可以出现 0 - N 次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于普通字符来说，我们可以下面的方式实现多种字符匹配：</p><table><thead><tr><th style="text-align:center">字符</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><strong>[ABC]</strong></td><td style="text-align:center">匹配 <strong>[…]</strong> 中的所有字符，例如 <strong>[aeiou]</strong> 匹配字符串 “google runoob taobao” 中所有的 e o u a 字母。</td></tr><tr><td style="text-align:center"><strong>[^ABC]</strong></td><td style="text-align:center">匹配除了 <strong>[…]</strong> 中字符的所有字符，例如 <strong>[^aeiou]</strong> 匹配字符串 “google runoob taobao” 中除了 e o u a 字母的所有字母。</td></tr><tr><td style="text-align:center"><strong>[A-Z]</strong></td><td style="text-align:center">[A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。</td></tr><tr><td style="text-align:center"><strong>.</strong></td><td style="text-align:center">匹配除换行符（\n、\r）之外的任何单个字符，相等于 [^\n\r]</td></tr><tr><td style="text-align:center"><strong>[\s\S]</strong></td><td style="text-align:center">匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。</td></tr><tr><td style="text-align:center"><strong>\w</strong></td><td style="text-align:center">匹配字母、数字、下划线。等价于 [A-Za-z0-9_]</td></tr></tbody></table><p>当然，这里仅仅是对正则表达式的简单使用，实际上正则表达式内容非常多，如果需要完整学习正则表达式，可以到：<a href="https://www.runoob.com/regexp/regexp-syntax.html">https://www.runoob.com/regexp/regexp-syntax.html</a></p><p>正则表达式并不是只有Java才支持，其他很多语言比如JavaScript、Python等等都是支持正则表达式的。</p><hr><h2 id="内部类">内部类</h2><p>上一章我们详细介绍了类，我们现在已经知道该如何创建类、使用类了。当然，类的创建其实可以有多种多样的方式，并不仅仅局限于普通的创建。内部类顾名思义，就是创建在内部的类，那么具体是什么的内部呢，我们接着就来讨论一下。</p><p>**注意：**内部类很多地方都很绕，所以说一定要仔细思考。</p><h3 id="成员内部类">成员内部类</h3><p>我们可以直接在类的内部定义成员内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;   <span class="comment">//内部类也是类，所以说里面也可以有成员变量、方法等，甚至还可以继续套娃一个成员内部类</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是成员内部类！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员内部类和成员方法、成员变量一样，是对象所有的，而不是类所有的，如果我们要使用成员内部类，那么就需要：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();   <span class="comment">//我们首先需要创建对象</span></span><br><span class="line">    Test.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> test.<span class="keyword">new</span> <span class="title class_">Inner</span>();   <span class="comment">//成员内部类的类型名称就是 外层.内部类名称</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然看着很奇怪，但是确实是这样使用的。我们同样可以使用成员内部类中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();</span><br><span class="line">    Test.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> test.<span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">    inner.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，成员内部类也可以使用访问权限控制，如果我们我们将其权限改为<code>private</code>，那么就像我们把成员变量访问权限变成私有一样，外部是无法访问到这个内部类的：</p><p><img src="https://s2.loli.net/2022/09/24/HklipN4uOfK9JrG.png" alt="image-20220924122217070"></p><p>可以看到这里直接不认识了。</p><p>这里我们需要特别注意一下，在成员内部类中，是可以访问到外层的变量的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是成员内部类：&quot;</span>+name);</span><br><span class="line">         <span class="comment">//成员内部类可以访问到外部的成员变量</span></span><br><span class="line">          <span class="comment">//因为成员内部类本身就是某个对象所有的，每个对象都有这样的一个类定义，这里的name是其所依附对象的</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/24/aQPow8piljRCs2d.png" alt="image-20220924123600217"></p><p>每个类可以创建一个对象，每个对象中都有一个单独的类定义，可以通过这个成员内部类又创建出更多对象，套娃了属于是。</p><p>所以说我们在使用时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Test</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>(<span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    Test.<span class="type">Inner</span> <span class="variable">inner1</span> <span class="operator">=</span> a.<span class="keyword">new</span> <span class="title class_">Inner</span>();   <span class="comment">//依附于a创建的对象，那么就是a的</span></span><br><span class="line">    inner1.test();</span><br><span class="line"></span><br><span class="line">    <span class="type">Test</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>(<span class="string">&quot;小红&quot;</span>);</span><br><span class="line">    Test.<span class="type">Inner</span> <span class="variable">inner2</span> <span class="operator">=</span> b.<span class="keyword">new</span> <span class="title class_">Inner</span>();  <span class="comment">//依附于b创建的对象，那么就是b的</span></span><br><span class="line">    inner2.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那现在问大家一个问题，外部能访问内部类里面的成员变量吗？</p><p>那么如果内部类中也定义了同名的变量，此时我们怎么去明确要使用的是哪一个呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line"></span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;方法参数的name = &quot;</span>+name);    <span class="comment">//依然是就近原则，最近的是参数，那就是参数了</span></span><br><span class="line">            System.out.println(<span class="string">&quot;成员内部类的name = &quot;</span>+<span class="built_in">this</span>.name);   <span class="comment">//在内部类中使用this关键字，只能表示内部类对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;成员内部类的name = &quot;</span>+Test.<span class="built_in">this</span>.name);</span><br><span class="line">          <span class="comment">//如果需要指定为外部的对象，那么需要在前面添加外部类型名称</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>包括对方法的调用和super关键字的使用，也是一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.toString();<span class="comment">//内部类自己的toString方法</span></span><br><span class="line">        <span class="built_in">super</span>.toString();    <span class="comment">//内部类父类的toString方法</span></span><br><span class="line">        Test.<span class="built_in">this</span>.toString();   <span class="comment">//外部类的toSrting方法</span></span><br><span class="line">        Test.<span class="built_in">super</span>.toString();  <span class="comment">//外部类父类的toString方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以说成员内部类其实在某些情况下使用起来比较麻烦，对于这种成员内部类，我们一般只会在类的内部自己使用。</p><h3 id="静态内部类">静态内部类</h3><p>前面我们介绍了成员内部类，它就像成员变量和成员方法一样，是属于对象的，同样的，静态内部类就像静态方法和静态变量一样，是属于类的，我们可以直接创建使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是静态内部类！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要依附任何对象，我们可以直接创建静态内部类的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Test.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>.Inner();   <span class="comment">//静态内部类的类名同样是之前的格式，但是可以直接new了</span></span><br><span class="line">  inner.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类由于是静态的，所以相对外部来说，整个内部类中都处于静态上下文（注意只是相当于外部来说）是无法访问到外部类的非静态内容的：</p><p><img src="https://s2.loli.net/2022/09/24/cZapwgeATlG2FHn.png" alt="image-20220924124919135"></p><p>只不过受影响的只是外部内容的使用，内部倒是不受影响，还是跟普通的类一样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line"></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是静态内部类：&quot;</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实也很容易想通，因为静态内部类是属于外部类的，不依附任何对象，那么我要是直接访问外部类的非静态属性，那到底访问哪个对象的呢？这样肯定是说不通的。</p><h3 id="局部内部类">局部内部类</h3><p>局部内部类就像局部变量一样，可以在方法中定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Test</span><span class="params">(String name)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;    <span class="comment">//直接在方法中创建局部内部类</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是在方法中声明的类，那作用范围也就只能在方法中了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;   <span class="comment">//局部内部类跟局部变量一样，先声明后使用</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;我是局部内部类&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Inner</span>();   <span class="comment">//局部内部类直接使用类名就行</span></span><br><span class="line">        inner.test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过这种局部内部类的形式，使用频率很低，基本上不会用到，所以说了解就行了。</p><h3 id="匿名内部类">匿名内部类</h3><p>匿名内部类是我们使用频率非常高的一种内部类，它是局部内部类的简化版。</p><p>还记得我们在之前学习的抽象类和接口吗？在抽象类和接口中都会含有某些抽象方法需要子类去实现，我们当时已经很明确地说了不能直接通过new的方式去创建一个抽象类或是接口对象，但是我们可以使用匿名内部类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常情况下，要创建一个抽象类的实例对象，只能对其进行继承，先实现未实现的方法，然后创建子类对象。</p><p>而我们可以在方法中使用匿名内部类，将其中的抽象方法实现，并直接创建实例对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>() &#123;   <span class="comment">//在new的时候，后面加上花括号，把未实现的方法实现了</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是匿名内部类的实现!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    student.test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时这里创建出来的Student对象，就是一个已经实现了抽象方法的对象，这个抽象类直接就定义好了，甚至连名字都没有，就可以直接就创出对象。</p><p>匿名内部类中同样可以使用类中的属性（因为它本质上就相当于是对应类型的子类）所以说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>() &#123;</span><br><span class="line">    <span class="type">int</span> a;   <span class="comment">//因为本质上就相当于是子类，所以说子类定义一些子类的属性完全没问题</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(name + <span class="string">&quot;我是匿名内部类的实现!&quot;</span>);   <span class="comment">//直接使用父类中的name变量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样的，接口也可以通过这种匿名内部类的形式，直接创建一个匿名的接口实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Study</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">study</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;我是学习方法！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    study.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，并不是说只有抽象类和接口才可以像这样创建匿名内部类，普通的类也可以，只不过意义不大，一般情况下只是为了进行一些额外的初始化工作而已。</p><h3 id="Lambda表达式">Lambda表达式</h3><p>前面我们介绍了匿名内部类，我们可以通过这种方式创建一个临时的实现子类。</p><p>特别的，<strong>如果一个接口中有且只有一个待实现的抽象方法</strong>，那么我们可以将匿名内部类简写为Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> () -&gt; System.out.println(<span class="string">&quot;我是学习方法！&quot;</span>);   <span class="comment">//是不是感觉非常简洁！</span></span><br><span class="line">  study.study();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初学阶段，为了简化学习，各位小伙伴就认为Lambda表达式就是匿名内部类的简写就行了（Lambda表达式的底层其实并不只是简简单单的语法糖替换，感兴趣的可以在新特性篇视频教程中了解）</p><p>那么它是一个怎么样的简写规则呢？我们来看一下Lambda表达式的具体规范：</p><ul><li>标准格式为：<code>([参数类型 参数名称,]...) ‐&gt; &#123; 代码语句，包括返回值 &#125;</code></li><li>和匿名内部类不同，Lambda仅支持接口，不支持抽象类</li><li>接口内部必须有且仅有一个抽象方法（可以有多个方法，但是必须保证其他方法有默认实现，必须留一个抽象方法出来）</li></ul><p>比如我们之前写的Study接口，只要求实现一个无参无返回值的方法，所以说直接就是最简单的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">&quot;我是学习方法！&quot;</span>);   <span class="comment">//跟之前流程控制一样，如果只有一行代码花括号可省略</span></span><br></pre></td></tr></table></figure><p>当然，如果有一个参数和返回值的话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> (a) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是学习方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;今天学会了&quot;</span>+a;    <span class="comment">//实际上这里面就是方法体，该咋写咋写</span></span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(study.study(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果方法体中只有一个返回语句，可以直接省去花括号和<code>return</code>关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> (a) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;今天学会了&quot;</span>+a;   <span class="comment">//这种情况是可以简化的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> (a) -&gt; <span class="string">&quot;今天学会了&quot;</span>+a;</span><br></pre></td></tr></table></figure><p>如果参数只有一个，那么可以省去小括号：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> a -&gt; <span class="string">&quot;今天学会了&quot;</span>+a;</span><br></pre></td></tr></table></figure><p>是不是感觉特别简洁，实际上我们程序员追求的就是写出简洁高效的代码，而Java也在朝这个方向一直努力，近年来从Java 9开始出现的一些新语法基本都是各种各样的简写版本。</p><p>如果一个方法的参数需要的是一个接口的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test(a -&gt; <span class="string">&quot;今天学会了&quot;</span>+a);   <span class="comment">//参数直接写成lambda表达式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(Study study)</span>&#123;</span><br><span class="line">    study.study(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，这还只是一部分，对于已经实现的方法，如果我们想直接作为接口抽象方法的实现，我们还可以使用方法引用。</p><h3 id="方法引用">方法引用</h3><p>方法引用就是将一个已实现的方法，直接作为接口中抽象方法的实现（当然前提是方法定义得一样才行）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;   <span class="comment">//待实现的求和方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么使用时候，可以直接使用Lambda表达式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> (a, b) -&gt; a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过还能更简单，因为Integer类中默认提供了求两个int值之和的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer类中就已经有对应的实现了</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，我们可以直接将已有方法的实现作为接口的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> (a, b) -&gt; Integer.sum(a, b);   <span class="comment">//直接使用Integer为我们通过好的求和方法</span></span><br><span class="line">    System.out.println(study.sum(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，Integer.sum的参数和返回值，跟我们在Study中定义的完全一样，所以说我们可以直接使用方法引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> Integer::sum;    <span class="comment">//使用双冒号来进行方法引用，静态方法使用 类名::方法名 的形式</span></span><br><span class="line">    System.out.println(study.sum(<span class="number">10</span>, <span class="number">20</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法引用其实本质上就相当于将其他方法的实现，直接作为接口中抽象方法的实现。任何方法都可以通过方法引用作为实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Study</span> &#123;</span><br><span class="line">    String <span class="title function_">study</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是普通从成员方法，我们同样需要使用对象来进行方法引用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Main</span>();</span><br><span class="line">    <span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> main::lbwnb;   <span class="comment">//成员方法因为需要具体对象使用，所以说只能使用 对象::方法名 的形式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">lbwnb</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;卡布奇诺今犹在，不见当年倒茶人。&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为现在只需要一个String类型的返回值，由于String的构造方法在创建对象时也会得到一个String类型的结果，所以说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Study</span> <span class="variable">study</span> <span class="operator">=</span> String::<span class="keyword">new</span>;    <span class="comment">//没错，构造方法也可以被引用，使用new表示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反正只要是符合接口中方法的定义的，都可以直接进行方法引用，对于Lambda表达式和方法引用，在Java新特性介绍篇视频教程中还有详细的讲解，这里就不多说了。</p><hr><h2 id="异常机制">异常机制</h2><p>在理想的情况下，我们的程序会按照我们的思路去运行，按理说是不会出现问题的，但是，代码实际编写后并不一定是完美的，可能会有我们没有考虑到的情况，如果这些情况能够正常得到一个错误的结果还好，但是如果直接导致程序运行出现问题了呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test(<span class="number">1</span>, <span class="number">0</span>);   <span class="comment">//当b为0的时候，还能正常运行吗？</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a/b;   <span class="comment">//没有任何的判断而是直接做计算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时我们可以看到，出现了运算异常：</p><p><img src="https://s2.loli.net/2022/09/24/5PxTJv7M2YFzfg4.png" alt="image-20220924164357033"></p><p>那么这个异常到底是什么样的一种存在呢？当程序运行出现我们没有考虑到的情况时，就有可能出现异常或是错误！</p><h3 id="异常的类型">异常的类型</h3><p>我们在之前其实已经接触过一些异常了，比如数组越界异常，空指针异常，算术异常等，他们其实都是异常类型，我们的每一个异常也是一个类，他们都继承自<code>Exception</code>类！异常类型本质依然类的对象，但是异常类型支持在程序运行出现问题时抛出（也就是上面出现的红色报错）也可以提前声明，告知使用者需要处理可能会出现的异常！</p><p>异常的第一种类型是运行时异常，如上述的列子，在编译阶段无法感知代码是否会出现问题，只有在运行的时候才知道会不会出错（正常情况下是不会出错的），这样的异常称为运行时异常，异常也是由类定义的，所有的运行时异常都继承自<code>RuntimeException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    object.toString();   <span class="comment">//这种情况就会出现运行时异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/24/cTAqbZ93HidRIGW.png" alt="image-20220924164637887"></p><p>又比如下面的这种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">Main</span> <span class="variable">main</span> <span class="operator">=</span> (Main) object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/24/QxMimbjZk19C25d.png" alt="image-20220924164844005"></p><p>异常的另一种类型是编译时异常，编译时异常明确指出可能会出现的异常，在编译阶段就需要进行处理（捕获异常）必须要考虑到出现异常的情况，如果不进行处理，将无法通过编译！默认继承自<code>Exception</code>类的异常都是编译时异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title function_">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException;</span><br></pre></td></tr></table></figure><p>比如Object类中定义的<code>clone</code>方法，就明确指出了在运行的时候会出现的异常。</p><p>还有一种类型是错误，错误比异常更严重，异常就是不同寻常，但不一定会导致致命的问题，而错误是致命问题，一般出现错误可能JVM就无法继续正常运行了，比如<code>OutOfMemoryError</code>就是内存溢出错误（内存占用已经超出限制，无法继续申请内存了）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如这样的一个无限递归的方法，会导致运行过程中无限制地向下调用方法，导致栈溢出：</p><p><img src="https://s2.loli.net/2022/09/24/9YEZV2L73ROQTuA.png" alt="image-20220924165500108"></p><p>这种情况就是错误了，已经严重到整个程序都无法正常运行了。又比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Object[] objects = <span class="keyword">new</span> <span class="title class_">Object</span>[Integer.MAX_VALUE];   <span class="comment">//这里申请一个超级大数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上我们电脑的内存是有限的，不可能无限制地使用内存来存放变量，所以说如果内存不够用了，会直接：</p><p><img src="https://s2.loli.net/2022/09/24/qj8zJnGxdS5IybX.png" alt="image-20220924165657392"></p><p>此时没有更多的可用内存供我们的程序使用，那么程序也就没办法继续运行下去了，这同样是一个很严重的错误。</p><p>当然，我们这一块主要讨论的目录依然是异常。</p><h3 id="自定义异常">自定义异常</h3><p>异常其实就两大类，一个是编译时异常，一个是运行时异常，我们先来看编译时异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);   <span class="comment">//这里我们选择使用父类的带参构造，这个参数就是异常的原因</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译时异常只需要继承Exception就行了，编译时异常的子类有很多很多，仅仅是SE中就有700多个。</p><p><img src="https://s2.loli.net/2022/09/24/TzUu5Sk6NycB9An.png" alt="image-20220924202450589"></p><p>异常多种多样，不同的异常对应着不同的情况，比如在类型转换时出错那么就是类型转换异常，如果是使用一个值为null的变量调用方法，那么就会出现空指针异常。</p><p>运行时异常只需要继承RuntimeException就行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestException</span> <span class="keyword">extends</span> <span class="title class_">RuntimeException</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TestException</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        <span class="built_in">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RuntimeException继承自Exception，Exception继承自Throwable：</p><p><img src="https://s2.loli.net/2022/09/24/RjzWnNDc6TZeSoJ.png" alt="image-20220924203130042"></p><p>运行时异常同同样也有很多，只不过运行时异常和编译型异常在使用时有一些不同，我们会在后面的学习中慢慢认识。</p><p>当然还有一种类型是Error，它是所有错误的父类，同样是继承自Throwable的。</p><h3 id="抛出异常">抛出异常</h3><p>当别人调用我们的方法时，如果传入了错误的参数导致程序无法正常运行，这时我们就可以手动抛出一个异常来终止程序继续运行下去，同时告知上一级方法执行出现了问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;被除数不能为0&quot;</span>);  <span class="comment">//使用throw关键字来抛出异常</span></span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>异常的抛出同样需要创建一个异常对象出来，我们抛出异常实际上就是将这个异常对象抛出，异常对象携带了我们抛出异常时的一些信息，比如是因为什么原因导致的异常，在RuntimeException的构造方法中我们可以写入原因。</p><p>当出现异常时：</p><p><img src="https://s2.loli.net/2022/09/24/Ttr4kZSyodKi3M8.png" alt="image-20220924200817314"></p><p>程序会终止，并且会打印栈追踪信息，因为各位小伙伴才初学，还不知道什么是栈，我们这里就简单介绍一下，实际上方法之间的调用是有层级关系的，而当异常发生时，方法调用的每一层都会在栈追踪信息中打印出来，比如这里有两个<code>at</code>，实际上就是在告诉我们程序运行到哪个位置时出现的异常，位于最上面的就是发生异常的最核心位置，我们代码的第15行。</p><p>并且这里会打印出当前抛出的异常类型和我们刚刚自定义异常信息。</p><p>注意，如果我们在方法中抛出了一个非运行时异常，那么必须告知函数的调用方我们会抛出某个异常，函数调用方必须要对抛出的这个异常进行对应的处理才可以：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;    <span class="comment">//使用throws关键字告知调用方此方法会抛出哪些异常，请调用方处理好</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Exception</span>(<span class="string">&quot;我是编译时异常！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果不同的分支条件会出现不同的异常，那么所有在方法中可能会抛出的异常都需要注明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">throws</span> FileNotFoundException, ClassNotFoundException &#123;  <span class="comment">//多个异常使用逗号隔开</span></span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FileNotFoundException</span>();</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，并不是只有非运行时异常可以像这样明确指出，运行时异常也可以，只不过不强制要求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至于如何处理明确抛出的异常，我们会下一个部分中进行讲解。</p><p>最后再提一下，我们在重写方法时，如果父类中的方法表明了会抛出某个异常，只要重写的内容中不会抛出对应的异常我们可以直接省去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">clone</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="异常的处理">异常的处理</h3><p>当程序没有按照我们理想的样子运行而出现异常时（默认会交给JVM来处理，JVM发现任何异常都会立即终止程序运行，并在控制台打印栈追踪信息）现在我们希望能够自己处理出现的问题，让程序继续运行下去，就需要对异常进行捕获，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;    <span class="comment">//使用try-catch语句进行异常捕获</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        object.toString();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e)&#123;   <span class="comment">//因为异常本身也是一个对象，catch中实际上就是用一个局部变量去接收异常</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序继续正常运行！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以将代码编写到<code>try</code>语句块中，只要是在这个范围内发生的异常，都可以被捕获，使用<code>catch</code>关键字对指定的异常进行捕获，这里我们捕获的是NullPointerException空指针异常：</p><p><img src="https://s2.loli.net/2022/09/24/7Ek5A46QHNKtWoJ.png" alt="image-20220924195434572"></p><p>可以看到，当我们捕获异常之后，程序可以继续正常运行，并不会像之前一样直接结束掉。</p><p>注意，catch中捕获的类型只能是Throwable的子类，也就是说要么是抛出的异常，要么是错误，不能是其他的任何类型。</p><p>我们可以在<code>catch</code>语句块中对捕获到的异常进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        object.toString();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e)&#123;</span><br><span class="line">        e.printStackTrace();   <span class="comment">//打印栈追踪信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;异常错误信息：&quot;</span>+e.getMessage());   <span class="comment">//获取异常的错误信息</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;程序继续正常运行！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/24/d15ns6hQblU8TAS.png" alt="image-20220924201405697"></p><p>如果某个方法明确指出会抛出哪些异常，除非抛出的异常是一个运行时异常，否则我们必须要使用try-catch语句块进行异常的捕获，不然就无法通过编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    test(<span class="number">10</span>);    <span class="comment">//必须要进行异常的捕获，否则报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">throws</span> IOException &#123;  <span class="comment">//明确会抛出IOException</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，如果我们确实不想在当前这个方法中进行处理，那么我们可以继续踢皮球，抛给上一级：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;  <span class="comment">//继续编写throws往上一级抛</span></span><br><span class="line">    test(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> a)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，如果已经是主方法了，那么就相当于到顶层了，此时发生异常再往上抛出的话，就会直接交给JVM进行处理，默认会让整个程序终止并打印栈追踪信息。</p><p>注意，如果我们要捕获的异常，是某个异常的父类，那么当发生这个异常时，同样可以捕获到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="number">100</span>;    <span class="comment">//这里发生的是数组越界异常，它是运行时异常的子类</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e)&#123;  <span class="comment">//使用运行时异常同样可以捕获到</span></span><br><span class="line">        System.out.println(<span class="string">&quot;捕获到异常&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当代码可能出现多种类型的异常时，我们希望能够分不同情况处理不同类型的异常，就可以使用多重异常捕获：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            </span><br><span class="line">&#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e)&#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e)&#123;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是要注意一下顺序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (RuntimeException e)&#123;  <span class="comment">//父类型在前，会将子类的也捕获</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException e) &#123;   <span class="comment">//永远都不会被捕获</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e)&#123;   <span class="comment">//永远都不会被捕获</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只不过这样写好像有点丑，我们也可以简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//....</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (NullPointerException | IndexOutOfBoundsException e) &#123;  <span class="comment">//用|隔开每种类型即可</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果简写的话，那么发生这些异常的时候，都会采用统一的方式进行处理了。</p><p>最后，当我们希望，程序运行时，无论是否出现异常，都会在最后执行任务，可以交给<code>finally</code>语句块来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            </span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;lbwnb&quot;</span>);   <span class="comment">//无论是否出现异常，都会在最后执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>try</code>语句块至少要配合<code>catch</code>或<code>finally</code>中的一个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    a /= <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;  <span class="comment">//不捕获异常，程序会终止，但在最后依然会执行下面的内容</span></span><br><span class="line">    System.out.println(<span class="string">&quot;lbwnb&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>思考：</strong><code>try</code>、<code>catch</code>和<code>finally</code>执行顺序？</p><h3 id="断言表达式">断言表达式</h3><p>我们可以使用断言表达式来对某些东西进行判断，如果判断失败会抛出错误，只不过默认情况下没有开启断言，我们需要在虚拟机参数中手动开启一下：</p><p><img src="https://s2.loli.net/2022/09/24/cAG8kY395fOuTLg.png" alt="image-20220924220327591"></p><p>开启断言之后，我们就可以开始使用了。</p><p>断言表达式需要使用到<code>assert</code>关键字，如果assert后面的表达式判断结果为false，将抛出AssertionError错误。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们可以判断变量的值，如果大于10就抛出错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">assert</span> a &gt; <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/24/12b6zRAL3evQ9ZB.png" alt="image-20220924220704026"></p><p>我们可以在表达式的后面添加错误信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">assert</span> a &gt; <span class="number">10</span> : <span class="string">&quot;我是自定义的错误信息&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就会显示到错误后面了：</p><p><img src="https://s2.loli.net/2022/09/24/NaYk5pFiBPLXVIr.png" alt="image-20220924220813609"></p><p>断言表达式一般只用于测试，我们正常的程序中一般不会使用，这里只做了解就行了。</p><hr><h2 id="常用工具类介绍">常用工具类介绍</h2><p>前面我们学习了包装类、数组和字符串，我们接着来看看常用的一些工具类。工具类就是专门为一些特定场景编写的，便于我们去使用的类，工具类一般都会内置大量的静态方法，我们可以通过类名直接使用。</p><h3 id="数学工具类">数学工具类</h3><p>Java提供的运算符实际上只能进行一些在小学数学中出现的运算，但是如果我们想要进行乘方、三角函数之类的高级运算，就没有对应的运算符能够做到，而此时我们就可以使用数学工具类来完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="comment">//Math也是java.lang包下的类，所以说默认就可以直接使用</span></span><br><span class="line">    System.out.println(Math.pow(<span class="number">5</span>, <span class="number">3</span>));   <span class="comment">//我们可以使用pow方法直接计算a的b次方</span></span><br><span class="line">  </span><br><span class="line">  Math.abs(-<span class="number">1</span>);    <span class="comment">//abs方法可以求绝对值</span></span><br><span class="line">  Math.max(<span class="number">19</span>, <span class="number">20</span>);    <span class="comment">//快速取最大值</span></span><br><span class="line">  Math.min(<span class="number">2</span>, <span class="number">4</span>);   <span class="comment">//快速取最小值</span></span><br><span class="line">  Math.sqrt(<span class="number">9</span>);    <span class="comment">//求一个数的算术平方根</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，三角函数肯定也是安排上了的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.sin(Math.PI / <span class="number">2</span>);     <span class="comment">//求π/2的正弦值，这里我们可以使用预置的PI进行计算</span></span><br><span class="line">Math.cos(Math.PI);       <span class="comment">//求π的余弦值</span></span><br><span class="line">Math.tan(Math.PI / <span class="number">4</span>);    <span class="comment">//求π/4的正切值</span></span><br><span class="line"></span><br><span class="line">Math.asin(<span class="number">1</span>);     <span class="comment">//三角函数的反函数也是有的，这里是求arcsin1的值</span></span><br><span class="line">Math.acos(<span class="number">1</span>);</span><br><span class="line">Math.atan(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>可能在某些情况下，计算出来的浮点数会得到一个很奇怪的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(Math.sin(Math.PI));   <span class="comment">//计算 sinπ 的结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/23/fZ6OVRejDXWSalC.png" alt="image-20220923231536032"></p><p>正常来说，sinπ的结果应该是0才对，为什么这里得到的是一个很奇怪的数？这个E是干嘛的，这其实是科学计数法的10，后面的数就是指数，上面的结果其实就是：</p><ul><li><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1.2246467991473532</mn><mo>×</mo><msup><mn>10</mn><mrow><mo>−</mo><mn>16</mn></mrow></msup></mrow><annotation encoding="application/x-tex">1.2246467991473532 \times 10^{-16}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">1.2246467991473532</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">16</span></span></span></span></span></span></span></span></span></span></span></span></li></ul><p>其实这个数是非常接近于0，这是因为精度问题导致的，所以说实际上结果就是0。</p><p>我们也可以快速计算对数函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Math.log(Math.E);    <span class="comment">//e为底的对数函数，其实就是ln，我们可以直接使用Math中定义好的e</span></span><br><span class="line">    Math.log10(<span class="number">100</span>);     <span class="comment">//10为底的对数函数</span></span><br><span class="line">    <span class="comment">//利用换底公式，我们可以弄出来任何我们想求的对数函数</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">a</span> <span class="operator">=</span> Math.log(<span class="number">4</span>) / Math.log(<span class="number">2</span>);   <span class="comment">//这里是求以2为底4的对数，log(2)4 = ln4 / ln2</span></span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一些比较特殊的计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Math.ceil(<span class="number">4.5</span>);    <span class="comment">//通过使用ceil来向上取整</span></span><br><span class="line">    Math.floor(<span class="number">5.6</span>);   <span class="comment">//通过使用floor来向下取整</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向上取整就是找一个大于当前数字的最小整数，向下取整就是砍掉小数部分。注意，如果是负数的话，向上取整就是去掉小数部分，向下取整就是找一个小于当前数字的最大整数。</p><p>这里我们再介绍一下随机数的生成，Java中想要生成一个随机数其实也很简单，我们需要使用Random类来生成（这个类时java.util包下的，需要手动导入才可以）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();   <span class="comment">//创建Random对象</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">        System.out.print(random.nextInt(<span class="number">100</span>)+<span class="string">&quot; &quot;</span>);  <span class="comment">//nextInt方法可以指定创建0 - x之内的随机数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为，可以看到确实是一堆随机数：</p><p><img src="https://s2.loli.net/2022/09/23/fM8J7zO2qHXhvst.png" alt="image-20220923234642670"></p><p>只不过，程序中的随机并不是真随机，而是根据某些东西计算出来的，只不过计算过程非常复杂，能够在一定程度上保证随机性（根据爱因斯坦理论，宏观物质世界不存在真随机，看似随机的事物只是现目前无法计算而已，唯物主义的公理之一就是任何事物都有因果关系）</p><h3 id="数组工具类">数组工具类</h3><p>前面我们介绍了数组，但是我们发现，想要操作数组实在是有点麻烦，比如我们要打印一个数组，还得一个一个元素遍历才可以，那么有没有一个比较方便的方式去使用数组呢？我们可以使用数组工具类Arrays。</p><p>这个类也是<code>java.util</code>包下类，它用于便捷操作数组，比如我们想要打印数组，可以直接通过toString方法转换字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/23/fx61nKT7LjdMv5q.png" alt="image-20220923235747731"></p><p>是不是感觉非常方便？这样我们直接就可以打印数组了！</p><p>除了这个方法，它还支持将数组进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">3</span>, <span class="number">6</span>&#125;;</span><br><span class="line">    Arrays.sort(arr);    <span class="comment">//可以对数组进行排序，将所有的元素按照从小到大的顺序排放</span></span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感兴趣的小伙伴可以在数据结构与算法篇视频教程中了解多种多样的排序算法，这里的排序底层实现实际上用到了多种排序算法。</p><p>数组中的内容也可以快速进行填充：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    Arrays.fill(arr, <span class="number">66</span>);</span><br><span class="line">    System.out.println(Arrays.toString(arr));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以快速地对一个数组进行拷贝：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] target = Arrays.copyOf(arr, <span class="number">5</span>);</span><br><span class="line">    System.out.println(Arrays.toString(target));   <span class="comment">//拷贝数组的全部内容，并生成一个新的数组对象</span></span><br><span class="line">    System.out.println(arr == target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] target = Arrays.copyOfRange(arr, <span class="number">3</span>, <span class="number">5</span>);   <span class="comment">//也可以只拷贝某个范围内的内容</span></span><br><span class="line">    System.out.println(Arrays.toString(target));</span><br><span class="line">    System.out.println(arr == target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们也可以将一个数组中的内容拷贝到其他数组中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span>[] target = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">10</span>];</span><br><span class="line">    System.arraycopy(arr, <span class="number">0</span>, target, <span class="number">0</span>, <span class="number">5</span>);   <span class="comment">//使用System.arraycopy进行搬运</span></span><br><span class="line">    System.out.println(Arrays.toString(target));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于一个有序的数组（从小到大排列）我们可以使用二分搜索快速找到对应的元素在哪个位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    System.out.println(Arrays.binarySearch(arr, <span class="number">5</span>));   <span class="comment">//二分搜索仅适用于有序数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里提到了二分搜索算法，我们会在后面的实战练习中进行讲解。</p><p>那要是现在我们使用的是多维数组呢？因为现在数组里面的每个元素就是一个数组，所以说toString会出现些问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] array = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">1</span>&#125;, &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/24/L2at7HJi3BKf6jF.png" alt="image-20220924114142785"></p><p>只不过别担心，Arrays也支持对多维数组进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] array = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">1</span>&#125;, &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    System.out.println(Arrays.deepToString(array));    <span class="comment">//deepToString方法可以对多维数组进行打印</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，因为数组本身没有重写equals方法，所以说无法判断两个不同的数组对象中的每一个元素是否相同，Arrays也为一维数组和多维数组提供了相等判断的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">1</span>&#125;, &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    <span class="type">int</span>[][] b = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">1</span>&#125;, &#123;<span class="number">9</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line">    System.out.println(Arrays.equals(a, b));   <span class="comment">//equals仅适用于一维数组</span></span><br><span class="line">    System.out.println(Arrays.deepEquals(a, b));   <span class="comment">//对于多维数组，需要使用deepEquals来进行深层次判断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里肯定有小伙伴疑问了，不是说基本类型的数组不能转换为引用类型的数组吗？为什么这里的deepEquals接受的是<code>Object[]</code>也可以传入参数呢？这是因为现在是二维数组，二维数组每个元素都是一个数组，而数组本身的话就是一个引用类型了，所以说可以转换为Object类型，但是如果是一维数组的话，就报错：</p><p><img src="https://s2.loli.net/2022/09/24/ab94eNcJPERlOYA.png" alt="image-20220924115440998"></p><p>总体来说，这个工具类对于我们数组的使用还是很方便的。</p>]]></content>
    
    
    <summary type="html">Java SE 2️⃣ 类和对象</summary>
    
    
    
    <category term="开发" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Java SE" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/Java-SE/"/>
    
    
    <category term="开发" scheme="https://www.angfff.top/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Java" scheme="https://www.angfff.top/tags/Java/"/>
    
    <category term="Java SE" scheme="https://www.angfff.top/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>Java SE 学习笔记 1️⃣</title>
    <link href="https://www.angfff.top/posts/6b4fa997.html"/>
    <id>https://www.angfff.top/posts/6b4fa997.html</id>
    <published>2024-02-02T03:42:47.000Z</published>
    <updated>2025-05-22T04:31:09.391Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、入门介绍">一、入门介绍</h2><ol><li><p>回顾：</p><ul><li>C 语言通过编译，将高级语言代码翻译为计算机能够直接执行的指令；</li><li>Python 并不会先进行编译，而是直接交给解释器解释执行<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure><img src="https://s2.loli.net/2022/09/16/xAe9TspMDtlz8SE.png" alt="image-20220916150119407"></li></ul></li><li><p>一般来说，编程语言分为两大类：</p><ul><li>编译型语言：需要先编译为计算机可以直接执行的命令才可以运行。优点是计算机直接运行，性能高；缺点是与平台密切相关，在一种操作系统上编译的程序，无法在其他非同类操作系统上运行，比如 Windows 下的 exe 程序在 Mac 上就无法运行。</li><li>解释型语言：只需要通过解释器代为执行即可，不需要进行编译。优点是可以跨平台，因为解释是解释器的事情，只需要在各个平台上安装对应的解释器，代码不需要任何修改就可以直接运行；缺点是需要依靠解释器解释执行，效率肯定没直接编译成机器指令运行的快，并且会产生额外的资源占用。</li></ul></li><li><p>Java语言（Java之父：James Gosling，詹姆斯·高斯林）</p><blockquote><p>Write Once, Run Anywhere.</p></blockquote><p>这是Java语言的标语，它的目标很明确：一次编写，到处运行，它旨在打破平台的限制，让Java语言可以运行在任何平台上，并且不需要重新编译，实现跨平台运行。<br>Java自1995年正式推出以来，已经度过了快28个春秋，而基于Java语言，我们的生活中也有了各种各样的应用：<br><img src="https://s2.loli.net/2022/09/16/8SWeCjp6M4ufBk2.png" alt="image-20220916151604563"></p><ul><li>诺基亚手机上的很多游戏都是使用Java编写的。</li><li>安卓系统中的各种应用程序也是使用Java编写的。</li><li>著名沙盒游戏《Minecraft》也有对应的Java版本，得益于Java跨平台特性，无论在什么操作系统上都可以玩到这款游戏。</li></ul></li><li><p>Java 运行机制<br>实际上，Java程序也是需要进行编译才可以运行的，这一点与C语言是一样的，Java程序编译之后会变成 <code>.class</code> 结尾的二进制文件：<br><img src="https://s2.loli.net/2022/09/16/5z2OWQb3B9AhwSZ.png" alt="image-20220916153102763"><br>不过不同的是，这种二进制文件计算机并不能直接运行，而是需要交给JVM（Java虚拟机）执行。<br><img src="https://s2.loli.net/2022/09/16/6HnkcSIfPdVZEpM.png" alt="image-20220916152514450"><br>JVM 类似于 Python 解释器，将编译完成的 <code>.class</code> 文件交给 JVM 运行，程序中要做的事情，都由 JVM 告诉计算机该如何去执行。<br>在不同的操作系统下，都有对应的 JVM 实现，程序员只需要将 Java 程序编译为 <code>.class</code> 文件就可以直接交给 JVM 运行，无论是什么操作系统，JVM 都采用的同一套标准读取和执行 <code>.class</code> 文件，所以编译之后，在任何平台都可以运行，从而实现跨平台。<br>由于 Java 又需要编译同时还需要依靠 JVM 解释执行，所以说 Java <strong>既是编译型语言，也是解释型语言。</strong></p></li><li><p>Java 版本</p><ul><li>**JavaSE：**标准版 Java</li><li>**JavaME：**微缩版 Java，已经基本没人用了。</li><li>**JavaEE：**企业级 Java，比如网站开发。</li></ul></li></ol><h2 id="二、环境安装">二、环境安装</h2><h3 id="（一）JDK-安装">（一）JDK 安装</h3><ol><li>JRE 和 JDK 区别<ul><li><strong>JRE（Java Runtime Environment）</strong>：Java 的运行环境，安装了运行环境之后，Java 程序才可以运行，一般不做开发，只是需要运行 Java 程序直接按照 JRE 即可。</li><li><strong>JDK（Java Development Kit）</strong>：包含 JRE，并且还附带了大量开发者工具。<br><img src="https://s2.loli.net/2022/09/16/MpGWrh5xZdI3bCJ.png" alt="image-20220916154906732"></li></ul></li><li>JDK 安装<ul><li><a href="https://blog.csdn.net/m0_43395703/article/details/119685247?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-119685247-blog-134803032.235%5Ev43%5Epc_blog_bottom_relevance_base3&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=2">ARM Mac JDK 安装教程</a></li><li><a href="https://www.azul.com/downloads">Zulu JDK 下载</a></li></ul></li><li>jenv 安装<ul><li><a href="https://blog.csdn.net/weixin_52911459/article/details/128063285">jenv 安装</a></li></ul></li></ol><h3 id="（二）Java-版本管理">（二）Java 版本管理</h3><blockquote><p>查看当前 Java 版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java --version</span><br></pre></td></tr></table></figure><p>查看已安装的所有版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jenv versions</span><br></pre></td></tr></table></figure><p>切换不同版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jenv global 1.8</span><br></pre></td></tr></table></figure><p>添加新安装版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jenv add /Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home</span><br></pre></td></tr></table></figure><p>删除已安装版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jenv remove xxx</span><br></pre></td></tr></table></figure></blockquote><h2 id="三、Java-基础">三、Java 基础</h2><h3 id="（一）基础语法">（一）基础语法</h3><ol><li><p>main 主方法，是整个程序的入口点，执行过程从 main 主方法内开始从下往下依次执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>⚠️</p><ul><li>Java 中严格区分大小写；</li><li>每行代码写完后需要添加分号；</li></ul></blockquote></li><li><p>注释的使用</p><ul><li>单行注释 //</li><li>多行注释 /* xxx */</li><li>说明文档 /** xxx */</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> angfff</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>); <span class="comment">//输出语句</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      多行注释</span></span><br><span class="line"><span class="comment">      Test</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>变量</p><ul><li><p>变量声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[数据类型] [变量名称];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 方法一</span></span><br><span class="line">          <span class="type">int</span> X; <span class="comment">// 定义整数类型变量 X</span></span><br><span class="line">          X = <span class="number">10</span>; <span class="comment">// 为 X 赋值为 10</span></span><br><span class="line">          <span class="comment">// 方法二</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">Y</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 定义变量 Y 并赋值为 20</span></span><br><span class="line">          <span class="comment">// 方法三</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">Z</span> <span class="operator">=</span> Y; <span class="comment">// 定义变量 Z 并赋值为 Y 的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关键字 final : 在变量前添加 final 关键字，可以将变量定义为不可变变量（常量），也即只能进行一次赋值，后续不能对其进行修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> x; <span class="comment">// 常量 x</span></span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">        x = <span class="number">20</span>; <span class="comment">// 报错，无法进行修改</span></span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="（二）基本数据类型">（二）基本数据类型</h3><ol><li><p>整数类型</p><ul><li>byte 字节型 （8 个 bit，也就是 1 个字节）范围：-128 ~ +127</li><li>short 短整形（16 个 bit，也就是 2 个字节 / 一个字）范围：-32768 ~ +32767</li><li>int 整形（32 个 bit，也就是 4 个字节 / 双字）最常用的类型，范围：-2147483648 ~ +2147483647</li><li>long 长整形（64 个 bit，也就是 8 个字节 / 四字）范围：-9223372036854775808 ~ +9223372036854775807</li></ul><blockquote><p>补充：隐式类型转换</p><ul><li>从存储范围小的类型到存储范围大的类型，会发生隐式类型转换，自动将某种类型的值，转换为另一种类型。</li><li>实际上我们在为变量赋一个常量数值时，也发生了隐式类型转换，比如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="comment">//这里的整数常量10，实际上默认情况下是int类型，但是由于正好在对应类型可以表示的范围内，所以说直接转换为了byte类型的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>由于直接编写的整数常量值默认为<code>int</code>，这里需要特别注意一下，比如下面这种情况：</p><p><img src="https://s2.loli.net/2022/09/16/76GgjWYz4DPBy1p.png" alt="image-20220916232420547"></p><p>按照 <code>long</code> 类型的规定，实际上是可以表示这么大的数字的，但是为什么这里报错了呢？这是因为我们直接在代码中写的常量数字，默认情况下就是 <code>int</code> 类型，这么大肯定是表示不下的，如果需要将其表示为一个 long 类型的常量数字，那么需要在后面添加大写或是小写的 <code>L</code> 才可以。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">922337203685477580L</span>;   <span class="comment">//这样就可以正常编译通过了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>针对于这种很长的数字，为了提升辨识度，我们可以使用下划线分割每一位：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1_000_000</span>;    <span class="comment">//当然这里依然表示的是1000000，没什么区别，但是辨识度会更高</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们也可以以8进制或是16进制表示一个常量值：<ul><li>**十六进制：**以 <code>0x</code> 开头的都是十六进制表示法</li><li>**八进制：**以 0 开头的都是八进制表示法</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">0xA</span>);</span><br><span class="line">    System.out.println(<span class="number">012</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>浮点类型</p><ul><li>float 单精度浮点数（32bit，4 字节）</li><li>double 双精度浮点数（64bit，8 字节）</li></ul><blockquote><p><img src="https://s2.loli.net/2022/09/17/CpI5jaWgR9nqTbc.png" alt="image-20220917102209246"></p><p>根据国际标准 IEEE 754，任意一个二进制浮点数 V 可以表示成下面的形式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>V</mi><mo>=</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>S</mi></msup><mo>×</mo><mi>M</mi><mo>×</mo><msup><mn>2</mn><mi>E</mi></msup></mrow><annotation encoding="application/x-tex">V = (-1)^S \times M \times 2^E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1413em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li>(-1)^S 表示符号位，当 S=0，V 为正数；当 S=1，V 为负数。</li><li>M 表示有效数字，大于等于 1，小于 2，但整数部分的 1 不变，因此可以省略。（例如尾数为 1111010，那么 M 实际上就是1.111010，尾数首位必须是 1，1 后面紧跟小数点，如果出现0001111 这样的情况，去掉前面的 0，移动 1 到首位；题外话：随着时间的发展，IEEE 754标准默认第一位为 1，故为了能够存放更多数据，就舍去了第一位，比如保存 1.0101 的时候， 只保存 0101，这样能够多存储一位数据）</li><li>2^E 表示指数位。（用于移动小数点，所以说才称为浮点型）</li></ul><p>浮点类型的大致取值范围：</p><ul><li>单精度：±3.40282347*10^38</li><li>双精度：±1.79769313486231570 *10^308</li></ul></blockquote><blockquote><p>⚠️ 跟整数类型常量一样，小数类型常量默认都是<code>double</code>类型，所以说如果我们直接给一个float类型赋值：</p><p><img src="https://s2.loli.net/2022/09/17/x7bOzyIacpDowKk.png" alt="image-20220917105141288"></p><p>由于<code>float</code>类型的精度不如<code>double</code>，如果直接给其赋一个double类型的值，会直接出现错误。</p><p>同样的，我们可以给常量后面添加大写或小写的 F 来表示这是一个<code>float</code>类型的常量值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">9.9F</span>;   <span class="comment">//这样就可以正常编译通过了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>⚠️ 隐式类型转换规则总结：</p><p>byte → short(char) → int → long → float → double</p></blockquote></li><li><p>字符类型</p><ul><li>char 字符型（16个bit，2字节，不带符号）范围 0 ~ 65535</li></ul><p><img src="https://s2.loli.net/2022/09/17/Z7AiBPNO6ylML4z.png" alt="img"></p><ul><li>String 字符串类型</li></ul><blockquote><p>⚠️ ’ ’ 单引号用于 char 字符类型；&quot; &quot; 双引号用于 String 字符串类型</p></blockquote></li><li><p>布尔类型</p><ul><li>true  -  真</li><li>false  -  假</li></ul><p>布尔类型（boolean）只有<code>true</code>和<code>false</code>两种值，也就是要么为真，要么为假，布尔类型的变量通常用作流程控制判断语句（不同于C语言，C语言中一般使用0表示false，除0以外的所有数都表示true）布尔类型占据的空间大小并未明确定义，而是根据不同的JVM会有不同的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">true</span>;   <span class="comment">//值只能是 true 或 false</span></span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="（三）运算符">（三）运算符</h3><ol><li><p>赋值运算符</p><p>赋值运算符可以直接给某个变量赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">666</span>;   <span class="comment">//使用等号进行赋值运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**使用规则为：**赋值运算符的左边必须是一个可以赋值的目标，比如变量，右边可以是任意满足要求的值，包括变量。</p></li><li><p>算术运算符</p><ul><li><p>&quot; + &quot; 加法运算，除了支持算数运算外，还可以对字符串进行拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;abc&quot;</span>; </span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span> + <span class="literal">true</span> + <span class="number">1.5</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>&quot; - &quot; 减法运算</p></li><li><p>&quot; * &quot; 乘法运算</p></li><li><p>&quot; / &quot; 除法运算</p><p>两个整数在进行除法运算时，得到的结果也是整数（会直接砍掉小数部分，注意不是四舍五入）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>, b = <span class="number">5</span>;</span><br><span class="line">    System.out.println(a / b); <span class="comment">// 结果为 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>&quot; % &quot; 取模（取余数）运算</p></li></ul><blockquote><p>⚠️ 不同类型之间可以进行运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"> <span class="type">short</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;   </span><br><span class="line"><span class="comment">//不同类型的整数一起运算，小类型需要转换为大类型；</span></span><br><span class="line"> <span class="comment">//其中 short、byte、char 一律转换为 int 再进行计算（无论算式中有无 int，都需要转换），结果也是 int ；</span></span><br><span class="line"><span class="comment">//如果算式中出现了long类型，那么全部都需要转换到long类型再进行计算，结果也是long，反正就是依大的来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><ol start="3"><li><p>括号运算符</p><ul><li><p>提升优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (a = <span class="number">8</span>) * (-a + <span class="number">10</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. 括号的优先级是最高的，需要先计算括号中的内容，如果存在多个括号，就从左往右计算</span></span><br><span class="line"><span class="comment">        2. 首先是 a = 8，计算完成之后a变成8，并且运算结果也为8</span></span><br><span class="line"><span class="comment">        3. 然后是后面的加法，-a就是-8，加上10就是2</span></span><br><span class="line"><span class="comment">        4. 最后才是乘法，左边此时是8，右边是2，最后结果为16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>强制类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">short</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">short</span>) a;   <span class="comment">//在括号中填写上强制转换的类型，就可以强制转换到对应的类型了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>自增自减运算符</p><ul><li>&quot; ++ &quot; 自增运算符</li><li>&quot; – &quot; 自减运算符</li><li>“+=”、“-=”、“*=”、“/=”、“%=”</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a++;   <span class="comment">//先出结果，再自增</span></span><br><span class="line">    System.out.println(b);  <span class="comment">//b得到的是a自增前的值 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> ++a;   <span class="comment">//先自增，再出结果</span></span><br><span class="line">    System.out.println(b);   <span class="comment">//b得到的是a自增之后的结果 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>⚠️ 自增运算符放在前面，是先自增再得到结果；而自增运算符放到后面，是先出结果再自增（自减同理）</p><p>⚠️ 自增自减运算符的优先级与正负号等价比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> -a++ + ++a; </span><br><span class="line"><span class="comment">//我们首先来看前面的a，因为正负号和自增是同一个优先级，结合性是从右往左，所以说先计算a++</span></span><br><span class="line"><span class="comment">//a++的结果还是8，然后是负号，得到-8</span></span><br><span class="line"><span class="comment">//接着是后面的a，因为此时a已经经过前面变成9了，所以说++a就是先自增，再得到10</span></span><br><span class="line"><span class="comment">//最后得到的结果为 -8 + 10 = 2</span></span><br><span class="line"> System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>位运算符</p><ul><li><p>&quot; &amp; &quot; 按位与 运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a &amp; b;    <span class="comment">//进行按位与运算</span></span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>按位与，就是让这两个数每一位都进行比较，如果这一位两个数都是 1，那么结果就是 1，否则就是 0：</p><ul><li>a = 9 = 1001</li><li>b = 3 = 0011</li><li>c = 1 = 0001（因为只有最后一位，两个数都是1，所以说结果最后一位是1，其他都是0）</li></ul></blockquote></li><li><p>&quot; | &quot; 按位或 运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a | b;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>按位或，就是只要任意一个为1（不能同时为0）那么结果就是1：</p><ul><li>a = 9 = 1001</li><li>b = 3 = 0011</li><li>c =11= 1011（只要上下有一个是1或者都是1，那结果就是1）</li></ul></blockquote></li><li><p>&quot; ^ &quot; 按位异或 运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a ^ b;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Java 中并没有乘方运算符，<code>^</code> 是按位异或运算符</p><p>异或，就是只有两边不相同的情况下，结果才是1，也就是说一边是1一边是0的情况：</p><ul><li>a = 9 = 1001</li><li>b = 3 = 0011</li><li>c =10= 1010（从左往右第二位、第四位要么两个都是0，要么两个都是1，所以说结果为0）</li></ul></blockquote></li><li><p>&quot; ~ &quot; 按位取反 运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">c</span> <span class="operator">=</span> ~<span class="number">127</span>;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>按位取反，跟前面的正负号一样，只操作一个数，最好理解，如果这一位上是1，变成0，如果是0，变成1：</p><ul><li>127 = 01111111</li><li>-128 = 10000000</li></ul></blockquote></li><li><p>&quot; &lt;&lt; &quot; 左移；&quot; &lt;&lt; &quot; 右移</p><blockquote><ul><li>**左移操作 &lt;&lt;：**高位直接丢弃，低位补0</li><li>**右移操作 &gt;&gt;：**低位直接丢弃，符号位是什么高位补什么</li></ul></blockquote></li><li><p>&quot; &gt;&gt;&gt; &quot; 无符号右移</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>-1    =   11111111 11111111 11111111 11111111</li><li>右移：  01111111 11111111 11111111 11111111（无符号右移使用0填充高位）</li></ul><p>此时得到的结果就是正数的最大值</p><p>⚠️ 不存在无符号左移。</p></blockquote></li></ul></li><li><p>关系和逻辑运算符</p><ul><li>关系判断的结果只可能是真或是假，所以说得到的结果是一个<code>boolean</code>类型的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;   大于</span><br><span class="line">&lt;   小于</span><br><span class="line">==  等于（注意是两个等号连在一起，不是一个等号，使用时不要搞混了）</span><br><span class="line">!=  不等于</span><br><span class="line">&gt;=  大于等于</span><br><span class="line">&lt;=  小于等于</span><br></pre></td></tr></table></figure><ul><li>逻辑运算符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp;     与运算，要求两边同时为<span class="literal">true</span>才能返回<span class="literal">true</span></span><br><span class="line">||     或运算，要求两边至少要有一个为<span class="literal">true</span>才能返回<span class="literal">true</span></span><br><span class="line">!      非运算，一般放在表达式最前面，表达式用括号扩起来，表示对表达式的结果进行反转</span><br></pre></td></tr></table></figure></li><li><p>三元运算符</p><p>三元运算符可以根据判断条件，返回不同的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">b</span> <span class="operator">=</span> a &gt; <span class="number">10</span> ? <span class="string">&#x27;A&#x27;</span> : <span class="string">&#x27;B&#x27;</span>;   <span class="comment">//三元运算符需要三个内容，第一个是判断语句，第二个是满足判断语句的值，第三个是不满足判断语句的值</span></span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三元运算符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断语句 ? 结果<span class="number">1</span> : 结果<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>运算符优先级总结</p><table><thead><tr><th style="text-align:center">优先级</th><th style="text-align:center">运算符</th><th style="text-align:center">结合性</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">( )</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">~   -   +  (强制类型转换)  ++   –</td><td style="text-align:center">从右向左</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">*   /  %</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">+   -</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">&lt;&lt;   &gt;&gt;   &gt;&gt;&gt;</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">&gt;   &lt;   &gt;=   &gt;=</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">==     !=</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">&amp;</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">^</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">|</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">&amp;&amp;</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">||</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">? :</td><td style="text-align:center">从右向左</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">=  +=  -=  *=   /=   %=   &amp;=   |=   ^=   &lt;&lt;=  &gt;&gt;=  &gt;&gt;&gt;=</td><td style="text-align:center">从右向左</td></tr></tbody></table></li></ol><h3 id="（四）流程控制">（四）流程控制</h3><ol><li><p>代码块与作用域</p><p>作用域：在代码块内定义的变量无法在代码块之外使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;   <span class="comment">//此时变量在代码块内定义</span></span><br><span class="line">        System.out.println(a);   <span class="comment">//处于其作用域内部的代码可以调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(a);   <span class="comment">//作用域外的代码无法调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>条件判断</p><ul><li>IF 语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件判断) &#123;</span><br><span class="line">  判断成功执行的代码 <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> () &#123;</span><br><span class="line">  判断成功执行的代码 <span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  判断成功执行的代码 <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span>  <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(score &gt;= <span class="number">90</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Switch 语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (目标) &#123;   <span class="comment">//目标变量 或 计算表达式</span></span><br><span class="line">  <span class="keyword">case</span> 匹配值:    <span class="comment">//如目标值等于给定匹配值，执行case的代码</span></span><br><span class="line">    代码...</span><br><span class="line">    <span class="keyword">break</span>;    <span class="comment">//代码执行结束后需要使用break来结束，否则会溜到下一个case继续执行代码</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">case</span> 匹配值:</span><br><span class="line">    代码...</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环语句</p><ul><li>for 循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>) &#123;</span><br><span class="line">  循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>while 循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件) &#123;</span><br><span class="line">  循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>do……while 循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确</span></span><br><span class="line">    <span class="keyword">do</span> &#123;  <span class="comment">//无论满不满足循环条件，先执行循环体里面的内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>);   <span class="comment">//再做判断，如果判断成功，开启下一轮循环，否则结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>continue 和 break</p><p>⚠️ 就近原则，也可以利用标签指定跳转位置</p><p>a. <code>continue + (标签)</code> 跳过本轮循环进入下一轮</p><p>b. <code>break + (标签)</code> 跳出 / 结束循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">outer: <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">4</span>; ++i) &#123;   <span class="comment">//在循环语句前，添加 标签: 来进行标记</span></span><br><span class="line">    inner: <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j) <span class="keyword">break</span> outer;    <span class="comment">//break后紧跟要结束的循环标记，当i == j时终止外层循环</span></span><br><span class="line">        System.out.println(i+<span class="string">&quot;, &quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <summary type="html">Java SE 1️⃣ 环境搭建 与 基础语法</summary>
    
    
    
    <category term="开发" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Java SE" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/Java-SE/"/>
    
    
    <category term="开发" scheme="https://www.angfff.top/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Java" scheme="https://www.angfff.top/tags/Java/"/>
    
    <category term="Java SE" scheme="https://www.angfff.top/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记</title>
    <link href="https://www.angfff.top/posts/83eeafe1.html"/>
    <id>https://www.angfff.top/posts/83eeafe1.html</id>
    <published>2024-01-24T13:04:43.000Z</published>
    <updated>2025-05-22T04:31:09.391Z</updated>
    
    <content type="html"><![CDATA[<h1>软件测试</h1><h2 id="一、概述">一、概述</h2><h3 id="（一）基本概念">（一）基本概念</h3><ol><li><p>概念</p><blockquote><p>软件测试是指对软件系统进行验证和评估的过程。它包括通过运行软件系统来检测错误、缺陷和问题，并确保软件能够按照预期的要求和功能正常工作。软件测试的目标是提高软件质量和可靠性，以确保用户能够获得高质量的软件产品。测试人员通常使用各种测试技术和方法，如功能测试、性能测试、安全测试等，来发现并报告潜在的问题。软件测试在软件开发生命周期的不同阶段进行，以确保在发布软件之前发现和修复问题。</p></blockquote></li><li><p>分类：</p><ul><li>功能测试</li><li>性能测试</li><li>安全测试</li></ul></li></ol><h3 id="（二）软件测试重要性">（二）软件测试重要性</h3><blockquote><p>软件测试在软件项目中扮演着至关重要的角色，其重要性体现在以下几个方面：</p><ol><li><p>发现和修复问题：软件测试的主要目标是发现软件系统中的错误、缺陷和问题。通过有效的测试，可以及早发现并修复这些问题，从而提高软件的质量和可靠性。</p></li><li><p>提高用户满意度：通过软件测试，可以确保软件系统按照预期的要求和功能正常工作。这有助于提高用户满意度，满足用户的需求和期望。</p></li><li><p>节约成本和资源：通过在早期发现和修复问题，可以避免将错误和缺陷传递到后续开发阶段，从而节约了修复这些问题所需的成本和资源。</p></li><li><p>降低风险：软件测试有助于降低软件项目的风险。通过检测和修复问题，可以减少软件系统引发故障、数据丢失或安全漏洞等风险的概率。</p></li><li><p>提高软件质量和可靠性：软件测试是提高软件质量和可靠性的关键步骤。通过不断优化和完善测试流程，可以确保软件系统具有较高的质量和可靠性，满足用户的需求。</p></li></ol><p>总之，软件测试在软件项目中的重要性不可忽视。它有助于发现问题、提高用户满意度、节约成本和资源、降低风险，并提高软件质量和可靠性。通过有效的测试，可以确保软件系统交付给用户之前经过充分验证，从而提供高质量的软件产品。</p></blockquote><h2 id="二、功能测试">二、功能测试</h2><h3 id="（一）基本概念-2">（一）基本概念</h3><blockquote><p>功能测试是对软件系统的功能进行验证的测试过程。它主要测试软件是否按照规格说明书或需求文档中所定义的功能进行操作和输出。</p><p>在功能测试中，测试人员通常会使用黑盒测试技术，即仅关注软件的输入和输出，不考虑内部实现细节。常用的功能测试技术包括边界值分析、等价类划分、决策表等。</p></blockquote><h3 id="（二）黑盒测试">（二）黑盒测试</h3><ol><li><p>概念：黑盒测试，它是通过测试来检测每个功能是否都能正常使用。在测试中，把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。</p></li><li><p>作用：</p><blockquote><p>是否有功能错误，是否有功能遗漏。</p><p>是否能够正确地接收输入数据并产生正确的输出结果。</p><p>是否有数据结构错误或外部信息访问错误。</p><p>是否有程序初始化和终止方面的错误。</p></blockquote></li><li><p>测试方法：</p><ol><li><p><strong><u>等价类划分法</u></strong></p><blockquote><p>等价类划分法是一种常用的测试技术，用于减少测试用例的数量，从而提高测试效率。它基于一个假设，即在一个等价类中的测试用例具有相同的测试结果。</p><p>等价类划分法将输入值划分为多个等价类，然后选择代表性的测试用例来代表每个等价类进行测试。</p><p>等价类划分法的步骤如下：</p><ol><li>确定输入值的合法和非法范围。</li><li>将输入值划分为多个等价类，每个等价类包含具有相同测试结果的输入值。</li><li>选择代表性的测试用例来代表每个等价类进行测试。</li></ol><p>例如，假设有一个登录功能，用户名只能包含字母和数字，且长度在6到12个字符之间。根据等价类划分法，可以将输入值划分为以下等价类：</p><ul><li>合法的用户名：包含字母和数字，长度在6到12个字符之间。</li><li>非法的用户名：包含除字母和数字以外的字符。</li><li>非法的用户名：长度小于6个字符或大于12个字符。</li></ul><p>然后，从每个等价类中选择一个或多个代表性的测试用例进行测试，例如选择一个合法的用户名和一个非法的用户名进行测试。</p><p>等价类划分法可以帮助测试人员在覆盖各种输入情况的同时，减少测试用例的数量，提高测试效率。</p></blockquote></li><li><p><strong><u>边界值分析法</u></strong></p><blockquote><p>边界值分析法是一种测试技术，用于确定测试用例的边界条件。它基于一个假设，即在边界上的输入值往往容易引发错误和异常情况。</p><p>边界值分析法通过选择接近边界的测试用例来测试系统的稳定性和准确性。</p><p>边界值分析法的步骤如下：</p><ol><li>确定输入值的合法范围和边界条件。例如，一个输入范围是1到100的整数，边界条件是1和100。</li><li>选择接近边界的测试用例进行测试。通常会选择边界值、边界值的前一个值和边界值的后一个值作为测试用例。</li><li>测试边界值本身的情况以及边界值周围的情况，以确保系统在边界条件下的正确性。</li></ol><p>例如，假设有一个年龄输入框，要求输入的年龄在18到65岁之间。根据边界值分析法，可以选择以下测试用例：</p><ul><li>边界值测试用例：18、65</li><li>边界前一个值测试用例：17（测试小于最小边界的情况）</li><li>边界后一个值测试用例：66（测试大于最大边界的情况）</li></ul><p>边界值分析法可以帮助测试人员发现在边界条件下可能存在的问题和错误，并确保系统在边界条件下的正确性。它也有助于减少测试用例的数量，提高测试效率。</p></blockquote></li><li><p><strong><u>错误推测法</u></strong></p><blockquote><p>错误推测法是基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性的设计测试用例的方法。</p><p>错误推测方法的基本思想： 列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据他们选择测试用例。</p><p>例如，输入数据和输出数据为 0的情况。 输入表格为空格或输入表格只有一行。</p></blockquote></li><li><p><strong><u>决策表</u></strong></p><blockquote><p>决策表法是一种测试技术，用于设计和执行测试用例，以覆盖多个条件组合和对应的行为。它通过创建一个决策表来描述系统的各种条件和相应的行为，并根据不同的条件组合选择相应的测试用例。</p><p>决策表通常由以下几个部分组成：</p><ol><li>条件列：列出所有可能的条件，每个条件通常有两个状态，例如&quot;是&quot;和&quot;否&quot;。</li><li>动作列：列出系统可能的行为或操作。</li><li>规则：将条件和动作组合起来形成规则，描述系统的行为。</li></ol><p>决策表法的步骤如下：</p><ol><li>确定系统的条件和动作。</li><li>创建决策表，列出所有可能的条件和相应的动作。</li><li>根据系统需求和测试目标，选择测试用例。</li><li>根据选择的测试用例，执行测试并记录结果。</li></ol><p>决策表法的优势在于能够覆盖多个条件组合，并根据不同的条件组合选择相应的测试用例。它可以帮助测试人员在较少的测试用例数量下覆盖更多的情况，从而提高测试效率。同时，决策表法也有助于可读性和可维护性，使得测试用例的设计更加系统化和规范化。</p></blockquote></li></ol></li></ol><h3 id="（三）白盒测试">（三）白盒测试</h3><ol><li>概念：白盒测试是一种软件测试方法，它基于对软件系统的内部结构和逻辑进行测试。在白盒测试中，测试人员具有对源代码、算法和系统内部的详细了解，以便设计和执行测试用例。白盒测试的主要目标是验证软件系统的内部逻辑、路径覆盖和代码执行的正确性。</li><li>测试方法：<ol><li><p><strong><u>语句覆盖</u></strong>（Statement Coverage）：测试人员通过执行测试用例，确保每个源代码语句都被执行到。</p></li><li><p><strong><u>分支覆盖</u></strong>（Branch Coverage）：测试人员通过执行测试用例，确保每个分支和决策点都被覆盖到。</p></li><li><p><strong><u>条件覆盖</u></strong>（Condition Coverage）：测试人员通过执行测试用例，确保每个条件语句的真值和假值都被覆盖到。</p></li><li><p><strong><u>路径覆盖</u></strong>（Path Coverage）：测试人员通过执行测试用例，确保覆盖所有可能的代码路径。</p></li></ol></li></ol><h2 id="三、性能测试">三、性能测试</h2><h3 id="（一）基本概念-3">（一）基本概念</h3><blockquote><p>性能测试是评估软件系统性能和响应能力的测试过程。它主要测试软件在不同负载和压力条件下的性能表现，如响应时间、并发用户数、吞吐量等。</p></blockquote><h3 id="（二）测试方式">（二）测试方式</h3><p>在性能测试中，测试人员通常会使用负载测试、压力测试、性能剖析等技术来模拟不同负载和压力条件，并测量软件的性能指标。</p><h2 id="四、安全测试">四、安全测试</h2><h3 id="（一）基本概念-4">（一）基本概念</h3><blockquote><p>安全测试是评估软件系统安全性和防护能力的测试过程。它主要测试软件系统是否存在安全漏洞和弱点，以及是否能够抵御恶意攻击和未授权访问。</p></blockquote><h3 id="（二）测试方式-2">（二）测试方式</h3><p>在安全测试中，测试人员通常会使用渗透测试、漏洞扫描、安全代码审查等技术来发现软件系统中的安全漏洞和弱点，并提出相应的修复建议。</p><h2 id="参考书目">参考书目</h2><ul><li>软件测试 [美] Ron Patton 机械工业出版社</li><li>Google 软件测试之道：像 Google 一样进行软件测试 [美] James A. Whittaker 等 人民邮电出版社</li><li>软件性能测试、分析与调优实践之路 [中] 张永清 清华大学出版社</li></ul>]]></content>
    
    
    <summary type="html">软件测试笔记</summary>
    
    
    
    <category term="开发" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="软件测试" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="开发" scheme="https://www.angfff.top/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="软件测试" scheme="https://www.angfff.top/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 笔记</title>
    <link href="https://www.angfff.top/posts/65316ea.html"/>
    <id>https://www.angfff.top/posts/65316ea.html</id>
    <published>2023-12-17T09:49:58.000Z</published>
    <updated>2025-05-22T04:31:09.391Z</updated>
    
    <content type="html"><![CDATA[<h1>一、概述</h1><h2 id="（一）数据管理技术发展过程">（一）数据管理技术发展过程</h2><h3 id="1-数据管理">1.数据管理</h3><p>（1）定义：对数据进行收集、分类、组织、编码、存储、检索和维护一系列活动的总和；</p><p>（2）发展过程：人工管理阶段 -&gt; 文件系统阶段 -&gt; 数据库系统阶段</p><h3 id="2-人工管理阶段">2.人工管理阶段</h3><ul><li>数据的管理者: 应用程序，数据不保存</li><li>数据面向的对象: 某一应用程序</li><li>数据的共享程度: 无共享、冗余度极大</li><li>数据的独立性: 不独立，完全依赖于程序</li><li>数据的结构化: 无结构</li><li>数据控制能力: 应用程序自己控制</li></ul><h3 id="3-文件系统阶段">3.文件系统阶段</h3><ul><li>数据的管理者: 文件系统，数据可长期保存</li><li>数据面向的对象: 某一应用程序</li><li>数据的共享程度: 共享性差、冗余度大</li><li>数据的结构化: 记录内有结构，整体无结构</li><li>数据的独立性: 独立性差，数据逻辑结构改变必须修改应用程序</li><li>数据控制能力: 应用程序自己控制</li></ul><h3 id="4-数据库系统阶段">4.数据库系统阶段</h3><p>（DBMS，独立的软件，位于操作系统之上）</p><ul><li>数据结构化</li><li>数据的共享性高，冗余度低且易扩充</li><li>数据独立性高（应用程序和数据库分离）</li><li>数据由 DBMS 统一管理和控制</li></ul><h2 id="（二）数据库">（二）数据库</h2><h3 id="1-数据-Data">1.数据(Data)</h3><ul><li>数据(Data)是数据库中存储的基本对象</li><li>数据的定义:描述事物的符号记录</li><li>数据的种类:文本、图形、图像、音频、视频、学生的档案记录、货物的运输情况等</li><li>数据的特点:数据与其语义是不可分的</li></ul><h3 id="2-数据库-Database">2.数据库(Database)</h3><ul><li>数据库(Database,简称DB)是长期储存在<u>计算机内</u>、<u>有组织</u>的、<u>可共享</u>的<u>大量数据</u>的集合</li></ul><h3 id="3-数据库管理系统-DBMS">3.数据库管理系统(DBMS)</h3><ul><li>定义:位于用户和操作系统之间的一层数据管理软件，是数据库和用户之间的一个接口</li><li>属性:数据库管理系统和操作系统一样都属于计算机的基础软件，也是一个大型复杂的软件系统。</li><li>作用:在数据库建立、运用和维护时对数据库进行统一控制，以保证数据的完整性、安全性，并在多用户同时使用数据库时进行并发控制，在发生故障后对数据库进行恢复。</li></ul><h3 id="4-数据库系统-DBS">4.数据库系统(DBS)</h3><p>​数据库系统的构成</p><ul><li>数据库</li><li>数据库管理系统(及其应用开发工具)</li><li>应用程序</li><li>数据库管理员</li></ul><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F.png" alt="数据库系统"></p><h2 id="（三）MySQL-安装与配置">（三）MySQL 安装与配置</h2><h3 id="1-安装">1.安装</h3><p>（1）macOS</p><ul><li>macOS 安装 MySQL <a href="https://blog.csdn.net/weixin_42148729/article/details/115056646?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168532550116800222872851%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168532550116800222872851&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-115056646-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=Mac%20mysql&amp;spm=1018.2226.3001.4187">教程</a></li></ul><p>（2）Windows</p><ul><li>Windows 安装 MySQL <a href="https://blog.csdn.net/xhmico/article/details/125029286">教程</a></li></ul><h3 id="2-连接">2.连接</h3><p>（1）终端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">Enter password: 123456</span><br></pre></td></tr></table></figure><p>（2）Navicat</p><p>（3）DataGrip</p><p>（4）VSCode</p><h1>二、 MySQL 基础</h1><h2 id="（一）概念">（一）概念</h2><p>DBMS 数据库管理系统</p><ul><li>关系型数据库 SQL</li><li>非关系型数据库 noSQL</li></ul><p>SQL: Structured Query Language 结构化查询语言</p><ol><li>设定为 主键 的属性可以唯一地表示每一条记录，即用 主键 可以区分不同的记录</li><li>可以通过 外键 将两张表格的记录关联起来，<ul><li>两张表间关联：表 A 中的 外键 对应到表 B 的 主键</li><li>一张表内关联：表A 中的 外键 也可以对应到自己的 主键 ，e.g 主管 id</li></ul></li><li>主键可以有多个，无论几个，其目的都是通过 一个/组 主键 ，区分不同的记录</li><li>可以同时将某一个属性设置为 主键 和 外键，表示从 A 可以查到 B 的某一条记录，从 B 也可以反过来找到 A 中的对应记录</li></ol><h2 id="（二）MySQL-数据类型">（二）MySQL 数据类型</h2><ol><li><p>数值</p><p>（1）整数</p><table><thead><tr><th style="text-align:left">数据类型</th><th style="text-align:left">字节数</th></tr></thead><tbody><tr><td style="text-align:left">TINYINT</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">SMALLINT</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">MEDIUMINT</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">INT</td><td style="text-align:left">4</td></tr><tr><td style="text-align:left">BIGINT</td><td style="text-align:left">8</td></tr></tbody></table><p>（2）浮点数</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>字节数</strong></th></tr></thead><tbody><tr><td>FLOAT</td><td>4</td></tr><tr><td>DOUBLE</td><td>8</td></tr></tbody></table><blockquote><p>注：float / double(m, n) 带有小数点的数</p><p>m 表示该数字总共有几位数n 表示小数部分所占的位数</p><p>e.g. float(3, 2) -&gt; 2.33 就是总共有 3 位数，其中小数占了 2 位</p></blockquote><p>（3）定点数 DECIMAL</p><blockquote><p>注：DECIMAL(m, n) 带有小数点的数</p><p>m 表示该数字总共有几位数n 表示小数部分所占的位数</p><p>e.g. DECIMAL(3, 2) -&gt; 2.33</p></blockquote><blockquote><p>注：浮点数和定点数的区别</p><ul><li>float / double 在 db 中存储的是近似值，而 decimal 则是以字符串形式进行保存的。因此，浮点数可能会存在精度丢失的问题，而定点数则不会丢失精度。</li><li>decimal(m,n) 的规则和 float / double 相同，但区别在 float / double 在不指定 m/n 时默认按照实际精度来处理，而 decimal 在不指定时默认为 decimal(10, 0)。</li></ul></blockquote></li><li><p>日期时间</p><table><thead><tr><th>数据类型</th><th>字节数</th><th>格式</th><th>备注</th></tr></thead><tbody><tr><td>date</td><td>3</td><td>yyyy-MM-dd</td><td>存储日期值</td></tr><tr><td>time</td><td>3</td><td>HH:mm:ss</td><td>存储时分秒</td></tr><tr><td>year</td><td>1</td><td>yyyy</td><td>存储年</td></tr><tr><td>datetime</td><td>8</td><td>yyyy-MM-dd HH:mm:ss</td><td>存储日期+时间</td></tr><tr><td>timestamp</td><td>4</td><td>yyyy-MM-dd HH:mm:ss</td><td>存储日期+时间，时间戳</td></tr></tbody></table><blockquote><p>注 1 ：datetime 和 timestamp 的区别：</p><ul><li>datetime 占8个字节，timestamp 占4个字节；</li><li>由于字节数区别，datetime 与 timestamp 能存储的时间范围也不同，datetime 的存储范围为 1000-01-01 00:00:00 — 9999-12-31 23:59:59，timestamp 存储的时间范围为 19700101080001—20380119111407；</li><li>datetime 默认值为空，当插入的值为 null 时，该列的值就是 null；timestamp 默认值不为空，当插入的值为 null 的时候，mysql 会取当前时间；</li><li>datetime 存储的时间与时区无关，timestamp 存储的时间及显示的时间都依赖于当前时区；</li></ul><p>注 2 ：通常表格中记录“创建时间”和“修改时间”字段时，用 timestamp</p></blockquote></li><li><p>字符串</p><p>（1）CHAR(n) 定长字符串</p><p>（2）VARCHAR(n) 变长字符串</p><p>（3）TEXT</p><p>（4）BLOB 二进制对象（图片、视频、档案等）</p><blockquote><p>注：</p><ul><li><p>MySql 单行最大数据量为 64K，为了存储大数据，因此创建了 TEXT 和 BLOB 两种类型；</p></li><li><p>TEXT 和 VARCHAR 比较类似，当 varchar(M) 的 M 大于某些数值时，varchar 会自动转为 text：</p><ul><li><p>M&gt;255 时转为 tinytext</p></li><li><p>M&gt;500 时转为 text</p></li><li><p>M&gt;20000 时转为 mediumtext</p></li></ul></li><li><p>varchar(M) 和 text 的区别：</p><ul><li><p>单行 64K 即 65535 字节的空间，varchar 只能用 63352 /  65533 个字节，text 可以用 65535 个字节；</p></li><li><p>text 可以指定 text(M) ，且 M 无限制</p></li><li><p>text 不允许有默认值，varchar 允许有默认值</p></li></ul></li><li><p>text 和 blob 的区别：text 存储的是字符串而 blob 存储的是二进制字符串。</p></li></ul></blockquote></li><li><p>JSON</p></li><li><p>空间</p></li></ol><h2 id="（三）SQL-语句分类">（三）SQL 语句分类</h2><ol><li><p>DDL (Data Definition Language) 数据定义语言</p><p>CREATE / DROP / ALTER / TRUNCATE</p></li><li><p>DML (Data Manipulation Language) 数据操作语言</p><p>INSERT / UPDATE / DELETE / CALL</p></li><li><p>DQL (Data Query Language) 数据查询语言</p><p>SELECT</p></li><li><p>DCL (Data Control Language) 数据控制语言</p><p>GRANT / REVOKE</p></li></ol><h1>三、常用 SQL 语句</h1><h2 id="（一）数据库和表操作">（一）数据库和表操作</h2><ol><li><p>新建数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `sql_tutorial`;</span><br></pre></td></tr></table></figure></li><li><p>查看所有数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure></li><li><p>删除数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE `sql_tutorial`;</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">drop</span> database test;</span><br><span class="line">ERROR <span class="number">1010</span> (HY000): Error dropping database (can<span class="string">&#x27;t rmdir &#x27;</span>.<span class="operator">/</span>test<span class="operator">/</span><span class="string">&#x27;, errno: 17)</span></span><br></pre></td></tr></table></figure><p>注：如果遇到上述无法删除数据库的情况，是因为 test 目录下存在着MySQL 不知道的文件，即 MySQL 中没有该文件的数据字典信息，需要手动删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/mysql/data/test# 进入 test 所在位置</span><br><span class="line">ls # 查看未知文件</span><br><span class="line">rm -rf xxx # 手动删除</span><br></pre></td></tr></table></figure><p>删除后，再次 DROP 即可。</p></blockquote></li><li><p>选择数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE `sql_tutorial`;</span><br></pre></td></tr></table></figure></li><li><p>创建表格</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `student` ( </span><br><span class="line">`student_id` <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>, # `属性名` 类型 主键,</span><br><span class="line">`name` <span class="type">VARCHAR</span> ( <span class="number">20</span> ), </span><br><span class="line">`major` <span class="type">VARCHAR</span> ( <span class="number">20</span> ) </span><br><span class="line">  #<span class="keyword">PRIMARY KEY</span>(`student_id`) 主键也可以不在属性后注明，也可以在下面单独写</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>查看表格</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> `student`;</span><br><span class="line"><span class="keyword">DESC</span> `student`;</span><br></pre></td></tr></table></figure></li><li><p>删除表格</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> `student`;</span><br></pre></td></tr></table></figure></li><li><p>新增表 字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> `student` <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> gpa <span class="type">DECIMAL</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p>删除表 字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> `student` <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> gpa;</span><br></pre></td></tr></table></figure></li><li><p>修改表 字段属性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> `student` MODIFY <span class="keyword">COLUMN</span> gpa <span class="type">FLOAT</span>(<span class="number">3</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改表 字段名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> `student` RENAME <span class="keyword">COLUMN</span> gpa <span class="keyword">to</span> Stu_GPA;</span><br></pre></td></tr></table></figure></li><li><p>导出数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 Shell 中使用</span></span><br><span class="line">mysqldump -u root -p DB (able) &gt; DB.sql</span><br></pre></td></tr></table></figure></li><li><p>导入数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 Shell 中使用</span></span><br><span class="line">mysql -u root -p DB &lt; DB.sql</span><br></pre></td></tr></table></figure></li></ol><h2 id="（二）数据操作">（二）数据操作</h2><ol><li><p>查询所有记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `student`;</span><br></pre></td></tr></table></figure></li><li><p>添加记录</p><ol><li><p>不指定属性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 这种方式添加记录，属性的顺序和数量必须全部匹配</span><br><span class="line"><span class="keyword">INSERT INTO</span> `student` <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;小白&#x27;</span>, <span class="string">&#x27;历史&#x27;</span>); </span><br></pre></td></tr></table></figure></li><li><p>指定属性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 可以在表格后添加属性序列，指定输入的属性，如后续值省略，则自动填入默认值</span><br><span class="line"><span class="keyword">INSERT INTO</span> `student`(`name`, `major`, `student_id`) <span class="keyword">VALUES</span>(<span class="string">&#x27;小蓝&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"># 插入多条数据</span><br><span class="line"><span class="keyword">INSERT INTO</span> `student`(`name`, `student_id`) <span class="keyword">VALUES</span>(<span class="string">&#x27;小红&#x27;</span>, <span class="number">5</span>),(<span class="string">&#x27;小绿&#x27;</span>, <span class="number">6</span>),(<span class="string">&#x27;小黄&#x27;</span>, <span class="number">7</span>);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>常用约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `student`</span><br><span class="line">(</span><br><span class="line">    `student_id` <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    `name`       <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span>, # 非空</span><br><span class="line">    `major`      <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>, # 唯一</span><br><span class="line">    `sex`        <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;男&#x27;</span># 默认值，通常应用在指定输入属性时</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>更新记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `student`</span><br><span class="line"><span class="keyword">SET</span> `major` <span class="operator">=</span> <span class="string">&#x27;English&#x27;</span>, `score` <span class="operator">=</span> <span class="number">98</span></span><br><span class="line"><span class="keyword">WHERE</span> `major` <span class="operator">=</span> <span class="string">&#x27;Math&#x27;</span> <span class="keyword">OR</span> `major` <span class="operator">=</span> <span class="string">&#x27;Chinese&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `student`</span><br><span class="line"><span class="keyword">WHERE</span> `student_id` <span class="operator">=</span> <span class="number">4</span>; # 不加条件，则删除所有记录</span><br></pre></td></tr></table></figure></li><li><p>查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">1</span>, 属性<span class="number">2</span></span><br><span class="line"><span class="keyword">FROM</span> 表</span><br><span class="line"><span class="keyword">WHERE</span> 属性<span class="number">1</span> <span class="operator">=</span> <span class="string">&#x27;特定值&#x27;</span> <span class="keyword">AND</span> <span class="operator">/</span> <span class="keyword">OR</span> 属性<span class="number">2</span> <span class="operator">&lt;&gt;</span> <span class="string">&#x27;特定值&#x27;</span></span><br><span class="line"># 链接符优先级 <span class="keyword">NOT</span> <span class="operator">&gt;</span> <span class="keyword">AND</span> <span class="operator">&gt;</span> <span class="keyword">OR</span>，可以用括号改变优先级顺序</span><br><span class="line"># 增加筛选条件（ <span class="operator">&lt;&gt;</span> 不等于 ）</span><br><span class="line"># 同一属性 a 判断多个条件并使用 <span class="keyword">OR</span> 连接时，可以用: 属性 <span class="keyword">IN</span> (<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"># 属性在某个区间内取值时，可以用: <span class="keyword">BETWEEN</span> a <span class="keyword">AND</span> b</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组依据</span><br><span class="line"><span class="keyword">HAVING</span> 分组后过滤的依据</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序依据<span class="number">1</span>, 排序依据<span class="number">2</span> <span class="keyword">DESC</span> </span><br><span class="line"># 默认升序 <span class="keyword">ASC</span> ，添加 <span class="keyword">DESC</span> 变为降序</span><br><span class="line"># 先按照依据<span class="number">1</span>排序，有相同的再按照依据<span class="number">2</span>排序</span><br><span class="line">LIMIT n <span class="operator">/</span> a,b </span><br><span class="line"># 如果只写一个数字 n 则返回前 n 条记录</span><br><span class="line"># 如果写 a,b 则返回 从 a<span class="operator">+</span><span class="number">1</span> 条记录开始的 b 条记录</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注：</p><ol><li>判断是否为空用 <code>IS NULL / IS NOT NULL</code>；</li><li>计算字符串中字符数的最佳函数是 <code>CHAR_LENGTH(str)</code>，它返回字符串 <code>str</code> 的长度；而函数 <code>LENGTH(str)</code> 返回字符串 <code>str</code> 的字节数，某些字符包含多于 1 个字节，可能导致返回结果错误。</li><li>DISTINCT + 属性 可用于去重；</li></ol></blockquote><h2 id="（三）进阶操作">（三）进阶操作</h2><ol><li><p>聚合函数</p><p>聚合函数用于对某些列进行一些计算，包括求和、计数、求平均等。</p><ul><li><p>COUNT( ) 返回集合中的项目数；</p></li><li><p>AVG( ) 返回集合的平均数；</p></li><li><p>SUM( ) 求和；</p></li><li><p>ROUND( 对象, 小数位数 ) 四舍五入保留小数；</p></li><li><p>MIN( ) 最小值；</p></li><li><p>MAX( ) 最大值；</p></li></ul></li><li><p>通配符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">属性 (<span class="keyword">NOT</span>) <span class="keyword">LIKE</span> <span class="string">&#x27;通配符&#x27;</span>;</span><br><span class="line"># <span class="operator">%</span> 表示任意长度的字符串</span><br><span class="line"># _ 表示任意单个字符</span><br></pre></td></tr></table></figure></li><li><p>正则表达式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">属性 REGEXP <span class="string">&#x27;正则表达式&#x27;</span>;</span><br><span class="line"># <span class="operator">^</span> 开头 $ 结尾</span><br><span class="line"># . 任意一个字符</span><br><span class="line"># [abc] 其中任意一个字符</span><br><span class="line"># [a<span class="operator">-</span>z] 范围内任意一个字符</span><br><span class="line"># A<span class="operator">|</span>B A 或 B</span><br></pre></td></tr></table></figure></li><li><p>集合运算</p><ul><li><p>UNION 并集</p><p>将两个结果合并为一个结果返回，后者直接接在前者最后；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">1</span> <span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">2</span> <span class="keyword">FROM</span> 表<span class="number">2</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>UNION 默认会去除两条 select 中得到的重复记录；如果要求不去重，则可以使用 UNION ALL。</p></blockquote></li><li><p>INTERSECT 交集</p><p>将两个结果取交集后返回；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">1</span> <span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">2</span> <span class="keyword">FROM</span> 表<span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>EXCEPT 差集</p><p>将两个结果取差集后返回，查找满足第一条语句但不满足第二条语句的记录；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">1</span> <span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">2</span> <span class="keyword">FROM</span> 表<span class="number">2</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>连接查询 JOIN</p><p>连接查询，将后者拼接在前者表的右边</p><p>（1）外连接</p><ul><li>LEFT JOIN（左连接）以左表为主，右表中没有的数据用 NULL 填充；</li><li>RIGHT JOIN（右连接）以右表为主，左表中没有的数据用 NULL填充；</li><li>FULL (OUTER) JOIN（全连接）两边连接，没有的都用 FULL 填充 <em><strong><u>并集</u></strong></em>。</li></ul><p>（2）内连接</p><ul><li>INNER JOIN （内连接）只返回两个表中都有的数据 <em><strong><u>交集</u></strong></em></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">1</span>, 属性<span class="number">2</span>, 属性<span class="number">3</span> <span class="keyword">FROM</span> 表<span class="number">1</span> </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span></span><br><span class="line"><span class="keyword">ON</span> 表<span class="number">1.</span>属性a <span class="operator">=</span> 表<span class="number">2.</span>属性b;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 内连接 也可以用 <span class="keyword">WHERE</span> 的方式实现</span><br><span class="line"># <span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">join</span> equip</span><br><span class="line"><span class="keyword">on</span> player.id <span class="operator">=</span> equip.player_id;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> player, equip</span><br><span class="line"><span class="keyword">where</span> player.id <span class="operator">=</span> equip.player_id;</span><br></pre></td></tr></table></figure><p>（3）交叉连接</p><ul><li><p>(CROSS) JOIN （交叉连接）相当于取两个表的***<u>笛卡尔积</u>***</p><blockquote><p>注：在 MySQL 中，如果不指定 ON 条件，则 CROSS JOIN 与 INNER JOIN 的结果是一样的，都是两张表的笛卡尔积。</p></blockquote></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">1</span>, 属性<span class="number">2</span>, 属性<span class="number">3</span> <span class="keyword">FROM</span> 表<span class="number">1</span> </span><br><span class="line">(<span class="keyword">CROSS</span>) <span class="keyword">JOIN</span> 表<span class="number">2</span></span><br><span class="line"><span class="keyword">ON</span> 表<span class="number">1.</span>属性a <span class="operator">=</span> 表<span class="number">2.</span>属性b;</span><br></pre></td></tr></table></figure></li><li><p>子查询 / 嵌套查询</p><p>（1）一个查询嵌套在另一个查询中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查询对一位客户销售金额超过 <span class="number">50000</span> 的员工姓名</span><br><span class="line"><span class="keyword">SELECT</span> Employee.name, Works_with.total_sales</span><br><span class="line"><span class="keyword">FROM</span> Employee <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Works_with</span><br><span class="line"><span class="keyword">ON</span> Employee.emp_id <span class="operator">=</span> Works_with.emp_id</span><br><span class="line"><span class="keyword">WHERE</span> Employee.emp_id <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">SELECT</span> Works_with.emp_id </span><br><span class="line">  <span class="keyword">FROM</span> Works_with </span><br><span class="line">  <span class="keyword">WHERE</span> Works_with.total_sales <span class="operator">&gt;=</span> <span class="number">50000</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 注: 这里内层的查询结果不止一个，所以不能用 <span class="operator">=</span> 连接内外查询，要用 <span class="keyword">IN</span> 连接内外查询</span><br></pre></td></tr></table></figure><p>（2）用子查询结果创建新表格</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查询所有等级小于 <span class="number">5</span> 级的玩家，并将结果保存到新的表格中</span><br><span class="line"><span class="keyword">CREATE TABLE</span> new_player <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> level <span class="operator">&lt;</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"># 查询所有等级在 <span class="number">6</span><span class="number">-10</span> 级的玩家，并将结果插入到 new_player 中</span><br><span class="line"><span class="keyword">INSERT INTO</span> new_player <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> level <span class="keyword">BETWEEN</span> <span class="number">6</span> <span class="keyword">AND</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>索引 INDEX</p><p>通常对一张表格的主键字段或常用字段创建索引，从而提高后续的查询效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 在指定表（的某些字段）上创建 唯一<span class="operator">/</span>全文<span class="operator">/</span>空间 索引</span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT<span class="operator">|</span>SPATIAL] INDEX 索引名称</span><br><span class="line"><span class="keyword">ON</span> 表名 (字段名称, ...);</span><br><span class="line"></span><br><span class="line"># 查看索引</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> 表名;</span><br><span class="line"></span><br><span class="line"># 删除索引</span><br><span class="line"><span class="keyword">DROP</span> INDEX 索引名称</span><br><span class="line"><span class="keyword">ON</span> 表;</span><br></pre></td></tr></table></figure></li></ol><h2 id="（四）窗口函数">（四）窗口函数</h2><ol><li><p>概念</p><p>窗口函数是一种特殊类型的 SQL 函数，它在查询结果集中的一定窗口（或称为窗口框架）上执行计算操作。</p><p>这个窗口是通过使用 OVER 子句定义的，它指定了在进行聚合、排序或分析等操作时应考虑的行集合。</p><p>窗口函数通常与聚合函数一起使用，但与普通的聚合函数不同，它不会将整个结果集作为输入，而是基于定义的窗口框架对子集进行计算。这使得在不引入子查询或自连接的情况下，能够在每一行上执行对整个结果集的聚合或分析操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  column1,</span><br><span class="line">  column2,</span><br><span class="line">  <span class="built_in">SUM</span>(column3) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> column1 # 按 column1 分组</span><br><span class="line">                     <span class="keyword">ORDER</span> <span class="keyword">BY</span> column2 # 按 column2 排序</span><br><span class="line">                     <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="number">1</span> PRECEDING <span class="keyword">AND</span> <span class="number">1</span> FOLLOWING # 当前行及其前后各一行</span><br><span class="line">                    ) <span class="keyword">AS</span> running_total</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  your_table;</span><br><span class="line"></span><br><span class="line"># SUM 是一个聚合函数，但它通过<span class="keyword">OVER</span>子句指定了一个窗口框架。</span><br><span class="line"># 在这个例子中，窗口由 <span class="keyword">PARTITION</span> <span class="keyword">BY</span> column1 定义，然后使用 <span class="keyword">ORDER</span> <span class="keyword">BY</span> column2 排序。</span><br><span class="line"># <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="number">1</span> PRECEDING <span class="keyword">AND</span> <span class="number">1</span> FOLLOWING指定了窗口的范围，表示当前行及其前后各一行。</span><br><span class="line"># 这样，SUM函数将在每个窗口内计算列column3的累计和。</span><br></pre></td></tr></table></figure></li><li><p>聚合函数</p><blockquote><p>示例数据</p><p>![截屏2023-12-20 21.15.22](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.15.22.png)</p></blockquote><ul><li><p><code>SUM</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line">       <span class="built_in">SUM</span>(Salary) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> GroupName) <span class="keyword">AS</span> 部门工资总和, # 按照部门分组，计算部门工资总和</span><br><span class="line">       <span class="built_in">SUM</span>(Salary) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> GroupName <span class="keyword">ORDER</span> <span class="keyword">BY</span> ID) <span class="keyword">AS</span> 累加_部门工资总和, # 按照部门分组，再按组内 ID 依次累加部门工资总和</span><br><span class="line">       <span class="built_in">SUM</span>(Salary) <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> ID) <span class="keyword">AS</span> 累加_全体工资总和, # 按所有人的 ID 依次累加工资总和</span><br><span class="line">       <span class="built_in">SUM</span>(Salary) <span class="keyword">OVER</span>() <span class="keyword">AS</span> 全体工资总和 # 窗口为空，直接计算所有员工工资总和 等同于 <span class="built_in">SUM</span>()</span><br><span class="line"><span class="keyword">FROM</span> Emp;</span><br></pre></td></tr></table></figure><p>![截屏2023-12-20 21.13.50](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.13.50.png)</p></li><li><p><code>MAX</code></p></li><li><p><code>MIN</code></p></li><li><p><code>COUNT</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> GroupName) <span class="keyword">AS</span> 部门人数,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> GroupName <span class="keyword">ORDER</span> <span class="keyword">BY</span> ID) <span class="keyword">AS</span> 累加_部门人数,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> ID) <span class="keyword">AS</span> 累加_全体人数,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">OVER</span>() <span class="keyword">AS</span> 总人数</span><br><span class="line"><span class="keyword">FROM</span> Emp;</span><br></pre></td></tr></table></figure><p>![截屏2023-12-20 21.14.46](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.14.46.png)</p></li><li><p><code>AVG</code></p></li></ul></li><li><p>排序函数</p><blockquote><p>示例数据</p><p>![截屏2023-12-20 21.16.26](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.16.26.png)</p></blockquote><ul><li><p><code>ROW_NUMBER</code> 将 SELECT 得到的数据进行排序，必须与 ORDER BY 连用，常用于分页查询；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line">       <span class="built_in">ROW_NUMBER</span>() <span class="keyword">over</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> ClassName <span class="keyword">ORDER</span> <span class="keyword">BY</span> Score <span class="keyword">DESC</span>) <span class="keyword">AS</span> 班内排名, # 按照班级分组，再按照分数降序排列，给每行一个排名</span><br><span class="line">       <span class="built_in">ROW_NUMBER</span>() <span class="keyword">over</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> Score <span class="keyword">DESC</span>) <span class="keyword">AS</span> 全体排名 # 按照分数降序排列，给每行一个排名</span><br><span class="line"><span class="keyword">FROM</span> SCO;</span><br></pre></td></tr></table></figure><p>![截屏2023-12-20 21.16.59](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.16.59.png)</p></li><li><p><code>RANK</code> 与 ROW_NUMBER 类似，但是允许并列排名，即分数相同时，排名也相同，后续跳过被占用的名次；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ROW_NUMBER</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>, <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> SCO.Score <span class="keyword">DESC</span>) <span class="keyword">AS</span> 总排名</span><br><span class="line"><span class="keyword">FROM</span> SCO; # 不能并列排名</span><br></pre></td></tr></table></figure><p>![截屏2023-12-20 21.18.28](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.18.28.png)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># RANK</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>, <span class="built_in">RANK</span>() <span class="keyword">over</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> SCO.Score <span class="keyword">DESC</span>) <span class="keyword">AS</span> 总排名</span><br><span class="line"><span class="keyword">FROM</span> SCO; # 可以并列，且后续跳过被占用的排名</span><br></pre></td></tr></table></figure><p>![截屏2023-12-20 21.18.40](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.18.40.png)</p></li><li><p><code>DENSE_RANK</code> 与 RANK 类似，允许并列排名，但后续不会跳过被占用的名次。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># DENSE_RANK</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>, <span class="built_in">DENSE_RANK</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> SCO.Score <span class="keyword">DESC</span> ) <span class="keyword">AS</span> 总排名</span><br><span class="line"><span class="keyword">FROM</span> SCO; # 可以并列，且后续不跳过被占用的排名</span><br></pre></td></tr></table></figure><p>![截屏2023-12-20 21.19.55](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.19.55.png)</p></li></ul></li><li><p>取值函数</p><p>（1）向前向后取数</p><ul><li><code>lag( )</code> 返回窗口内当前行之前的第 N 行数据</li><li><code>lead( )</code> 返回窗口内当前行之后的第 N 行数据</li></ul><p>（2）First_value &amp; Last_value</p><ul><li><code>First_value</code> 返回窗口内第一行数据，可以用 Min 聚合函数替代</li><li><code>Last_value</code> 返回窗口内最后一行数据，可以用 Max 聚合函数替代</li></ul></li></ol><h2 id="（五）函数">（五）函数</h2><ol><li><code>substr( 属性 a, begin, n )</code> 截取属性 a 从 begin 位置开始的 n 个字符，e.g. 查找姓氏 substr(name, 1, 1)；</li><li><code>datediff( 日期 1, 日期 2 )</code> 前减后，得到的结果是日期 1 与日期 2 相差的天数。如果日期 1 比日期 2 大，结果为正；如果日期 1 比日期 2 小，结果为负。</li><li><code>timestampdiff(时间类型, 日期1, 日期2)</code> 后减前在“时间类型”的参数位置，通过添加“day”, “hour”, “second”等关键词，来规定计算天数差、小时数差、还是分钟数差。日期 1 大于日期 2 ，结果为负，日期 1 小于日期 2 ，结果为正。</li><li><code>IFNULL( 判断对象 A, 替换值 N )</code> 如果判断对象 A 的值为 NULL，则返回替换值 N。</li><li><code>mod( 操作对象 A, 取模数 n ) = x</code> 判断操作对象 A 对 n 取模的结果是否为 x，等价于 A % n = x。</li><li></li></ol><h2 id="（六）视图">（六）视图</h2><ol><li>创建视图的目的是将查询结果保存为一张虚拟的表，当后续需要使用该查询结果时，就可以直接从视图中调用，做进一步的查询。</li><li>视图是动态变化的，随着原表的修改而修改。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 创建视图</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名;</span><br><span class="line"></span><br><span class="line"># 修改视图</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名称</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名;</span><br><span class="line"></span><br><span class="line"># 删除视图</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> 视图名称;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">MySQL 学习笔记</summary>
    
    
    
    <category term="技术" scheme="https://www.angfff.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="MySQL" scheme="https://www.angfff.top/categories/%E6%8A%80%E6%9C%AF/MySQL/"/>
    
    
    <category term="技术" scheme="https://www.angfff.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="MySQL" scheme="https://www.angfff.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Sklearn 导入随机逻辑回归函数 RLR 失败原因及解决</title>
    <link href="https://www.angfff.top/posts/5fd458f7.html"/>
    <id>https://www.angfff.top/posts/5fd458f7.html</id>
    <published>2023-12-09T08:05:10.000Z</published>
    <updated>2025-05-22T04:31:09.390Z</updated>
    
    <content type="html"><![CDATA[<h1>一、问题描述</h1><ol><li><p>描述：在进行分类任务时，导入随机逻辑回归模型 RandomizedLogisticRegression 时会提示无法找到该模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> RandomizedLogisticRegression <span class="keyword">as</span> RLR</span><br></pre></td></tr></table></figure></li><li><p>分析：自 sklearn 0.19.2 版本后，随机逻辑回归模型已经被移除</p></li><li><p>当前软件版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn</span><br><span class="line">sklearn.show_versions()</span><br></pre></td></tr></table></figure><blockquote><p>System:<br>python: 3.9.16</p><p>Python dependencies:</p><p>​sklearn: 1.3.2</p><p>​numpy: 1.26.2</p><p>​scipy: 1.10.1</p><p>​pandas: 2.1.3</p><p>​matplotlib: 3.7.1</p><p>​joblib: 1.3.2</p></blockquote></li></ol><h1>二、解决办法</h1><h2 id="（一）手动安装随机逻辑回归模型">（一）手动安装随机逻辑回归模型</h2><ol><li><p>模型仓库：<a href="https://github.com/scikit-learn-contrib/stability-selection">https://github.com/scikit-learn-contrib/stability-selection</a></p></li><li><p>安装参考：<a href="https://github.com/scikit-learn-contrib/stability-selection/issues/38">https://github.com/scikit-learn-contrib/stability-selection/issues/38</a></p><blockquote><p>注：</p><p>​安装随机逻辑回归模型后，能够解决模型导入时的报错问题，并能够正确拟合训练模型。</p><p>​但是在后续查看特征筛选结果和 Score 分数时，会无法调用 rlr.get_support() 和 rlr.scores_ 方法，可能是因为高版本在移除随机逻辑回归模型时，也对 sklearn_base 中的方法做了修改，无法再按旧版本方法调用。</p></blockquote></li></ol><h2 id="（二）采用低版本-Scikit-Learn">（二）采用低版本 Scikit-Learn</h2><ol><li><p>低版本 Scikit-Learn 所需的环境</p><blockquote><p>Python 3.8 及以下（建议 Python 3.6）</p><p>Numpy 1.23.5 及以下（建议 Numpy 1.20.0）</p><p>Scikit-Learn 0.19.2</p><p>注：</p><ol><li>所建议版本是较为久远的版本，可能会出现无法找到对应源、无法安装的情况，需根据自己的电脑情况调整；</li><li>M 系列 Mac 由于架构不同，不支持 3.8 版本以下的 Python，请使用 Python 3.8；</li><li>Scikit-Learn 最好使用 0.19.2 版本。</li></ol></blockquote></li><li><p>安装过程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">conda 创建虚拟环境 Python 3.8</span></span><br><span class="line">conda create -n py38 python=3.8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">激活 py38 环境</span></span><br><span class="line">conda activate py38</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装相关库</span></span><br><span class="line">pip install numpy==1.23.5</span><br><span class="line">pip install scipy</span><br><span class="line">pip install pandas</span><br><span class="line">pip install xlrd</span><br><span class="line">pip install scikit-learn==0.19.2</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><ol><li>以上过程均在终端 shell 中安装；</li><li>或者选用 Anaconda 图形化界面安装。</li></ol></blockquote></li><li><p>安装完毕后，在 Pycharm 右下角添加并使用新的 Python 解释器即可。</p></li></ol>]]></content>
    
    
    <summary type="html">Python Sklearn 导入随机逻辑回归函数 RLR 失败原因及解决</summary>
    
    
    
    <category term="环境配置" scheme="https://www.angfff.top/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    <category term="Sklearn" scheme="https://www.angfff.top/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Sklearn/"/>
    
    
    <category term="环境配置" scheme="https://www.angfff.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    <category term="Sklearn" scheme="https://www.angfff.top/tags/Sklearn/"/>
    
  </entry>
  
  <entry>
    <title>CIFAR100 多模型训练结果及分析</title>
    <link href="https://www.angfff.top/posts/2fb8888f.html"/>
    <id>https://www.angfff.top/posts/2fb8888f.html</id>
    <published>2023-12-09T02:50:31.000Z</published>
    <updated>2025-05-22T04:31:09.390Z</updated>
    
    <content type="html"><![CDATA[<h1>一、自建网络</h1><h2 id="两层-CNN-网络">两层 CNN 网络</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: Adam</li></ul></blockquote></li><li><p>思路</p><blockquote><p>CNN：Conv2d -&gt; BatchNorm2d -&gt; ReLu -&gt; MaxPool2d</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-2CNN.png" alt="Arch_2CNN"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-2CNN.png" alt="Loss_2CNN"></p><blockquote><ul><li>Time: 0:01:11.308311</li><li>Min Loss: 1.4500</li><li>Final Loss: 1.9618</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：39.75 %</li></ul></blockquote></li></ol><h2 id="三层-CNN-网络">三层 CNN 网络</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: Adam</li></ul></blockquote></li><li><p>思路</p><blockquote><p>CNN：Conv2d -&gt; BatchNorm2d -&gt; ReLu -&gt; MaxPool2d</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-3CNN.png" alt="Arch_3CNN"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-3CNN.png" alt="Loss_3CNN"></p><blockquote><ul><li>Time: 0:01:10.645922</li><li>Min Loss: 1.5404</li><li>Final Loss: 1.9817</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：44.14 %</li></ul></blockquote></li></ol><h2 id="五层-CNN-网络">五层 CNN 网络</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: Adam</li></ul></blockquote></li><li><p>思路</p><blockquote><p>CNN：Conv2d -&gt; BatchNorm2d -&gt; ReLu -&gt; MaxPool2d</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-5CNN.png" alt="Arch_5CNN"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-5CNN.png" alt="Loss_5CNN"></p><blockquote><ul><li>Time: 0:02:12.387121</li><li>Min Loss: 1.3080</li><li>Final Loss: 1.5872</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：44.20 %</li></ul></blockquote></li></ol><h1>二、经典 CNN 网络</h1><h2 id="VGG-19">VGG 19</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: SGD</li></ul></blockquote></li><li><p>思路</p><blockquote><p>VGG 19 -&gt; Transforms ( Resize + ToTensor + Normalize) -&gt; Model Arch ( fc out 100 ) -&gt; Fine Tune</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-VGG.png" alt="Arch_VGG"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-VGG.png" alt="Loss_VGG"></p><blockquote><ul><li>Time: 0:24:17.983430</li><li>Min Loss: 0.3057</li><li>Final Loss: 0.7126</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：71.61 %</li></ul></blockquote></li></ol><h2 id="ResNet-101">ResNet 101</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: SGD</li></ul></blockquote></li><li><p>思路</p><blockquote><p>ResNet 101 -&gt; Transforms ( Resize + ToTensor + Normalize) -&gt; Model Arch ( fc out 100 ) -&gt; Fine Tune</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-ResNet.png" alt="Arch_ResNet"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-ResNet.png" alt="Loss_ResNet"></p><blockquote><ul><li>Time: 0:26:58.626524</li><li>Min Loss: 0.0667</li><li>Final Loss: 0.0942</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：83.92 %</li></ul></blockquote></li></ol><h1>三、 Vision Transformer 网络</h1><h2 id="ViT-b-32">ViT_b_32</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: SGD</li></ul></blockquote></li><li><p>思路</p><blockquote><p>ViT_b_32 -&gt; Transforms ( Resize + ToTensor + Normalize) -&gt; Model Arch ( fc out 100 ) -&gt; Fine Tune</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-ViT.png" alt="Arch_ViT"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-ViT.png" alt="Loss_ViT"></p><blockquote><ul><li>Time: 0:11:34.681656</li><li>Min Loss: 0.1308</li><li>Final Loss: 0.1308</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：84.34 %</li></ul></blockquote></li></ol><h2 id="Swin-b">Swin_b</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: SGD</li></ul></blockquote></li><li><p>思路</p><blockquote><p>Swim_b -&gt; Transforms ( Resize + ToTensor + Normalize) -&gt; Model Arch ( fc out 100 ) -&gt; Fine Tune</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-Swin.png" alt="Arch_Swin"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-Swin.png" alt="Loss_Swin"></p><blockquote><ul><li>Time: 0:40:31.978593</li><li>Min Loss: 0.2692</li><li>Final Loss: 0.5661</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：83.53 %</li></ul></blockquote></li></ol><h1>四、对比分析</h1><table><thead><tr><th>Model</th><th>Total Params</th><th>Total Size</th><th>Min loss</th><th>Final Loss</th><th>Accuracy</th></tr></thead><tbody><tr><td>CNN_2</td><td>219,044</td><td>40.63</td><td>1.4500</td><td>1.9618</td><td>39.75 %</td></tr><tr><td>CNN_3</td><td>168,036</td><td>46.94</td><td>1.5404</td><td>1.9817</td><td>44.14 %</td></tr><tr><td>CNN_5</td><td>1,116,388</td><td>55.43</td><td>1.3080</td><td>1.5872</td><td>44.20 %</td></tr><tr><td>VGG19</td><td>139,979,940</td><td>773.24</td><td>0.3057</td><td>0.7126</td><td>71.61 %</td></tr><tr><td>ResNet101</td><td>42,705,060</td><td>593.20</td><td>0.0667</td><td>0.0942</td><td>83.92 %</td></tr><tr><td>ViT_b_32</td><td>87,532,132</td><td>263.59</td><td>0.1308</td><td>0.1308</td><td>84.34 %</td></tr><tr><td>Swin_b</td><td>86,845,724</td><td>425.33</td><td>0.2692</td><td>0.5661</td><td>83.53 %</td></tr></tbody></table><ol><li>对比自建 CNN 网络<ul><li>从 2 层 CNN 到 3 层 CNN 模型的总参数量有所下降，主要原因是 FC 层 Linear 函数的输入参数减少，导致了总参数量的下降。</li><li>从 2 层 CNN 到 3 层 CNN 模型准确率提升了约 4.39%；从 3 层 CNN 到 5 层 CNN 模型准确率几乎没有提升。虽然从 3 层到 5 层模型的总参数量扩大了约 6.64 倍，但是模型的性能没有显著提升，推测是因为此时模型深度的增加已经无法帮助模型学到更多有用的特征，且深度的增加也可能会导致模型出现过拟合现象，致使准确率无法得到进一步提升。</li></ul></li><li>对比经典 CNN 网络<ul><li>VGG19 模型拥有近 1.4 亿的参数量，其规模也是本次测试中最大的模型。 VGG19 的测试结果（71.61%），也证明了使用更小的卷积核（3 * 3）并且增加卷积神经网络的深度，可以有效地提升模型的性能。</li><li>ResNet101 通过引入残差块在网络内部跳跃连接，缓解了深度增加所导致的梯度消失的问题。从模型结果来看（83.92%），在增加模型深度，缓解梯度消失问题的同时也减少了参数量，相比于 VGG19 模型取得了更好的效果。</li></ul></li><li>对比 Transformer 网络<ul><li>本次所选用的 Transformer 网络都是该系列下的基础模型。ViT_b_32 模型 和 Swin_b 模型参数量相当，最后测试结果也较为接近，都具有较好的性能。</li><li>值得一提的是，在实际训练和测试时，Swin_b 模型对显存的占用非常高，训练时大约需要 15G 左右的显存空间，而测试时大概需要 30G 左右的显存空间，对硬件设备的要求很高。</li></ul></li></ol><h1>五、总结与优化</h1><h2 id="总结">总结</h2><ul><li>从自建 CNN 网络到 VGG 模型，可以看出增加网络的宽度和深度可以很好的提高模型的性能；但如果一直简单地增加深度，可能会遇到梯度爆炸或梯度消失的问题，对于前者可以尝试使用正则化的方式解决，但对于梯度消失的问题，就需要引入残差网络，在不增加额外参数的情况下，尽可能让深层次的模型得到充分训练，进而继续提升模型的性能，上述过程也在本次实验中得到了充分的验证。</li><li>转向 Transformer 架构，在 ViT 模型的思路下，用自注意力机制来捕捉全局图像信息，从而得到全连接的网络结构，能够很好的捕捉数据的特征；Swin 模型进一步采用分层的窗口化注意力机制和分层的网络结构，在降低计算复杂度的同时，也通过层级嵌套捕捉了多尺度的特征，使得模型在处理不同尺度的信息时更加灵活。</li><li>但是在本次实验中，ResNet 和 ViT 以及 Swin 的模型性能（测试集准确率）相近，没能很好的展现出 Transformer 架构在 CV 领域的巨大潜力。推测其中的原因，一是 ResNet 残差网络的性能确实很好，能够非常显著的降低梯度消失风险、提升 CNN 网络的性能；二是本次实验所选用的 CIFAR100 数据集相对原本的 ImageNet 而言更简单，用 ResNet 模型就足以捕捉其中的关键特征，能够较好的完成分类任务，ViT 和 Swin 的潜力没能得到充分发挥；三是模型的选用及训练策略的不足，本次实验选用的 ResNet 模型为 101 层，而 ViT 和 Swin 都只选用了 Base 模型，同时训练的 Epoch 较少，损失函数和优化器的选用没有做进一步的比对分析，学习率也没有做进一步的尝试。</li></ul><h2 id="优化">优化</h2><ul><li>宏观层面，下一步将继续尝试不同的模型，结合模型结构和实验结果分析每种模型的特点、改进点。</li><li>微观层面，下一步将尝试调整训练策略，增加 Epoch 的同时引入验证集，根据验证集准确率等指标提前停止训练防止模型过拟合现象的产生，同时将尝试不同的损失函数和优化器，以及综合使用 Warm up、余弦退火等技巧逐步改善学习率，进一步提升模型的性能。</li></ul>]]></content>
    
    
    <summary type="html">CIFAR100 经典 CNN 与 ViT 模型对比</summary>
    
    
    
    <category term="AI" scheme="https://www.angfff.top/categories/AI/"/>
    
    <category term="CV" scheme="https://www.angfff.top/categories/AI/CV/"/>
    
    
    <category term="DL" scheme="https://www.angfff.top/tags/DL/"/>
    
    <category term="CV" scheme="https://www.angfff.top/tags/CV/"/>
    
    <category term="CNN" scheme="https://www.angfff.top/tags/CNN/"/>
    
    <category term="ViT" scheme="https://www.angfff.top/tags/ViT/"/>
    
    <category term="Transformer" scheme="https://www.angfff.top/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>每日LeetCode_230903</title>
    <link href="https://www.angfff.top/posts/4d3cdec0.html"/>
    <id>https://www.angfff.top/posts/4d3cdec0.html</id>
    <published>2023-09-03T14:26:37.000Z</published>
    <updated>2025-05-22T04:31:09.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-寻找两个正序数组的中位数">4.寻找两个正序数组的中位数</h2><h3 id="（1）题目">（1）题目</h3><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li></ul><h3 id="（2）题解">（2）题解</h3><blockquote><p>给定两个有序数组，要求找到两个有序数组的中位数，最直观的思路有以下两种：</p><ol><li>使用归并的方式，合并两个有序数组，得到一个大的有序数组。大的有序数组的中间位置的元素，即为中位数。第一种思路的时间复杂度是 O(m+n) ，空间复杂度是 O(m+n) ；</li><li>不需要合并两个有序数组，只要找到中位数的位置即可。由于两个数组的长度已知，因此中位数对应的两个数组的下标之和也是已知的。维护两个指针，初始时分别指向两个数组的下标 0 的位置，每次将指向较小值的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到到达中位数的位置。空间复杂度降到 O(1) ，时间复杂度仍是 O(m+n) ；</li></ol></blockquote><ul><li><p>不合并数组，依次取数，直至中位数位置</p><p>中位数的位置一定在 (m+n)/2 附近：</p><ul><li>如果是偶数，中位数就是最后取的两个数的平均数；</li><li>如果是奇数，中位数就是最后取的那个数。</li></ul><p>取数阶段，循环 (m + n) / 2.0 + 1 次即可；判断中位数时，关键是奇数情况，可能有指针溢出，需要判断一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 nums1 和 nums2 中每次取一个数，直到取出的数的个数 &lt;= (m+n)/2 + 1</span></span><br><span class="line"><span class="type">int</span> m = nums<span class="number">1.</span><span class="built_in">size</span>(), n = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>; <span class="comment">// x, y 分别是 nums1 和 nums2 的下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (m + n) / <span class="number">2.0</span> + <span class="number">1</span>; ++i)&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; m &amp;&amp; y &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1[x] &lt; nums2[y]) ++x;</span><br><span class="line">    <span class="keyword">else</span> ++y;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (x &lt; m) ++x;</span><br><span class="line">  <span class="keyword">else</span> ++y;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> (nums1[x - <span class="number">1</span>] + nums2[y - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt;= m)&#123;</span><br><span class="line">    <span class="keyword">return</span> nums1[x - <span class="number">1</span>];</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (y &gt;= n)&#123;</span><br><span class="line">    <span class="keyword">return</span> nums2[y - <span class="number">1</span>];</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(nums1[x - <span class="number">1</span>], nums2[y - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法测试用例可行，但 LeetCode 无法通过，可能是指针溢出形成空指针不被允许。</p></li><li><p>改进</p><p>我们首先计算出两个数组的长度，然后将它们的长度相加，得到总长度。接下来，我们使用一个循环来遍历这两个数组，直到到达中位数的位置。在循环中，我们维护两个指针 <code>aStart</code> 和 <code>bStart</code>，它们分别指向两个数组的下标 0 的位置。我们还维护两个变量 <code>left</code> 和 <code>right</code>，它们分别表示当前的中位数和前一个元素。在每次循环中，我们将 <code>left</code> 的值更新为 <code>right</code>，然后将指向较小值的指针后移一位。最后，如果总长度是偶数，则中位数是 <code>left</code> 和 <code>right</code> 的平均值，否则中位数是 <code>right</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m = nums<span class="number">1.</span><span class="built_in">size</span>(), n = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> len = m + n;</span><br><span class="line"><span class="type">int</span> left = <span class="number">-1</span>, right = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> aStart = <span class="number">0</span>, bStart = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len / <span class="number">2</span>; i++)&#123;</span><br><span class="line">left = right;</span><br><span class="line">  <span class="keyword">if</span> (aStart &lt; m &amp;&amp; (bStart &gt;= n || nums1[aStart] &lt; nums2[bStart]))&#123;</span><br><span class="line">    right = nums1[aStart++];</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    right = nums2[bStart++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> (left + right) / <span class="number">2.0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二分查找</p><p>如果对时间复杂度的要求有 log⁡ ，通常都需要用到二分查找：</p><p>根据中位数的定义，当 m+n 是奇数时，中位数是两个有序数组中的第 (m+n)/2 个元素，当 m+n 是偶数时，中位数是两个有序数组中的第 (m+n)/2 个元素和第 (m+n)/2+1 个元素的平均值。因此，这道题可以转化成寻找两个有序数组中的第 k 小的数，其中 k 为 (m+n)/2 或 (m+n)/2+1 。</p><p>假设两个有序数组分别是 A 和 B。要找到第 k 个元素，我们可以比较 A[k/2−1] 和 B[k/2−1] ，其中 / 表示整数除法。由于 A 和 B 的前面分别有  k/2−1 个元素，对于 A[k/2−1] 和 B[k/2−1] 中的较小值，最多只会有 (k/2−1)+(k/2−1)≤k−2 个元素比它小，那么它就不能是第 k 小的数了。</p><p>因此我们可以归纳出三种情况：</p><ol><li>如果 A[k/2−1]&lt;B[k/2−1] ，则比 A[k/2−1] 小的数最多只有 A 的前 k/2−1 个数和 B 的前 k/2−1 个数，即比 A[k/2−1] 小的数最多只有 k−2 个，因此 A[k/2−1] 不可能是第 k 个数，A[0] 到 A[k/2−1] 也都不可能是第 k 个数，可以全部排除。</li><li>如果 A[k/2−1]&gt;B[k/2−1] ，则可以排除 B[0] 到 B[k/2−1] 。</li><li>如果 A[k/2−1]=B[k/2−1] ，则可以归入第一种情况处理。</li></ol><p><img src="https://assets.leetcode-cn.com/solution-static/4/4_fig1.png" alt=""></p><p>可以看到，比较 A[k/2−1] 和 B[k/2−1] 之后，可以排除 k/2 个不可能是第 k 小的数，查找范围缩小了一半。同时，我们将在排除后的新数组上继续进行二分查找，并且根据我们排除数的个数，减少 k 的值，这是因为我们排除的数都不大于第 k 小的数。</p><p>有以下三种情况需要特殊处理：</p><ol><li>如果 A[k/2−1] 或者 B[k/2−1] 越界，那么我们可以选取对应数组中的最后一个元素。在这种情况下，我们必须根据排除数的个数减少 k 的值，而不能直接将 k 减去 k/2。</li><li>如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第 k 小的元素。</li><li>如果 k=1 ，我们只要返回两个数组首元素的最小值即可。</li></ol><p>用一个例子说明上述算法。假设两个有序数组如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: 1 3 4 9</span><br><span class="line">B: 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>两个有序数组的长度分别是 4 和 9，长度之和是 13，中位数是两个有序数组中的第 7 个元素，因此需要找到第 k=7 个元素。</p><p>比较两个有序数组中下标为 k/2−1=2 的数，即 A[2]=4 和 B[2]=3 ，如下面所示：<br>由于 A[2]&gt;B[2] ，因此排除 B[0] 到 B[2] ，即数组 B 的下标偏移（offset）变为 3，同时更新 k 的值：k=k−k/2=4。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: 1 3 4 9</span><br><span class="line">B: [1 2 3] 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>下一步寻找，比较两个有序数组中下标为 k/2−1=1 的数，即 A[1]=3 和 B[4]=5 ，如下面所示，其中方括号部分表示已经被排除的数。<br>由于 A[1]&lt;B[4]，因此排除 A[0] 到 A[1]，即数组 A 的下标偏移变为 2，同时更新 k 的值：k=k−k/2=2。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: [1 3] 4 9</span><br><span class="line">B: [1 2 3] 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>下一步寻找，比较两个有序数组中下标为 k/2−1=0 的数，即比较 A[2]=4 和 B[3]=4 ，如下面所示，其中方括号部分表示已经被排除的数。<br>由于 A[2]=B[3]，根据之前的规则，排除 A 中的元素，因此排除 A[2] ，即数组 A 的下标偏移变为 3 ，同时更新 k 的值： k=k−k/2=1 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: [1 3 4] 9</span><br><span class="line">B: [1 2 3] 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>由于 k 的值变成 1，因此比较两个有序数组中的未排除下标范围内的第一个数，其中较小的数即为第 k 个数，由于 A[3]=9&gt;B[3]=4 ，因此第 k 个数是 B[3]=4。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthElement</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class="line"><span class="comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> m = nums<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (index1 == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="type">int</span> newIndex1 = <span class="built_in">min</span>(index1 + k / <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> newIndex2 = <span class="built_in">min</span>(index2 + k / <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> pivot1 = nums1[newIndex1];</span><br><span class="line">            <span class="type">int</span> pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= newIndex1 - index1 + <span class="number">1</span>;</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= newIndex2 - index2 + <span class="number">1</span>;</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> totalLength = nums<span class="number">1.</span><span class="built_in">size</span>() + nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKthElement</span>(nums1, nums2, (totalLength + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span>) + <span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="（3）知识点">（3）知识点</h3><ul><li><a href="https://suanfa8.com/binary-search">二分查找总结</a></li><li><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/39941/jiang-qi-zhuan-wei-zhao-liang-ge-you-xu-shu-zu-de-/">本题思路 1</a></li><li><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/6098/4-xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu/">本题思路 2</a></li></ul>]]></content>
    
    
    <summary type="html">每日LeetCode 寻找两个正序数组的中位数</summary>
    
    
    
    <category term="算法" scheme="https://www.angfff.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://www.angfff.top/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://www.angfff.top/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://www.angfff.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>每日LeetCode_230902</title>
    <link href="https://www.angfff.top/posts/3a3bee56.html"/>
    <id>https://www.angfff.top/posts/3a3bee56.html</id>
    <published>2023-09-02T14:20:44.000Z</published>
    <updated>2025-05-22T04:31:09.390Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-无重复字符的最长子串">3. 无重复字符的最长子串</h2><h3 id="（1）题目">（1）题目</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 </span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h3 id="（2）题解">（2）题解</h3><ul><li><p>暴力循环</p><p>两层循环，外层循环从左侧开始，依次移动；内层循环从外层循环的下一个位置开始移动，每移动一次检测是否有重复，若有重复，则找到当前起始位置的最长子串，停止内层循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表，用于检测是否有重复字符</span></span><br><span class="line">unordered_set&lt;<span class="type">char</span>&gt; HashTable;</span><br><span class="line"><span class="comment">// 最长子串长度</span></span><br><span class="line"><span class="type">int</span> maxlength = <span class="number">0</span>;       </span><br><span class="line"><span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 外层循环从左向右遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">  HashTable.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">  <span class="comment">// 内层循环从 i + 1 开始向右遍历</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">    <span class="comment">// 如果 j 到达边界，或者出现重复字符</span></span><br><span class="line">    <span class="keyword">if</span>(j == n || HashTable.<span class="built_in">find</span>(s[j]) != HashTable.<span class="built_in">end</span>())&#123;</span><br><span class="line">      <span class="comment">// 更新最长子串长度</span></span><br><span class="line">      maxlength = <span class="built_in">max</span>(maxlength, j - i);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，将 s[j] 加入哈希表</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      HashTable.<span class="built_in">insert</span>(s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清空哈希表</span></span><br><span class="line">  HashTable.<span class="built_in">clear</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxlength;</span><br></pre></td></tr></table></figure><p>该方法在每次外层循环时都要重建哈希表，对于内存的占用过高；同时，因为有两层循环，且每次都是逐个字母检测，耗时过长，并不推荐使用。</p></li><li><p>滑动窗口</p><p>假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 rk 。 那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 rk 的字符显然是不重复的，并且由于少了原本的第 k 个字符，可以尝试继续增大 rk ，直到右侧出现了重复字符为止。</p><ul><li><p>使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表「枚举子串的起始位置」，右指针代表窗口的结束位置 rk ；</p></li><li><p>在每一步的操作中，将左指针向右移动一格，表示开始枚举下一个字符作为起始位置，然后不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着<em><strong>以左指针开始的，不包含重复字符的最长子串</strong></em>；</p></li><li><p>判断重复字符：哈希表（即 C++ 中的 std::unordered_set，Java 中的 HashSet，Python 中的 set, JavaScript 中的 Set）。在左指针向右移动的时候，从哈希集合中移除一个字符，在右指针向右移动的时候，往哈希集合中添加一个字符。</p><p><strong>注意：这里所使用的哈希表只是为了确认每次加入的新字母是否与已有序列重复，因此加入后，统计表中的新字母的个数即可。</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">      unordered_set&lt;<span class="type">char</span>&gt; occ;</span><br><span class="line">      <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">      <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">      <span class="type">int</span> rk = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 枚举左指针的位置，初始值隐性地表示为 -1</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">          occ.<span class="built_in">erase</span>(s[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.<span class="built_in">count</span>(s[rk + <span class="number">1</span>]))&#123;</span><br><span class="line">          <span class="comment">// 不断地移动右指针</span></span><br><span class="line">          occ.<span class="built_in">insert</span>(s[rk + <span class="number">1</span>]);</span><br><span class="line">          ++rk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>进一步改进，出现重复字符就缩小窗口</p><p>外层循环改进为 右指针到达字符串末尾就停止循环，这样可以减少一定的循环次数；</p><p>循环内，仅用了 c 和 d 两个临时变量用于存储窗口的边界字符，并利用此检测是否有重复字符以及增减出现次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 记录最长集合</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>; <span class="comment">// 窗口左指针</span></span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>; <span class="comment">// 窗口右指针</span></span><br><span class="line">        <span class="comment">// 哈希表，记录每个字符是否出现过</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line">        <span class="comment">// 外层循环，扩张窗口</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[right]; <span class="comment">// 记录右指针字符</span></span><br><span class="line">            right++;</span><br><span class="line">            window[c]++; <span class="comment">// 将 c 在哈希表中出现的次数+1</span></span><br><span class="line">            <span class="comment">// 如果出现重复字符，就缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span> (window[c] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">char</span> d = s[left]; <span class="comment">// 记录左指针字符</span></span><br><span class="line">                left++;</span><br><span class="line">                window[d]--; <span class="comment">// 减少 d 的出现次数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最长集合</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>window[c]++</code> 这一句代码的意思是将字符 <code>c</code> 在 <code>window</code> 映射中的出现次数加 1。如果 <code>c</code> 在 <code>window</code> 映射中不存在，则会自动插入一个键值对 <code>(c, 0)</code>，然后将出现次数加 1。这个操作可以用来维护当前窗口中每个字符的出现次数。</p></blockquote></li></ul><h3 id="（3）知识点">（3）知识点</h3><ol><li>滑动窗口算法：该算法是一种常用的解决字符串子串问题的方法。它通过维护一个窗口，来遍历字符串中的所有子串。在每次移动窗口时，可以通过一些技巧来避免重复计算，从而达到线性时间复杂度的目的。</li><li>哈希表：哈希表是一种常用的数据结构，可以用来快速地查找和插入元素。在本题中，我们可以使用哈希表来维护当前窗口中每个字符的出现次数。</li><li>双指针：双指针是一种常用的技巧，可以使用两个指针 <code>i</code> 和 <code>j</code> 来维护当前窗口的左右边界。</li></ol>]]></content>
    
    
    <summary type="html">每日LeetCode 无重复字符的最长子串</summary>
    
    
    
    <category term="算法" scheme="https://www.angfff.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://www.angfff.top/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://www.angfff.top/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://www.angfff.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门</title>
    <link href="https://www.angfff.top/posts/89826705.html"/>
    <id>https://www.angfff.top/posts/89826705.html</id>
    <published>2023-08-31T15:14:57.000Z</published>
    <updated>2025-05-22T04:31:09.390Z</updated>
    
    <content type="html"><![CDATA[<h1>Docker 入门</h1><h2 id="一、-Docker-介绍">一、 Docker 介绍</h2><p>Docker 是一个用于 构建(build)、运行(run)、传送(share) 应用程序的平台。</p><p>通过 Docker 我们可以将应用程序及其运行时所依赖的环境、第三方软件库、配置文件等打包在一起，行成一个个“集装箱”，运送至其他平台，以便于在任何环境中正确地运行。</p><h2 id="二、-Docker-应用场景">二、 Docker 应用场景</h2><blockquote><p>应用隔离、环境配置、 安装部署、持续集成、持续发布、DevOps</p></blockquote><p>例如，我们利用目前较为主流的前后端分离架构写了一个网站，前端使用 Vue 来构建网站的界面，后端使用 Java 的 SpringBoot 微服务架构来提供各种服务和接口，使用 MySQL 数据库来存储数据。</p><p>如果不使用 Docker，我们需要先安装 NodeJs 环境、安装各种 npm 依赖包，配置 Java 运行环境，安装 SpringBoot 微服务的各种第三方依赖包，安装 MySQL 数据库，以及配置各种环境变量、启动服务等。与此同时，如果要把该网站部署在测试环境和生产环境上，还需要将上述步骤再重复一遍。</p><p>相反，如果我们使用 Docker，只要我们在开发环境中配置好了所有环境并将其打包成一个“集装箱”，那么就可以直接在其他环境中直接运行。</p><h2 id="三、容器和虚拟机的区别">三、容器和虚拟机的区别</h2><h3 id="（一）传统虚拟机">（一）传统虚拟机</h3><p>传统虚拟机软件包括：VMware 、 Virtalbox、 Parallels Desktop 、 WSL 、 Hyper-V 等</p><p>虚拟机是完整的操作系统，可以在该操作系统中运行各种支持的应用程序。虚拟机实际上是利用 虚拟化技术(Hypervisor) 将物理资源虚拟化为多个逻辑资源，它可以将一个物理服务器虚拟为多个逻辑服务器，每个逻辑服务器都有自己的操作系统、 CPU 、内存、硬盘和网络接口等。逻辑服务器之间是完全隔离的，可以独立运行。</p><p>虚拟机在一定程度上实现了资源的整合，可以将一台服务器的计算能力、存储能力、网络资源分配给多台虚拟服务器，实现多台服务器的功能。但虚拟机也存在一定的缺点，每台虚拟服务器都将占用非常多的资源，且启动速度慢。</p><p>实际上我们并不需要让每台服务器都运行多个虚拟机。通常情况下，每台物理服务器都有其特定的用途，如 Web 服务器只需提供收发数据包的功能即可，并不需要一个完整的操作系统，因此没有必要在该服务器上使用虚拟机来收发数据包。</p><h3 id="（二）容器">（二）容器</h3><p>容器是一个虚拟化技术，一定程度上类似虚拟机，是一个独立的环境。Docker 是容器的一种实现方式，是一个容器话的解决方案和平台。</p><p>与虚拟机不同的是，容器中并不需要运行一个完整的操作系统便可以运行应用程序，因此其占用的资源更少、启动速度更快。</p><h2 id="四、基本原理">四、基本原理</h2><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Docker%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.jpeg" alt="Docker基本概念"></p><h3 id="（一）镜像-images">（一）镜像 images</h3><p>镜像是一个只读模版，可以用来创建容器。（类）</p><h3 id="（二）容器-containers">（二）容器 containers</h3><p>容器是 Docker 的运行实例，提供了一个独立的可移植的环境，可以在该环境中运行应用程序。（对象）</p><h3 id="（三）仓库-registry">（三）仓库 registry</h3><p>用于存储 Docker 镜像。</p><h2 id="五、安装配置">五、安装配置</h2><h3 id="（一）安装">（一）安装</h3><ul><li><p>macOS 安装</p><p>下载安装即可。安装后运行 Docker，便可以在终端中使用 Docker 命令。</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Docker%E5%AE%89%E8%A3%85.png" alt="Docker安装"></p></li><li><p>Windows 安装</p><p>下载安装完毕后，需要在系统设置-Windows 功能中开启 Hyper-V 功能，才能正常启用 Docker 。</p></li></ul><h3 id="（二）容器化">（二）容器化</h3><ol><li>将应用程序打包成容器，然后在容器中运行应用程序的过程。</li><li>容器化步骤：<ol><li>创建一个 Dockerfile ；</li><li>使用 Dockerfile 构建镜像；</li><li>使用镜像创建和运行容器。</li></ol></li><li>Dockerfile：文本文件，包含了多条指令，用于指导 Docker 构建镜像。通常包括精简版的操作系统、应用程序的运行环境、应用程序本体、第三方依赖包或库、应用程序的配置文件、环境变量等。</li></ol><h2 id="六、常用命令">六、常用命令</h2><p><a href="https://www.runoob.com/docker/docker-command-manual.html">Docker 常用命令</a></p><h2 id="七、构建镜像并启动容器">七、构建镜像并启动容器</h2><h3 id="（一）创建-Dockerfile-文件">（一）创建 Dockerfile 文件</h3><ol><li><p>创建 HelloDocker 文件夹；</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/1-1%20%E5%88%9B%E5%BB%BA%20HelloDocker%20%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt=""></p></li><li><p>在项目文件夹中创建 index.js 文件并键入简单 JS 命令，使之在控制台输出语句；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在控制台输出语句</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/1-2%20%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F.png" alt=""></p><p>现在，在开发环境中已经可以输出语句了；</p><p>但是，如果我们需要在其他环境也运行该程序，就需要安装兼容的操作系统、JS 运行环境 NodeJS，并将该程序及其依赖包和配置文件一并复制到新的环境中，才能正常运行；</p><p>此时，就可以利用 Docker，将这些步骤打包起来，写入 Dockerfile 文件中。</p></li><li><p>在项目文件夹中创建 Dockerfile 文件并写入相关命令；</p><ol><li><p>设置镜像</p><p>镜像是按层次结构来构建的，每一层都是基于上一层的，因此需要先指定一个基础镜像；然后在该镜像的基础上添加应用程序。</p><p>这里使用到了 NodeJS ，因此需要添加其对应的基础镜像，本来应该从 Linux 的基础镜像（操作系统）开始，例如 alpine ，但 NodeJS 的镜像实际上已经是基于 Alpine 镜像构建的了，所以我们可以直接使用 NodeJS 的镜像作为我们的基础镜像。</p></li><li><p>将应用程序复制到 Docker 中</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> 源文件路径 目标路径</span></span><br></pre></td></tr></table></figure></li><li><p>在镜像中运行应用程序</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;可执行程序名&quot;</span>, <span class="string">&quot;可执行程序接受的参数&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/1-3%20%E7%BC%96%E5%86%99%20Dockerfile%20%E6%96%87%E4%BB%B6.png" alt=""></p></li></ol></li></ol><h3 id="（二）创建镜像">（二）创建镜像</h3><ol><li><p>在终端中创建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t 镜像名称[:版本号] 目录</span><br><span class="line">// 版本号可省略，不指定版本默认使用最新版本</span><br><span class="line">// . 表示当前目录</span><br></pre></td></tr></table></figure><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/2-1%20%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F.png" alt=""></p></li><li><p>查看镜像是否创建成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">// docker image ls</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/2-2%20%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F.png" alt=""></p><h3 id="（三）运行镜像">（三）运行镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run 镜像名称</span><br></pre></td></tr></table></figure><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/2-3%20%E8%BF%90%E8%A1%8C%E9%95%9C%E5%83%8F.png" alt=""></p><h3 id="（四）在其他环境中运行镜像">（四）在其他环境中运行镜像</h3><ul><li><p>将镜像复制到当前环境中，运行即可；</p></li><li><p>将镜像上传至 Dockerhub 中，在任意环境中 pull 拉取再运行即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 用户名/镜像名称</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">容器是将操作系统层虚拟化，虚拟机则是虚拟化硬件。借助 Docker 可以更便捷地实现应用的开发、交付和运行。</summary>
    
    
    
    <category term="必备工具" scheme="https://www.angfff.top/categories/%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Docker" scheme="https://www.angfff.top/categories/%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/Docker/"/>
    
    
    <category term="必备工具" scheme="https://www.angfff.top/tags/%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Docker" scheme="https://www.angfff.top/tags/Docker/"/>
    
  </entry>
  
</feed>
