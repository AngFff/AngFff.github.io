<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AngFff&#39;s Blog</title>
  
  
  <link href="https://www.angfff.top/atom.xml" rel="self"/>
  
  <link href="https://www.angfff.top/"/>
  <updated>2025-03-06T04:40:56.796Z</updated>
  <id>https://www.angfff.top/</id>
  
  <author>
    <name>AngFff</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>互联网产品分析笔记(二)</title>
    <link href="https://www.angfff.top/posts/412c0b00.html"/>
    <id>https://www.angfff.top/posts/412c0b00.html</id>
    <published>2025-02-19T03:02:50.000Z</published>
    <updated>2025-03-06T04:40:56.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="飞猪（Fliggy）">飞猪（Fliggy）</h2><h3 id="产品概述"><strong>产品概述</strong></h3><p>飞猪（Fliggy）是阿里巴巴集团旗下的在线旅游平台，提供机票、酒店、火车票、度假套餐、签证办理等一站式旅行服务。作为国内OTA（在线旅游代理）市场的重要玩家，飞猪依托阿里生态，为用户提供个性化的旅行方案，并结合支付宝、小红书等平台打造社交化旅行体验。</p><h3 id="核心功能"><strong>核心功能</strong></h3><ol><li><strong>机票与酒店预订</strong>：提供国内外航班与酒店预订，支持多种支付方式和优惠补贴。</li><li><strong>旅行套餐</strong>：整合机票+酒店+景点门票，为用户提供一站式出行方案。</li><li><strong>信用住</strong>：依托芝麻信用，用户可“先住后付”，降低入住门槛。</li><li><strong>火车票与签证办理</strong>：支持12306购票，并提供全球签证办理服务。</li><li><strong>会员体系</strong>：飞猪F3/F4会员享受专属折扣、快速退改签等权益。</li><li><strong>旅游直播</strong>：与达人合作直播带货，推荐旅行产品，提高用户购买转化率。</li></ol><h3 id="用户体验评估"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>阿里生态整合</strong>：与支付宝、淘宝、小红书联动，实现无缝支付和社交分享。</li><li><strong>信用体系完善</strong>：芝麻信用体系降低用户预订成本，提高信任度。</li><li><strong>价格竞争力强</strong>：依托大数据动态定价，提供个性化优惠。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>品牌认知度相对较低</strong>，相比携程、美团在OTA市场仍有劣势。</li><li><strong>国际航班和酒店资源相对有限</strong>，在高端市场竞争力不足。</li><li><strong>客服响应速度偶尔较慢</strong>，影响用户体验。</li></ul></li></ul><h3 id="商业模式解释"><strong>商业模式解释</strong></h3><ol><li><strong>佣金收入</strong>：与航司、酒店、旅行社合作，收取交易佣金。</li><li><strong>会员付费</strong>：F4会员可获得更高折扣和专属权益，提高复购率。</li><li><strong>广告投放</strong>：品牌方可在飞猪进行搜索排名、定向投放，提高曝光率。</li><li><strong>供应链合作</strong>：与酒店、景区、航空公司联合推出专属产品。</li></ol><h3 id="竞争分析"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>携程（Ctrip）</strong>：行业龙头，资源丰富，覆盖高端市场。</li><li><strong>美团旅行</strong>：依托美团生态，主打本地化旅游与性价比。</li><li><strong>去哪儿</strong>：擅长机票比价，吸引价格敏感型用户。</li></ul></li><li><strong>优势</strong>：<ul><li><strong>阿里流量扶持</strong>，可直接转化淘宝/支付宝用户。</li><li><strong>信用住等创新产品</strong>，降低用户预订门槛，提高信任感。</li></ul></li><li><strong>劣势</strong>：<ul><li><strong>市场份额相对较低</strong>，用户心智仍主要集中在携程、美团等平台。</li><li><strong>缺乏差异化竞争力</strong>，在高端商旅市场吸引力较弱。</li></ul></li></ul><h3 id="运营策略"><strong>运营策略</strong></h3><ol><li><strong>强化品牌认知</strong>：增加营销推广，提高用户对飞猪的品牌认可度。</li><li><strong>优化国际化布局</strong>：拓展海外酒店、航司合作，提高全球覆盖率。</li><li><strong>提升服务体验</strong>：优化客服响应，增强售后保障，提高用户满意度。</li><li><strong>拓展年轻用户市场</strong>：通过直播、短视频等方式，加强年轻用户的互动体验。</li></ol><h3 id="改进建议"><strong>改进建议</strong></h3><ol><li><strong>优化搜索与推荐算法</strong>：提升个性化推荐能力，提高用户转化率。</li><li><strong>增强国际业务拓展</strong>：与更多国际酒店、航司合作，吸引海外用户。</li><li><strong>提升会员权益</strong>：增加F3/F4会员独家折扣，增强用户忠诚度。</li><li><strong>减少广告干扰</strong>：优化页面信息流，提高用户体验。</li></ol><h3 id="总结"><strong>总结</strong></h3><p>飞猪依托阿里生态，在OTA市场具备一定竞争力，但仍需进一步强化品牌认知、优化国际化布局，并提升用户体验，才能在竞争激烈的旅游市场中抢占更多份额。</p><hr><h2 id="网易云音乐（NetEase-Cloud-Music）">网易云音乐（NetEase Cloud Music）</h2><h3 id="产品概述-2"><strong>产品概述</strong></h3><p>网易云音乐是中国主流在线音乐平台之一，以个性化推荐、用户社区和高质量曲库为核心竞争力。自2013年推出以来，网易云音乐凭借UGC（用户生成内容）+ PGC（专业生成内容）双重生态，以及“乐评文化”打造了独特的音乐社区，吸引了大量年轻用户。</p><h3 id="核心功能-2"><strong>核心功能</strong></h3><ol><li><strong>个性化推荐</strong>：基于用户听歌习惯，AI算法推荐每日歌曲、私人歌单、电台等。</li><li><strong>用户社区</strong>：用户可在歌曲评论区互动，形成独特的“乐评文化”。</li><li><strong>社交功能</strong>：支持创建歌单、发布动态、音乐匹配交友等。</li><li><strong>直播与K歌</strong>：提供音乐直播、K歌房，增强互动性和变现能力。</li><li><strong>版权内容</strong>：涵盖华语、日韩、欧美等多种曲库，同时发展独立音乐人扶持计划。</li><li><strong>HiFi音质</strong>：提供无损音乐、高级音效，为发烧友提供高质量听觉体验。</li></ol><h3 id="用户体验评估-2"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>个性化推荐精准，增强用户粘性。</li><li>乐评社区活跃，形成差异化社交氛围。</li><li>界面设计美观，用户体验较佳。</li></ul></li><li><strong>不足</strong>：<ul><li>版权库相较于QQ音乐、Apple Music等仍有短板。</li><li>会员体系复杂，部分功能需额外付费，用户体验受影响。</li><li>由于UGC内容开放，部分评论质量较低，影响社区氛围。</li></ul></li></ul><h3 id="商业模式解释-2"><strong>商业模式解释</strong></h3><ol><li><strong>会员订阅</strong>：黑胶VIP提供无损音质、曲库解锁、专属音效等权益。</li><li><strong>广告收入</strong>：信息流广告、开屏广告、品牌合作营销等。</li><li><strong>直播打赏</strong>：用户可在音乐直播、K歌房内购买虚拟礼物，平台抽成。</li><li><strong>数字专辑与付费单曲</strong>：支持歌手发布专辑，用户可购买数字音乐内容。</li><li><strong>音乐人扶持计划</strong>：与独立音乐人合作，分成收益，提高平台原创内容比重。</li></ol><h3 id="竞争分析-2"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>QQ音乐</strong>（腾讯生态加持，曲库优势明显）。</li><li><strong>Apple Music、Spotify</strong>（在国际市场竞争激烈，付费模式成熟）。</li><li><strong>酷狗音乐、咪咕音乐</strong>（国内市场竞争者，但社区属性较弱）。</li></ul></li><li><strong>优势</strong>：<ul><li>乐评文化和社交互动，用户粘性强。</li><li>个性化推荐领先，算法优化较好。</li></ul></li><li><strong>劣势</strong>：<ul><li>版权问题仍是短板，热门歌曲可能受限。</li><li>变现能力仍低于腾讯系音乐平台。</li></ul></li></ul><h3 id="运营策略-2"><strong>运营策略</strong></h3><ol><li><strong>扩展版权合作</strong>：加大投入获取更多独家曲库，提高用户留存。</li><li><strong>优化会员体系</strong>：简化VIP功能，让用户更容易理解并愿意付费。</li><li><strong>提升UGC社区质量</strong>：加强乐评内容审核，扶持优质音乐内容创作者。</li><li><strong>拓展国际市场</strong>：利用中国音乐出海趋势，吸引海外用户。</li></ol><h3 id="改进建议-2"><strong>改进建议</strong></h3><ol><li><strong>优化音乐推荐机制</strong>：增强用户自主探索能力，减少算法“听觉过滤泡沫”。</li><li><strong>减少广告干扰</strong>：优化免费用户体验，减少过多的商业化推广。</li><li><strong>提高社交玩法</strong>：增加更多互动玩法，如虚拟演唱会、AI作曲功能等。</li><li><strong>加强数据安全与隐私保护</strong>：优化用户数据管理，提升平台信任度。</li></ol><h3 id="总结-2"><strong>总结</strong></h3><p>网易云音乐凭借个性化推荐和社区氛围，在在线音乐市场形成独特优势。然而，面对版权竞争、变现挑战，平台需要进一步优化商业模式、提升用户体验，并在内容生态、国际化方面寻找新的增长点，以保持市场竞争力。</p><hr><h2 id="剪映（CapCut）">剪映（CapCut）</h2><h3 id="产品概述-3"><strong>产品概述</strong></h3><p>剪映（CapCut）是字节跳动推出的一款全能视频剪辑工具，支持移动端和PC端操作，主打“简单易用+强大功能”的剪辑体验。作为抖音官方推荐的视频编辑工具，剪映凭借强大的特效、AI功能和免费无水印优势，迅速成为短视频创作者的首选。</p><h3 id="核心功能-3"><strong>核心功能</strong></h3><ol><li><strong>多轨剪辑</strong>：支持视频、音频、文本多轨编辑，适合专业级剪辑需求。</li><li><strong>智能字幕</strong>：自动语音识别生成字幕，提高编辑效率。</li><li><strong>AI特效与滤镜</strong>：丰富的动态特效、滤镜、转场，降低创作门槛。</li><li><strong>音乐与音效库</strong>：提供海量版权音乐和音效，适用于不同场景。</li><li><strong>智能抠像</strong>：无需绿幕，一键去除背景，适用于短视频创作。</li><li><strong>一键成片</strong>：内置视频模板和智能生成工具，降低新手剪辑难度。</li><li><strong>云端存储</strong>：支持多设备协同编辑，提升工作流效率。</li></ol><h3 id="用户体验评估-3"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>界面简洁，功能强大，适合新手和专业用户。</li><li>AI自动化剪辑工具降低操作门槛，提高效率。</li><li>免费无水印，相比同类产品（如VN、KineMaster）竞争力更强。</li></ul></li><li><strong>不足</strong>：<ul><li>PC端功能相较于专业剪辑软件（如Premiere、Final Cut Pro）仍有差距。</li><li>云端存储需要优化，部分用户反馈同步速度较慢。</li><li>依赖字节跳动生态，海外市场拓展仍受竞争压力。</li></ul></li></ul><h3 id="商业模式解释-3"><strong>商业模式解释</strong></h3><ol><li><strong>免费基础功能</strong>：提供完整的基础剪辑功能，吸引用户规模。</li><li><strong>增值订阅</strong>：剪映专业版提供更高级的特效、模板、云存储空间等。</li><li><strong>企业服务</strong>：为品牌方、内容机构提供定制化剪辑工具和广告素材优化服务。</li><li><strong>与抖音/海外TikTok联动</strong>：引导用户在剪映编辑后直接分享到短视频平台，提高生态闭环变现能力。</li></ol><h3 id="竞争分析-3"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>CapCut（国际版剪映）</strong>：在海外市场与Adobe Rush、iMovie等竞争。</li><li><strong>VN、KineMaster</strong>（移动端剪辑工具，部分提供高级订阅功能）。</li><li><strong>Premiere、Final Cut Pro</strong>（高端专业剪辑软件，适用于电影级制作）。</li></ul></li><li><strong>优势</strong>：<ul><li>AI智能化剪辑工具，使小白用户也能轻松上手。</li><li>与抖音、TikTok生态紧密结合，形成用户增长飞轮。</li></ul></li><li><strong>劣势</strong>：<ul><li>在专业剪辑领域竞争力不足，难以吸引高端创作者。</li><li>变现路径仍在探索，部分高阶功能可能需要商业化支撑。</li></ul></li></ul><h3 id="运营策略-3"><strong>运营策略</strong></h3><ol><li><strong>强化AI智能剪辑</strong>：进一步优化智能字幕、自动特效，降低视频创作门槛。</li><li><strong>拓展B端市场</strong>：为品牌营销、MCN机构提供定制化剪辑方案，提高商业变现能力。</li><li><strong>国际化扩展</strong>：加大对CapCut的推广，争夺海外短视频市场。</li><li><strong>优化云服务</strong>：提升跨设备编辑体验，增强用户粘性。</li></ol><h3 id="改进建议-3"><strong>改进建议</strong></h3><ol><li><strong>增强PC端能力</strong>：增加更多专业功能，向高级视频编辑用户渗透。</li><li><strong>推出更丰富的订阅服务</strong>：增加更多高级滤镜、素材库，提高用户付费转化率。</li><li><strong>减少系统资源占用</strong>：优化软件性能，降低剪辑时的卡顿问题。</li><li><strong>提升社交分享能力</strong>：增加作品社区，提高用户互动与创作灵感交换。</li></ol><h3 id="总结-3"><strong>总结</strong></h3><p>剪映凭借其智能化、免费、易用的优势，已成为短视频时代的重要剪辑工具。但面对竞争压力，未来需要在专业剪辑、商业化路径、国际市场拓展等方面不断优化，才能确保长期竞争力。</p><hr><h2 id="石墨文档（Shimo-Docs）">石墨文档（Shimo Docs）</h2><h3 id="产品概述-4"><strong>产品概述</strong></h3><p>石墨文档是中国领先的在线协作文档工具，类似于 Google Docs，提供云端文档、表格、演示文稿等功能，支持多人实时协作编辑。它专注于提高团队办公效率，并在教育、科技、媒体等行业广泛应用。</p><h3 id="核心功能-4"><strong>核心功能</strong></h3><ol><li><strong>云端文档</strong>：支持多人实时编辑，自动保存，历史版本追溯。</li><li><strong>团队协作</strong>：提供权限管理、评论、任务指派，提高团队协作效率。</li><li><strong>表格与演示</strong>：支持类似 Excel 的在线表格、PPT 演示文稿制作。</li><li><strong>企业知识库</strong>：团队可创建共享文档库，方便知识沉淀与管理。</li><li><strong>Markdown 支持</strong>：方便开发者、技术人员撰写文档。</li><li><strong>API 集成</strong>：支持与企业内部系统对接，提高自动化办公能力。</li></ol><h3 id="用户体验评估-4"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>操作流畅</strong>，界面简洁，使用体验接近 Google Docs。</li><li><strong>多人协作能力强</strong>，适合远程办公和团队项目管理。</li><li><strong>本地化优势</strong>，相比 Google Docs 适应国内网络环境，无需翻墙。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>高级功能收费</strong>，部分企业版功能需要订阅。</li><li><strong>生态闭环较弱</strong>，缺乏完整的办公套件（如邮件、日历）。</li><li><strong>移动端体验有待优化</strong>，部分功能在手机端适配不佳。</li></ul></li></ul><h3 id="商业模式解释-4"><strong>商业模式解释</strong></h3><ol><li><strong>企业订阅</strong>：提供按月/年付费的企业版，增强管理功能。</li><li><strong>个人高级版</strong>：订阅会员可解锁更多存储空间、高级权限管理等功能。</li><li><strong>企业定制化</strong>：提供 API 接入、私有化部署，满足大企业需求。</li><li><strong>广告与合作</strong>：部分功能可与 SaaS 工具合作推广，实现流量变现。</li></ol><h3 id="竞争分析-4"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>腾讯文档</strong>（依托微信生态，用户增长快）。</li><li><strong>金山文档</strong>（WPS 旗下，集成度高）。</li><li><strong>飞书 Docs</strong>（字节跳动产品，与飞书深度融合）。</li><li><strong>Google Docs</strong>（在国际市场占据主导地位）。</li></ul></li><li><strong>优势</strong>：<ul><li>本地化适配优秀，符合国内用户需求。</li><li>功能丰富，协作体验优于传统 Office 软件。</li></ul></li><li><strong>劣势</strong>：<ul><li>生态整合能力不及大厂产品，如腾讯、字节等。</li><li>市场推广能力相对较弱，用户增长主要靠口碑传播。</li></ul></li></ul><h3 id="运营策略-4"><strong>运营策略</strong></h3><ol><li><strong>优化移动端体验</strong>：增强 APP 端的操作流畅性，提高移动办公能力。</li><li><strong>增强生态整合</strong>：与更多企业软件（如钉钉、企业微信）联动，提高市场渗透率。</li><li><strong>扩展教育市场</strong>：加强与高校、在线教育平台合作，提升品牌影响力。</li><li><strong>优化定价策略</strong>：推出更多灵活的套餐，降低中小企业使用门槛。</li></ol><h3 id="改进建议-4"><strong>改进建议</strong></h3><ol><li><strong>提升离线编辑功能</strong>，增强无网络环境下的使用体验。</li><li><strong>增加 AI 助手</strong>，提供智能写作、翻译、数据分析等功能。</li><li><strong>优化权限管理</strong>，为企业客户提供更细粒度的访问控制。</li><li><strong>加强安全性</strong>，推出更高级的加密与数据备份方案，吸引更多企业客户。</li></ol><h3 id="总结-4"><strong>总结</strong></h3><p>石墨文档凭借其本地化优势和优秀的协作能力，在国内文档市场占据一席之地。但面对腾讯、金山等强劲对手，未来需加强生态整合、优化产品体验，并探索更多商业化路径，以实现长期竞争力。</p><hr><h2 id="Keep">Keep</h2><h3 id="产品概述-5"><strong>产品概述</strong></h3><p>Keep 是中国领先的健身运动平台，提供在线健身课程、智能硬件、社交社区等功能，帮助用户在家或户外进行科学锻炼。作为国内最受欢迎的健身 APP 之一，Keep 通过“内容 + 硬件 + 社区 + 电商”形成了闭环生态，满足用户多样化的健身需求。</p><h3 id="核心功能-5"><strong>核心功能</strong></h3><ol><li><strong>在线健身课程</strong>：涵盖瑜伽、有氧、力量训练等，支持定制训练计划。</li><li><strong>运动数据追踪</strong>：记录跑步、骑行、步数等数据，并提供分析和激励机制。</li><li><strong>社交社区</strong>：用户可分享健身动态、打卡、参与挑战，提高运动动力。</li><li><strong>智能健身设备</strong>：与 Keep 自研硬件（如跑步机、跳绳）连接，实现数据同步。</li><li><strong>个性化推荐</strong>：基于用户身体数据和训练习惯，推荐适合的课程和饮食建议。</li><li><strong>Keep 商城</strong>：销售运动装备、健康食品、课程会员等，提高用户粘性。</li></ol><h3 id="用户体验评估-5"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>课程体系丰富，适合不同健身水平的用户。</li><li>界面简洁，操作流畅，用户体验良好。</li><li>社区氛围积极，增强用户长期坚持健身的动力。</li></ul></li><li><strong>不足</strong>：<ul><li>课程免费内容有限，高质量训练内容需会员付费。</li><li>设备与 APP 的联动体验仍需优化，如部分数据同步不稳定。</li><li>会员体系较复杂，部分用户认为付费权益不够吸引人。</li></ul></li></ul><h3 id="商业模式解释-5"><strong>商业模式解释</strong></h3><ol><li><strong>会员订阅</strong>：Keep 会员提供高级课程、个性化训练计划、去广告等权益。</li><li><strong>硬件销售</strong>：智能健身设备（如跑步机、动感单车、智能手环）成为重要收入来源。</li><li><strong>课程付费</strong>：部分高端训练计划、明星教练课程需要单独购买。</li><li><strong>电商变现</strong>：运动装备、营养品、服饰等商品销售贡献收入。</li><li><strong>品牌合作</strong>：与运动品牌、健康食品企业合作推广，实现广告收入。</li></ol><h3 id="竞争分析-5"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>咕咚</strong>（主打运动社交和智能设备）。</li><li><strong>乐刻运动</strong>（结合线上课程与线下健身房）。</li><li><strong>Peloton（国际）</strong>（智能硬件 + 订阅课程模式）。</li></ul></li><li><strong>优势</strong>：<ul><li>健身内容丰富，覆盖全场景需求（家庭、户外、健身房）。</li><li>生态闭环完善，涵盖软件、硬件、电商、社交等多个环节。</li></ul></li><li><strong>劣势</strong>：<ul><li>盈利模式依赖会员订阅，用户增长后期可能放缓。</li><li>运动硬件市场竞争激烈，产品创新和用户体验需持续优化。</li></ul></li></ul><h3 id="运营策略-5"><strong>运营策略</strong></h3><ol><li><strong>优化会员体系</strong>：调整定价策略，提高会员权益吸引力。</li><li><strong>增强智能设备体验</strong>：改进数据同步问题，优化硬件交互。</li><li><strong>拓展海外市场</strong>：借鉴 Peloton 模式，探索国际化增长机会。</li><li><strong>强化 AI 训练助手</strong>：结合 AI 提供个性化运动指导，提高用户粘性。</li></ol><h3 id="改进建议-5"><strong>改进建议</strong></h3><ol><li><strong>降低新用户门槛</strong>：提供更多免费基础课程，提高用户转化率。</li><li><strong>加强社交互动</strong>：增加线上 PK 赛、团队挑战，提高用户活跃度。</li><li><strong>优化硬件软件联动</strong>：提高设备数据精准度，提升智能化体验。</li><li><strong>增加线下体验店</strong>：结合智能健身房模式，提升品牌影响力。</li></ol><h3 id="总结-5"><strong>总结</strong></h3><p>Keep 通过“内容 + 硬件 + 电商”构建了完整的运动生态，用户粘性较强。但面临会员增长瓶颈和硬件竞争压力，需要优化商业模式、增强智能化体验，并探索更多变现渠道，以确保长期竞争力。</p><hr><h2 id="滴滴出行（DiDi）">滴滴出行（DiDi）</h2><h3 id="产品概述-6"><strong>产品概述</strong></h3><p>滴滴出行是中国最大的网约车平台，提供打车、顺风车、共享单车、代驾等多元化出行服务。作为全球领先的智能出行平台，滴滴通过大数据和AI优化调度，提高出行效率，并不断拓展国际市场。</p><h3 id="核心功能-6"><strong>核心功能</strong></h3><ol><li><strong>即时叫车</strong>：用户可通过APP快速叫车，支持快车、专车、出租车等多种车型。</li><li><strong>拼车服务</strong>：用户可选择拼车以降低费用，同时提高车辆利用率。</li><li><strong>顺风车</strong>：允许私家车主搭载顺路乘客，提供成本更低的出行方式（曾暂停，后部分城市试点恢复）。</li><li><strong>共享单车与电动车</strong>：整合青桔单车、电动车服务，满足短途出行需求。</li><li><strong>代驾服务</strong>：为酒后或不便驾驶的用户提供代驾服务。</li><li><strong>安全保障</strong>：提供行程录音、紧急联系人、一键报警等安全功能。</li></ol><h3 id="用户体验评估-6"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>覆盖范围广</strong>，一二线城市及部分海外市场均可使用。</li><li><strong>AI调度优化</strong>，减少用户等待时间，提高司机接单效率。</li><li><strong>多种出行选择</strong>，从经济型到高端车型，满足不同用户需求。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>动态定价机制争议</strong>，高峰期价格浮动较大，用户体验受影响。</li><li><strong>安全问题</strong>，尽管滴滴已加强安全措施，仍存在用户担忧。</li><li><strong>司机与用户匹配优化空间</strong>，部分司机接单后长时间不动或绕路问题仍存在。</li></ul></li></ul><h3 id="商业模式解释-6"><strong>商业模式解释</strong></h3><ol><li><strong>佣金收入</strong>：从每笔订单抽取固定比例的佣金（一般为10%-30%）。</li><li><strong>会员订阅</strong>：提供会员权益，如折扣、优先派单等，提高用户复购率。</li><li><strong>广告业务</strong>：APP内信息流广告、司机端广告位投放等。</li><li><strong>金融服务</strong>：滴滴金融提供车贷、保险等服务，为司机提供金融支持。</li><li><strong>企业用车</strong>：提供企业专属出行方案，优化企业差旅管理。</li></ol><h3 id="竞争分析-6"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>高德打车</strong>（聚合平台，整合多个网约车品牌，竞争力增强）。</li><li><strong>T3出行</strong>（车企主导，司机补贴力度较大）。</li><li><strong>美团打车</strong>（依托美团生态，整合本地生活服务）。</li><li><strong>Uber（国际）</strong>（在海外市场与滴滴竞争）。</li></ul></li><li><strong>优势</strong>：<ul><li><strong>市场占有率高</strong>，用户基数庞大，形成网络效应。</li><li><strong>技术能力强</strong>，AI调度、路线规划等领先。</li></ul></li><li><strong>劣势</strong>：<ul><li><strong>政策监管压力大</strong>，数据安全、司机资质等问题需持续优化。</li><li><strong>盈利挑战</strong>，补贴减少后，如何维持用户增长和司机供给仍是难题。</li></ul></li></ul><h3 id="运营策略-6"><strong>运营策略</strong></h3><ol><li><strong>优化定价策略</strong>：平衡司机收入与用户体验，减少高峰期过高溢价。</li><li><strong>增强司机管理</strong>：提升司机审核、培训机制，提高服务质量。</li><li><strong>拓展国际市场</strong>：深化在拉美、东南亚等市场的布局，提升海外竞争力。</li><li><strong>加码自动驾驶</strong>：推进Robotaxi（无人驾驶网约车）测试，抢占未来出行市场。</li></ol><h3 id="改进建议-6"><strong>改进建议</strong></h3><ol><li><strong>优化动态定价</strong>：提供更透明的价格机制，减少用户对价格波动的不满。</li><li><strong>提升安全措施</strong>：增加行程风险预警，提高女性及夜间出行的安全性。</li><li><strong>加强用户运营</strong>：提供更多会员权益，增加用户留存率。</li><li><strong>探索多元化盈利模式</strong>：如车载广告、智能车载硬件等，拓展收入来源。</li></ol><h3 id="总结-6"><strong>总结</strong></h3><p>滴滴出行在国内网约车市场占据主导地位，但面对竞争加剧、监管趋严等挑战，需要持续优化用户体验、提升安全性，并探索自动驾驶、国际市场等新增长点，以保持长期竞争力。</p><hr><h2 id="TapTap">TapTap</h2><h3 id="产品概述-7"><strong>产品概述</strong></h3><p>TapTap 是一个专注于手游推荐、下载与社区交流的平台，主打“发现好游戏”，避免传统应用商店的刷榜和劣质推广问题。其核心特点是“无广告、无联运、真实评价”，让用户能够获取更优质的游戏推荐，并与玩家、开发者互动。</p><h3 id="核心功能-7"><strong>核心功能</strong></h3><ol><li><strong>游戏推荐与下载</strong>：提供高质量游戏推荐，支持官方渠道安装，避免盗版与山寨游戏。</li><li><strong>玩家社区</strong>：用户可发表游戏评价、攻略、讨论，形成互动交流。</li><li><strong>排行榜与评分系统</strong>：基于用户评价的公平评分系统，推荐真正优质的游戏。</li><li><strong>开发者直连</strong>：开发者可直接发布游戏，与玩家交流，提高用户反馈效率。</li><li><strong>游戏预约与测试</strong>：支持新游戏的预约、封测、抢先体验，增强用户期待感。</li></ol><h3 id="用户体验评估-7"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>无广告、无诱导下载，推荐内容相对客观。</li><li>社区氛围较好，玩家互动活跃，评价较真实。</li><li>游戏更新及时，支持官方安装包，避免盗版风险。</li></ul></li><li><strong>不足</strong>：<ul><li>受限于国内政策，部分海外游戏无法上架，导致资源不够丰富。</li><li>作为独立平台，受限于安卓生态，iOS 端体验不如安卓端。</li><li>由于评分机制透明，部分游戏存在“恶意差评”现象，影响评分公正性。</li></ul></li></ul><h3 id="商业模式解释-7"><strong>商业模式解释</strong></h3><ol><li><strong>开发者服务</strong>：提供游戏分发、运营支持、社区互动等增值服务。</li><li><strong>游戏联运</strong>（部分尝试）：部分游戏可能会进行合作推广，但不影响公正性。</li><li><strong>社区变现</strong>：通过社区活跃度提升用户留存，带动游戏长尾效应，从而获取更多开发者合作。</li><li><strong>增值工具</strong>：提供游戏数据分析、市场洞察等付费服务，帮助开发者优化推广策略。</li></ol><h3 id="竞争分析-7"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>App Store &amp; Google Play</strong>（主流应用商店，但推荐算法不透明，游戏发现机制较弱）。</li><li><strong>腾讯应用宝</strong>（拥有海量腾讯系游戏资源，生态优势明显）。</li><li><strong>好游快爆</strong>（同样主打社区+游戏推荐，但用户粘性稍逊）。</li></ul></li><li><strong>优势</strong>：<ul><li>强调公平推荐，避免广告干扰，深受核心玩家喜爱。</li><li>社区互动强，玩家与开发者联系紧密，提高游戏生命周期。</li></ul></li><li><strong>劣势</strong>：<ul><li>资源受限，部分大厂游戏仍依赖官方商店，无法完全覆盖市场。</li><li>商业化探索仍处于初期阶段，盈利模式较弱。</li></ul></li></ul><h3 id="运营策略-7"><strong>运营策略</strong></h3><ol><li><strong>增强独家内容</strong>：争取更多独立游戏、精品手游的首发合作，提高吸引力。</li><li><strong>优化社区管理</strong>：提升评价审核机制，防止恶意评分和水军干扰。</li><li><strong>探索更多变现模式</strong>：如推出会员体系，提供数据分析、专属试玩等高级功能。</li><li><strong>拓展国际市场</strong>：借鉴 Steam 经验，吸引海外开发者入驻，提高全球影响力。</li></ol><h3 id="改进建议-7"><strong>改进建议</strong></h3><ol><li><strong>加强与开发者的合作</strong>，推出更多试玩、折扣活动，提高用户活跃度。</li><li><strong>优化推荐算法</strong>，提升个性化游戏推荐能力，减少用户探索成本。</li><li><strong>增加社交玩法</strong>，如游戏成就系统、好友互动，提高用户粘性。</li><li><strong>拓展云游戏功能</strong>，降低高配置游戏的设备门槛，吸引更多轻度用户。</li></ol><h3 id="总结-7"><strong>总结</strong></h3><p>TapTap 以公平、公正的游戏推荐和社区互动优势，在手游市场建立了独特的竞争力。然而，面对传统应用商店和大厂生态的挑战，其需要在内容独占性、商业化探索和国际化扩展方面进一步优化，以实现长期增长。</p><hr><h2 id="得物（Dewu）">得物（Dewu）</h2><h3 id="产品概述-8"><strong>产品概述</strong></h3><p>得物（Dewu）是一款潮流电商平台，最早以“毒APP”起家，专注于球鞋、潮牌服饰、电子产品等年轻用户喜爱的高端商品。平台主打“先鉴别，后发货”模式，确保商品真实性，满足消费者对正品潮流单品的需求。</p><h3 id="核心功能-8"><strong>核心功能</strong></h3><ol><li><strong>商品鉴别</strong>：平台提供专业的鉴别服务，防止假货流通，提升用户信任度。</li><li><strong>潮流电商</strong>：涵盖球鞋、潮牌服饰、奢侈品、电子数码等品类。</li><li><strong>社区互动</strong>：用户可以在APP内分享穿搭、晒单，形成社交氛围。</li><li><strong>拍卖与闪购</strong>：提供限量商品抢购、竞拍等模式，提高稀缺商品流通效率。</li><li><strong>二手交易</strong>：支持用户转售闲置潮流商品，实现商品流转。</li></ol><h3 id="用户体验评估-8"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>强大鉴别机制</strong>，有效降低假货风险，提高消费者信心。</li><li><strong>潮流属性突出</strong>，吸引年轻用户，社区氛围浓厚。</li><li><strong>多种购物模式</strong>（竞拍、预售等），提升用户购物体验。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>价格溢价高</strong>，部分商品因炒作导致价格远超市场价。</li><li><strong>鉴别服务争议</strong>，部分用户反馈鉴别结果不稳定。</li><li><strong>退换货体验一般</strong>，部分商品因鉴别流程影响退款效率。</li></ul></li></ul><h3 id="商业模式解释-8"><strong>商业模式解释</strong></h3><ol><li><strong>交易佣金</strong>：从买卖双方交易中抽取佣金（类似StockX模式）。</li><li><strong>鉴别服务费</strong>：部分商品需要额外支付鉴别费用。</li><li><strong>品牌合作</strong>：与潮牌、运动品牌合作推出独家联名款或营销推广。</li><li><strong>增值服务</strong>：如加速鉴别、VIP会员、竞拍等功能收费。</li></ol><h3 id="竞争分析-8"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>Nice</strong>（同样专注潮流交易，但社交氛围更强）。</li><li><strong>StockX</strong>（国际化平台，鉴别体系成熟）。</li><li><strong>闲鱼</strong>（二手市场庞大，但无专业鉴别服务）。</li></ul></li><li><strong>优势</strong>：<ul><li><strong>强社交属性</strong>，用户社区活跃，增强用户粘性。</li><li><strong>正品保障机制</strong>，提高用户信任，形成竞争壁垒。</li></ul></li><li><strong>劣势</strong>：<ul><li><strong>炒作氛围较浓</strong>，部分商品价格过高，影响长期市场稳定性。</li><li><strong>国际化能力较弱</strong>，相比 StockX 在全球市场的影响力有限。</li></ul></li></ul><h3 id="运营策略-8"><strong>运营策略</strong></h3><ol><li><strong>优化鉴别体系</strong>：提升鉴别准确度，减少争议，增强用户信任。</li><li><strong>拓展品类</strong>：增加更多高端电子产品、潮流玩具，提高用户消费频次。</li><li><strong>强化社交玩法</strong>：推出更多UGC互动玩法，如潮流挑战赛、达人推荐等。</li><li><strong>探索海外市场</strong>：与国际品牌合作，推动全球化扩张。</li></ol><h3 id="改进建议-8"><strong>改进建议</strong></h3><ol><li><strong>降低交易成本</strong>，减少溢价，提升用户长期留存率。</li><li><strong>优化物流效率</strong>，缩短鉴别与发货时间，提高用户体验。</li><li><strong>推出个性化推荐</strong>，基于AI算法优化商品推荐，提高转化率。</li><li><strong>增强线下体验</strong>，结合实体店提供鉴别、试穿等增值服务。</li></ol><h3 id="总结-8"><strong>总结</strong></h3><p>得物凭借“鉴别+潮流电商”模式，在年轻消费者群体中形成较强影响力。但面对市场竞争与用户信任问题，平台需要优化鉴别机制、拓展国际化布局，并平衡炒作与稳定增长之间的关系，以保持长期竞争力。</p><hr><h2 id="饿了么（Ele-me）">饿了么（<a href="http://Ele.me">Ele.me</a>）</h2><h3 id="产品概述-9"><strong>产品概述</strong></h3><p>饿了么是中国领先的本地生活服务平台，主打外卖配送，同时涵盖生鲜、商超、药品等即时配送业务。作为阿里巴巴旗下的核心本地生活业务之一，饿了么与支付宝、高德、美团等生态产品形成协同，为用户提供便捷的到家服务。</p><h3 id="核心功能-9"><strong>核心功能</strong></h3><ol><li><strong>外卖配送</strong>：提供全国范围的餐饮外卖服务，支持定时送达、夜宵、团餐等模式。</li><li><strong>即时零售</strong>：涵盖超市、生鲜、药品、鲜花等品类，满足日常消费需求。</li><li><strong>会员体系</strong>：“饿了么超级会员”提供免配送费、折扣红包等专属权益。</li><li><strong>智能推荐</strong>：基于用户偏好、时间、天气等因素推荐个性化餐饮选择。</li><li><strong>骑手调度</strong>：智能分单系统优化配送路径，提高送餐效率。</li><li><strong>品牌营销</strong>：支持商家投放满减折扣、红包、广告推广，提高曝光率和订单转化。</li></ol><h3 id="用户体验评估-9"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>阿里生态整合</strong>，支持支付宝支付、88VIP会员联动，提升用户粘性。</li><li><strong>即时配送体系完善</strong>，外卖准时率较高，服务范围广泛。</li><li><strong>优惠力度大</strong>，相比美团，饿了么常有较大补贴，价格优势明显。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>市场份额落后于美团</strong>，部分区域商家覆盖率相对较低。</li><li><strong>配送体验依赖第三方骑手</strong>，部分区域配送服务质量不稳定。</li><li><strong>商家端运营成本较高</strong>，部分小商家因佣金压力降低入驻积极性。</li></ul></li></ul><h3 id="商业模式解释-9"><strong>商业模式解释</strong></h3><ol><li><strong>商家佣金</strong>：从订单中抽取一定比例作为平台服务费（通常 10%-20%）。</li><li><strong>会员订阅</strong>：用户购买“超级会员”享受折扣和免配送费权益，提高复购率。</li><li><strong>广告推广</strong>：商家投放搜索排名、首页推荐等广告，提升曝光量。</li><li><strong>即时零售抽成</strong>：药品、生鲜等非餐饮品类的佣金和服务费。</li><li><strong>物流服务费</strong>：部分订单由平台自营配送，收取额外物流费。</li></ol><h3 id="竞争分析-9"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>美团外卖</strong>（市场占有率更高，骑手团队更完善）。</li><li><strong>京东到家</strong>（主打超市、生鲜配送，与饿了么即时零售业务重叠）。</li><li><strong>达达快送</strong>（专注即时配送，与商家深度合作）。</li></ul></li><li><strong>优势</strong>：<ul><li><strong>阿里生态加持</strong>，流量入口广，支付体验流畅。</li><li><strong>大额补贴</strong>，在价格竞争上更具优势。</li></ul></li><li><strong>劣势</strong>：<ul><li><strong>商家资源不及美团</strong>，部分城市餐厅入驻率较低。</li><li><strong>用户心智弱于美团</strong>，习惯性使用率有待提升。</li></ul></li></ul><h3 id="运营策略-9"><strong>运营策略</strong></h3><ol><li><strong>强化本地商家覆盖</strong>，增加优质品牌合作，提高用户选择范围。</li><li><strong>优化配送体验</strong>，加强骑手管理，提升服务稳定性和时效性。</li><li><strong>增强会员权益</strong>，提高超级会员的独特价值，提高用户留存率。</li><li><strong>拓展即时零售</strong>，加强与超市、生鲜、药店的合作，提高客单价和订单频次。</li></ol><h3 id="改进建议-9"><strong>改进建议</strong></h3><ol><li><strong>提升商家支持政策</strong>，降低佣金压力，提高商家入驻积极性。</li><li><strong>优化用户体验</strong>，减少应用内广告和不必要的促销弹窗，提升界面清爽度。</li><li><strong>增强配送可视化</strong>，提升订单追踪系统，让用户更清晰地了解送餐进度。</li><li><strong>加强品牌营销</strong>，利用短视频、社交媒体增加品牌曝光，提高年轻用户群体认知度。</li></ol><h3 id="总结-9"><strong>总结</strong></h3><p>饿了么凭借阿里生态和补贴策略在市场上占据重要地位，但面临美团的强势竞争。未来需强化本地商家资源、优化配送体验，并拓展即时零售业务，以提升市场竞争力和用户粘性。</p><hr><h2 id="快看漫画（Kuaikan-Manhua）">快看漫画（Kuaikan Manhua）</h2><h3 id="产品概述-10"><strong>产品概述</strong></h3><p>快看漫画是中国领先的漫画内容平台，专注于正版国漫、条漫（竖屏漫画）和社区互动。平台以“轻量级、碎片化阅读”吸引年轻用户群体，并通过IP孵化、会员订阅和衍生品销售形成完整的商业生态。</p><h3 id="核心功能-10"><strong>核心功能</strong></h3><ol><li><strong>海量漫画库</strong>：涵盖原创漫画、国漫、韩漫、日漫等多种类型，满足不同用户需求。</li><li><strong>条漫模式</strong>：采用竖屏滚动阅读，适配手机端，优化用户体验。</li><li><strong>会员与付费章节</strong>：提供VIP会员模式，解锁付费章节，提高内容变现能力。</li><li><strong>互动社区</strong>：用户可以点赞、评论、发弹幕，与作者互动，增强社交属性。</li><li><strong>IP孵化与动画化</strong>：部分热门漫画改编为动画、影视作品，拓展产业链。</li><li><strong>周边商城</strong>：售卖漫画相关的周边、实体书、手办等，提升粉丝经济变现能力。</li></ol><h3 id="用户体验评估-10"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>竖屏漫画适合移动阅读，降低阅读门槛。</li><li>内容更新快，原创漫画质量较高。</li><li>互动性强，社区氛围活跃，增加用户粘性。</li></ul></li><li><strong>不足</strong>：<ul><li>部分热门漫画付费比例较高，影响免费用户体验。</li><li>版权拓展仍有待加强，日漫、欧美漫画资源相对有限。</li><li>社交功能相较于B站、微博等平台仍有提升空间。</li></ul></li></ul><h3 id="商业模式解释-10"><strong>商业模式解释</strong></h3><ol><li><strong>会员订阅</strong>：用户支付VIP费用，享受提前解锁章节、去广告等权益。</li><li><strong>章节付费</strong>：部分热门漫画采用单话或整卷付费模式，提高内容变现能力。</li><li><strong>广告投放</strong>：品牌方在漫画阅读页、社区等位置投放广告。</li><li><strong>IP孵化与授权</strong>：热门漫画改编为动画、影视作品，授权至其他平台。</li><li><strong>周边电商</strong>：销售漫画衍生产品，如手办、服饰、实体书等。</li></ol><h3 id="竞争分析-10"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>腾讯动漫</strong>（版权资源丰富，依托腾讯生态，市场份额较大）。</li><li><strong>哔哩哔哩漫画</strong>（结合B站社区，流量转化能力强）。</li><li><strong>Webtoon（韩国）</strong>（国际化运营，全球市场占有率高）。</li></ul></li><li><strong>优势</strong>：<ul><li>深耕原创国漫，培养优质创作者，内容差异化明显。</li><li>社区氛围浓厚，用户互动性高，形成独特的二次元社群。</li></ul></li><li><strong>劣势</strong>：<ul><li>付费模式仍需优化，用户对部分高价章节存有争议。</li><li>海外市场拓展较慢，相较于Webtoon等国际平台影响力较弱。</li></ul></li></ul><h3 id="运营策略-10"><strong>运营策略</strong></h3><ol><li><strong>加强版权合作</strong>：拓展日漫、欧美漫画版权，提高内容多样性。</li><li><strong>优化会员体系</strong>：调整VIP权益，提高用户付费意愿。</li><li><strong>深耕IP孵化</strong>：推动热门漫画动画化、影视化，提高品牌影响力。</li><li><strong>拓展海外市场</strong>：推出多语言版本，进军东南亚、欧美市场。</li></ol><h3 id="改进建议-10"><strong>改进建议</strong></h3><ol><li><strong>降低部分章节付费门槛</strong>，通过广告收益补贴，提高用户留存率。</li><li><strong>增加社交玩法</strong>，如漫画二创比赛、角色扮演互动，提高社区活跃度。</li><li><strong>优化推荐算法</strong>，基于用户偏好提供个性化漫画推荐，提高阅读时长。</li><li><strong>增强作者扶持计划</strong>，提供更多流量、收益分成，吸引优质创作者入驻。</li></ol><h3 id="总结-10"><strong>总结</strong></h3><p>快看漫画凭借竖屏条漫、原创内容和活跃社区，在国漫市场占据重要地位。但面对腾讯动漫、B站漫画等强势对手，需进一步优化内容策略、提升用户体验，并加速海外市场拓展，以保持竞争优势。</p><hr><h2 id="Fanbook">Fanbook</h2><h3 id="产品概述-11"><strong>产品概述</strong></h3><p>Fanbook 是一款专注于游戏玩家和兴趣社群的即时通讯平台，类似于海外的 Discord。它为游戏公会、兴趣社群、品牌社群等提供聊天、语音频道、直播、活动管理等功能，旨在帮助用户建立高粘性的互动社区。</p><h3 id="核心功能-11"><strong>核心功能</strong></h3><ol><li><strong>语音与文字聊天</strong>：支持群组聊天、语音频道、视频通话，提高社交互动体验。</li><li><strong>社群管理</strong>：提供频道分类、权限管理、机器人插件，提高社群运营效率。</li><li><strong>游戏集成</strong>：部分游戏支持官方社群，与玩家互动，提供攻略、赛事信息等。</li><li><strong>多媒体分享</strong>：支持图片、视频、文件共享，适用于游戏内容创作者。</li><li><strong>活动与日程</strong>：可设置社群活动，支持提醒、报名功能，增强社区互动。</li><li><strong>虚拟道具与奖励系统</strong>：部分社群支持积分、勋章等玩法，增强用户粘性。</li></ol><h3 id="用户体验评估-11"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>界面清爽，类 Discord 设计，易上手。</li><li>语音质量稳定，适合游戏玩家长时间使用。</li><li>机器人插件丰富，可实现自动管理、任务提醒等功能。</li></ul></li><li><strong>不足</strong>：<ul><li>生态相对封闭，国际化程度较低，主要面向国内用户。</li><li>服务器管理工具仍有优化空间，部分功能不够灵活。</li><li>用户基数不及 QQ 群、微信群等传统社交工具，增长面临挑战。</li></ul></li></ul><h3 id="商业模式解释-11"><strong>商业模式解释</strong></h3><ol><li><strong>会员订阅</strong>：提供高级会员，享受更高质量音视频、个性化装扮等功能。</li><li><strong>社群增值服务</strong>：部分社群可开通付费入群、专属内容订阅模式。</li><li><strong>品牌合作</strong>：为游戏厂商、电竞战队等提供官方社群支持，获取 B 端收益。</li><li><strong>虚拟商品</strong>：销售徽章、主题装扮、道具等，提高用户付费意愿。</li></ol><h3 id="竞争分析-11"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>Discord</strong>（国际主流，生态成熟，但在国内受限）。</li><li><strong>QQ 频道</strong>（腾讯推出的竞品，依托 QQ 生态，用户基数庞大）。</li><li><strong>微信群、贴吧、B站动态</strong>（用户已形成习惯，社交迁移成本较高）。</li></ul></li><li><strong>优势</strong>：<ul><li>目标用户精准，聚焦游戏社群，互动体验优于传统社交平台。</li><li>语音与社群功能结合紧密，适合高粘性用户运营。</li></ul></li><li><strong>劣势</strong>：<ul><li>市场认知度较低，需要更多品牌推广。</li><li>生态封闭，缺少第三方应用接入，扩展性受限。</li></ul></li></ul><h3 id="运营策略-11"><strong>运营策略</strong></h3><ol><li><strong>加强游戏合作</strong>：与热门游戏、电竞战队合作，推广官方社群，提高品牌曝光。</li><li><strong>优化社群管理工具</strong>：提供更智能的管理插件，吸引公会、公会主积极运营。</li><li><strong>拓展内容创作者市场</strong>：吸引游戏主播、KOL 入驻，打造高质量社群内容。</li><li><strong>探索海外市场</strong>：学习 Discord 经验，布局东南亚等游戏活跃市场。</li></ol><h3 id="改进建议-11"><strong>改进建议</strong></h3><ol><li><strong>增加 API 开放能力</strong>，支持开发者接入更多插件，提高扩展性。</li><li><strong>优化移动端体验</strong>，提升推送机制，增强用户活跃度。</li><li><strong>加强 AI 管理功能</strong>，提供自动过滤、关键词检测等，优化社群质量。</li><li><strong>推出激励机制</strong>，如活跃积分、任务奖励，提高用户贡献度。</li></ol><h3 id="总结-11"><strong>总结</strong></h3><p>Fanbook 作为国内版 Discord，具备较强的游戏社群运营能力，但面临用户增长和市场认知挑战。未来需要通过游戏厂商合作、优化社群体验、拓展国际市场等方式提升竞争力。</p><hr><h2 id="腾讯会议（VooV-Meeting）">腾讯会议（VooV Meeting）</h2><h3 id="产品概述-12"><strong>产品概述</strong></h3><p>腾讯会议（VooV Meeting）是腾讯推出的云视频会议平台，支持远程办公、线上教育、企业协作等场景。凭借腾讯云的强大技术支持，腾讯会议在稳定性、易用性和智能化方面具有明显优势，是国内市场上最受欢迎的视频会议软件之一。</p><h3 id="核心功能-12"><strong>核心功能</strong></h3><ol><li><strong>高清视频会议</strong>：支持1080P高清画质，提供智能降噪、虚拟背景等增强体验功能。</li><li><strong>屏幕共享</strong>：支持多人实时共享屏幕，适用于演示、教学和远程协作。</li><li><strong>AI智能功能</strong>：提供智能会议纪要、自动生成字幕，提高会议效率。</li><li><strong>多终端适配</strong>：支持Windows、Mac、iOS、Android及Web端，兼容性强。</li><li><strong>会议管理</strong>：支持主持人权限管理、会议锁定、录制存档等功能。</li><li><strong>企业级安全保障</strong>：提供端到端加密、企业专属会议链接，保障数据安全。</li></ol><h3 id="用户体验评估-12"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li>会议稳定性高，音视频质量优越。</li><li>操作简单，界面清爽，适合各类用户。</li><li>结合微信、企业微信，可实现无缝协同，提高工作效率。</li></ul></li><li><strong>不足</strong>：<ul><li>免费版会议时间有限，部分高级功能需付费解锁。</li><li>会议录制存储受限，需要额外购买云存储空间。</li><li>相较于Zoom等国际产品，海外市场影响力较低。</li></ul></li></ul><h3 id="商业模式解释-12"><strong>商业模式解释</strong></h3><ol><li><strong>基础版免费</strong>：个人用户可免费使用基本会议功能，但有时长和人数限制。</li><li><strong>企业版订阅</strong>：企业用户可付费解锁更长会议时长、更多参会人数及高级功能。</li><li><strong>云存储与增值服务</strong>：提供会议录制存储、AI会议纪要等增值服务。</li><li><strong>SaaS集成</strong>：与企业微信、腾讯文档等协同办公工具深度集成，提升企业用户粘性。</li></ol><h3 id="竞争分析-12"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>钉钉会议</strong>（阿里系，深度绑定钉钉生态，企业客户多）。</li><li><strong>飞书会议</strong>（字节跳动旗下，国际化能力较强）。</li><li><strong>Zoom</strong>（全球领先的视频会议软件，海外市场占有率高）。</li></ul></li><li><strong>优势</strong>：<ul><li>依托腾讯云和微信生态，用户获取成本低，市场渗透率高。</li><li>会议稳定性和音视频质量优于多数竞品，适合大规模会议。</li></ul></li><li><strong>劣势</strong>：<ul><li>付费商业化模式仍在探索，盈利能力需进一步提升。</li><li>在国际市场的竞争力较弱，难以对抗Zoom等成熟产品。</li></ul></li></ul><h3 id="运营策略-12"><strong>运营策略</strong></h3><ol><li><strong>优化商业化路径</strong>：推出更多细分订阅方案，满足不同企业用户需求。</li><li><strong>强化AI智能功能</strong>：优化自动会议纪要、语音转录，提高会议效率。</li><li><strong>拓展海外市场</strong>：提升多语言支持能力，加强与国际企业的合作。</li><li><strong>深度整合腾讯生态</strong>：增强与企业微信、腾讯文档的协同，提高产品粘性。</li></ol><h3 id="改进建议-12"><strong>改进建议</strong></h3><ol><li><strong>增加免费版权益</strong>，提高用户转化率，如适度延长免费会议时长。</li><li><strong>优化海外体验</strong>，提升跨国会议的网络稳定性和多语言支持。</li><li><strong>加强互动功能</strong>，如虚拟白板、投票系统，提高会议的互动性。</li><li><strong>推出行业定制版</strong>，为教育、医疗、金融等行业提供专属优化方案。</li></ol><h3 id="总结-12"><strong>总结</strong></h3><p>腾讯会议凭借稳定的技术、流畅的体验和腾讯生态支持，在国内视频会议市场占据领先地位。未来需持续优化商业化模式、增强AI智能功能，并积极拓展海外市场，以提升全球竞争力。</p><hr><h2 id="淘宝逛逛">淘宝逛逛</h2><h3 id="产品概述-13"><strong>产品概述</strong></h3><p>淘宝逛逛是阿里巴巴旗下淘宝平台推出的内容种草社区，类似于小红书，旨在通过短视频、图文笔记等内容吸引用户，并促进电商转化。淘宝逛逛不仅是一个信息流内容平台，还结合了淘宝购物场景，打通了“内容种草—兴趣探索—下单购买”的闭环。</p><h3 id="核心功能-13"><strong>核心功能</strong></h3><ol><li><strong>短视频+图文种草</strong>：商家、达人、普通用户可以发布产品测评、穿搭、美妆等内容。</li><li><strong>一键购买</strong>：用户在浏览种草内容时，可直接跳转至商品详情页并完成购买。</li><li><strong>个性化推荐</strong>：基于用户浏览、收藏、购买行为，推荐相关内容。</li><li><strong>社交互动</strong>：用户可以点赞、评论、关注达人，并加入话题讨论。</li><li><strong>创作者激励</strong>：提供流量扶持和佣金机制，吸引内容创作者加入。</li></ol><h3 id="用户体验评估-13"><strong>用户体验评估</strong></h3><ul><li><strong>优点</strong>：<ul><li><strong>电商与内容深度融合</strong>，降低购物决策成本，增强购买冲动。</li><li><strong>淘宝生态流量支持</strong>，与淘宝首页、搜索等入口联动，流量充足。</li><li><strong>推荐算法精准</strong>，基于用户购买行为优化内容分发，提高转化率。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>社区氛围较弱</strong>，相比小红书，用户主要以购买为目的，互动性偏低。</li><li><strong>内容创作者质量参差不齐</strong>，部分内容过度营销，影响用户信任度。</li><li><strong>独立品牌认知度较低</strong>，部分用户对淘宝逛逛的认知度不及抖音、小红书等内容平台。</li></ul></li></ul><h3 id="商业模式解释-13"><strong>商业模式解释</strong></h3><ol><li><strong>商品转化佣金</strong>：商家为推广内容提供佣金，内容创作者可获得分成。</li><li><strong>品牌广告投放</strong>：品牌可投放信息流广告，提高曝光率。</li><li><strong>达人带货</strong>：KOL 通过种草内容带货，淘宝收取平台服务费。</li><li><strong>会员权益</strong>：未来可能探索会员订阅模式，如提供独家折扣、专属内容等。</li></ol><h3 id="竞争分析-13"><strong>竞争分析</strong></h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>小红书</strong>（主打UGC种草，社区氛围更强，用户信任度较高）。</li><li><strong>抖音种草+电商</strong>（短视频带货更具吸引力，算法分发能力更强）。</li><li><strong>京东种草社区</strong>（主要面向高性价比消费人群，适合3C、家电类商品）。</li></ul></li><li><strong>优势</strong>：<ul><li>依托淘宝生态，流量和供应链优势明显。</li><li>内容转化效率高，减少购买路径，提高下单率。</li></ul></li><li><strong>劣势</strong>：<ul><li>缺乏社交属性，用户停留时间短，复购率较依赖商品本身。</li><li>过度商业化内容影响社区信任度，需优化内容审核机制。</li></ul></li></ul><h3 id="运营策略-13"><strong>运营策略</strong></h3><ol><li><strong>增强社区互动</strong>：鼓励用户分享购物心得，推出“购物问答”“达人挑战”等玩法。</li><li><strong>优化内容推荐</strong>：减少低质量广告内容，提高真实用户体验分享的权重。</li><li><strong>提升创作者激励</strong>：推出达人分级体系，给予优质创作者更多流量扶持。</li><li><strong>探索多元变现</strong>：如推出直播带货、品牌联合营销，提高收入来源。</li></ol><h3 id="改进建议-13"><strong>改进建议</strong></h3><ol><li><strong>提升内容质量</strong>，加强KOL审核机制，防止过度营销和虚假宣传。</li><li><strong>优化购物体验</strong>，推出“真实买家评价”功能，增强用户信任感。</li><li><strong>增加社交属性</strong>，鼓励用户之间的讨论和分享，提高社区活跃度。</li><li><strong>打破淘宝体系封闭性</strong>，尝试与微信、微博等社交平台联动，提高品牌曝光。</li></ol><h3 id="总结-13"><strong>总结</strong></h3><p>淘宝逛逛作为淘宝内容电商的一部分，具备强大的供应链和流量支持，但仍需优化社区氛围，提高用户互动性，并完善创作者体系，以增强用户粘性和平台竞争力。</p><hr>]]></content>
    
    
    <summary type="html">互联网产品分析笔记(二)</summary>
    
    
    
    <category term="产品分析" scheme="https://www.angfff.top/categories/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="互联网产品" scheme="https://www.angfff.top/tags/%E4%BA%92%E8%81%94%E7%BD%91%E4%BA%A7%E5%93%81/"/>
    
    <category term="产品分析" scheme="https://www.angfff.top/tags/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"/>
    
    <category term="PM" scheme="https://www.angfff.top/tags/PM/"/>
    
  </entry>
  
  <entry>
    <title>互联网产品分析笔记(一)</title>
    <link href="https://www.angfff.top/posts/a1cb95bf.html"/>
    <id>https://www.angfff.top/posts/a1cb95bf.html</id>
    <published>2025-02-09T05:01:48.000Z</published>
    <updated>2025-03-06T04:40:56.796Z</updated>
    
    <content type="html"><![CDATA[<h2 id="微信（Wechat）">微信（Wechat）</h2><h3 id="产品概述">产品概述</h3><p>微信是由腾讯公司于2011年推出的一款集即时通讯、社交、支付和多种服务功能于一体的移动应用程序。它不仅是中国用户数量最多的通讯工具，还延伸成为一个“超级应用”，涵盖了社交、支付、购物、内容消费等多个领域。</p><h3 id="核心功能">核心功能</h3><ol><li><strong>即时通讯</strong>：支持文本、语音、视频、表情、图片和文件的多媒体交流。</li><li><strong>朋友圈</strong>：提供用户分享生活动态的社交平台，支持文字、图片和短视频内容的发布。</li><li><strong>微信支付</strong>：包括转账、消费支付和小额理财功能，与二维码深度结合，支持线上和线下场景。</li><li><strong>公众号</strong>：为企业和个人提供内容分发渠道，包括订阅号和服务号。</li><li><strong>小程序</strong>：轻量化应用生态，无需下载即可使用的多功能平台。</li><li><strong>视频号</strong>：短视频内容创作与分享，进一步强化内容生态。</li><li><strong>企业微信</strong>：专为企业设计的内部沟通和外部服务工具。</li></ol><h3 id="用户体验评估">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>界面简洁直观，功能布局合理，用户上手容易。</li><li>通讯功能高效稳定，支持语音、视频通话等多场景需求。</li><li>生态闭环强大，用户可一站式完成社交、支付、购物等多项任务。</li></ul></li><li><strong>不足</strong>：<ul><li>功能过于繁杂，部分用户可能面临信息过载问题。</li><li>隐私政策和数据保护问题受到一定质疑。</li></ul></li></ul><h3 id="商业模式解释">商业模式解释</h3><ol><li><strong>广告收入</strong>：通过公众号广告、朋友圈广告以及小程序流量分发实现收入。</li><li><strong>支付分成</strong>：微信支付在交易过程中抽取一定比例作为手续费。</li><li><strong>增值服务</strong>：如表情包商店、视频号直播打赏等。</li><li><strong>企业服务</strong>：企业微信及相关功能的订阅费或服务费。</li></ol><h3 id="竞争分析">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li>国内：阿里巴巴的支付宝（在支付领域竞争），抖音（在短视频和社交娱乐领域）。</li><li>国际：WhatsApp（即时通讯），Facebook Messenger（社交）。</li></ul></li><li><strong>优势</strong>：<ul><li>生态闭环完整，用户粘性极高。</li><li>庞大的用户基数（超过12亿月活跃用户）。</li></ul></li><li><strong>劣势</strong>：<ul><li>创新速度可能不足以应对快速变化的市场需求。</li><li>面临反垄断监管压力。</li></ul></li></ul><h3 id="运营策略">运营策略</h3><ol><li><strong>内容生态</strong>：强化视频号、公众号等内容生态，吸引更多内容创作者和消费者。</li><li><strong>支付场景拓展</strong>：挖掘更多线下支付场景，并增强跨境支付能力。</li><li><strong>国际化发展</strong>：针对东南亚等新兴市场推广微信生态系统。</li><li><strong>用户教育</strong>：通过活动和教程引导用户使用更多高级功能（如小程序）。</li></ol><h3 id="改进建议">改进建议</h3><ol><li><strong>优化用户界面</strong>：简化功能入口，为用户提供定制化的界面选择。</li><li><strong>提升隐私保护</strong>：加强数据保护和隐私政策透明度，赢得用户信任。</li><li><strong>加强AI能力</strong>：利用人工智能技术改进内容推荐和用户交互体验。</li><li><strong>支持个性化需求</strong>：允许用户对常用功能模块进行自由配置。</li></ol><h3 id="总结">总结</h3><p>微信作为一款超级应用，其强大的生态系统和功能集成功能使其在中国市场占据主导地位。但在激烈竞争和监管压力下，需要不断优化用户体验并加速创新，以保持长期竞争力。</p><hr><h2 id="知乎（Zhihu）">知乎（Zhihu）</h2><h3 id="产品概述-2">产品概述</h3><p>知乎是中国知名的问答类社交平台，于2011年推出。它最初以知识分享和专业讨论为核心定位，吸引了大量高质量用户参与，后来逐步扩展为一个综合性的内容平台，覆盖了问答、文章、直播、视频等多种内容形式。</p><h3 id="核心功能-2">核心功能</h3><ol><li><strong>问答社区</strong>：用户可以提问或回答，优质内容通过点赞和评论机制被推送到更广的用户群体。</li><li><strong>文章与专栏</strong>：用户可以发布深度内容，通过专栏形式吸引粉丝订阅。</li><li><strong>视频与直播</strong>：支持短视频和知识类直播，满足用户多样化内容消费需求。</li><li><strong>想法（轻量化动态）</strong>：提供快速表达观点的平台，类似微博或朋友圈功能。</li><li><strong>盐选会员</strong>：提供付费阅读优质内容的功能，包括电子书、课程和独家问答等。</li><li><strong>好物推荐</strong>：结合用户信任机制，鼓励KOL通过内容带货，实现知识电商化。</li><li><strong>机构号与付费咨询</strong>：企业和专业人士可通过平台提供咨询、推广和知识变现。</li></ol><h3 id="用户体验评估-2">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>内容质量普遍较高，适合希望获取专业知识和见解的用户。</li><li>社区氛围相对理性，用户之间互动性强。</li><li>内容形式多样化，从长文到短视频，满足不同消费偏好。</li></ul></li><li><strong>不足</strong>：<ul><li>部分领域内容质量下降，营销软文增多，影响用户体验。</li><li>社区讨论氛围有所下降，争议性话题易引发对立情绪。</li><li>会员内容价值感不够突出，部分用户认为付费内容质量参差不齐。</li></ul></li></ul><h3 id="商业模式解释-2">商业模式解释</h3><ol><li><strong>会员订阅</strong>：盐选会员通过提供优质内容和权益，带来持续收入。</li><li><strong>广告收入</strong>：以信息流广告、品牌合作等形式为主。</li><li><strong>付费问答</strong>：用户可以支付费用向专家提问，平台收取分成。</li><li><strong>教育产品</strong>：知识付费类课程与电子书销售。</li><li><strong>电商与带货</strong>：通过知乎好物推荐、直播带货等方式变现。</li></ol><h3 id="竞争分析-2">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li>百度知道（问答领域）：内容广度强但深度不足。</li><li>今日头条（内容分发领域）：算法推荐机制更强大。</li><li>B站、喜马拉雅（知识分享领域）：更注重多媒体形式。</li></ul></li><li><strong>优势</strong>：<ul><li>社区生态相对成熟，优质内容和用户粘性高。</li><li>用户群体定位清晰，覆盖年轻、有消费能力的人群。</li></ul></li><li><strong>劣势</strong>：<ul><li>新用户获取难度增加，社区增长速度放缓。</li><li>部分高质量创作者向其他平台流失。</li></ul></li></ul><h3 id="运营策略-2">运营策略</h3><ol><li><strong>内容引导</strong>：加强对优质内容的扶持，优化激励机制吸引内容创作者。</li><li><strong>多样化内容形式</strong>：进一步扩展短视频、音频课程等内容供给，增加用户留存率。</li><li><strong>社区运营</strong>：举办主题活动或知识竞赛，提升用户活跃度和参与感。</li><li><strong>国际化发展</strong>：探索海外市场，通过语言本地化运营扩展用户基础。</li></ol><h3 id="改进建议-2">改进建议</h3><ol><li><strong>优化内容质量</strong>：引入更精细的内容审核机制，遏制低质量内容和营销行为。</li><li><strong>提升算法推荐</strong>：通过AI优化推荐算法，减少用户的信息过载，精准推送符合兴趣的内容。</li><li><strong>创新会员权益</strong>：扩展盐选会员的服务范围，比如独家线下活动或与其他平台合作的跨界权益。</li><li><strong>社交功能改进</strong>：增加更丰富的互动形式，例如讨论组或话题标签页，增强用户间的联系。</li><li><strong>提高用户互动</strong>：通过问答激励、社区活动等方式增强用户粘性。</li><li><strong>加强垂直领域深耕</strong>：针对科技、财经、法律、医学等领域建立更专业的知识社区。</li></ol><h3 id="总结-2">总结</h3><p>知乎作为知识型社区的代表，凭借高质量内容和良好的用户体验在市场中占有重要地位。但在流量竞争加剧和用户增长放缓的情况下，需要通过技术和运营创新，保持平台的长期活力与竞争力。</p><hr><h2 id="豆瓣（Douban）">豆瓣（Douban）</h2><h3 id="产品概述-3">产品概述</h3><p>豆瓣是一个于2005年上线的社交媒体和文化内容平台，主要服务于对书籍、电影、音乐等文化内容感兴趣的用户。它提供了丰富的用户生成内容，包括评分、评论、讨论小组和推荐列表，被视为中国文化圈的重要内容社区。</p><h3 id="核心功能-3">核心功能</h3><ol><li><strong>评分与评论</strong>：用户可为电影、书籍、音乐等内容评分并撰写评论，形成权威的用户口碑参考。</li><li><strong>兴趣小组</strong>：基于主题的讨论社区，用户可加入喜欢的圈子交流观点。</li><li><strong>豆瓣FM</strong>：音乐推荐与流媒体播放功能，通过个性化算法推送歌曲。</li><li><strong>豆瓣阅读</strong>：提供电子书购买与阅读服务，同时支持作者投稿原创作品。</li><li><strong>个人主页</strong>：用户可以展示收藏、愿望清单及文化消费记录。</li></ol><h3 id="用户体验评估-3">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>界面设计简洁清晰，功能聚焦于文化内容，契合目标用户需求。</li><li>社区氛围浓厚，讨论质量较高，特别是在文艺和独立文化领域具有独特吸引力。</li><li>评分系统公信力强，是用户选择电影、书籍等的重要参考依据。</li></ul></li><li><strong>不足</strong>：<ul><li>新用户引导较弱，部分功能对新人不够友好。</li><li>交互设计相对陈旧，与现代审美和使用习惯有一定差距。</li><li>兴趣小组内存在一些低质量或广告内容，影响用户体验。</li></ul></li></ul><h3 id="商业模式解释-3">商业模式解释</h3><ol><li><strong>广告收入</strong>：通过内容页面、评分页以及社区的广告投放获取收入。</li><li><strong>电子书销售</strong>：通过豆瓣阅读平台销售电子书和订阅服务。</li><li><strong>付费增值服务</strong>：如豆瓣FM高级账户和豆瓣阅读的VIP权益。</li><li><strong>品牌合作</strong>：与电影、出版物等文化品牌的联动推广活动。</li></ol><h3 id="竞争分析-3">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li>电影领域：猫眼、淘票票（在票务与影评方面竞争）。</li><li>阅读领域：掌阅、微信读书（在电子书销售与阅读体验上竞争）。</li><li>音乐领域：网易云音乐、QQ音乐（流媒体播放和音乐推荐）。</li></ul></li><li><strong>优势</strong>：<ul><li>强大的UGC社区，用户对评分与评论具有较高信任度。</li><li>在文艺爱好者和知识型用户中具有良好口碑。</li></ul></li><li><strong>劣势</strong>：<ul><li>缺乏内容变现的强大能力，营收模式单一。</li><li>用户增长有限，社区活跃度有下滑风险。</li></ul></li></ul><h3 id="运营策略-3">运营策略</h3><ol><li><strong>优化社区生态</strong>：强化内容审核机制，打击低质量内容，提升用户讨论的质量和参与感。</li><li><strong>内容推荐升级</strong>：利用大数据和AI技术改进内容推荐算法，为用户提供更精准的兴趣匹配。</li><li><strong>品牌联动</strong>：加强与影视、出版和音乐厂商的合作，推出更多联动推广活动。</li><li><strong>国际化发展</strong>：探索海外市场，特别是在华人文化圈内扩大影响力。</li></ol><h3 id="改进建议-3">改进建议</h3><ol><li><strong>改进界面设计</strong>：更新UI/UX设计，提升视觉效果与交互体验，吸引年轻用户。</li><li><strong>增强社交功能</strong>：增加用户间互动方式，例如点赞、即时聊天或语音讨论功能，增强社交属性。</li><li><strong>探索多元化收入模式</strong>：尝试引入更多变现手段，如内容电商、知识付费等。</li><li><strong>扶持原创内容创作者</strong>：通过奖励机制或流量扶持，吸引更多优质用户分享原创内容，增强社区活力。</li></ol><h3 id="总结-3">总结</h3><p>豆瓣作为中国文化类社区的代表，凭借其评分系统和优质讨论氛围占据独特市场地位。然而，面对日益激烈的市场竞争与用户需求的变化，它需要通过技术和运营创新，进一步释放商业潜力并保持用户黏性。</p><hr><h2 id="哔哩哔哩（Bilibili）">哔哩哔哩（Bilibili）</h2><h3 id="产品概述-4">产品概述</h3><p>哔哩哔哩（B站）是中国领先的年轻人文化社区和视频平台，成立于2009年。最初以二次元和弹幕文化为核心吸引用户，现已扩展至泛娱乐、教育、直播、电商等多个领域，成为年轻人获取内容、互动和消费的重要平台。</p><h3 id="核心功能-4">核心功能</h3><ol><li><strong>弹幕视频播放</strong>：提供独特的实时弹幕互动功能，增强观看体验和社区氛围。</li><li><strong>内容创作与分发</strong>：支持用户上传原创视频，涵盖多个领域，如动画、游戏、科技、生活等。</li><li><strong>直播服务</strong>：涵盖游戏、音乐、二次元等直播内容，同时支持观众与主播互动。</li><li><strong>知识分享</strong>：教育类内容逐渐增加，如课程视频、科普内容等，满足用户学习需求。</li><li><strong>会员与权益</strong>：大会员提供高清画质、免广告、独占内容等多项特权。</li><li><strong>电商与周边</strong>：销售与内容相关的周边产品以及合作商品。</li></ol><h3 id="用户体验评估-4">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>弹幕互动增强用户参与感，形成了鲜明的社区特色。</li><li>内容形式丰富，覆盖了广泛的兴趣领域，吸引多样化的用户群体。</li><li>推荐算法较为精准，满足个性化需求。</li><li>社区氛围强，UGC 内容丰富，用户粘性高。</li></ul></li><li><strong>不足</strong>：<ul><li>商业化难度大，用户对广告接受度低，会员转化率有限。</li><li>审核压力大，内容管理难度高，面临监管风险。</li><li>带宽与服务器成本高，影响盈利能力。</li><li>新手用户的引导不够完善，功能入口稍显复杂。</li></ul></li></ul><h3 id="商业模式解释-4">商业模式解释</h3><ol><li><strong>会员订阅</strong>：通过大会员服务提供增值功能，如高清画质、独占内容、弹幕特权等。</li><li><strong>广告收入</strong>：信息流广告、视频前贴片广告和内容合作推广。</li><li><strong>直播打赏</strong>：用户通过购买虚拟礼物支持主播，平台抽成获利。</li><li><strong>电商业务</strong>：销售与内容相关的周边商品、IP合作款等。</li><li><strong>游戏分发</strong>：与游戏厂商合作进行推广和分发，获取分成收入。</li></ol><h3 id="竞争分析-4">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li>视频领域：抖音、快手（短视频领域竞争），腾讯视频、爱奇艺（长视频、影视内容竞争）。</li><li>直播领域：虎牙、斗鱼（电竞直播竞争）。</li><li>知识类平台：知乎、网易云课堂（在教育内容方面竞争）。</li></ul></li><li><strong>优势</strong>：<ul><li>强社区属性，用户粘性和忠诚度高。</li><li>品牌定位鲜明，深受年轻用户青睐。</li><li>用户生成内容（UGC）和专业生成内容（PGC）并存，丰富平台生态。</li></ul></li><li><strong>劣势</strong>：<ul><li>内容成本较高，特别是版权内容采购和原创补贴。</li><li>变现能力不足，相较于短视频平台，广告投放吸引力较低。</li><li>面临短视频平台的流量挤压，用户增长可能放缓。</li></ul></li></ul><h3 id="运营策略-4">运营策略</h3><ol><li><strong>扶持内容创作者</strong>：通过创作者激励计划，吸引更多优质视频创作者，提升内容多样性。</li><li><strong>扩展知识领域</strong>：增加教育和职业发展类内容，满足用户在学习方面的需求。</li><li><strong>品牌合作</strong>：加强与IP方的合作，推出更多主题活动和周边商品，增强变现能力。</li><li><strong>海外拓展</strong>：继续加大国际化步伐，探索东南亚和欧美市场用户需求。</li></ol><h3 id="改进建议-4">改进建议</h3><ol><li><strong>优化广告体验</strong>：通过智能广告分发和广告形式创新，尽量减少对用户观看体验的干扰。</li><li><strong>增强社区管理</strong>：加强内容审核机制，确保社区氛围和内容质量。</li><li><strong>优化新用户引导</strong>：提供更直观的功能介绍和社区规则教育，帮助新人快速融入平台。</li><li><strong>提升推荐算法</strong>：进一步优化视频推荐，减少同质化内容，增加用户探索新领域的机会。</li></ol><h3 id="总结-4">总结</h3><p>哔哩哔哩作为中国领先的年轻人文化社区，通过独特的弹幕互动和多元化内容，成功吸引了大批忠实用户。但在激烈的市场竞争中，需要通过内容生态优化、社区运营创新和商业模式拓展来保持其竞争力和长远发展潜力。</p><hr><h2 id="飞书（Feishu）">飞书（Feishu）</h2><h3 id="产品概述-5">产品概述</h3><p>飞书是字节跳动推出的一款企业协作工具，集即时通讯、在线文档、日程管理、音视频会议和知识管理等功能于一体。作为中国企业数字化转型的重要工具，飞书定位为一站式高效办公平台，旨在帮助团队提升协作效率和生产力。</p><h3 id="核心功能-5">核心功能</h3><ol><li><strong>即时通讯</strong>：支持群聊、点对点消息传递、智能搜索、已读未读标记以及消息撤回等功能。</li><li><strong>在线文档</strong>：多用户实时协作编辑文档与表格，内嵌评论功能，支持多种格式导出。</li><li><strong>日程管理</strong>：团队共享日历，集成会议安排与提醒功能，提高时间管理效率。</li><li><strong>音视频会议</strong>：高清音视频通话，支持屏幕共享和会议录制，满足远程会议需求。</li><li><strong>知识管理</strong>：企业内知识库功能，方便员工整理和查找文档资源。</li><li><strong>集成与开放平台</strong>：与其他企业工具（如HR系统、CRM）深度集成，提供API支持个性化开发。</li></ol><h3 id="用户体验评估-5">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>界面设计简洁现代，符合年轻化用户审美。</li><li>功能深度集成，用户无需频繁切换应用。</li><li>高效的实时协作体验，特别是文档与日程功能在国内市场具有竞争力。</li></ul></li><li><strong>不足</strong>：<ul><li>部分中小企业可能难以承受高端功能的费用。</li><li>功能学习曲线较陡，新用户可能需要一定时间适应。</li></ul></li></ul><h3 id="商业模式解释-5">商业模式解释</h3><ol><li><strong>免费增值（Freemium）</strong>：核心功能免费提供，高级版本收取订阅费，包括更大存储空间、更强管理功能和定制化服务。</li><li><strong>企业服务</strong>：为大中型企业提供专属服务，如定制化解决方案和企业培训。</li><li><strong>生态收入</strong>：通过飞书开放平台收取第三方应用集成费用或分成。</li></ol><h3 id="竞争分析-5">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li>钉钉（DingTalk）：阿里巴巴旗下产品，以轻量化管理工具见长。</li><li>企业微信（WeCom）：腾讯旗下产品，优势在于与微信生态的无缝连接。</li><li>国际：Slack、Microsoft Teams（在多语言、跨国企业市场中竞争）。</li></ul></li><li><strong>优势</strong>：<ul><li>强大的产品设计能力和体验优化，实时协作性能优越。</li><li>背靠字节跳动的资源优势，在数据分析与AI技术上具备前沿能力。</li></ul></li><li><strong>劣势</strong>：<ul><li>市场认知度相对钉钉和企业微信稍弱，特别是在中小企业市场。</li><li>用户获取成本较高，需要较大的市场推广投入。</li></ul></li></ul><h3 id="运营策略-5">运营策略</h3><ol><li><strong>市场教育</strong>：通过案例分享、行业解决方案展示等形式，提高目标客户对产品的认知。</li><li><strong>生态建设</strong>：扩大与第三方工具和平台的集成合作，形成闭环生态体系。</li><li><strong>中小企业扶持</strong>：提供针对小微企业的优惠套餐，降低其使用门槛。</li><li><strong>国际化拓展</strong>：以东南亚和欧美市场为重点，推出本地化产品和服务。</li></ol><h3 id="改进建议-5">改进建议</h3><ol><li><strong>优化入门体验</strong>：为新用户设计更直观的引导流程，简化产品学习曲线。</li><li><strong>增强安全性</strong>：特别针对大型企业需求，提供更全面的数据隐私保护方案。</li><li><strong>个性化功能定制</strong>：支持企业根据需求选择功能模块，灵活配置产品。</li><li><strong>丰富插件与API</strong>：吸引更多开发者为平台提供创新功能，扩大用户选择范围。</li></ol><h3 id="总结-5">总结</h3><p>飞书凭借高效的协作功能和优秀的用户体验，在国内企业服务市场具有较大潜力。然而，在强敌环伺的竞争环境中，飞书需要加大市场推广力度、丰富功能生态，并不断优化服务策略，以实现更大规模的市场渗透和用户增长。</p><hr><h2 id="小红书（RED）">小红书（RED）</h2><h3 id="产品概述-6">产品概述</h3><p>小红书是中国领先的生活方式社区与电商平台，于2013年上线。它以UGC（用户生成内容）为核心，用户可以分享购物心得、美妆评测、旅行体验等内容。近年来，小红书逐渐发展为一个综合性的内容与消费平台，吸引了大量年轻用户。</p><h3 id="核心功能-6">核心功能</h3><ol><li><strong>内容社区</strong>：用户可以发布图文或视频笔记，内容涵盖美妆、时尚、健身、旅行等多种领域。</li><li><strong>搜索与推荐</strong>：通过AI算法实现精准内容推荐和搜索，满足用户个性化需求。</li><li><strong>电商平台</strong>：整合社区与电商，用户可以直接购买与笔记相关的商品。</li><li><strong>品牌合作</strong>：为品牌提供营销工具，如投放广告、种草内容及KOL（关键意见领袖）合作。</li><li><strong>社交功能</strong>：支持点赞、评论、收藏以及私信互动，增强用户黏性。</li></ol><h3 id="用户体验评估-6">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>界面设计简洁美观，操作直观，符合年轻用户审美。</li><li>内容丰富，尤其在时尚、美妆等领域具有较强专业性和实用性。</li><li>搜索与推荐功能强大，帮助用户快速找到感兴趣的内容。</li></ul></li><li><strong>不足</strong>：<ul><li>商业化内容较多，用户可能对过度营销感到反感。</li><li>社区管理存在挑战，偶尔出现低质量或虚假内容。</li></ul></li></ul><h3 id="商业模式解释-6">商业模式解释</h3><ol><li><strong>广告收入</strong>：通过品牌广告、原生内容广告以及达人种草推广获得收入。</li><li><strong>电商佣金</strong>：用户在平台内完成购物交易，小红书从中抽取一定比例的佣金。</li><li><strong>会员服务</strong>：提供增值服务（如更高曝光度或高级搜索功能）以获取订阅收入。</li><li><strong>数据服务</strong>：为品牌方提供消费洞察报告，支持其精准营销。</li></ol><h3 id="竞争分析-6">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li>抖音与快手：短视频内容生态竞争，覆盖相似人群。</li><li>淘宝、京东：在电商领域的流量竞争更为激烈。</li><li>知乎：在知识型分享和问答领域具有竞争性。</li></ul></li><li><strong>优势</strong>：<ul><li>用户粘性强，内容生态与电商结合紧密。</li><li>深耕“种草”经济，对女性用户和年轻人具有强吸引力。</li></ul></li><li><strong>劣势</strong>：<ul><li>内容门槛较低，部分领域存在低质量内容。</li><li>商业化转型中，如何平衡用户体验与广告压力成为难题。</li></ul></li></ul><h3 id="运营策略-6">运营策略</h3><ol><li><strong>内容优化</strong>：引入内容激励计划，扶持高质量创作者，规范内容审核机制。</li><li><strong>增强电商体验</strong>：提高购物路径的便捷性，完善物流与售后服务。</li><li><strong>品牌合作升级</strong>：推出更多创新营销工具，帮助品牌更高效地触达目标用户。</li><li><strong>国际化扩展</strong>：进入海外市场，通过多语言支持与本地化运营吸引更多用户。</li></ol><h3 id="改进建议-6">改进建议</h3><ol><li><strong>减少广告干扰</strong>：优化广告展示逻辑，避免影响用户体验。</li><li><strong>提升社区氛围</strong>：建立更严格的内容审核与推荐机制，维护社区优质内容的输出。</li><li><strong>个性化推荐</strong>：进一步优化算法，提升用户对推荐内容的满意度。</li><li><strong>电商升级</strong>：加强商品质量把控和售后服务，提升用户信任度。</li></ol><h3 id="总结-6">总结</h3><p>小红书通过“社区+电商”的模式成功建立了自己的核心竞争力。未来需要在内容质量提升、商业化转型和用户体验之间找到平衡，以巩固其市场地位并实现长远发展。</p><hr><h2 id="百度网盘（Baidu-Cloud）">百度网盘（Baidu Cloud）</h2><h3 id="产品概述-7">产品概述</h3><p>百度网盘是百度公司推出的云存储服务，提供用户个人数据的在线存储、同步、备份和分享功能。自2012年推出以来，已成为中国市场上最受欢迎的云存储服务之一，特别适用于大文件存储和跨设备访问。</p><h3 id="核心功能-7">核心功能</h3><ol><li><strong>云存储</strong>：支持用户上传、下载和管理各种格式的文件，如图片、视频、文档等。</li><li><strong>文件分享</strong>：可通过链接分享文件，并支持加密、限时下载等权限设置。</li><li><strong>多设备同步</strong>：PC、移动端和网页端无缝同步数据，方便随时访问。</li><li><strong>在线播放</strong>：支持视频、音乐等媒体文件的在线预览和播放，无需下载。</li><li><strong>自动备份</strong>：提供手机相册自动备份、文档同步等功能，防止数据丢失。</li><li><strong>企业版</strong>：提供团队协作、共享云盘等企业级功能。</li></ol><h3 id="用户体验评估-7">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li><strong>存储空间大</strong>：免费用户可获得较大初始空间，付费用户享受更大存储额度。</li><li><strong>多终端支持</strong>：支持Windows、macOS、iOS、Android等多个平台。</li><li><strong>文件管理便捷</strong>：支持批量操作、智能分类、搜索等功能，提高管理效率。</li></ul></li><li><strong>不足</strong>：<ul><li><strong>下载速度限制</strong>：非会员用户的下载速度较慢，影响体验。</li><li><strong>广告与推广较多</strong>：免费用户在使用过程中可能遇到较多的会员推广弹窗。</li><li><strong>隐私问题</strong>：部分用户担忧数据安全与隐私保护问题。</li></ul></li></ul><h3 id="商业模式解释-7">商业模式解释</h3><ol><li><strong>会员订阅</strong>：提供普通会员、超级会员等付费套餐，提升存储空间和下载速度。</li><li><strong>增值服务</strong>：包括离线下载、视频倍速播放、高速传输等功能，需额外付费。</li><li><strong>企业服务</strong>：百度网盘企业版提供团队共享、权限管理等功能，按年收费。</li><li><strong>广告收入</strong>：部分页面和功能入口包含广告投放，增加变现能力。</li></ol><h3 id="竞争分析-7">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>阿里云盘</strong>：阿里巴巴推出的云存储服务，主打无下载限速和用户体验优化。</li><li><strong>腾讯微云</strong>：腾讯旗下云存储产品，依托微信和QQ生态提供便捷的文件共享功能。</li><li><strong>海外竞争对手</strong>：Google Drive、Dropbox（但在中国市场影响有限）。</li></ul></li><li><strong>优势</strong>：<ul><li>市场占有率高，用户群体庞大。</li><li>百度搜索和AI技术支持，提供更强的智能化体验。</li></ul></li><li><strong>劣势</strong>：<ul><li>口碑受到下载限速问题影响，部分用户流向阿里云盘等竞品。</li><li>用户体验有待提升，广告较多可能影响使用感受。</li></ul></li></ul><h3 id="运营策略-7">运营策略</h3><ol><li><strong>优化用户体验</strong>：改进免费用户的基础体验，如适当提高非会员下载速度。</li><li><strong>加强安全性</strong>：提升隐私保护机制，增强数据加密和访问权限管理。</li><li><strong>丰富企业服务</strong>：针对企业级用户推出更多协作功能，提高B端市场占有率。</li><li><strong>加强内容生态</strong>：与视频、办公软件等产品深度结合，提升用户粘性。</li></ol><h3 id="改进建议-7">改进建议</h3><ol><li><strong>优化限速机制</strong>：提供更合理的非会员下载速度策略，提升整体用户口碑。</li><li><strong>减少广告干扰</strong>：减少推广弹窗，提高用户体验满意度。</li><li><strong>增强智能推荐</strong>：利用AI技术优化文件分类、搜索推荐等功能。</li><li><strong>推出更多增值服务</strong>：如AI自动整理、智能识别、协作文档等，提高会员吸引力。</li></ol><h3 id="总结-7">总结</h3><p>百度网盘凭借强大的云存储能力和百度生态支持，占据了中国云存储市场的重要位置。但在用户体验优化、隐私安全和商业模式创新方面仍有改进空间，未来需通过优化基础服务、增强企业市场拓展和智能化升级，进一步巩固市场地位。</p><hr><h2 id="携程旅行（Ctrip）">携程旅行（Ctrip）</h2><h3 id="产品概述-8">产品概述</h3><p>携程旅行（Ctrip）是中国领先的在线旅游服务平台，提供机票、酒店、火车票、旅游度假、租车、签证等全方位的旅行服务。作为国内在线旅游市场的龙头企业，携程通过技术和供应链整合，为用户提供一站式旅行解决方案。</p><h3 id="核心功能-8">核心功能</h3><ol><li><strong>机票预订</strong>：支持国内、国际航班查询和预订，提供价格对比、航班提醒等增值服务。</li><li><strong>酒店预订</strong>：涵盖全球各类酒店，提供用户评价、图片、地图定位及会员专享优惠。</li><li><strong>火车票/汽车票</strong>：支持高铁、动车和长途汽车票的在线预订，并提供抢票服务。</li><li><strong>旅游度假</strong>：提供自由行、跟团游、定制游等产品，覆盖国内外目的地。</li><li><strong>租车与接送机</strong>：提供全球租车服务，并支持机场接送、包车游等特色服务。</li><li><strong>签证与保险</strong>：支持在线办理签证，并提供旅行保险产品，提高用户便利性。</li><li><strong>会员体系</strong>：通过携程会员计划（如钻石、白金会员），提供专属折扣和服务。</li></ol><h3 id="用户体验评估-8">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>界面设计清晰，搜索和预订流程流畅，用户体验较好。</li><li>供应链资源丰富，提供广泛的旅行产品选择。</li><li>会员体系较完善，老用户粘性较高。</li></ul></li><li><strong>不足</strong>：<ul><li>价格波动较大，部分用户对价格透明度有疑虑。</li><li>订单改签、退款流程相对复杂，客服体验有待优化。</li><li>广告和推送较多，可能影响部分用户体验。</li></ul></li></ul><h3 id="商业模式解释-8">商业模式解释</h3><ol><li><strong>佣金收入</strong>：与航空公司、酒店、旅行社等合作，通过订单抽佣获利。</li><li><strong>增值服务</strong>：包括保险、签证办理、贵宾休息室等附加服务。</li><li><strong>广告收入</strong>：向酒店、旅游供应商提供广告推广服务。</li><li><strong>金融服务</strong>：提供分期付款、携程信用支付等金融产品。</li></ol><h3 id="竞争分析-8">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>国内</strong>：同程旅行、飞猪（阿里巴巴旗下）、马蜂窝（社交+旅游模式）。</li><li><strong>国际</strong>：<a href="http://Booking.com">Booking.com</a>、Expedia（在国际酒店预订和机票市场竞争）。</li></ul></li><li><strong>优势</strong>：<ul><li>供应链强大，与大量航司、酒店建立长期合作关系。</li><li>具有较强的品牌信任度和较高市场占有率。</li></ul></li><li><strong>劣势</strong>：<ul><li>竞争对手（如飞猪）依托阿里生态流量，市场竞争压力大。</li><li>用户对价格和服务的敏感度较高，易受竞争平台影响。</li></ul></li></ul><h3 id="运营策略-8">运营策略</h3><ol><li><strong>优化服务体验</strong>：简化订单改签、退票流程，提高用户服务满意度。</li><li><strong>深耕国际市场</strong>：加大海外市场拓展力度，提升全球竞争力。</li><li><strong>强化智能推荐</strong>：利用AI技术优化个性化推荐，提高用户留存率。</li><li><strong>拓展会员权益</strong>：增加高端会员专属权益，提升忠诚度。</li></ol><h3 id="改进建议-8">改进建议</h3><ol><li><strong>提升客服体验</strong>：优化人工客服响应速度，增加智能客服能力。</li><li><strong>增强价格透明度</strong>：减少隐藏费用，提高用户信任感。</li><li><strong>减少无关推送</strong>：优化个性化推荐逻辑，减少对用户造成困扰的消息推送。</li><li><strong>加强用户评价体系</strong>：提升用户对商家的信任度，改善服务质量。</li></ol><h3 id="总结-8">总结</h3><p>携程旅行作为中国最大的在线旅游平台，在供应链整合、品牌信任度和用户规模上占据优势。但面对激烈的市场竞争和用户体验的高要求，携程需要持续优化产品服务，提升用户体验，并加强国际市场布局，以保持市场领先地位。</p><hr><h2 id="美团（Meituan）">美团（Meituan）</h2><h3 id="产品概述-9">产品概述</h3><p>美团是一款综合性的本地生活服务平台，提供外卖、酒店预订、电影票、休闲娱乐、出行等多种服务。作为中国领先的O2O（Online to Offline）平台，美团通过技术和数据驱动，为用户提供便捷的生活消费服务，同时帮助商家提升运营效率。</p><h3 id="核心功能-9">核心功能</h3><ol><li><strong>外卖配送</strong>：美团外卖覆盖全国多个城市，提供餐饮、超市、生鲜、药品等配送服务。</li><li><strong>酒店预订</strong>：用户可以通过美团预订国内外酒店，并享受优惠折扣和会员特权。</li><li><strong>电影票预订</strong>：支持全国电影院的在线选座购票，并提供优惠券和会员折扣。</li><li><strong>本地服务</strong>：涵盖KTV、按摩、美容、健身、亲子等消费场景，用户可在线购买团购或预约服务。</li><li><strong>美团打车</strong>：提供网约车服务，与滴滴等平台竞争，主打高性价比出行体验。</li><li><strong>美团买菜</strong>：支持生鲜食品的即时配送，满足家庭用户的日常采购需求。</li><li><strong>商家服务</strong>：提供流量推广、用户运营、数据分析等工具，帮助商家提升销量。</li></ol><h3 id="用户体验评估-9">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li><strong>一站式服务</strong>，涵盖多种本地消费需求，提升用户便利性。</li><li><strong>界面设计简洁</strong>，操作流程流畅，支持个性化推荐。</li><li><strong>配送效率高</strong>，特别是在大城市，外卖和买菜服务体验较佳。</li></ul></li><li><strong>不足</strong>：<ul><li>部分服务商的质量不稳定，用户体验受限于商家能力。</li><li>广告和促销信息较多，可能对用户造成一定干扰。</li><li>会员体系的权益不够清晰，部分用户对订阅付费持观望态度。</li></ul></li></ul><h3 id="商业模式解释-9">商业模式解释</h3><ol><li><strong>佣金收入</strong>：向入驻商家收取交易佣金，如外卖商家、酒店、餐厅等。</li><li><strong>广告推广</strong>：提供商家流量推广、竞价排名等广告营销服务。</li><li><strong>会员订阅</strong>：美团推出“超级会员”计划，提供专属折扣、红包等增值权益。</li><li><strong>配送服务费</strong>：美团外卖和买菜业务收取一定的配送服务费。</li><li><strong>金融服务</strong>：通过美团支付、美团信用等金融产品获得额外收益。</li></ol><h3 id="竞争分析-9">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>饿了么</strong>（外卖业务）：阿里巴巴旗下平台，主打会员折扣和补贴竞争。</li><li><strong>携程、飞猪</strong>（酒店业务）：旅游住宿预订领域竞争激烈。</li><li><strong>滴滴</strong>（网约车业务）：美团打车在市场份额上仍与滴滴有较大差距。</li></ul></li><li><strong>优势</strong>：<ul><li>强大的地推和商家合作能力，市场覆盖广泛。</li><li>生态闭环完整，从餐饮到出行，用户粘性较高。</li></ul></li><li><strong>劣势</strong>：<ul><li>业务线多，运营成本较高，盈利能力面临挑战。</li><li>在部分业务（如网约车）上，与主要竞争对手仍存在差距。</li></ul></li></ul><h3 id="运营策略-9">运营策略</h3><ol><li><strong>强化外卖生态</strong>：提高商家质量，优化配送服务，增强用户体验。</li><li><strong>拓展本地生活</strong>：增加更多生活服务，如家政、维修、医疗等领域。</li><li><strong>增强会员权益</strong>：优化超级会员体系，提高用户留存率和付费转化率。</li><li><strong>国际化探索</strong>：尝试在东南亚市场复制中国模式，拓展海外市场。</li></ol><h3 id="改进建议-9">改进建议</h3><ol><li><strong>优化广告展示</strong>：减少无关推送，增强个性化推荐机制，提高用户满意度。</li><li><strong>提升商家管理</strong>：加强对低质量商家的监管，提高用户消费体验。</li><li><strong>完善售后服务</strong>：特别是在外卖和酒店业务上，提高投诉处理效率。</li><li><strong>技术创新</strong>：运用AI优化配送路线、智能客服等，提高运营效率。</li></ol><h3 id="总结-9">总结</h3><p>美团凭借其强大的本地服务生态，在外卖、酒店、本地娱乐等领域占据领先地位。但面对竞争和高运营成本压力，美团需要持续优化用户体验、提升商家质量，并探索新的增长点，以保持长期竞争力。</p><hr><h2 id="快手（Kuaishou）">快手（Kuaishou）</h2><h3 id="产品概述-10">产品概述</h3><p>快手是中国领先的短视频和直播平台，成立于2011年，最初是一款GIF制作工具，后逐步发展为短视频社交平台。快手的核心特点是去中心化推荐机制，鼓励普通用户创作内容，并形成强互动的社交氛围。</p><h3 id="核心功能-10">核心功能</h3><ol><li><strong>短视频发布与观看</strong>：用户可上传短视频，平台通过AI推荐内容，增强用户粘性。</li><li><strong>直播互动</strong>：支持主播打赏、连麦互动、PK等多种直播玩法，提高用户活跃度。</li><li><strong>社交功能</strong>：用户可关注、评论、点赞、分享，并建立私信联系，增强社交属性。</li><li><strong>电商带货</strong>：平台内嵌电商系统，主播和用户可在视频或直播中推广商品。</li><li><strong>本地生活</strong>：提供到店优惠、团购、外卖等本地消费服务，与短视频结合提高转化率。</li></ol><h3 id="用户体验评估-10">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>以“老铁”文化为核心，社交氛围浓厚，用户互动性强。</li><li>内容覆盖广泛，从乡村生活到城市潮流，满足不同人群需求。</li><li>短视频与直播结合紧密，增强用户留存。</li></ul></li><li><strong>不足</strong>：<ul><li>相较于抖音，品牌影响力稍弱，在高端市场吸引力不足。</li><li>平台内容质量参差不齐，部分低俗或重复内容影响用户体验。</li></ul></li></ul><h3 id="商业模式解释-10">商业模式解释</h3><ol><li><strong>广告收入</strong>：信息流广告、品牌合作投放。</li><li><strong>直播打赏</strong>：用户可向主播赠送虚拟礼物，平台抽取分成。</li><li><strong>电商佣金</strong>：直播带货、短视频种草，快手在交易中收取佣金。</li><li><strong>本地生活与服务</strong>：与商家合作提供团购、优惠券等服务，赚取佣金或推广费。</li></ol><h3 id="竞争分析-10">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>抖音</strong>：市场最大竞争者，流量更大，品牌影响力更强。</li><li><strong>小红书</strong>：在种草、内容电商方面竞争激烈。</li><li><strong>B站</strong>：在年轻人市场，二次元、长视频方向有较大竞争。</li></ul></li><li><strong>优势</strong>：<ul><li>用户互动高，社区氛围较强。</li><li>下沉市场占有率较高，覆盖大量三四线及农村用户。</li></ul></li><li><strong>劣势</strong>：<ul><li>品牌调性不够高端，在白领用户群体渗透较慢。</li><li>直播变现模式依赖度高，电商与广告的盈利能力仍需提升。</li></ul></li></ul><h3 id="运营策略-10">运营策略</h3><ol><li><strong>提升品牌形象</strong>：加强优质内容创作，吸引更多专业用户和品牌方。</li><li><strong>优化内容推荐</strong>：加强AI推荐算法，提高内容质量，减少低俗内容曝光。</li><li><strong>拓展电商生态</strong>：强化供应链整合，优化直播带货体验，提高用户购物满意度。</li><li><strong>国际化发展</strong>：继续开拓东南亚、南美等市场，提升全球竞争力。</li></ol><h3 id="改进建议-10">改进建议</h3><ol><li><strong>减少低质量内容</strong>：加强内容审核，提高优质创作者的激励力度。</li><li><strong>增强短视频变现能力</strong>：优化短视频广告、电商变现能力，降低对直播打赏的依赖。</li><li><strong>提升商业合作深度</strong>：与更多品牌商家合作，提高广告、电商、线下服务的综合变现能力。</li><li><strong>优化用户增长策略</strong>：在一二线城市增加推广，吸引更多年轻和高端用户。</li></ol><h3 id="总结-10">总结</h3><p>快手凭借独特的社区文化和强互动性，在短视频和直播市场占据重要地位。但面对抖音的竞争压力，它需要不断优化内容质量、拓展商业模式，并提升品牌影响力，以保持竞争优势。</p><hr><h2 id="微博（Weibo）">微博（Weibo）</h2><h3 id="产品概述-11">产品概述</h3><p>微博（Weibo）是中国最大的社交媒体平台之一，类似于Twitter，用户可以发布短内容（微博）、关注热点话题，并与公众人物、品牌或普通用户互动。作为信息传播和社交互动的重要工具，微博在新闻、娱乐、营销等领域具有广泛影响力。</p><h3 id="核心功能-11">核心功能</h3><ol><li><strong>信息流</strong>：用户可以关注感兴趣的博主，并通过信息流获取实时动态。</li><li><strong>热搜与话题</strong>：微博的热搜榜和话题广场帮助用户快速了解热点新闻和趋势。</li><li><strong>互动功能</strong>：包括评论、转发、点赞、私信等社交互动形式。</li><li><strong>短视频与直播</strong>：支持用户上传短视频、开设直播，增强内容丰富度。</li><li><strong>微博会员</strong>：提供VIP用户专属权益，如个性化主页、评论置顶等。</li><li><strong>广告与电商</strong>：品牌方可通过广告推广、KOL合作、直播带货等方式实现营销转化。</li></ol><h3 id="用户体验评估-11">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>信息获取及时，适合作为新闻和热点追踪工具。</li><li>互动性强，普通用户可与明星、品牌、KOL直接互动。</li><li>话题运营机制较成熟，用户可以围绕兴趣进行内容消费。</li></ul></li><li><strong>不足</strong>：<ul><li>信息流广告较多，影响阅读体验。</li><li>低质量内容和营销号泛滥，影响平台公信力。</li><li>用户增长趋于饱和，活跃度面临挑战。</li></ul></li></ul><h3 id="商业模式解释-11">商业模式解释</h3><ol><li><strong>广告收入</strong>：信息流广告、品牌推广、KOL合作等形式。</li><li><strong>会员订阅</strong>：微博会员提供增值功能，如专属标识、优先曝光等。</li><li><strong>电商与直播带货</strong>：用户可通过微博进行商品推广，平台抽取佣金。</li><li><strong>数据服务</strong>：提供企业级数据分析和营销解决方案。</li></ol><h3 id="竞争分析-11">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>微信</strong>：在社交和私域流量方面更具优势。</li><li><strong>抖音、快手</strong>：短视频平台分流了大量用户的内容消费时间。</li><li><strong>小红书</strong>：在内容社区和种草电商领域对微博形成竞争。</li></ul></li><li><strong>优势</strong>：<ul><li>具有较强的社交属性，用户粘性较高。</li><li>作为公共舆论场，仍是众多品牌、媒体和公众人物的重要阵地。</li></ul></li><li><strong>劣势</strong>：<ul><li>受短视频平台冲击，用户活跃度下降。</li><li>过度商业化导致部分用户体验下降。</li></ul></li></ul><h3 id="运营策略-11">运营策略</h3><ol><li><strong>优化内容推荐</strong>：提升算法推荐精度，减少低质量内容曝光。</li><li><strong>增强用户互动</strong>：鼓励用户生产优质内容，提高社区氛围。</li><li><strong>拓展电商生态</strong>：强化微博电商能力，与更多品牌、KOL深度合作。</li><li><strong>降低广告干扰</strong>：优化广告展示方式，提高用户体验。</li></ol><h3 id="改进建议-11">改进建议</h3><ol><li><strong>加强内容治理</strong>：减少营销号和低质内容，提升信息可信度。</li><li><strong>优化社交功能</strong>：增强私信、社群等互动功能，提升用户粘性。</li><li><strong>提升视频内容比重</strong>：加大短视频和直播投入，迎合用户内容消费趋势。</li><li><strong>国际化发展</strong>：拓展海外市场，吸引更多全球用户。</li></ol><h3 id="总结-11">总结</h3><p>微博作为中国最大的社交媒体平台之一，在新闻传播和品牌营销方面具有重要影响力。但面对短视频平台的冲击，其用户增长和活跃度面临挑战。未来需要优化内容生态、提升用户体验，并探索新的商业模式，以保持市场竞争力。</p><hr><h2 id="得到（Dedao）">得到（Dedao）</h2><h3 id="产品概述-12">产品概述</h3><p>得到是一款专注于知识付费的应用，提供音频课程、电子书、直播讲座和知识社群。其核心目标是为用户提供高质量的学习内容，涵盖商业、管理、科技、人文等多个领域，帮助用户系统化学习和提升认知能力。</p><h3 id="核心功能-12">核心功能</h3><ol><li><strong>付费专栏</strong>：知名讲师开设长期专栏，每日更新知识点，如李翔商业内参、薛兆丰经济学课等。</li><li><strong>精品课</strong>：提供深度知识课程，涵盖多个领域，帮助用户快速掌握某一主题。</li><li><strong>电子书</strong>：精选优质书籍，结合讲解和精华提炼，提升阅读效率。</li><li><strong>听书服务</strong>：将经典书籍拆解为音频内容，用户可在碎片时间内学习。</li><li><strong>社群互动</strong>：用户可在课程下交流，或参与得到社区，促进学习氛围。</li></ol><h3 id="用户体验评估-12">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>内容深度高，适合有系统学习需求的用户。</li><li>课程讲解清晰，音频和文本结合，方便用户多场景学习。</li><li>课程质量较高，主讲人多为行业专家或知名学者。</li></ul></li><li><strong>不足</strong>：<ul><li>付费门槛较高，部分用户可能难以接受长期订阅模式。</li><li>知识体系偏向商业和管理，对其他专业领域的覆盖度较弱。</li><li>社区互动功能相对较弱，用户粘性较依赖内容而非社交关系。</li></ul></li></ul><h3 id="商业模式解释-12">商业模式解释</h3><ol><li><strong>订阅制</strong>：用户购买年度会员，解锁部分课程或享受折扣。</li><li><strong>单次付费</strong>：用户可购买单个专栏、课程或电子书。</li><li><strong>企业培训</strong>：为企业提供团队学习方案，批量订阅课程。</li><li><strong>直播付费</strong>：知识分享直播，用户可付费观看或购买回放内容。</li></ol><h3 id="竞争分析-12">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>喜马拉雅</strong>：音频平台，涵盖更多泛娱乐内容，吸引更广泛用户群体。</li><li><strong>樊登读书</strong>：专注于书籍解读，针对中高端职场人士。</li><li><strong>知乎盐选</strong>：知乎的付费内容体系，结合问答社区增强互动性。</li></ul></li><li><strong>优势</strong>：<ul><li>课程质量高，内容体系化，适合深度学习用户。</li><li>品牌定位清晰，目标用户群体精准。</li></ul></li><li><strong>劣势</strong>：<ul><li>受众相对较窄，主要吸引职场人士，对年轻群体吸引力有限。</li><li>竞争对手在社交互动、内容丰富度方面更具优势。</li></ul></li></ul><h3 id="运营策略-12">运营策略</h3><ol><li><strong>扩展内容类别</strong>：增加科技、心理学、艺术等领域的知识课程，覆盖更广用户群体。</li><li><strong>优化社群互动</strong>：增强用户间的学习交流功能，提高用户粘性。</li><li><strong>提升会员价值</strong>：增加更多增值权益，如线下活动、专属咨询等，提升会员留存率。</li><li><strong>拓展企业市场</strong>：加强B端业务，推广企业学习方案，提升商业化能力。</li></ol><h3 id="改进建议-12">改进建议</h3><ol><li><strong>降低学习门槛</strong>：推出更多短期体验课，吸引新用户尝试。</li><li><strong>优化推荐系统</strong>：基于用户兴趣和学习进度，精准推送个性化内容。</li><li><strong>提升社交属性</strong>：推出小组学习模式，让用户在团队环境中共同成长。</li><li><strong>增加免费优质内容</strong>：通过免费试听或限时活动，提高用户转化率。</li></ol><h3 id="总结-12">总结</h3><p>得到在知识付费市场占据重要地位，凭借高质量内容和专业讲师体系吸引了大量职场用户。然而，在市场竞争加剧的情况下，需要不断优化产品体验、拓展内容品类，并增强社群互动，以提高用户粘性和商业价值。</p><hr><h2 id="夸克（Quark）">夸克（Quark）</h2><h3 id="产品概述-13">产品概述</h3><p>夸克是一款由阿里巴巴旗下的UC团队推出的智能搜索引擎和浏览器应用，主打极简设计、AI驱动的搜索体验，并结合了云存储、文档扫描等工具，成为年轻用户群体中的热门工具类应用。</p><h3 id="核心功能-13">核心功能</h3><ol><li><strong>智能搜索</strong>：基于AI算法优化搜索结果，提供精准的知识问答、图像搜索、学术搜索等功能。</li><li><strong>云盘存储</strong>：夸克网盘提供文件存储、智能分类、在线预览等功能，与夸克搜索深度集成。</li><li><strong>文档扫描</strong>：内置OCR文字识别技术，支持文档扫描、拍照翻译等功能。</li><li><strong>广告拦截</strong>：内置广告过滤功能，为用户提供更清爽的浏览体验。</li><li><strong>AI助手</strong>：智能摘要、AI问答、学习助手等功能，提升用户的信息获取效率。</li></ol><h3 id="用户体验评估-13">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>界面极简，浏览体验流畅，广告干扰较少。</li><li>搜索结果精准度较高，尤其在学术和专业知识领域有一定优势。</li><li>夸克网盘功能强大，适合学生和职场人士存储学习资料。</li></ul></li><li><strong>不足</strong>：<ul><li>市场认知度相较于百度、Google等搜索引擎较低，用户基数有限。</li><li>夸克网盘的免费存储空间较小，付费门槛较高。</li><li>生态体系不够完善，缺乏对其他阿里系产品的深度整合。</li></ul></li></ul><h3 id="商业模式解释-13">商业模式解释</h3><ol><li><strong>会员订阅</strong>：提供夸克网盘VIP，包含更大存储空间、加速下载等增值功能。</li><li><strong>搜索广告</strong>：与电商、信息流广告结合，在搜索结果中插入广告。</li><li><strong>增值工具</strong>：OCR扫描、AI翻译等高级功能可通过单次购买或订阅解锁。</li></ol><h3 id="竞争分析-13">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>百度</strong>（在中文搜索市场占据主导地位）。</li><li><strong>Google</strong>（在海外市场搜索体验更优，但在中国无法使用）。</li><li><strong>讯飞扫描王</strong>（在OCR识别、文档管理领域竞争）。</li><li><strong>阿里云盘、百度网盘</strong>（在云存储市场竞争）。</li></ul></li><li><strong>优势</strong>：<ul><li>无广告干扰的极简体验，吸引追求效率的用户。</li><li>AI功能较强，智能摘要、翻译等特色功能提高用户留存率。</li></ul></li><li><strong>劣势</strong>：<ul><li>市场份额相对较小，用户习惯尚未养成。</li><li>变现能力较弱，相较于百度的广告模式仍需探索更多盈利点。</li></ul></li></ul><h3 id="运营策略-13">运营策略</h3><ol><li><strong>增强用户教育</strong>：推广夸克的搜索、网盘等特色功能，提高用户认知度。</li><li><strong>优化会员权益</strong>：提升付费用户的独享功能，如更大存储、个性化搜索推荐等。</li><li><strong>拓展B端市场</strong>：与教育、科研机构合作，提供学术搜索、智能办公等解决方案。</li><li><strong>加强生态整合</strong>：与阿里云、支付宝、钉钉等产品联动，提高用户触达率。</li></ol><h3 id="改进建议-13">改进建议</h3><ol><li><strong>提升搜索精准度</strong>：进一步优化AI搜索能力，提高与竞品的核心差异化。</li><li><strong>优化网盘体验</strong>：增加免费用户存储空间，提高存储扩展的灵活性。</li><li><strong>增强用户增长策略</strong>：推出联合推广、邀请返利等活动，提升市场渗透率。</li><li><strong>拓展内容生态</strong>：引入更多知识类、专业类内容，提高平台信息质量。</li></ol><h3 id="总结-13">总结</h3><p>夸克凭借极简设计和AI搜索能力，在搜索引擎和工具应用市场中形成了一定的竞争力。然而，面对百度的市场垄断和用户习惯的固化，夸克需要进一步提升搜索能力、优化商业模式，并加强品牌推广，以提升市场占有率和用户忠诚度。</p><hr><h2 id="喜马拉雅（Ximalaya）">喜马拉雅（Ximalaya）</h2><h3 id="产品概述-14">产品概述</h3><p>喜马拉雅是中国领先的音频内容平台，提供有声书、播客、新闻、相声、音乐等多种音频内容。自2012年成立以来，喜马拉雅逐步构建了内容创作者生态，吸引了大量用户在通勤、学习、休闲时使用，形成了“耳朵经济”领域的领导品牌。</p><h3 id="核心功能-14">核心功能</h3><ol><li><strong>有声书</strong>：涵盖文学、历史、科幻等多类型书籍，用户可在线收听或下载离线播放。</li><li><strong>播客节目</strong>：提供新闻、访谈、财经、科技等丰富的播客内容，满足不同用户需求。</li><li><strong>知识付费</strong>：名人讲座、课程订阅、学术讲解等内容，适合提升个人技能。</li><li><strong>睡眠与冥想</strong>：助眠音乐、白噪音、冥想课程，帮助用户放松和改善睡眠质量。</li><li><strong>儿童专区</strong>：专门为儿童提供寓教于乐的音频内容，如故事、英语启蒙等。</li><li><strong>主播互动</strong>：用户可以关注喜爱的主播，点赞、评论、打赏，提高社区互动性。</li></ol><h3 id="用户体验评估-14">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>内容种类丰富，适合不同人群的需求。</li><li>界面简洁，播放体验流畅，支持多设备同步。</li><li>知识付费体系完善，用户可以系统化学习。</li></ul></li><li><strong>不足</strong>：<ul><li>免费用户广告较多，影响听觉体验。</li><li>付费会员权益较为分散，用户可能对订阅模式的价值感知不足。</li><li>播客与部分内容的个性化推荐有待优化。</li></ul></li></ul><h3 id="商业模式解释-14">商业模式解释</h3><ol><li><strong>会员订阅</strong>：提供VIP会员，解锁付费内容、去广告、音质提升等权益。</li><li><strong>知识付费</strong>：用户可以单独购买课程、有声书、讲座等内容。</li><li><strong>广告收入</strong>：平台在音频内容、开屏广告、信息流广告等位置投放广告。</li><li><strong>主播打赏与直播</strong>：用户可向喜爱的主播赠送虚拟礼物，平台抽取分成。</li><li><strong>品牌合作</strong>：与企业、出版社、教育机构合作，推广优质内容。</li></ol><h3 id="竞争分析-14">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>蜻蜓FM</strong>（另一家音频平台，主打电台节目）。</li><li><strong>得到</strong>（专注知识付费，竞争力较强）。</li><li><strong>Apple Podcasts / Spotify</strong>（在国际市场占有优势，但在国内影响有限）。</li></ul></li><li><strong>优势</strong>：<ul><li>内容生态丰富，涵盖免费与付费内容，满足不同用户需求。</li><li>头部主播与独家内容多，具有较强用户粘性。</li></ul></li><li><strong>劣势</strong>：<ul><li>过度依赖知识付费，商业模式单一化风险较高。</li><li>在播客领域的国际化竞争中，相比Spotify等平台存在差距。</li></ul></li></ul><h3 id="运营策略-14">运营策略</h3><ol><li><strong>优化会员体系</strong>：加强会员权益整合，提高用户订阅意愿。</li><li><strong>提升AI推荐能力</strong>：利用算法优化个性化推荐，提升用户留存率。</li><li><strong>拓展海外市场</strong>：开发海外中文听众市场，提高国际影响力。</li><li><strong>加强社区互动</strong>：引入更多社交元素，如听友群、讨论区，提高用户活跃度。</li></ol><h3 id="改进建议-14">改进建议</h3><ol><li><strong>减少广告干扰</strong>：优化广告展示方式，降低对免费用户的影响。</li><li><strong>增强免费内容</strong>：提供更多高质量免费节目，提高新用户转化率。</li><li><strong>提升音频体验</strong>：引入3D音效、沉浸式播放，提高高端用户体验。</li><li><strong>扩展内容品类</strong>：加强财经、科技、创业等垂直领域的音频内容，提高专业性。</li></ol><h3 id="总结-14">总结</h3><p>喜马拉雅凭借其丰富的音频内容和强大的用户生态，在中国音频市场占据领先地位。未来需优化会员权益、提升内容推荐精准度，并拓展国际市场，以保持长期竞争力。</p><hr><h2 id="探探（Tantan）">探探（Tantan）</h2><h3 id="产品概述-15">产品概述</h3><p>探探是中国领先的社交交友应用，主打“滑动匹配”模式，帮助年轻人基于兴趣、地理位置找到潜在朋友或约会对象。探探的核心特色在于匿名、轻量化交互，让用户可以自由选择是否与对方建立联系。</p><h3 id="核心功能-15">核心功能</h3><ol><li><strong>滑动匹配</strong>：用户向右滑动喜欢的人，向左滑动跳过，只有双方都喜欢才可聊天。</li><li><strong>即时聊天</strong>：匹配成功后可进入私聊，支持文字、图片、语音等多种交流方式。</li><li><strong>个性化推荐</strong>：基于AI算法推荐可能感兴趣的用户，提高匹配成功率。</li><li><strong>附近的人</strong>：基于地理位置，展示周边活跃用户，增强本地社交体验。</li><li><strong>超级喜欢 &amp; 反悔功能</strong>：用户可发送超级喜欢，提高被匹配概率，或撤销误操作的滑动。</li></ol><h3 id="用户体验评估-15">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li><strong>界面简洁直观</strong>，滑动匹配降低社交压力，提高互动率。</li><li><strong>AI推荐较精准</strong>，基于兴趣和行为优化匹配结果。</li><li><strong>匿名机制保护隐私</strong>，降低用户初次交流的心理负担。</li></ul></li><li><strong>不足</strong>：<ul><li>机器人账号和虚假信息较多，影响用户信任度。</li><li>付费门槛较高，非会员用户匹配效率较低。</li><li>部分用户抱怨社交目的单一，缺乏深度关系建立的功能。</li></ul></li></ul><h3 id="商业模式解释-15">商业模式解释</h3><ol><li><strong>会员订阅（VIP）</strong>：提供无限滑动、查看谁喜欢你等高级功能，提升匹配效率。</li><li><strong>付费道具</strong>：如超级喜欢、反悔、增加曝光等，提高用户的互动机会。</li><li><strong>广告收入</strong>：通过信息流广告、品牌合作推广等方式变现。</li><li><strong>增值服务</strong>：推出类似“探探约会”等高端社交活动，提高用户付费意愿。</li></ol><h3 id="竞争分析-15">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>陌陌</strong>（主打陌生人社交，直播带货收入较高）。</li><li><strong>Soul</strong>（强调兴趣社交和社群互动，弱化颜值匹配）。</li><li><strong>Tinder</strong>（国际化社交软件，在海外市场具有较强竞争力）。</li></ul></li><li><strong>优势</strong>：<ul><li>产品模式成熟，匹配机制易上手，用户粘性较高。</li><li>在国内年轻人市场有较高的品牌认知度。</li></ul></li><li><strong>劣势</strong>：<ul><li>用户增长趋缓，市场竞争激烈，存在用户流失风险。</li><li>社交质量不稳定，部分用户体验较差，影响口碑。</li></ul></li></ul><h3 id="运营策略-15">运营策略</h3><ol><li><strong>优化匹配质量</strong>：加强身份认证机制，减少机器人和虚假账户，提高用户信任感。</li><li><strong>拓展社交场景</strong>：增加兴趣小组、在线活动，提高用户互动深度。</li><li><strong>优化会员权益</strong>：提供更多差异化功能，如语音匹配、视频聊天等，提高付费转化率。</li><li><strong>国际化探索</strong>：借鉴Tinder经验，拓展东南亚等社交市场，增加用户增长点。</li></ol><h3 id="改进建议-15">改进建议</h3><ol><li><strong>打击虚假用户</strong>：加强审核机制，提升用户体验和平台安全性。</li><li><strong>优化女性用户体验</strong>：增加更多社交互动机制，提高女性用户留存率。</li><li><strong>增强内容生态</strong>：支持短视频社交，提升用户之间的互动深度。</li><li><strong>降低付费门槛</strong>：推出更多灵活订阅方案，提高普通用户的参与度。</li></ol><h3 id="总结-15">总结</h3><p>探探作为中国市场上的领先社交应用，凭借“滑动匹配”模式吸引了大量年轻用户。但面对激烈的竞争和用户需求变化，探探需要优化匹配质量、提升用户体验，并探索更多社交场景，以确保长期增长和市场领先地位。</p><hr><h2 id="叮咚买菜（Dingdong-Maicai）">叮咚买菜（Dingdong Maicai）</h2><h3 id="产品概述-16">产品概述</h3><p>叮咚买菜是中国领先的生鲜电商平台，提供即时配送的生鲜食品服务。平台主要通过前置仓模式，在用户下单后提供最快30分钟到1小时的配送服务，满足城市用户对生鲜食品的即时需求。</p><h3 id="核心功能-16">核心功能</h3><ol><li><strong>生鲜品类</strong>：涵盖蔬菜、水果、肉禽、海鲜、乳制品等日常食品。</li><li><strong>极速配送</strong>：依托前置仓模式，实现1小时内送达的即时配送服务。</li><li><strong>智能推荐</strong>：基于用户购买习惯，AI推荐个性化商品。</li><li><strong>会员服务</strong>：提供折扣、专属优惠券等会员权益，提高用户复购率。</li><li><strong>食品溯源</strong>：部分产品支持可追溯体系，确保食品安全。</li></ol><h3 id="用户体验评估-16">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>配送速度快，满足即时生鲜需求。</li><li>商品品类丰富，基本可覆盖家庭日常采购需求。</li><li>界面简洁，购物流程流畅，用户体验友好。</li></ul></li><li><strong>不足</strong>：<ul><li>价格相对传统菜市场和超市偏高，性价比不足。</li><li>受限于前置仓布局，部分区域可能配送不到。</li><li>供应链成本高，盈利模式仍需优化。</li></ul></li></ul><h3 id="商业模式解释-16">商业模式解释</h3><ol><li><strong>商品销售</strong>：通过销售生鲜食品赚取利润。</li><li><strong>会员订阅</strong>：提供VIP会员服务，享受折扣和专属权益。</li><li><strong>品牌合作</strong>：与食品供应商合作，推广品牌商品。</li><li><strong>数据增值服务</strong>：通过大数据分析优化供应链，提高运营效率。</li></ol><h3 id="竞争分析-16">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>美团买菜</strong>（同样采用前置仓模式，依托美团生态流量）。</li><li><strong>盒马鲜生</strong>（线上+线下结合模式，门店体验更强）。</li><li><strong>多多买菜</strong>（拼多多旗下，社区团购模式，价格更具优势）。</li></ul></li><li><strong>优势</strong>：<ul><li>专注生鲜即时配送，供应链能力较强。</li><li>在一线城市用户基础稳固，品牌认知度较高。</li></ul></li><li><strong>劣势</strong>：<ul><li>运营成本高，盈利能力受限。</li><li>竞争激烈，市场份额容易受价格战影响。</li></ul></li></ul><h3 id="运营策略-16">运营策略</h3><ol><li><strong>优化供应链</strong>：提高仓储管理和物流效率，降低配送成本。</li><li><strong>提升用户粘性</strong>：丰富会员权益，提高用户复购率。</li><li><strong>拓展市场</strong>：进入二三线城市，增加市场渗透率。</li><li><strong>加强食品安全监管</strong>：提高食品质量管控，增强用户信任感。</li></ol><h3 id="改进建议-16">改进建议</h3><ol><li><strong>优化定价策略</strong>：提供更多促销和套餐，提高性价比。</li><li><strong>加强区域覆盖</strong>：拓展前置仓布局，覆盖更多城市。</li><li><strong>提升智能推荐</strong>：优化AI算法，提高用户个性化购物体验。</li><li><strong>探索多元化服务</strong>：引入半成品预制菜、即食食品等，提高客单价。</li></ol><h3 id="总结-16">总结</h3><p>叮咚买菜凭借即时配送和强供应链管理，在生鲜电商领域占据重要位置。但面对竞争激烈的市场环境，需要优化成本结构、提升用户粘性，并拓展更多增长点，以实现长期可持续发展。</p><hr><h2 id="美图秀秀（Meitu-Xiuxiu）">美图秀秀（Meitu Xiuxiu）</h2><h3 id="产品概述-17">产品概述</h3><p>美图秀秀是中国领先的图片编辑与美颜软件，提供强大的修图、美颜、滤镜、AI特效等功能，深受年轻用户尤其是女性用户喜爱。美图秀秀不仅是国内修图软件的代表，还在短视频、社交、美妆AI等领域不断拓展，形成独特的产品生态。</p><h3 id="核心功能-17">核心功能</h3><ol><li><strong>智能美颜</strong>：支持自拍美颜、瘦脸、磨皮、美白、五官调整等。</li><li><strong>滤镜与特效</strong>：提供多种风格滤镜和AI特效，增强照片艺术感。</li><li><strong>AI绘画</strong>：基于AI技术，将照片转换成漫画风、二次元风等。</li><li><strong>视频美化</strong>：支持短视频美颜、特效、字幕添加等功能。</li><li><strong>社交分享</strong>：用户可将编辑后的图片分享到美图社区或其他社交平台。</li><li><strong>美妆与穿搭推荐</strong>：结合AI分析，为用户提供个性化美妆和穿搭建议。</li></ol><h3 id="用户体验评估-17">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>界面简洁易用，新手用户可快速上手。</li><li>美颜与修图功能强大，满足不同用户需求。</li><li>AI特效持续创新，提高用户新鲜感。</li></ul></li><li><strong>不足</strong>：<ul><li>部分高级功能需付费，非会员用户体验受限。</li><li>过度美颜可能影响照片真实性，引发审美焦虑争议。</li><li>广告较多，影响部分用户使用体验。</li></ul></li></ul><h3 id="商业模式解释-17">商业模式解释</h3><ol><li><strong>会员订阅</strong>：美图VIP提供高级滤镜、无水印、AI特效等增值功能。</li><li><strong>广告收入</strong>：在应用内展示品牌广告，或与美妆、时尚品牌合作推广。</li><li><strong>AI美妆与电商</strong>：结合AI技术，推出个性化美妆推荐，并与品牌电商合作。</li><li><strong>授权技术</strong>：向第三方平台提供AI美颜、图像处理技术服务。</li></ol><h3 id="竞争分析-17">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>FaceU、B612</strong>（主打拍照美颜，竞争美颜自拍市场）。</li><li><strong>Snapchat、Instagram</strong>（在短视频、滤镜社交领域形成竞争）。</li><li><strong>剪映、VN</strong>（在短视频编辑市场有一定替代性）。</li></ul></li><li><strong>优势</strong>：<ul><li>深耕修图市场多年，品牌认知度高，用户群体忠诚度强。</li><li>AI技术创新持续推进，拓展美妆、社交等领域。</li></ul></li><li><strong>劣势</strong>：<ul><li>变现方式较单一，仍依赖会员订阅和广告收入。</li><li>海外市场拓展有限，国际竞争力有待提升。</li></ul></li></ul><h3 id="运营策略-17">运营策略</h3><ol><li><strong>优化会员体系</strong>：提升VIP会员权益，增加独家滤镜和AI功能，提高付费转化率。</li><li><strong>增强社交属性</strong>：推动美图社区互动，提升用户留存和分享欲望。</li><li><strong>深化AI技术应用</strong>：扩展至更多AI智能美妆、智能穿搭功能，提高用户价值。</li><li><strong>拓展国际市场</strong>：加强海外推广，针对欧美、日本等市场推出本地化版本。</li></ol><h3 id="改进建议-17">改进建议</h3><ol><li><strong>减少广告干扰</strong>：优化广告展示逻辑，避免影响用户体验。</li><li><strong>推出个性化推荐</strong>：基于用户行为优化滤镜、特效推荐，提高用户粘性。</li><li><strong>增加短视频功能</strong>：增强视频剪辑、美颜能力，提升用户对短视频创作的兴趣。</li><li><strong>探索更多商业化模式</strong>：如推出AI虚拟形象、NFT头像生成等创新产品，扩大营收来源。</li></ol><h3 id="总结-17">总结</h3><p>美图秀秀凭借其强大的修图与美颜功能，在市场中占据重要地位。然而，面对短视频、社交产品的竞争，美图秀秀需要持续创新，优化用户体验，并探索更多商业化模式，以保持长期竞争力。</p><hr><h2 id="微信读书（WeChat-Reading）">微信读书（WeChat Reading）</h2><h3 id="产品概述-18">产品概述</h3><p>微信读书是腾讯旗下的数字阅读平台，依托微信生态，为用户提供电子书、听书、笔记分享、社交阅读等功能。其核心特色是“社交+阅读”模式，用户可以与微信好友互动，查看好友的阅读动态，增强阅读体验。</p><h3 id="核心功能-18">核心功能</h3><ol><li><strong>电子书阅读</strong>：提供海量书籍，涵盖文学、商业、科技等多个类别。</li><li><strong>听书功能</strong>：部分书籍支持音频朗读，适合碎片化学习。</li><li><strong>社交阅读</strong>：用户可查看好友书架、阅读时长、笔记等，增强互动感。</li><li><strong>无限卡会员</strong>：订阅会员可畅读大部分书籍，提升阅读自由度。</li><li><strong>阅读挑战</strong>：鼓励用户参与读书打卡，提高阅读动力。</li><li><strong>跨设备同步</strong>：支持手机、平板、电脑端同步阅读进度。</li></ol><h3 id="用户体验评估-18">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>依托微信社交关系链，提升用户阅读动力。</li><li>书籍种类丰富，界面简洁，阅读体验优良。</li><li>无限卡模式降低单本书购买成本，适合高频阅读用户。</li></ul></li><li><strong>不足</strong>：<ul><li>对非微信用户吸引力有限，依赖微信生态较强。</li><li>部分优质书籍仍需单独购买，影响会员体验。</li><li>听书功能相较于专业平台（如喜马拉雅）仍有提升空间。</li></ul></li></ul><h3 id="商业模式解释-18">商业模式解释</h3><ol><li><strong>会员订阅</strong>：无限卡提供畅读权限，用户按月/年付费。</li><li><strong>单本购买</strong>：部分热门书籍需要单独购买或租赁。</li><li><strong>广告与推广</strong>：与出版社、品牌合作，进行书籍推广和营销。</li><li><strong>社交裂变</strong>：通过好友邀请、阅读挑战等提高用户活跃度和续订率。</li></ol><h3 id="竞争分析-18">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>Kindle中国</strong>（亚马逊旗下，书籍资源丰富，但生态封闭）。</li><li><strong>掌阅、QQ阅读</strong>（传统数字阅读平台，市场份额较大）。</li><li><strong>喜马拉雅、得到</strong>（专注于知识付费和听书市场）。</li></ul></li><li><strong>优势</strong>：<ul><li>微信生态加持，社交阅读模式独特。</li><li>订阅模式降低购书成本，提高用户黏性。</li></ul></li><li><strong>劣势</strong>：<ul><li>受限于微信生态，独立性较弱，难以吸引非微信用户。</li><li>内容与出版资源仍需拓展，部分专业书籍覆盖不足。</li></ul></li></ul><h3 id="运营策略-18">运营策略</h3><ol><li><strong>优化听书体验</strong>：引入更多专业主播朗读，增强有声书吸引力。</li><li><strong>提升会员权益</strong>：扩展会员专属书库，提高无限卡吸引力。</li><li><strong>拓展企业市场</strong>：为公司、学校提供阅读订阅方案，扩大B端业务。</li><li><strong>国际化探索</strong>：推出适配海外用户的版本，拓展全球华人市场。</li></ol><h3 id="改进建议-18">改进建议</h3><ol><li><strong>增强社交互动</strong>：增加书友社群、读书会功能，提高用户参与度。</li><li><strong>优化内容推荐</strong>：基于AI分析用户兴趣，推送个性化阅读书单。</li><li><strong>提升电子书排版</strong>：优化阅读排版和笔记功能，提供更专业的阅读体验。</li><li><strong>探索知识付费模式</strong>：推出深度解读、课程等增值内容，提高用户价值。</li></ol><h3 id="总结-18">总结</h3><p>微信读书凭借社交+阅读模式，在数字阅读市场中形成差异化竞争优势。但要进一步扩大市场份额，需要优化听书体验、强化会员价值，并探索新的商业化模式，以实现长期增长。</p><hr><h2 id="即刻（Jike）">即刻（Jike）</h2><h3 id="产品概述-19">产品概述</h3><p>即刻是一款主打兴趣社区与信息聚合的社交应用，最初以“信息订阅”功能闻名，后逐步转型为年轻人兴趣社交平台。即刻的核心理念是让用户基于兴趣发现内容、建立社群，并围绕共同话题进行交流。</p><h3 id="核心功能-19">核心功能</h3><ol><li><strong>兴趣话题</strong>：用户可以关注自己感兴趣的话题（如科技、游戏、电影），获取个性化信息流。</li><li><strong>社区互动</strong>：支持用户在话题下发布动态、评论、点赞，提高社交参与度。</li><li><strong>即时热点</strong>：基于算法推荐最新的网络热点，帮助用户及时获取热门信息。</li><li><strong>小组功能</strong>：类似论坛，用户可以加入或创建兴趣小组，进行更深入的交流。</li><li><strong>内容创作与分发</strong>：支持用户发布短文、长文、图片、视频，增强内容生态。</li></ol><h3 id="用户体验评估-19">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>界面设计清爽，信息流逻辑清晰，使用体验良好。</li><li>关注兴趣点而非社交关系，降低信息冗余，提高内容质量。</li><li>社区氛围较好，适合优质内容生产者和深度讨论。</li></ul></li><li><strong>不足</strong>：<ul><li>用户规模相对较小，部分兴趣小组活跃度不高。</li><li>变现模式尚未完全成熟，盈利能力受限。</li><li>相较于微博、豆瓣等竞争对手，内容丰富度仍需加强。</li></ul></li></ul><h3 id="商业模式解释-19">商业模式解释</h3><ol><li><strong>广告投放</strong>：品牌可在兴趣话题、社区推荐位等进行精准广告投放。</li><li><strong>会员订阅</strong>：提供额外权益，如无广告、高级功能等，提高用户付费转化。</li><li><strong>内容电商</strong>：基于兴趣社群，结合KOL推荐，尝试社交电商变现。</li><li><strong>品牌合作</strong>：与媒体、出版机构等合作，提供独家内容或推广服务。</li></ol><h3 id="竞争分析-19">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>微博</strong>（信息流+社交，但信息噪音较多）。</li><li><strong>豆瓣</strong>（兴趣社群，但社区氛围相对封闭）。</li><li><strong>小红书</strong>（基于内容的社交推荐，偏种草方向）。</li></ul></li><li><strong>优势</strong>：<ul><li>关注兴趣，而非社交关系，降低社交压力，提高内容质量。</li><li>社区互动性较强，讨论深度优于微博等泛社交平台。</li></ul></li><li><strong>劣势</strong>：<ul><li>用户基数较小，难以形成大规模影响力。</li><li>变现模式探索中，商业化能力仍需加强。</li></ul></li></ul><h3 id="运营策略-19">运营策略</h3><ol><li><strong>提升用户增长</strong>：通过精准营销、口碑传播，吸引更多高质量用户。</li><li><strong>优化推荐算法</strong>：提升兴趣匹配精准度，提高用户粘性和活跃度。</li><li><strong>增强商业化探索</strong>：尝试知识付费、电商带货等变现方式，提升收入能力。</li><li><strong>拓展内容生态</strong>：引入更多优质创作者，增加原创内容供给，提高用户留存率。</li></ol><h3 id="改进建议-19">改进建议</h3><ol><li><strong>优化用户推荐机制</strong>：减少无关内容，提高兴趣匹配的精准度。</li><li><strong>增强社群互动工具</strong>：推出更多互动玩法，如直播、语音聊天室等，提升用户体验。</li><li><strong>提升商业化能力</strong>：探索品牌合作、电商、知识付费等多元盈利模式。</li><li><strong>加速用户增长</strong>：通过与高校、KOL合作，吸引更多年轻用户进入平台。</li></ol><h3 id="总结-19">总结</h3><p>即刻凭借兴趣社交模式，在信息聚合与社区互动方面具有一定竞争力。但要进一步扩大影响力，需要加强用户增长、优化内容生态，并探索更多商业化模式，以确保平台的可持续发展。</p><hr><h2 id="百度地图（Baidu-Maps）">百度地图（Baidu Maps）</h2><h3 id="产品概述-20">产品概述</h3><p>百度地图是中国领先的地图导航服务，提供精准的地点搜索、实时交通、公交换乘、步行导航等功能。作为百度 AI 战略的重要组成部分，百度地图近年来不断升级 AI 算法，优化导航体验，并扩展至自动驾驶、智慧出行等领域。</p><h3 id="核心功能-20">核心功能</h3><ol><li><strong>智能导航</strong>：提供实时路况信息，支持驾车、步行、骑行、公交等多种出行方式。</li><li><strong>实时交通</strong>：基于大数据分析，提供精准的拥堵预测和动态路线优化。</li><li><strong>室内地图</strong>：覆盖商场、机场、车站等室内场景，支持 AR 导航。</li><li><strong>自动驾驶支持</strong>：百度 Apollo 自动驾驶技术在百度地图上已有部分落地。</li><li><strong>语音助手</strong>：智能语音交互，支持语音导航、地点查询，提高驾驶安全性。</li><li><strong>生活服务</strong>：集成酒店预订、美食推荐、加油站查询等本地生活功能。</li></ol><h3 id="用户体验评估-20">用户体验评估</h3><ul><li><strong>优点</strong>：<ul><li>地图数据精准，适用于国内各种出行场景。</li><li>AI 算法优化路径规划，提升出行效率。</li><li>语音助手和 AR 导航增强了智能化体验。</li></ul></li><li><strong>不足</strong>：<ul><li>广告较多，部分推广内容影响用户体验。</li><li>海外地图数据不如 Google Maps 完善，限制国际化使用。</li><li>个人隐私数据安全问题仍需加强透明度和用户控制权限。</li></ul></li></ul><h3 id="商业模式解释-20">商业模式解释</h3><ol><li><strong>广告业务</strong>：通过信息流广告、商家标注、POI（兴趣点）推广等形式盈利。</li><li><strong>企业服务</strong>：提供 API、企业地图解决方案，涵盖物流、零售、旅游等行业。</li><li><strong>自动驾驶生态</strong>：与百度 Apollo 结合，布局智能驾驶商业化。</li><li><strong>本地生活变现</strong>：与酒店、餐饮、出行等服务商合作，实现交易分成。</li></ol><h3 id="竞争分析-20">竞争分析</h3><ul><li><strong>主要竞争对手</strong>：<ul><li><strong>高德地图</strong>（阿里巴巴旗下，数据精准，用户体验较强）。</li><li><strong>腾讯地图</strong>（微信生态加持，但市场占有率较低）。</li><li><strong>Google Maps</strong>（全球覆盖度广，但在国内无法使用）。</li></ul></li><li><strong>优势</strong>：<ul><li>强大的 AI 算法优化导航和搜索体验。</li><li>百度生态支持，与搜索、Apollo 业务形成协同效应。</li></ul></li><li><strong>劣势</strong>：<ul><li>用户体验因广告和信息冗余受到一定影响。</li><li>在高端导航市场（如智能驾驶、海外数据）尚未形成绝对优势。</li></ul></li></ul><h3 id="运营策略-20">运营策略</h3><ol><li><strong>优化用户体验</strong>：减少广告干扰，提高导航界面清晰度和交互体验。</li><li><strong>强化智慧出行</strong>：增加智能驾驶支持，推动百度 Apollo 生态落地。</li><li><strong>扩展企业市场</strong>：提供更强大的 API 能力，拓展 B 端客户。</li><li><strong>国际化布局</strong>：加强海外地图数据建设，提升全球导航能力。</li></ol><h3 id="改进建议-20">改进建议</h3><ol><li><strong>降低广告占比</strong>：优化商业模式，减少对普通用户的广告干扰。</li><li><strong>增强隐私保护</strong>：提升用户数据管理权限，提高透明度。</li><li><strong>提升 AR 导航体验</strong>：优化 AR 导航精度，提高在复杂场景下的实用性。</li><li><strong>拓展 AI 语音助手能力</strong>：增加个性化语音指令，提高智能化水平。</li></ol><h3 id="总结-20">总结</h3><p>百度地图凭借 AI 能力和百度生态，在中国市场具备较强竞争力。但面对高德地图的市场主导地位，百度地图需要进一步优化用户体验、增强自动驾驶能力，并拓展国际市场，以提升长期竞争力。</p><hr>]]></content>
    
    
    <summary type="html">互联网产品分析笔记(一)</summary>
    
    
    
    <category term="产品分析" scheme="https://www.angfff.top/categories/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"/>
    
    
    <category term="互联网产品" scheme="https://www.angfff.top/tags/%E4%BA%92%E8%81%94%E7%BD%91%E4%BA%A7%E5%93%81/"/>
    
    <category term="产品分析" scheme="https://www.angfff.top/tags/%E4%BA%A7%E5%93%81%E5%88%86%E6%9E%90/"/>
    
    <category term="PM" scheme="https://www.angfff.top/tags/PM/"/>
    
  </entry>
  
  <entry>
    <title>MLX-学习笔记</title>
    <link href="https://www.angfff.top/posts/d37068c6.html"/>
    <id>https://www.angfff.top/posts/d37068c6.html</id>
    <published>2025-02-09T03:23:37.000Z</published>
    <updated>2025-03-06T04:40:56.796Z</updated>
    
    <content type="html"><![CDATA[<h1>一、框架文档 <a href="https://ml-explore.github.io/mlx/build/html/index.html">MLX</a></h1><hr><h1>二、框架安装</h1><h2 id="（一）创建并使用环境">（一）创建并使用环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">% python &gt;= 3.10 %%</span></span><br><span class="line">conda create -n mlx python=3.10</span><br><span class="line"></span><br><span class="line">conda activate mlx</span><br></pre></td></tr></table></figure><h2 id="（二）安装框架">（二）安装框架</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mlx</span><br></pre></td></tr></table></figure><hr><h1>三、LLM</h1><h2 id="（一）相关链接">（一）相关链接</h2><ul><li><a href="https://github.com/ml-explore/mlx-examples">mlx-examples</a></li><li><a href="https://github.com/ml-explore/mlx-examples/tree/main/llms">mlx-llms</a></li><li><a href="https://huggingface.co/mlx-community?message=You've%20joined%20MLX%20Community!">mlx-community</a></li></ul><h2 id="（二）安装-mlx-lm-库">（二）安装 mlx_lm 库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mlx-lm</span><br></pre></td></tr></table></figure><h2 id="（三）拉取-mlx-examples">（三）拉取 mlx-examples</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">% 官方示例库，方便学习参考 %%</span></span><br><span class="line">git clone https://github.com/ml-explore/mlx-examples.git</span><br></pre></td></tr></table></figure><h2 id="（四）Hugging-Face-模型下载">（四）Hugging Face 模型下载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">% 安装 git-lfs 方便拉取大文件 %%</span></span><br><span class="line">brew install git-lfs</span><br><span class="line">git lfs install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">% 拉取模型文件 %%</span></span><br><span class="line">git clone https://huggingface.co/Qwen/Qwen2.5-0.5B-Instruct</span><br></pre></td></tr></table></figure><h2 id="（五）模型推理-Generate">（五）模型推理 Generate</h2><h3 id="5-1-Generate-from-a-model">5.1 Generate from a model</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mlx_lm.generate \</span><br><span class="line">--model &lt;path&gt; \</span><br><span class="line">--prompt &quot;&lt;prompt&gt;&quot;</span><br></pre></td></tr></table></figure><h3 id="5-2-Generate-from-a-model-after-finetuning-with-adapter">5.2 Generate from a model after finetuning with adapter</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mlx_lm.generate \</span><br><span class="line">--model &lt;path&gt; \</span><br><span class="line">--adapter-path &lt;path&gt; \</span><br><span class="line">--prompt &quot;&lt;prompt&gt;&quot;</span><br></pre></td></tr></table></figure><h2 id="（六）模型微调">（六）模型微调</h2><h3 id="6-1-Finetune-Lora">6.1 Finetune --Lora</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mlx_lm.lora \</span><br><span class="line">--model &lt;path&gt; \</span><br><span class="line">--train \</span><br><span class="line">--data &lt;path&gt; \</span><br><span class="line">--iters 600</span><br></pre></td></tr></table></figure><h3 id="6-2-Fuse-整合">6.2 Fuse 整合</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mlx_lm.fuse \</span><br><span class="line">--model &lt;path&gt; \</span><br><span class="line">--adapter-path &lt;path&gt; \</span><br><span class="line">--save-path &lt;path&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">MLX 学习笔记</summary>
    
    
    
    <category term="AI" scheme="https://www.angfff.top/categories/AI/"/>
    
    <category term="LLM" scheme="https://www.angfff.top/categories/AI/LLM/"/>
    
    
    <category term="MLX" scheme="https://www.angfff.top/tags/MLX/"/>
    
    <category term="AI" scheme="https://www.angfff.top/tags/AI/"/>
    
    <category term="LLM" scheme="https://www.angfff.top/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>实战项目——股票分析系统</title>
    <link href="https://www.angfff.top/posts/82f46f22.html"/>
    <id>https://www.angfff.top/posts/82f46f22.html</id>
    <published>2025-01-03T06:55:23.000Z</published>
    <updated>2025-03-06T04:40:56.796Z</updated>
    
    
    <summary type="html">基于 Flask 和 Vuetify 框架的股票分析系统，结合 LLM 与 LSTM 模型，实现股票基本面、技术面及市场情绪分析等功能。</summary>
    
    
    
    <category term="实战项目" scheme="https://www.angfff.top/categories/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="股票分析系统" scheme="https://www.angfff.top/categories/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/%E8%82%A1%E7%A5%A8%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Python" scheme="https://www.angfff.top/tags/Python/"/>
    
    <category term="实战项目" scheme="https://www.angfff.top/tags/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="Flask" scheme="https://www.angfff.top/tags/Flask/"/>
    
    <category term="Node.js" scheme="https://www.angfff.top/tags/Node-js/"/>
    
    <category term="Vuetify" scheme="https://www.angfff.top/tags/Vuetify/"/>
    
    <category term="前后端分离" scheme="https://www.angfff.top/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>Python 学习笔记</title>
    <link href="https://www.angfff.top/posts/7db8c537.html"/>
    <id>https://www.angfff.top/posts/7db8c537.html</id>
    <published>2024-09-29T11:37:59.000Z</published>
    <updated>2025-03-06T04:40:56.796Z</updated>
    
    <content type="html"><![CDATA[<h1>1. 基础</h1><h2 id="1-1-编码-标识符-保留字">1.1 编码 / 标识符 / 保留字</h2><ol><li>默认情况下，Python 3 源码文件以 <strong>UTF-8</strong> 编码，所有字符串都是 unicode 字符串；</li><li>标识符<ul><li>第一个字符必须是字母表中字母或下划线_</li><li>标识符的其他的部分由字母、数字和下划线组成</li><li>标识符对大小写敏感</li></ul></li><li>保留字即关键字，不能把它们用作任何标识符名称。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line"><span class="built_in">print</span>(keyword.kwlist)</span><br></pre></td></tr></table></figure></li></ol><h2 id="1-2-注释">1.2 注释</h2><ol><li>单行注释以 <strong>#</strong> 开头</li><li>多行注释可以用多个#号，或者三个单 / 双引号 ‘’’ 和 “”&quot;</li><li>多行注释中不能再嵌套多行注释，但可以使用单行注释 #</li><li>输出函数的注释<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;函数注释&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.__doc__)</span><br></pre></td></tr></table></figure></li></ol><h2 id="1-3-多行语句">1.3 多行语句</h2><ol><li>Python 通常是一行写完一条语句，但如果语句很长，可以使用反斜杠来实现多行语句<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure></li><li>在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 \<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total = [<span class="string">&#x27;item_one&#x27;</span>, <span class="string">&#x27;item_two&#x27;</span>, <span class="string">&#x27;item_three&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;item_four&#x27;</span>, <span class="string">&#x27;item_five&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ol><h2 id="1-4-输出">1.4 输出</h2><h3 id="1-4-1-基本输出">1.4.1 基本输出</h3><ol><li>Python 使用 print 输出内容，默认输出是换行的；</li><li>要实现不换行，则需要在变量末尾加上 <code>end=&quot;&quot;</code>；<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 换行输出 </span></span><br><span class="line"><span class="built_in">print</span>( x ) </span><br><span class="line"><span class="comment"># 不换行输出 </span></span><br><span class="line"><span class="built_in">print</span>( x, end=<span class="string">&quot;&quot;</span> )</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-4-2-输出格式调整">1.4.2 输出格式调整</h3><ol><li><p>转为字符串</p><ul><li>str()：函数返回一个用户易读的表达形式；</li><li>repr()：产生一个解释器易读的表达形式；</li></ul></li><li><p>zfill( )</p><ul><li>该函数会在数字的左边填充 0；</li></ul></li><li><p>str.format()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 参数替换</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;网址： &quot;&#123;&#125;!&quot;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;AngFff&#x27;</span>, <span class="string">&#x27;www.angfff.top&#x27;</span>)) </span><br><span class="line"><span class="comment"># 输出： AngFff网址： &quot;www.angfff.top!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 数字标明位置</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125; 和 &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>))  </span><br><span class="line"><span class="comment"># 输出：Google 和 Apple</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 关键字指定参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;name&#125;网址：&#123;site&#125;&#x27;</span>.<span class="built_in">format</span>(name=<span class="string">&#x27;AngFff&#x27;</span>, site=<span class="string">&#x27;123&#x27;</span>))  </span><br><span class="line"><span class="comment"># AngFff网址：123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 可选项，进一步控制格式</span></span><br><span class="line"><span class="comment"># 将 Pi 保留到小数点后三位</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;常量 PI 的值近似为 &#123;0:.3f&#125;。&#x27;</span>.<span class="built_in">format</span>(math.pi)) </span><br><span class="line"><span class="comment"># 输出：常量 PI 的值近似为 3.142。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 控制宽度</span></span><br><span class="line">table = &#123;<span class="string">&#x27;Google&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;Runoob&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;Taobao&#x27;</span>: <span class="number">3</span>&#125;  </span><br><span class="line"><span class="keyword">for</span> name, number <span class="keyword">in</span> table.items():  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;0:10&#125; ==&gt; &#123;1:10d&#125;&#x27;</span>.<span class="built_in">format</span>(name, number))  </span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># Google     ==&gt;          1  </span></span><br><span class="line"><span class="comment"># Runoob     ==&gt;          2  </span></span><br><span class="line"><span class="comment"># Taobao     ==&gt;          3  </span></span><br></pre></td></tr></table></figure><ul><li>括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换；</li><li>在括号中的数字用于指向传入对象在 format() 中的位置；</li><li>如果在 format() 中使用了关键字参数, 那么它们的值会指向使用该名字的参数，位置及关键字参数可以任意的结合；</li><li>!a (使用 <strong>ascii()</strong>),  !s (使用 <strong>str()</strong>) 和  !r (使用 <strong>repr()</strong>) 可以用于在格式化某个值之前对其进行转化；</li><li>可选项 : 和格式标识符可以跟着字段名，允许对值进行更好的格式化；</li><li>在 : 后传入一个整数, 可以保证该域至少有这么多的宽度；</li></ul></li></ol><h2 id="1-5-输入">1.5 输入</h2><h3 id="1-5-1-标准输入">1.5.1 标准输入</h3><ol><li><p>input( ) 内置函数 从标准输入读入一行文本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;请输入：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入内容为：&quot;</span>, <span class="built_in">str</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-5-2-文件读写">1.5.2 文件读写</h3><ol><li><p>创建文件对象</p><ul><li>open() 将会返回一个 file 对象 <code>open(filename, mode)</code></li><li>filename：要打开的文件名</li><li>mode：决定了打开文件的模式，只读 ‘r’，写入 ‘w’，追加 ‘a’ 等。该参数是非强制的，默认文件访问模式为只读 ‘r’</li><li>每次打开文件后，都需要关闭文件对象，调用 <code>f.close()</code></li></ul><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Python%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%A8%A1%E5%BC%8F.png" alt="Python文件读写模式.png"></p></li><li><p>针对文件对象进行读取</p><ul><li>在已创建 文件对象 的情况下 f = open()</li><li>f.read()<ul><li>调用 f.read(size)，将读取一定数目的数据，然后作为字符串或字节对象返回</li><li>size 是一个可选的数字类型的参数，当 size 为空或者负，则该文件的所有内容都将被读取并且返回</li></ul></li><li>f.readline()<ul><li>f.readline() 会从文件中读取单独的一行，换行符为 ‘\n’</li><li>如果返回一个空字符串，说明已经已经读取到最后一行</li></ul></li><li>f.readlines()<ul><li>f.readlines() 将返回该文件中包含的所有行</li><li>如果设置可选参数 sizehint，则读取指定长度的字节，并且将这些字节按行分割</li></ul></li></ul></li><li><p>针对文件对象进行写入</p><ul><li>在已创建 文件对象 的情况下 f = open()</li><li>f.write()<ul><li>f.write(string) 将 string 写入到文件中，然后返回写入的字符数</li></ul></li><li>f.tell()<ul><li>f.tell() 用于返回文件当前的读/写位置（即文件指针的位置）</li><li>文件指针表示从文件开头开始的字节数偏移量</li></ul></li><li>f.seek()<ul><li>要改变文件指针的位置，可以用 f.seek(offset, whence)</li><li>offset 表示相对于 whence 参数的偏移量，whence 如果是 0 表示开头，如果是 1 表示当前位置, 2 表示文件的结尾<ul><li>seek(x,0)：从起始位置即文件首行首字符开始移动 x 个字</li><li>seek(x,1)：表示从当前位置往后移动 x 个字符</li><li>seek(-x,2)：表示从文件的结尾往前移动 x 个字符</li></ul></li></ul></li></ul></li><li><p>关闭文件</p><ul><li>在已创建 文件对象 的情况下 f = open()</li><li>f.close()<ul><li>调用 f.close() 来关闭文件并释放系统的资源</li></ul></li><li>with 关键字用于简化文件操作并确保文件在使用完后自动关闭，避免手动调用 close() 方法。它会在代码块执行结束后自动管理资源的释放，即使代码中发生异常，也能保证文件被正确关闭<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/test.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    read_data = f.read()</span><br><span class="line"><span class="comment"># 运行结束后，会自动关闭 f 对象，释放资源</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="1-6-运算符">1.6 运算符</h2><ol><li><p>算数运算符</p><blockquote><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>加 - 两个对象相加</td></tr><tr><td>-</td><td>减 - 得到负数或是一个数减去另一个数</td></tr><tr><td>*</td><td>乘 - 两个数相乘或是返回一个被重复若干次的字符串</td></tr><tr><td>/</td><td>除 - x 除以 y</td></tr><tr><td>%</td><td>取模 - 返回除法的余数</td></tr><tr><td>**</td><td>幂 - 返回x的y次幂</td></tr><tr><td>//</td><td>取整除 - 向下 / 左取整</td></tr></tbody></table></blockquote></li><li><p>比较（关系）运算符</p><blockquote><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>==</td><td>等于 - 比较对象是否相等</td></tr><tr><td>!=</td><td>不等于 - 比较两个对象是否不相等</td></tr><tr><td>&gt;</td><td>大于 - 返回x是否大于y</td></tr><tr><td>&lt;</td><td>小于 - 返回x是否小于y</td></tr><tr><td>&gt;=</td><td>大于等于 - 返回x是否大于等于y</td></tr><tr><td>&lt;=</td><td>小于等于 - 返回x是否小于等于y</td></tr></tbody></table></blockquote></li><li><p>赋值运算符</p><blockquote><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符</td></tr><tr><td>+=</td><td>加法赋值运算符</td></tr><tr><td>-=</td><td>减法赋值运算符</td></tr><tr><td>*=</td><td>乘法赋值运算符</td></tr><tr><td>/=</td><td>除法赋值运算符</td></tr><tr><td>%=</td><td>取模赋值运算符</td></tr><tr><td>**=</td><td>幂赋值运算符</td></tr><tr><td>//=</td><td>取整除赋值运算符</td></tr><tr><td>:=</td><td>海象运算符，这个运算符的主要目的是在表达式中同时进行赋值和返回赋值的值。<strong>Python3.8 版本新增运算符</strong></td></tr></tbody></table></blockquote></li><li><p>位运算符</p><blockquote><table><thead><tr><th>运算符</th><th>描述</th><th>实例(a=12 / b=13)</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td><td>(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td></tr><tr><td>|</td><td>按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td><td>(a | b) 输出结果 61 ，二进制解释： 0011 1101</td></tr><tr><td>^</td><td>按位异或运算符：当两对应的二进位相异时，结果为1</td><td>(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td></tr><tr><td>~</td><td>按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1</td><td>(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。</td></tr><tr><td>&lt;&lt;</td><td>左移动运算符：运算数的各二进位全部左移若干位，由&quot;&lt;&lt;&quot;右边的数指定移动的位数，高位丢弃，低位补0。</td><td>a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>右移动运算符：把&quot;&gt;&gt;“左边的运算数的各二进位全部右移若干位，”&gt;&gt;&quot;右边的数指定移动的位数</td><td>a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td></tr></tbody></table></blockquote></li><li><p>逻辑运算符</p><blockquote><table><thead><tr><th>运算符</th><th>逻辑表达式</th><th>描述</th></tr></thead><tbody><tr><td>and</td><td>x and y</td><td>布尔&quot;与&quot; - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。</td></tr><tr><td>or</td><td>x or y</td><td>布尔&quot;或&quot; - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td></tr><tr><td>not</td><td>not x</td><td>布尔&quot;非&quot; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td></tr></tbody></table></blockquote></li><li><p>成员运算符</p><blockquote><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>in</td><td>如果在指定的序列中找到值返回 True，否则返回 False。</td></tr><tr><td>not in</td><td>如果在指定的序列中没有找到值返回 True，否则返回 False。</td></tr></tbody></table></blockquote></li><li><p>身份运算符</p><blockquote><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>is</td><td>is 是判断两个标识符是不是引用自一个对象</td></tr><tr><td>is not</td><td>is not 是判断两个标识符是不是引用自不同对象</td></tr></tbody></table></blockquote></li></ol><h1>2. 基本数据类型</h1><h2 id="2-1-数字-Number">2.1 数字(Number)</h2><ol><li><strong>int</strong> (整数)<ul><li>只有一种整数类型 int，表示为长整型，没有 Long</li></ul></li><li><strong>bool</strong> (布尔)<ul><li>bool 是 int 的子类，True / 1 和 False / 0 可以和数字相加</li></ul></li><li><strong>float</strong> (浮点数)<ul><li>如 1.23、3E-2</li></ul></li><li><strong>complex</strong> (复数)<ul><li>如 1 + 2j、 1.1 + 2.2j</li></ul></li></ol><blockquote><table><thead><tr><th>函数</th><th>返回值 ( 描述 )</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/python3/python3-func-number-abs.html">abs(x)</a></td><td>返回数字的绝对值，如abs(-10) 返回 10</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-ceil.html">ceil(x)</a></td><td>返回数字的上入整数，如math.ceil(4.1) 返回 5</td></tr><tr><td>cmp(x, y)</td><td>如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 <strong>Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换</strong>。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-exp.html">exp(x)</a></td><td>返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-fabs.html">fabs(x)</a></td><td>以浮点数形式返回数字的绝对值，如math.fabs(-10) 返回10.0</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-floor.html">floor(x)</a></td><td>返回数字的下舍整数，如math.floor(4.9)返回 4</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-log.html">log(x)</a></td><td>如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-log10.html">log10(x)</a></td><td>返回以10为基数的x的对数，如math.log10(100)返回 2.0</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-max.html">max(x1, x2,…)</a></td><td>返回给定参数的最大值，参数可以为序列。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-min.html">min(x1, x2,…)</a></td><td>返回给定参数的最小值，参数可以为序列。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-modf.html">modf(x)</a></td><td>返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-pow.html">pow(x, y)</a></td><td>x**y 运算后的值。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-round.html">round(x [,n])</a></td><td>返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。<br><br><strong>其实准确的说是保留值将保留到离上一位更近的一端。</strong></td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-sqrt.html">sqrt(x)</a></td><td>返回数字x的平方根。</td></tr></tbody></table></blockquote><h2 id="2-2-字符串-String">2.2 字符串(String)</h2><ol><li>字符串用单引号 ’ 或双引号 &quot; 括起来，单引号 ’ 和双引号 &quot; 的使用完全相同，使用三引号(‘’’ 或 “”&quot;)可以指定一个多行字符串；</li><li>使用反斜杠 \ 转义特殊字符，使用 r 可以让反斜杠不发生转义。 如 <strong>r&quot;this is a line with \n&quot;</strong> 则 \n 会显示，并不是换行；</li><li>字符串的截取 / 切片<ul><li><code>字符串[start:end:step]</code>，左含右不含、步长参数 step，step 为负数时表示逆向；</li><li>索引值以 0 为开始值，-1 为从末尾的开始位置；</li><li>加号 + 是字符串的连接符， 星号 * 表示复制当前字符串；</li></ul></li><li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串；</li><li>字符串不能通过索引赋值、修改元素值；</li></ol><h2 id="2-3-布尔-Bool">2.3 布尔(Bool)</h2><ol><li>布尔类型只有两个值：True 和 False，等价于 1 和 0；</li><li>布尔类型可以转换成其他数据类型；</li><li>使用 <code>bool()</code> 函数将其他类型的值转换为布尔值；</li><li>布尔类型可以和逻辑运算符一起使用，包括 and、or 和 not；</li></ol><h2 id="2-4-列表-List">2.4 列表(List)</h2><ol><li>列表写在方括号 [] 之间、用逗号分隔元素；</li><li>列表中的元素类型可以互不相同；</li><li>列表可以通过索引赋值、修改元素值；</li><li>列表的截取 / 切片<ul><li><code>列表[start:end:step]</code>，左含右不含、步长参数 step，step 为负数时表示逆向；</li><li>索引值以 0 为开始值，-1 为从末尾的开始位置；</li><li>加号 + 是列表的连接符， 星号 * 表示复制当前列表；</li></ul></li></ol><h2 id="2-5-元组-Tuple">2.5 元组(Tuple)</h2><ol><li>元组写在小括号 () 之间、用逗号分隔元素；</li><li>元组中的元素类型可以互不相同；</li><li>元组不能通过索引赋值、修改元素值；</li><li>元组的截取 / 切片<ul><li><code>元组[start:end:step]</code>，左含右不含、步长参数 step，step 为负数时表示逆向；</li><li>索引值以 0 为开始值，-1 为从末尾的开始位置；</li><li>加号 + 是元组的连接符， 星号 * 表示复制当前元组；</li></ul></li><li>构造包含 0 个或 1 个元素的元组比较特殊<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup1 = () <span class="comment"># 空元组</span></span><br><span class="line">tup2 = (<span class="number">20</span>,) <span class="comment"># 一个元素，需要在元素后添加逗号</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="2-6-集合-Set">2.6 集合(Set)</h2><ol><li>集合写在大括号 {} 之间、用逗号分隔元素，另外也可以使用 <code>set()</code> 函数创建集合；</li><li>创建一个空集合必须用 <code>set()</code> 而不是 <code>&#123; &#125;</code>， <code>&#123; &#125;</code> 用于创建空字典；</li><li>集合是一种无序、可变的数据类型，其中的元素不会重复；</li><li>集合运算<ul><li>交集 &amp;</li><li>并集 |</li><li>差集 -</li><li>两集合中不同时存在的元素 ^</li></ul></li></ol><h2 id="2-7-字典-Dictionary">2.7 字典(Dictionary)</h2><ol><li>字典是一种映射类型，字典用 <code>&#123; &#125;</code> 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合；</li><li>在同一个字典中，键必须是唯一的，且键必须使用不可变类型；</li><li>字典的创建<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dict1 = &#123;&#125;</span><br><span class="line">dict1[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&quot;1 A&quot;</span></span><br><span class="line">dict1[<span class="number">2</span>] = <span class="string">&quot;2 F&quot;</span></span><br><span class="line"></span><br><span class="line">dict2 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Ang&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;18&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典推导式</span></span><br><span class="line">dict3 = &#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)&#125;</span><br><span class="line"></span><br><span class="line">x = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">y = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">dict4 = &#123;i:j <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(x,y)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># dict 函数</span></span><br><span class="line">dict5 = <span class="built_in">dict</span>(Runoob=<span class="number">1</span>, Google=<span class="number">2</span>, Taobao=<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li>键值对输出<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dic1 = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="keyword">for</span> k,v. <span class="keyword">in</span> dict1.items():</span><br><span class="line">    <span class="built_in">print</span>(k, <span class="string">&#x27;:&#x27;</span>, v)</span><br></pre></td></tr></table></figure></li></ol><h1>3. 基本数据类型的转换</h1><h2 id="3-1-隐式类型转换">3.1 隐式类型转换</h2><ol><li>对两种不同类型的数据进行运算时，较低数据类型会转换为较高数据类型以避免数据丢失；<ul><li>当整数与浮点数进行运算时，整数会被自动转换为浮点数；</li><li>布尔值在与数字进行运算时会被自动转换为整数，<code>True</code> 被视为 <code>1</code>，<code>False</code> 被视为 <code>0</code>；</li></ul></li><li>数据类型的高低：bool &lt; int &lt; float &lt; complex</li></ol><h2 id="3-2-显式类型转换">3.2 显式类型转换</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>int(x [,base])</td><td>将x转换为一个整数</td></tr><tr><td>float(x)</td><td>将x转换到一个浮点数</td></tr><tr><td>complex(real [,imag])</td><td>创建一个复数</td></tr><tr><td>str(x)</td><td>将对象 x 转换为字符串</td></tr><tr><td>repr(x)</td><td>将对象 x 转换为表达式字符串</td></tr><tr><td>eval(str)</td><td>用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td>tuple(s)</td><td>将序列 s 转换为一个元组</td></tr><tr><td>list(s)</td><td>将序列 s 转换为一个列表</td></tr><tr><td>set(s)</td><td>转换为可变集合</td></tr><tr><td>dict(d)</td><td>创建一个字典。d 必须是一个 (key, value)元组序列。</td></tr><tr><td>frozenset(s)</td><td>转换为不可变集合</td></tr><tr><td>chr(x)</td><td>将一个整数转换为一个字符</td></tr><tr><td>ord(x)</td><td>将一个字符转换为它的整数值</td></tr><tr><td>hex(x)</td><td>将一个整数转换为一个十六进制字符串</td></tr><tr><td>oct(x)</td><td>将一个整数转换为一个八进制字符串</td></tr></tbody></table><h1>4. 条件控制</h1><h2 id="4-1-if-elif-else">4.1 if-elif-else</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_block_3</span><br></pre></td></tr></table></figure><ul><li>每个条件后面要使用冒号，表示接下来是满足条件后要执行的语句块。</li><li>如果 if 的执行语句只有一句，可以写在 if 的同一行。</li></ul><h2 id="4-2-match-case">4.2 match-case</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> subject:</span><br><span class="line">    <span class="keyword">case</span> &lt;pattern_1&gt;:</span><br><span class="line">        &lt;action_1&gt;</span><br><span class="line">    <span class="keyword">case</span> &lt;pattern_2&gt;:</span><br><span class="line">        &lt;action_2&gt;</span><br><span class="line">    <span class="keyword">case</span> &lt;pattern_3&gt;:</span><br><span class="line">        &lt;action_3&gt;</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        &lt;action_wildcard&gt;</span><br></pre></td></tr></table></figure><ul><li>case _: 类似于 C 和 Java 中的 <strong>default:</strong>，当其他 case 都无法匹配时，匹配这条，保证永远会匹配成功。</li></ul><h1>5. 循环语句</h1><h2 id="5-1-while">5.1 while</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;expr&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;additional_statement(s)&gt;</span><br></pre></td></tr></table></figure><ul><li>如果 while 的执行语句只有一句，可以写在 while 的同一行。</li></ul><h2 id="5-2-for">5.2 for</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> iterable:</span><br><span class="line">    <span class="comment"># 循环主体</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 循环结束后执行的代码</span></span><br></pre></td></tr></table></figure><h2 id="5-3-break-continue-pass">5.3 break &amp; continue &amp; pass</h2><ul><li><strong>break</strong> 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。</li><li><strong>continue</strong> 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮循环。</li><li><strong>pass</strong> 不做任何事情，一般用做占位语句。</li></ul><h1>6. 推导式</h1><h2 id="6-1-列表推导式">6.1 列表推导式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表]</span><br><span class="line"></span><br><span class="line">或者 </span><br><span class="line"></span><br><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表 <span class="keyword">if</span> 条件]</span><br></pre></td></tr></table></figure><p>e.g. 过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;alice&#x27;</span>,<span class="string">&#x27;Jerry&#x27;</span>,<span class="string">&#x27;Wendy&#x27;</span>,<span class="string">&#x27;Smith&#x27;</span>]</span><br><span class="line">new_names = [name.upper()<span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> <span class="built_in">len</span>(name)&gt;<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(new_names)</span><br></pre></td></tr></table></figure><h2 id="6-2-字典推导式">6.2 字典推导式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection &#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition &#125;</span><br></pre></td></tr></table></figure><p>e.g. 将列表中各字符串值为键，各字符串的长度为值，组成键值对</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listdemo = [<span class="string">&#x27;Google&#x27;</span>,<span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line">newdict = &#123;key:<span class="built_in">len</span>(key) <span class="keyword">for</span> key <span class="keyword">in</span> listdemo&#125;</span><br><span class="line"><span class="built_in">print</span>(newdict)</span><br></pre></td></tr></table></figure><h2 id="6-3-集合推导式">6.3 集合推导式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> &#125;</span><br><span class="line">或</span><br><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional &#125;</span><br></pre></td></tr></table></figure><p>e.g. 判断不是 abc 的字母并输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abracadabra&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><h2 id="6-4-元组推导式">6.4 元组推导式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> )</span><br><span class="line">或</span><br><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional )</span><br></pre></td></tr></table></figure><ul><li>元组推导式返回的结果是一个生成器对象，使用 tuple() 函数，可以直接将生成器对象转换成元组；</li></ul><p>e.g. 生成一个包含数字 1~9 的元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(t) <span class="comment"># 输出 &lt;generator object &lt;genexpr&gt; at 0x104b0e890&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(t)) <span class="comment"># 输出 (1, 2, 3, 4, 5, 6, 7, 8, 9)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># range() 返回的是一个可迭代对象，而不是一个列表</span></span><br><span class="line"><span class="comment"># 如果需要列表，可以使用 list() 函数将其转换</span></span><br></pre></td></tr></table></figure><h1>7. 迭代器 &amp; 生成器</h1><h2 id="7-1-迭代器">7.1 迭代器</h2><h3 id="（1）概念">（1）概念</h3><blockquote><p>在 Python 中，迭代器（Iterator）是一种用于遍历集合（如列表、元组、字典等）元素的对象。迭代器遵循迭代协议，主要包括两个方法：<code>__iter__()</code> 和 <code>__next__()</code>。下面是对迭代器的详细解释：</p><ol><li>迭代器的基本概念</li></ol><ul><li><strong>迭代器对象</strong>：实现了 <code>__iter__()</code> 和 <code>__next__()</code> 方法的对象。</li><li><strong>可迭代对象</strong>：实现了 <code>__iter__()</code> 方法的对象，可以返回一个迭代器。</li></ul><ol start="2"><li>迭代器的工作原理</li></ol><ul><li><strong><code>__iter__()</code> 方法</strong>：返回迭代器对象本身。通常在可迭代对象上调用时会返回一个迭代器。</li><li><strong><code>__next__()</code> 方法</strong>：返回序列中的下一个值。如果没有更多的值可返回，应该抛出 <code>StopIteration</code> 异常。</li></ul></blockquote><h3 id="（2）从集合生成迭代器">（2）从集合生成迭代器</h3><ul><li>可迭代对象：可以使用 <code>for</code> 循环遍历的对象，如列表、元组、字典、集合等。可迭代对象实现了 <code>__iter__()</code> 方法。</li><li>基本方法：iter()；next()</li></ul><p>e.g. 从列表生成迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原列表</span></span><br><span class="line">list_a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代器对象</span></span><br><span class="line">it = <span class="built_in">iter</span>(list_a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出单个元素，使用 next() 方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环输出剩余元素，使用 for/while 循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line"><span class="built_in">print</span>(i, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># while 循环注意结束条件</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">sys.exit()</span><br></pre></td></tr></table></figure><h3 id="（3）创建自定义迭代器">（3）创建自定义迭代器</h3><ul><li>通过定义一个类并实现 _<em>iter</em>_\ 和 _<em>next</em>_\ 两个方法来创建自定义迭代器。例如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建迭代器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyIterator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">max</span></span>):</span><br><span class="line">        <span class="variable language_">self</span>.<span class="built_in">max</span> = <span class="built_in">max</span></span><br><span class="line">        <span class="variable language_">self</span>.current = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.current &lt; <span class="variable language_">self</span>.<span class="built_in">max</span>:</span><br><span class="line">            result = <span class="variable language_">self</span>.current</span><br><span class="line">            <span class="variable language_">self</span>.current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义迭代器</span></span><br><span class="line">my_iter = MyIterator(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> my_iter:</span><br><span class="line">    <span class="built_in">print</span>(num) <span class="comment"># 输出 0 1 2 3 4</span></span><br></pre></td></tr></table></figure><h3 id="（4）迭代器与可迭代对象的区别">（4）迭代器与可迭代对象的区别</h3><ul><li><strong>可迭代对象</strong>：可以使用 <code>for</code> 循环遍历的对象，如列表、元组、字典、集合等。可迭代对象实现了 <code>__iter__()</code> 方法。</li><li><strong>迭代器</strong>：是可迭代对象的一个实现，具有 <code>__iter__()</code> 和 <code>__next__()</code> 方法。迭代器可以在遍历时保持状态。</li></ul><h2 id="7-2-生成器">7.2 生成器</h2><h3 id="（1）概念-2">（1）概念</h3><blockquote><p>在 Python 中，生成器（Generator）是一种特殊类型的迭代器，用于创建可迭代的序列。生成器的主要特点是它们使用 <code>yield</code> 语句来返回值，而不是使用 <code>return</code> 语句。生成器在每次调用时会记住上一次的状态，从而实现惰性求值。</p><ul><li><strong>生成器函数</strong>：使用 <code>yield</code> 语句定义的函数。调用生成器函数不会立即执行，而是返回一个生成器对象。</li><li><strong>生成器对象</strong>：可以被迭代的对象，支持 <code>__iter__()</code> 和 <code>__next__()</code> 方法。</li></ul></blockquote><h3 id="（2）创建生成器">（2）创建生成器</h3><ul><li>生成器函数的定义与普通函数类似，但使用 <code>yield</code> 语句来返回值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a  <span class="comment"># 当运行到这里时，就会停止，直到再次调用 next，会接着从这里继续生成 a</span></span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出值</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(f), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure><h3 id="（3）生成器的工作原理">（3）生成器的工作原理</h3><ul><li>当调用生成器函数时，函数体不会立即执行，而是返回一个生成器对象。</li><li>每次调用生成器对象的 <code>__next__()</code> 方法时，函数会从上次 <code>yield</code> 语句停止的地方继续执行，直到遇到下一个 <code>yield</code> 语句。</li><li>当没有更多的 <code>yield</code> 语句可执行时，生成器会抛出 <code>StopIteration</code> 异常，表示迭代结束。</li></ul><h1>8. 函数</h1><h2 id="8-1-定义-调用函数">8.1 定义 / 调用函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>（参数列表）:</span><br><span class="line"><span class="comment"># 函数说明</span></span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">返回值 = 函数名(参数)</span><br></pre></td></tr></table></figure><p>python 函数的参数传递：</p><ul><li><p><strong>不可变类型</strong>：类似 C++ 的值传递，不可变类型对象包括 整数、字符串、元组。对于不可变类型对象 a，调用 fun(a) 时，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象，函数外部的 a 不会受影响。</p></li><li><p><strong>可变类型</strong>：类似 C++ 的引用传递，可变类型对象包括 列表，字典。对于可变类型对象 b，调用 fun(b) 时，则是将 b 真正的传过去，修改后 fun 外部的 b 也会受影响。</p></li></ul><h2 id="8-2-函数参数">8.2 函数参数</h2><h3 id="（1）必需参数">（1）必需参数</h3><ul><li>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样，否则会因缺少参数而报错。</li></ul><h3 id="（2）关键字参数">（2）关键字参数</h3><ul><li>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</li><li>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</li></ul><p>e.g.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> name, age </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">&quot;runoob&quot;</span> )</span><br></pre></td></tr></table></figure><h3 id="（3）默认参数">（3）默认参数</h3><ul><li>调用函数时，如果没有传递参数，则会使用默认参数</li></ul><h3 id="（4）不定长参数">（4）不定长参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个 * 的参数会以元组形式导入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">functionname</span>(<span class="params">[formal_args,] *var_args_tuple </span>):</span><br><span class="line">   <span class="string">&quot;函数_文档字符串&quot;</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 两个 * 的参数会以字典形式导入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> arg1, **vardict </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">   <span class="built_in">print</span> (arg1)</span><br><span class="line">   <span class="built_in">print</span> (vardict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单独出现 *，则 * 以后的所有参数都需要带上参数名称再传入</span></span><br><span class="line"><span class="comment"># 函数定义</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a,b,*,c</span>):</span><br><span class="line"><span class="keyword">return</span> a+b+c</span><br><span class="line"><span class="comment"># 函数调用</span></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,c=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制位置参数 /</span></span><br><span class="line"><span class="comment"># 函数定义</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b, /, c, d, *, e, f</span>):</span><br><span class="line"><span class="built_in">print</span>(a, b, c, d, e, f)</span><br><span class="line"><span class="comment"># 函数调用</span></span><br><span class="line">f(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, d=<span class="number">40</span>, e=<span class="number">50</span>, f=<span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 和 f 要求为关键字形参</span></span><br></pre></td></tr></table></figure><ul><li>加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数</li><li>可以不向函数传递未命名的变量，如果在函数调用时没有指定参数，它就是一个空元组</li><li>加了两个星号 ** 的参数会以字典的形式导入</li><li>如果单独出现星号 * ，则星号 * 后的参数必须用关键字传入</li><li>强制位置参数：Python3.8 新增了一个函数形参语法 / 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。</li></ul><h2 id="8-3-lambda-匿名函数">8.3 lambda 匿名函数</h2><h3 id="（1）概念-3">（1）概念</h3><p>在 Python 中，<code>lambda</code> 函数是一种小型、匿名的、内联函数，它可以具有任意数量的参数，但只能有一个表达式。与常规的函数定义（使用 <code>def</code> 关键字）相比，<code>lambda</code> 函数通常用于需要快速定义简单函数的场景。</p><p>① <code>lambda</code> 函数的基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arguments: expression</span><br></pre></td></tr></table></figure><ul><li><strong>arguments</strong>: 输入参数，可以是多个，用逗号分隔。</li><li><strong>expression</strong>: 一个表达式，返回值是这个表达式的计算结果。</li></ul><p>② 示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个简单的 lambda 函数</span></span><br><span class="line">add = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 lambda 函数</span></span><br><span class="line">result = add(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: 8</span></span><br></pre></td></tr></table></figure><h3 id="（2）应用（使用-lambda-函数作为参数）">（2）应用（使用 <code>lambda</code> 函数作为参数）</h3><p><code>lambda</code> 函数常用于需要函数作为参数的场景，例如在 <code>map()</code>, <code>filter()</code>, 和 <code>sorted()</code> 函数中。<br>① <code>map()</code></p><ul><li><code>map()</code> 函数用于将指定函数应用于给定可迭代对象的每个元素，并返回一个迭代器<ul><li><code>map(function, iterable)</code></li><li>function: 要应用的函数（可以是 <code>lambda</code> 函数）</li><li>iterable: 要处理的可迭代对象（如列表、元组等）</li></ul></li><li>示例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, numbers)) <span class="comment"># map 会遍历 numbers 中的每个元素，并将每个元素传递给 lambda 函数，计算完成后作为 map 迭代器的结果，需要时输出</span></span><br><span class="line"><span class="built_in">print</span>(squared)  <span class="comment"># 输出: [1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure><p>② <code>filter()</code></p><ul><li><code>filter()</code> 函数用于过滤可迭代对象中的元素，返回满足条件的元素<ul><li><code>filter(function, iterable)</code></li><li>遍历每个元素，如果满足 function 中的条件(返回 True)，则保留该元素；否则，丢弃该元素</li></ul></li><li>示例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">even_numbers = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, numbers)) <span class="comment"># filter 会遍历 numbers 中的每个元素，并将每个元素传递给 lambda 函数，判断元素是否为偶数，是偶数则保留，否则丢弃该元素</span></span><br><span class="line"><span class="built_in">print</span>(even_numbers)  <span class="comment"># 输出: [2, 4]</span></span><br></pre></td></tr></table></figure><p>③ <code>sorted()</code></p><ul><li><code>sorted()</code> 函数用于对可迭代对象进行排序，可以使用 <code>lambda</code> 函数自定义排序规则。<ul><li><code>sorted(iterable, key=None, reverse=False)</code></li><li>key 是一个函数，用于从每个元素中提取比较键</li><li>默认升序排列，reverse=True，则调整为降序</li></ul></li><li>示例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">points = [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">5</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">3</span>)]</span><br><span class="line">sorted_points = <span class="built_in">sorted</span>(points, key=<span class="keyword">lambda</span> point: point[<span class="number">1</span>])  <span class="comment"># sorted 会遍历 points 中的每个元组，并将每个元组传递给 lambda 函数，lambda 会提取每个元组的第二个元素（y 坐标）作为排序的依据，最终按 key（y坐标）排序</span></span><br><span class="line"><span class="built_in">print</span>(sorted_points)  <span class="comment"># 输出: [(5, 0), (3, 1), (1, 2), (0, 3)]</span></span><br></pre></td></tr></table></figure><h3 id="（3）注意">（3）注意</h3><ul><li><strong>单行表达式</strong>：<code>lambda</code> 函数只能包含一个表达式，不能包含多个语句或复杂的逻辑。</li><li><strong>可读性</strong>：虽然 <code>lambda</code> 函数可以使代码更简洁，但在复杂的情况下，使用常规的 <code>def</code> 函数可能会提高代码的可读性。</li><li><strong>命名</strong>：<code>lambda</code> 函数是匿名的，但可以赋值给变量以便后续使用。</li></ul><h1>9. 装饰器</h1><h2 id="9-1-概念">9.1 概念</h2><h3 id="（1）定义">（1）定义</h3><p>在 Python 中，装饰器（decorator）是一种用于修改或增强函数或方法行为的设计模式。装饰器本质上是一个函数，它接受另一个函数作为参数，并返回一个新的函数。通过使用装饰器，可以在不修改原始函数代码的情况下，添加额外的功能或行为。</p><h3 id="（2）常见用途">（2）常见用途</h3><ul><li><strong>日志记录</strong>：记录函数的调用信息。</li><li><strong>权限检查</strong>：在执行函数之前检查用户权限。</li><li><strong>缓存</strong>：缓存函数的返回值以提高性能。</li><li><strong>输入验证</strong>：验证函数参数的有效性。</li></ul><h2 id="9-2-装饰器的基本语法">9.2 装饰器的基本语法</h2><ul><li>装饰器通常使用 <code>@decorator_name</code> 语法来应用，放在被装饰函数的定义上方</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义 装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something is happening before the function is called.&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something is happening after the function is called.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用 装饰器</span></span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line">say_hello() <span class="comment"># 输出三行句子</span></span><br></pre></td></tr></table></figure><h2 id="9-3-带参数的装饰器">9.3 带参数的装饰器</h2><ul><li>装饰器也可以接受参数。为了实现这一点，通常需要在最外层再嵌套一层函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义 含参数的装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">repeat</span>(<span class="params">num_times</span>):</span><br><span class="line"><span class="comment"># 最外层用于定义参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator_repeat</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_times):</span><br><span class="line">                func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator_repeat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用 装饰器</span></span><br><span class="line"><span class="meta">@repeat(<span class="params">num_times=<span class="number">3</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&quot;Alice&quot;</span>) <span class="comment"># 重复输出三次 Hello, Alice!</span></span><br></pre></td></tr></table></figure><h1>10. 数据结构</h1><h2 id="10-1-将列表当作栈使用">10.1 将列表当作栈使用</h2><ul><li>在 Python 中，可以使用列表（list）来实现栈的功能。栈是一种后进先出（LIFO, Last-In-First-Out）数据结构，意味着最后添加的元素最先被移除。</li><li>用 append() 方法可以把一个元素添加到栈顶，用不指定索引的 pop() 方法可以把一个元素从栈顶释放出来。</li></ul><blockquote><ul><li><strong>压入（Push）</strong>: 将一个元素添加到栈的顶端。</li><li><strong>弹出（Pop）</strong>: 移除并返回栈顶元素。</li><li><strong>查看栈顶元素（Peek/Top）</strong>: 返回栈顶元素而不移除它。</li><li><strong>检查是否为空（IsEmpty）</strong>: 检查栈是否为空。</li><li><strong>获取栈的大小（Size）</strong>: 获取栈中元素的数量。</li></ul><p>1、创建一个空栈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack = []  </span><br></pre></td></tr></table></figure><p>2、压入（Push）操作</p><ul><li>使用 append() 方法将元素添加到栈的顶端</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack.append(<span class="number">1</span>)  </span><br><span class="line">stack.append(<span class="number">2</span>)  </span><br><span class="line">stack.append(<span class="number">3</span>)  </span><br><span class="line"><span class="built_in">print</span>(stack)  <span class="comment"># 输出: [1, 2, 3]  </span></span><br></pre></td></tr></table></figure><p>3、弹出（Pop）操作</p><ul><li>使用 pop() 方法移除并返回栈顶元素</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">top_element = stack.pop()  </span><br><span class="line"><span class="built_in">print</span>(top_element)  <span class="comment"># 输出: 3  </span></span><br><span class="line"><span class="built_in">print</span>(stack)        <span class="comment"># 输出: [1, 2]  </span></span><br></pre></td></tr></table></figure><p>4、查看栈顶元素（Peek/Top）</p><ul><li>直接访问列表的最后一个元素（不移除）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top_element = stack[-<span class="number">1</span>]  </span><br><span class="line"><span class="built_in">print</span>(top_element)  <span class="comment"># 输出: 2  </span></span><br></pre></td></tr></table></figure><p>5、检查是否为空（IsEmpty）</p><ul><li>检查列表是否为空</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">is_empty = <span class="built_in">len</span>(stack) == <span class="number">0</span>  </span><br><span class="line"><span class="built_in">print</span>(is_empty)  <span class="comment"># 输出: False  </span></span><br></pre></td></tr></table></figure><p>6、获取栈的大小（Size）</p><ul><li>使用 len() 函数获取栈中元素的数量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size = <span class="built_in">len</span>(stack)  </span><br><span class="line"><span class="built_in">print</span>(size)  <span class="comment"># 输出: 2</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="10-2-将列表当作队列使用">10.2 将列表当作队列使用</h2><ul><li>在 Python 中，列表（list）可以用作队列（queue），但由于列表的特点，直接使用列表来实现队列并不是最优的选择。</li><li>队列是一种先进先出（FIFO, First-In-First-Out）的数据结构，意味着最早添加的元素最先被移除。</li><li>使用列表时，如果频繁地在列表的开头插入或删除元素，性能会受到影响，因为这些操作的时间复杂度是 O(n)。为了解决这个问题，Python 提供了 collections.deque，它是双端队列，可以在两端高效地添加和删除元素。</li></ul><blockquote><ul><li>collections.deque 是 Python 标准库的一部分，非常适合用于实现队列。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 创建一个空队列  </span></span><br><span class="line">queue = deque()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 向队尾添加元素  </span></span><br><span class="line">queue.append(<span class="string">&#x27;a&#x27;</span>)  </span><br><span class="line">queue.append(<span class="string">&#x27;b&#x27;</span>)  </span><br><span class="line">queue.append(<span class="string">&#x27;c&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列状态:&quot;</span>, queue)  <span class="comment"># 输出: 队列状态: deque([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 从队首移除元素  </span></span><br><span class="line">first_element = queue.popleft()  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;移除的元素:&quot;</span>, first_element)  <span class="comment"># 输出: 移除的元素: a  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列状态:&quot;</span>, queue)            <span class="comment"># 输出: 队列状态: deque([&#x27;b&#x27;, &#x27;c&#x27;])  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 查看队首元素（不移除）  </span></span><br><span class="line">front_element = queue[<span class="number">0</span>]  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队首元素:&quot;</span>, front_element)    <span class="comment"># 输出: 队首元素: b  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 检查队列是否为空  </span></span><br><span class="line">is_empty = <span class="built_in">len</span>(queue) == <span class="number">0</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列是否为空:&quot;</span>, is_empty)     <span class="comment"># 输出: 队列是否为空: False  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 获取队列大小  </span></span><br><span class="line">size = <span class="built_in">len</span>(queue)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列大小:&quot;</span>, size)            <span class="comment"># 输出: 队列大小: 2  </span></span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li>虽然 deque更高效，但如果坚持使用列表来实现队列，也可以这么做。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建队列</span></span><br><span class="line">queue = []  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 向队尾添加元素，使用 append() 方法将元素添加到队尾</span></span><br><span class="line">queue.append(<span class="string">&#x27;a&#x27;</span>)  </span><br><span class="line">queue.append(<span class="string">&#x27;b&#x27;</span>)  </span><br><span class="line">queue.append(<span class="string">&#x27;c&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列状态:&quot;</span>, queue)  <span class="comment"># 输出: 队列状态: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 从队首移除元素，使用 pop(0) 方法从队首移除元素</span></span><br><span class="line">first_element = queue.pop(<span class="number">0</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;移除的元素:&quot;</span>, first_element)  <span class="comment"># 输出: 移除的元素: a  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列状态:&quot;</span>, queue)            <span class="comment"># 输出: 队列状态: [&#x27;b&#x27;, &#x27;c&#x27;]  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 查看队首元素，直接访问列表的第一个元素</span></span><br><span class="line">front_element = queue[<span class="number">0</span>]  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队首元素:&quot;</span>, front_element)    <span class="comment"># 输出: 队首元素: b  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 检查队列是否为空</span></span><br><span class="line">is_empty = <span class="built_in">len</span>(queue) == <span class="number">0</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列是否为空:&quot;</span>, is_empty)     <span class="comment"># 输出: 队列是否为空: False  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 获取队列大小，使用 len() 函数获取队列的大小</span></span><br><span class="line">size = <span class="built_in">len</span>(queue)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列大小:&quot;</span>, size)            <span class="comment"># 输出: 队列大小: 2  </span></span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <summary type="html">Python 学习笔记</summary>
    
    
    
    <category term="开发" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Python" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/Python/"/>
    
    
    <category term="开发" scheme="https://www.angfff.top/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Python" scheme="https://www.angfff.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Java SE 学习笔记 2️⃣</title>
    <link href="https://www.angfff.top/posts/c3baad0f.html"/>
    <id>https://www.angfff.top/posts/c3baad0f.html</id>
    <published>2024-02-02T03:55:17.000Z</published>
    <updated>2025-03-06T04:40:56.795Z</updated>
    
    <content type="html"><![CDATA[<h1>Java SE</h1>]]></content>
    
    
    <summary type="html">Java SE 2️⃣ 类和对象</summary>
    
    
    
    <category term="开发" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Java SE" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/Java-SE/"/>
    
    
    <category term="开发" scheme="https://www.angfff.top/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Java" scheme="https://www.angfff.top/tags/Java/"/>
    
    <category term="Java SE" scheme="https://www.angfff.top/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>Java SE 学习笔记 1️⃣</title>
    <link href="https://www.angfff.top/posts/6b4fa997.html"/>
    <id>https://www.angfff.top/posts/6b4fa997.html</id>
    <published>2024-02-02T03:42:47.000Z</published>
    <updated>2025-03-06T04:40:56.795Z</updated>
    
    <content type="html"><![CDATA[<h1>Java SE</h1><h2 id="一、入门介绍">一、入门介绍</h2><ol><li><p>回顾：</p><ul><li><p>C 语言通过编译，将高级语言代码翻译为计算机能够直接执行的指令；</p></li><li><p>Python 并不会先进行编译，而是直接交给解释器解释执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/16/xAe9TspMDtlz8SE.png" alt="image-20220916150119407"></p></li></ul></li><li><p>一般来说，编程语言分为两大类：</p><ul><li><p>**编译型语言：**需要先编译为计算机可以直接执行的命令才可以运行。优点是计算机直接运行，性能高；缺点是与平台密切相关，在一种操作系统上编译的程序，无法在其他非同类操作系统上运行，比如 Windows 下的 exe 程序在 Mac 上就无法运行。</p></li><li><p>**解释型语言：**只需要通过解释器代为执行即可，不需要进行编译。优点是可以跨平台，因为解释是解释器的事情，只需要在各个平台上安装对应的解释器，代码不需要任何修改就可以直接运行；缺点是需要依靠解释器解释执行，效率肯定没直接编译成机器指令运行的快，并且会产生额外的资源占用。</p></li></ul></li><li><p>Java语言（Java之父：James Gosling，詹姆斯·高斯林）</p><blockquote><p>Write Once, Run Anywhere.</p></blockquote><p>这是Java语言的标语，它的目标很明确：一次编写，到处运行，它旨在打破平台的限制，让Java语言可以运行在任何平台上，并且不需要重新编译，实现跨平台运行。</p><p>Java自1995年正式推出以来，已经度过了快28个春秋，而基于Java语言，我们的生活中也有了各种各样的应用：</p><p><img src="https://s2.loli.net/2022/09/16/8SWeCjp6M4ufBk2.png" alt="image-20220916151604563"></p><ul><li><p>诺基亚手机上的很多游戏都是使用Java编写的。</p></li><li><p>安卓系统中的各种应用程序也是使用Java编写的。</p></li><li><p>著名沙盒游戏《Minecraft》也有对应的Java版本，得益于Java跨平台特性，无论在什么操作系统上都可以玩到这款游戏。</p></li><li><p>…</p></li></ul></li><li><p>Java 运行机制</p><p>实际上，Java程序也是需要进行编译才可以运行的，这一点与C语言是一样的，Java程序编译之后会变成 <code>.class</code> 结尾的二进制文件：</p><p><img src="https://s2.loli.net/2022/09/16/5z2OWQb3B9AhwSZ.png" alt="image-20220916153102763"></p><p>不过不同的是，这种二进制文件计算机并不能直接运行，而是需要交给JVM（Java虚拟机）执行。</p><p><img src="https://s2.loli.net/2022/09/16/6HnkcSIfPdVZEpM.png" alt="image-20220916152514450"></p><p>JVM 类似于 Python 解释器，将编译完成的 <code>.class</code> 文件交给 JVM 运行，程序中要做的事情，都由 JVM 告诉计算机该如何去执行。</p><p>在不同的操作系统下，都有对应的 JVM 实现，程序员只需要将 Java 程序编译为 <code>.class</code> 文件就可以直接交给 JVM 运行，无论是什么操作系统，JVM 都采用的同一套标准读取和执行 <code>.class</code> 文件，所以编译之后，在任何平台都可以运行，从而实现跨平台。</p><p>由于 Java 又需要编译同时还需要依靠 JVM 解释执行，所以说 Java <strong>既是编译型语言，也是解释型语言。</strong></p></li><li><p>Java 版本</p><ul><li><p>**JavaSE：**标准版 Java</p></li><li><p>**JavaME：**微缩版 Java，已经基本没人用了。</p></li><li><p>**JavaEE：**企业级 Java，比如网站开发。</p></li></ul></li></ol><h2 id="二、环境安装">二、环境安装</h2><h3 id="（一）JDK-安装">（一）JDK 安装</h3><ol><li><p>JRE 和 JDK 区别</p><ul><li><p><strong>JRE（Java Runtime Environment）</strong>：Java 的运行环境，安装了运行环境之后，Java 程序才可以运行，一般不做开发，只是需要运行 Java 程序直接按照 JRE 即可。</p></li><li><p><strong>JDK（Java Development Kit）</strong>：包含 JRE，并且还附带了大量开发者工具。</p><p><img src="https://s2.loli.net/2022/09/16/MpGWrh5xZdI3bCJ.png" alt="image-20220916154906732"></p></li></ul></li><li><p>JDK 安装</p><ul><li><a href="https://blog.csdn.net/m0_43395703/article/details/119685247?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-119685247-blog-134803032.235%5Ev43%5Epc_blog_bottom_relevance_base3&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=2">ARM Mac JDK 安装教程</a></li><li><a href="https://www.azul.com/downloads">Zulu JDK 下载</a></li></ul></li><li><p>jenv 安装</p><ul><li><a href="https://blog.csdn.net/weixin_52911459/article/details/128063285">jenv 安装</a></li></ul></li></ol><h3 id="（二）Java-版本管理">（二）Java 版本管理</h3><blockquote><p>查看当前 Java 版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java --version</span><br></pre></td></tr></table></figure><p>查看已安装的所有版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jenv versions</span><br></pre></td></tr></table></figure><p>切换不同版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jenv global 1.8</span><br></pre></td></tr></table></figure><p>添加新安装版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jenv add /Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home</span><br></pre></td></tr></table></figure><p>删除已安装版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jenv remove xxx</span><br></pre></td></tr></table></figure></blockquote><h2 id="三、Java-基础">三、Java 基础</h2><h3 id="（一）基础语法">（一）基础语法</h3><ol><li><p>main 主方法，是整个程序的入口点，执行过程从 main 主方法内开始从下往下依次执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>⚠️</p><ul><li>Java 中严格区分大小写；</li><li>每行代码写完后需要添加分号；</li></ul></blockquote></li><li><p>注释的使用</p><ul><li>单行注释 //</li><li>多行注释 /* xxx */</li><li>说明文档 /** xxx */</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> angfff</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>); <span class="comment">//输出语句</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      多行注释</span></span><br><span class="line"><span class="comment">      Test</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>变量</p><ul><li><p>变量声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[数据类型] [变量名称];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 方法一</span></span><br><span class="line">          <span class="type">int</span> X; <span class="comment">// 定义整数类型变量 X</span></span><br><span class="line">          X = <span class="number">10</span>; <span class="comment">// 为 X 赋值为 10</span></span><br><span class="line">          <span class="comment">// 方法二</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">Y</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 定义变量 Y 并赋值为 20</span></span><br><span class="line">          <span class="comment">// 方法三</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">Z</span> <span class="operator">=</span> Y; <span class="comment">// 定义变量 Z 并赋值为 Y 的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关键字 final : 在变量前添加 final 关键字，可以将变量定义为不可变变量（常量），也即只能进行一次赋值，后续不能对其进行修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> x; <span class="comment">// 常量 x</span></span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">        x = <span class="number">20</span>; <span class="comment">// 报错，无法进行修改</span></span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="（二）基本数据类型">（二）基本数据类型</h3><ol><li><p>整数类型</p><ul><li>byte 字节型 （8 个 bit，也就是 1 个字节）范围：-128 ~ +127</li><li>short 短整形（16 个 bit，也就是 2 个字节 / 一个字）范围：-32768 ~ +32767</li><li>int 整形（32 个 bit，也就是 4 个字节 / 双字）最常用的类型，范围：-2147483648 ~ +2147483647</li><li>long 长整形（64 个 bit，也就是 8 个字节 / 四字）范围：-9223372036854775808 ~ +9223372036854775807</li></ul><blockquote><p>补充：隐式类型转换</p><ul><li>从存储范围小的类型到存储范围大的类型，会发生隐式类型转换，自动将某种类型的值，转换为另一种类型。</li><li>实际上我们在为变量赋一个常量数值时，也发生了隐式类型转换，比如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="comment">//这里的整数常量10，实际上默认情况下是int类型，但是由于正好在对应类型可以表示的范围内，所以说直接转换为了byte类型的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>由于直接编写的整数常量值默认为<code>int</code>，这里需要特别注意一下，比如下面这种情况：</p><p><img src="https://s2.loli.net/2022/09/16/76GgjWYz4DPBy1p.png" alt="image-20220916232420547"></p><p>按照 <code>long</code> 类型的规定，实际上是可以表示这么大的数字的，但是为什么这里报错了呢？这是因为我们直接在代码中写的常量数字，默认情况下就是 <code>int</code> 类型，这么大肯定是表示不下的，如果需要将其表示为一个 long 类型的常量数字，那么需要在后面添加大写或是小写的 <code>L</code> 才可以。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">922337203685477580L</span>;   <span class="comment">//这样就可以正常编译通过了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>针对于这种很长的数字，为了提升辨识度，我们可以使用下划线分割每一位：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1_000_000</span>;    <span class="comment">//当然这里依然表示的是1000000，没什么区别，但是辨识度会更高</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们也可以以8进制或是16进制表示一个常量值：<ul><li>**十六进制：**以 <code>0x</code> 开头的都是十六进制表示法</li><li>**八进制：**以 0 开头的都是八进制表示法</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">0xA</span>);</span><br><span class="line">    System.out.println(<span class="number">012</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>浮点类型</p><ul><li>float 单精度浮点数（32bit，4 字节）</li><li>double 双精度浮点数（64bit，8 字节）</li></ul><blockquote><p><img src="https://s2.loli.net/2022/09/17/CpI5jaWgR9nqTbc.png" alt="image-20220917102209246"></p><p>根据国际标准 IEEE 754，任意一个二进制浮点数 V 可以表示成下面的形式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>V</mi><mo>=</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>S</mi></msup><mo>×</mo><mi>M</mi><mo>×</mo><msup><mn>2</mn><mi>E</mi></msup></mrow><annotation encoding="application/x-tex">V = (-1)^S \times M \times 2^E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1413em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li>(-1)^S 表示符号位，当 S=0，V 为正数；当 S=1，V 为负数。</li><li>M 表示有效数字，大于等于 1，小于 2，但整数部分的 1 不变，因此可以省略。（例如尾数为 1111010，那么 M 实际上就是1.111010，尾数首位必须是 1，1 后面紧跟小数点，如果出现0001111 这样的情况，去掉前面的 0，移动 1 到首位；题外话：随着时间的发展，IEEE 754标准默认第一位为 1，故为了能够存放更多数据，就舍去了第一位，比如保存 1.0101 的时候， 只保存 0101，这样能够多存储一位数据）</li><li>2^E 表示指数位。（用于移动小数点，所以说才称为浮点型）</li></ul><p>浮点类型的大致取值范围：</p><ul><li>单精度：±3.40282347*10^38</li><li>双精度：±1.79769313486231570 *10^308</li></ul></blockquote><blockquote><p>⚠️ 跟整数类型常量一样，小数类型常量默认都是<code>double</code>类型，所以说如果我们直接给一个float类型赋值：</p><p><img src="https://s2.loli.net/2022/09/17/x7bOzyIacpDowKk.png" alt="image-20220917105141288"></p><p>由于<code>float</code>类型的精度不如<code>double</code>，如果直接给其赋一个double类型的值，会直接出现错误。</p><p>同样的，我们可以给常量后面添加大写或小写的 F 来表示这是一个<code>float</code>类型的常量值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">9.9F</span>;   <span class="comment">//这样就可以正常编译通过了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>⚠️ 隐式类型转换规则总结：</p><p>byte → short(char) → int → long → float → double</p></blockquote></li><li><p>字符类型</p><ul><li>char 字符型（16个bit，2字节，不带符号）范围 0 ~ 65535</li></ul><p><img src="https://s2.loli.net/2022/09/17/Z7AiBPNO6ylML4z.png" alt="img"></p><ul><li>String 字符串类型</li></ul><blockquote><p>⚠️ ’ ’ 单引号用于 char 字符类型；&quot; &quot; 双引号用于 String 字符串类型</p></blockquote></li><li><p>布尔类型</p><ul><li>true  -  真</li><li>false  -  假</li></ul><p>布尔类型（boolean）只有<code>true</code>和<code>false</code>两种值，也就是要么为真，要么为假，布尔类型的变量通常用作流程控制判断语句（不同于C语言，C语言中一般使用0表示false，除0以外的所有数都表示true）布尔类型占据的空间大小并未明确定义，而是根据不同的JVM会有不同的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">true</span>;   <span class="comment">//值只能是 true 或 false</span></span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="（三）运算符">（三）运算符</h3><ol><li><p>赋值运算符</p><p>赋值运算符可以直接给某个变量赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">666</span>;   <span class="comment">//使用等号进行赋值运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**使用规则为：**赋值运算符的左边必须是一个可以赋值的目标，比如变量，右边可以是任意满足要求的值，包括变量。</p></li><li><p>算术运算符</p><ul><li><p>&quot; + &quot; 加法运算，除了支持算数运算外，还可以对字符串进行拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;abc&quot;</span>; </span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span> + <span class="literal">true</span> + <span class="number">1.5</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>&quot; - &quot; 减法运算</p></li><li><p>&quot; * &quot; 乘法运算</p></li><li><p>&quot; / &quot; 除法运算</p><p>两个整数在进行除法运算时，得到的结果也是整数（会直接砍掉小数部分，注意不是四舍五入）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>, b = <span class="number">5</span>;</span><br><span class="line">    System.out.println(a / b); <span class="comment">// 结果为 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>&quot; % &quot; 取模（取余数）运算</p></li></ul><blockquote><p>⚠️ 不同类型之间可以进行运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"> <span class="type">short</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;   </span><br><span class="line"><span class="comment">//不同类型的整数一起运算，小类型需要转换为大类型；</span></span><br><span class="line"> <span class="comment">//其中 short、byte、char 一律转换为 int 再进行计算（无论算式中有无 int，都需要转换），结果也是 int ；</span></span><br><span class="line"><span class="comment">//如果算式中出现了long类型，那么全部都需要转换到long类型再进行计算，结果也是long，反正就是依大的来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><ol start="3"><li><p>括号运算符</p><ul><li><p>提升优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (a = <span class="number">8</span>) * (-a + <span class="number">10</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. 括号的优先级是最高的，需要先计算括号中的内容，如果存在多个括号，就从左往右计算</span></span><br><span class="line"><span class="comment">        2. 首先是 a = 8，计算完成之后a变成8，并且运算结果也为8</span></span><br><span class="line"><span class="comment">        3. 然后是后面的加法，-a就是-8，加上10就是2</span></span><br><span class="line"><span class="comment">        4. 最后才是乘法，左边此时是8，右边是2，最后结果为16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>强制类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">short</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">short</span>) a;   <span class="comment">//在括号中填写上强制转换的类型，就可以强制转换到对应的类型了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>自增自减运算符</p><ul><li>&quot; ++ &quot; 自增运算符</li><li>&quot; – &quot; 自减运算符</li><li>“+=”、“-=”、“*=”、“/=”、“%=”</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a++;   <span class="comment">//先出结果，再自增</span></span><br><span class="line">    System.out.println(b);  <span class="comment">//b得到的是a自增前的值 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> ++a;   <span class="comment">//先自增，再出结果</span></span><br><span class="line">    System.out.println(b);   <span class="comment">//b得到的是a自增之后的结果 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>⚠️ 自增运算符放在前面，是先自增再得到结果；而自增运算符放到后面，是先出结果再自增（自减同理）</p><p>⚠️ 自增自减运算符的优先级与正负号等价比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> -a++ + ++a; </span><br><span class="line"><span class="comment">//我们首先来看前面的a，因为正负号和自增是同一个优先级，结合性是从右往左，所以说先计算a++</span></span><br><span class="line"><span class="comment">//a++的结果还是8，然后是负号，得到-8</span></span><br><span class="line"><span class="comment">//接着是后面的a，因为此时a已经经过前面变成9了，所以说++a就是先自增，再得到10</span></span><br><span class="line"><span class="comment">//最后得到的结果为 -8 + 10 = 2</span></span><br><span class="line"> System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>位运算符</p><ul><li><p>&quot; &amp; &quot; 按位与 运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a &amp; b;    <span class="comment">//进行按位与运算</span></span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>按位与，就是让这两个数每一位都进行比较，如果这一位两个数都是 1，那么结果就是 1，否则就是 0：</p><ul><li>a = 9 = 1001</li><li>b = 3 = 0011</li><li>c = 1 = 0001（因为只有最后一位，两个数都是1，所以说结果最后一位是1，其他都是0）</li></ul></blockquote></li><li><p>&quot; | &quot; 按位或 运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a | b;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>按位或，就是只要任意一个为1（不能同时为0）那么结果就是1：</p><ul><li>a = 9 = 1001</li><li>b = 3 = 0011</li><li>c =11= 1011（只要上下有一个是1或者都是1，那结果就是1）</li></ul></blockquote></li><li><p>&quot; ^ &quot; 按位异或 运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a ^ b;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Java 中并没有乘方运算符，<code>^</code> 是按位异或运算符</p><p>异或，就是只有两边不相同的情况下，结果才是1，也就是说一边是1一边是0的情况：</p><ul><li>a = 9 = 1001</li><li>b = 3 = 0011</li><li>c =10= 1010（从左往右第二位、第四位要么两个都是0，要么两个都是1，所以说结果为0）</li></ul></blockquote></li><li><p>&quot; ~ &quot; 按位取反 运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">c</span> <span class="operator">=</span> ~<span class="number">127</span>;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>按位取反，跟前面的正负号一样，只操作一个数，最好理解，如果这一位上是1，变成0，如果是0，变成1：</p><ul><li>127 = 01111111</li><li>-128 = 10000000</li></ul></blockquote></li><li><p>&quot; &lt;&lt; &quot; 左移；&quot; &lt;&lt; &quot; 右移</p><blockquote><ul><li>**左移操作 &lt;&lt;：**高位直接丢弃，低位补0</li><li>**右移操作 &gt;&gt;：**低位直接丢弃，符号位是什么高位补什么</li></ul></blockquote></li><li><p>&quot; &gt;&gt;&gt; &quot; 无符号右移</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>-1    =   11111111 11111111 11111111 11111111</li><li>右移：  01111111 11111111 11111111 11111111（无符号右移使用0填充高位）</li></ul><p>此时得到的结果就是正数的最大值</p><p>⚠️ 不存在无符号左移。</p></blockquote></li></ul></li><li><p>关系和逻辑运算符</p><ul><li>关系判断的结果只可能是真或是假，所以说得到的结果是一个<code>boolean</code>类型的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;   大于</span><br><span class="line">&lt;   小于</span><br><span class="line">==  等于（注意是两个等号连在一起，不是一个等号，使用时不要搞混了）</span><br><span class="line">!=  不等于</span><br><span class="line">&gt;=  大于等于</span><br><span class="line">&lt;=  小于等于</span><br></pre></td></tr></table></figure><ul><li>逻辑运算符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp;     与运算，要求两边同时为<span class="literal">true</span>才能返回<span class="literal">true</span></span><br><span class="line">||     或运算，要求两边至少要有一个为<span class="literal">true</span>才能返回<span class="literal">true</span></span><br><span class="line">!      非运算，一般放在表达式最前面，表达式用括号扩起来，表示对表达式的结果进行反转</span><br></pre></td></tr></table></figure></li><li><p>三元运算符</p><p>三元运算符可以根据判断条件，返回不同的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">b</span> <span class="operator">=</span> a &gt; <span class="number">10</span> ? <span class="string">&#x27;A&#x27;</span> : <span class="string">&#x27;B&#x27;</span>;   <span class="comment">//三元运算符需要三个内容，第一个是判断语句，第二个是满足判断语句的值，第三个是不满足判断语句的值</span></span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三元运算符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断语句 ? 结果<span class="number">1</span> : 结果<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>运算符优先级总结</p><table><thead><tr><th style="text-align:center">优先级</th><th style="text-align:center">运算符</th><th style="text-align:center">结合性</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">( )</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">~   -   +  (强制类型转换)  ++   –</td><td style="text-align:center">从右向左</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">*   /  %</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">+   -</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">&lt;&lt;   &gt;&gt;   &gt;&gt;&gt;</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">&gt;   &lt;   &gt;=   &gt;=</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">==     !=</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">&amp;</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">^</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">|</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">&amp;&amp;</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">||</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">? :</td><td style="text-align:center">从右向左</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">=  +=  -=  *=   /=   %=   &amp;=   |=   ^=   &lt;&lt;=  &gt;&gt;=  &gt;&gt;&gt;=</td><td style="text-align:center">从右向左</td></tr></tbody></table></li></ol><h3 id="（四）流程控制">（四）流程控制</h3><ol><li><p>代码块与作用域</p><p>作用域：在代码块内定义的变量无法在代码块之外使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;   <span class="comment">//此时变量在代码块内定义</span></span><br><span class="line">        System.out.println(a);   <span class="comment">//处于其作用域内部的代码可以调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(a);   <span class="comment">//作用域外的代码无法调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>条件判断</p><ul><li>IF 语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件判断) &#123;</span><br><span class="line">  判断成功执行的代码 <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> () &#123;</span><br><span class="line">  判断成功执行的代码 <span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  判断成功执行的代码 <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span>  <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(score &gt;= <span class="number">90</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Switch 语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (目标) &#123;   <span class="comment">//目标变量 或 计算表达式</span></span><br><span class="line">  <span class="keyword">case</span> 匹配值:    <span class="comment">//如目标值等于给定匹配值，执行case的代码</span></span><br><span class="line">    代码...</span><br><span class="line">    <span class="keyword">break</span>;    <span class="comment">//代码执行结束后需要使用break来结束，否则会溜到下一个case继续执行代码</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">case</span> 匹配值:</span><br><span class="line">    代码...</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环语句</p><ul><li>for 循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>) &#123;</span><br><span class="line">  循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>while 循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件) &#123;</span><br><span class="line">  循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>do……while 循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确</span></span><br><span class="line">    <span class="keyword">do</span> &#123;  <span class="comment">//无论满不满足循环条件，先执行循环体里面的内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>);   <span class="comment">//再做判断，如果判断成功，开启下一轮循环，否则结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>continue 和 break</p><p>⚠️ 就近原则，也可以利用标签指定跳转位置</p><p>a. <code>continue + (标签)</code> 跳过本轮循环进入下一轮</p><p>b. <code>break + (标签)</code> 跳出 / 结束循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">outer: <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">4</span>; ++i) &#123;   <span class="comment">//在循环语句前，添加 标签: 来进行标记</span></span><br><span class="line">    inner: <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j) <span class="keyword">break</span> outer;    <span class="comment">//break后紧跟要结束的循环标记，当i == j时终止外层循环</span></span><br><span class="line">        System.out.println(i+<span class="string">&quot;, &quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <summary type="html">Java SE 1️⃣ 环境搭建 与 基础语法</summary>
    
    
    
    <category term="开发" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Java SE" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/Java-SE/"/>
    
    
    <category term="开发" scheme="https://www.angfff.top/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Java" scheme="https://www.angfff.top/tags/Java/"/>
    
    <category term="Java SE" scheme="https://www.angfff.top/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记</title>
    <link href="https://www.angfff.top/posts/83eeafe1.html"/>
    <id>https://www.angfff.top/posts/83eeafe1.html</id>
    <published>2024-01-24T13:04:43.000Z</published>
    <updated>2025-03-06T04:40:56.795Z</updated>
    
    <content type="html"><![CDATA[<h1>软件测试</h1><h2 id="一、概述">一、概述</h2><h3 id="（一）基本概念">（一）基本概念</h3><ol><li><p>概念</p><blockquote><p>软件测试是指对软件系统进行验证和评估的过程。它包括通过运行软件系统来检测错误、缺陷和问题，并确保软件能够按照预期的要求和功能正常工作。软件测试的目标是提高软件质量和可靠性，以确保用户能够获得高质量的软件产品。测试人员通常使用各种测试技术和方法，如功能测试、性能测试、安全测试等，来发现并报告潜在的问题。软件测试在软件开发生命周期的不同阶段进行，以确保在发布软件之前发现和修复问题。</p></blockquote></li><li><p>分类：</p><ul><li>功能测试</li><li>性能测试</li><li>安全测试</li></ul></li></ol><h3 id="（二）软件测试重要性">（二）软件测试重要性</h3><blockquote><p>软件测试在软件项目中扮演着至关重要的角色，其重要性体现在以下几个方面：</p><ol><li><p>发现和修复问题：软件测试的主要目标是发现软件系统中的错误、缺陷和问题。通过有效的测试，可以及早发现并修复这些问题，从而提高软件的质量和可靠性。</p></li><li><p>提高用户满意度：通过软件测试，可以确保软件系统按照预期的要求和功能正常工作。这有助于提高用户满意度，满足用户的需求和期望。</p></li><li><p>节约成本和资源：通过在早期发现和修复问题，可以避免将错误和缺陷传递到后续开发阶段，从而节约了修复这些问题所需的成本和资源。</p></li><li><p>降低风险：软件测试有助于降低软件项目的风险。通过检测和修复问题，可以减少软件系统引发故障、数据丢失或安全漏洞等风险的概率。</p></li><li><p>提高软件质量和可靠性：软件测试是提高软件质量和可靠性的关键步骤。通过不断优化和完善测试流程，可以确保软件系统具有较高的质量和可靠性，满足用户的需求。</p></li></ol><p>总之，软件测试在软件项目中的重要性不可忽视。它有助于发现问题、提高用户满意度、节约成本和资源、降低风险，并提高软件质量和可靠性。通过有效的测试，可以确保软件系统交付给用户之前经过充分验证，从而提供高质量的软件产品。</p></blockquote><h2 id="二、功能测试">二、功能测试</h2><h3 id="（一）基本概念-2">（一）基本概念</h3><blockquote><p>功能测试是对软件系统的功能进行验证的测试过程。它主要测试软件是否按照规格说明书或需求文档中所定义的功能进行操作和输出。</p><p>在功能测试中，测试人员通常会使用黑盒测试技术，即仅关注软件的输入和输出，不考虑内部实现细节。常用的功能测试技术包括边界值分析、等价类划分、决策表等。</p></blockquote><h3 id="（二）黑盒测试">（二）黑盒测试</h3><ol><li><p>概念：黑盒测试，它是通过测试来检测每个功能是否都能正常使用。在测试中，把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。</p></li><li><p>作用：</p><blockquote><p>是否有功能错误，是否有功能遗漏。</p><p>是否能够正确地接收输入数据并产生正确的输出结果。</p><p>是否有数据结构错误或外部信息访问错误。</p><p>是否有程序初始化和终止方面的错误。</p></blockquote></li><li><p>测试方法：</p><ol><li><p><strong><u>等价类划分法</u></strong></p><blockquote><p>等价类划分法是一种常用的测试技术，用于减少测试用例的数量，从而提高测试效率。它基于一个假设，即在一个等价类中的测试用例具有相同的测试结果。</p><p>等价类划分法将输入值划分为多个等价类，然后选择代表性的测试用例来代表每个等价类进行测试。</p><p>等价类划分法的步骤如下：</p><ol><li>确定输入值的合法和非法范围。</li><li>将输入值划分为多个等价类，每个等价类包含具有相同测试结果的输入值。</li><li>选择代表性的测试用例来代表每个等价类进行测试。</li></ol><p>例如，假设有一个登录功能，用户名只能包含字母和数字，且长度在6到12个字符之间。根据等价类划分法，可以将输入值划分为以下等价类：</p><ul><li>合法的用户名：包含字母和数字，长度在6到12个字符之间。</li><li>非法的用户名：包含除字母和数字以外的字符。</li><li>非法的用户名：长度小于6个字符或大于12个字符。</li></ul><p>然后，从每个等价类中选择一个或多个代表性的测试用例进行测试，例如选择一个合法的用户名和一个非法的用户名进行测试。</p><p>等价类划分法可以帮助测试人员在覆盖各种输入情况的同时，减少测试用例的数量，提高测试效率。</p></blockquote></li><li><p><strong><u>边界值分析法</u></strong></p><blockquote><p>边界值分析法是一种测试技术，用于确定测试用例的边界条件。它基于一个假设，即在边界上的输入值往往容易引发错误和异常情况。</p><p>边界值分析法通过选择接近边界的测试用例来测试系统的稳定性和准确性。</p><p>边界值分析法的步骤如下：</p><ol><li>确定输入值的合法范围和边界条件。例如，一个输入范围是1到100的整数，边界条件是1和100。</li><li>选择接近边界的测试用例进行测试。通常会选择边界值、边界值的前一个值和边界值的后一个值作为测试用例。</li><li>测试边界值本身的情况以及边界值周围的情况，以确保系统在边界条件下的正确性。</li></ol><p>例如，假设有一个年龄输入框，要求输入的年龄在18到65岁之间。根据边界值分析法，可以选择以下测试用例：</p><ul><li>边界值测试用例：18、65</li><li>边界前一个值测试用例：17（测试小于最小边界的情况）</li><li>边界后一个值测试用例：66（测试大于最大边界的情况）</li></ul><p>边界值分析法可以帮助测试人员发现在边界条件下可能存在的问题和错误，并确保系统在边界条件下的正确性。它也有助于减少测试用例的数量，提高测试效率。</p></blockquote></li><li><p><strong><u>错误推测法</u></strong></p><blockquote><p>错误推测法是基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性的设计测试用例的方法。</p><p>错误推测方法的基本思想： 列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据他们选择测试用例。</p><p>例如，输入数据和输出数据为 0的情况。 输入表格为空格或输入表格只有一行。</p></blockquote></li><li><p><strong><u>决策表</u></strong></p><blockquote><p>决策表法是一种测试技术，用于设计和执行测试用例，以覆盖多个条件组合和对应的行为。它通过创建一个决策表来描述系统的各种条件和相应的行为，并根据不同的条件组合选择相应的测试用例。</p><p>决策表通常由以下几个部分组成：</p><ol><li>条件列：列出所有可能的条件，每个条件通常有两个状态，例如&quot;是&quot;和&quot;否&quot;。</li><li>动作列：列出系统可能的行为或操作。</li><li>规则：将条件和动作组合起来形成规则，描述系统的行为。</li></ol><p>决策表法的步骤如下：</p><ol><li>确定系统的条件和动作。</li><li>创建决策表，列出所有可能的条件和相应的动作。</li><li>根据系统需求和测试目标，选择测试用例。</li><li>根据选择的测试用例，执行测试并记录结果。</li></ol><p>决策表法的优势在于能够覆盖多个条件组合，并根据不同的条件组合选择相应的测试用例。它可以帮助测试人员在较少的测试用例数量下覆盖更多的情况，从而提高测试效率。同时，决策表法也有助于可读性和可维护性，使得测试用例的设计更加系统化和规范化。</p></blockquote></li></ol></li></ol><h3 id="（三）白盒测试">（三）白盒测试</h3><ol><li>概念：白盒测试是一种软件测试方法，它基于对软件系统的内部结构和逻辑进行测试。在白盒测试中，测试人员具有对源代码、算法和系统内部的详细了解，以便设计和执行测试用例。白盒测试的主要目标是验证软件系统的内部逻辑、路径覆盖和代码执行的正确性。</li><li>测试方法：<ol><li><p><strong><u>语句覆盖</u></strong>（Statement Coverage）：测试人员通过执行测试用例，确保每个源代码语句都被执行到。</p></li><li><p><strong><u>分支覆盖</u></strong>（Branch Coverage）：测试人员通过执行测试用例，确保每个分支和决策点都被覆盖到。</p></li><li><p><strong><u>条件覆盖</u></strong>（Condition Coverage）：测试人员通过执行测试用例，确保每个条件语句的真值和假值都被覆盖到。</p></li><li><p><strong><u>路径覆盖</u></strong>（Path Coverage）：测试人员通过执行测试用例，确保覆盖所有可能的代码路径。</p></li></ol></li></ol><h2 id="三、性能测试">三、性能测试</h2><h3 id="（一）基本概念-3">（一）基本概念</h3><blockquote><p>性能测试是评估软件系统性能和响应能力的测试过程。它主要测试软件在不同负载和压力条件下的性能表现，如响应时间、并发用户数、吞吐量等。</p></blockquote><h3 id="（二）测试方式">（二）测试方式</h3><p>在性能测试中，测试人员通常会使用负载测试、压力测试、性能剖析等技术来模拟不同负载和压力条件，并测量软件的性能指标。</p><h2 id="四、安全测试">四、安全测试</h2><h3 id="（一）基本概念-4">（一）基本概念</h3><blockquote><p>安全测试是评估软件系统安全性和防护能力的测试过程。它主要测试软件系统是否存在安全漏洞和弱点，以及是否能够抵御恶意攻击和未授权访问。</p></blockquote><h3 id="（二）测试方式-2">（二）测试方式</h3><p>在安全测试中，测试人员通常会使用渗透测试、漏洞扫描、安全代码审查等技术来发现软件系统中的安全漏洞和弱点，并提出相应的修复建议。</p><h2 id="参考书目">参考书目</h2><ul><li>软件测试 [美] Ron Patton 机械工业出版社</li><li>Google 软件测试之道：像 Google 一样进行软件测试 [美] James A. Whittaker 等 人民邮电出版社</li><li>软件性能测试、分析与调优实践之路 [中] 张永清 清华大学出版社</li></ul>]]></content>
    
    
    <summary type="html">软件测试笔记</summary>
    
    
    
    <category term="开发" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="软件测试" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="开发" scheme="https://www.angfff.top/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="软件测试" scheme="https://www.angfff.top/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 笔记</title>
    <link href="https://www.angfff.top/posts/65316ea.html"/>
    <id>https://www.angfff.top/posts/65316ea.html</id>
    <published>2023-12-17T09:49:58.000Z</published>
    <updated>2025-03-06T04:40:56.795Z</updated>
    
    <content type="html"><![CDATA[<h1>一、概述</h1><h2 id="（一）数据管理技术发展过程">（一）数据管理技术发展过程</h2><h3 id="1-数据管理">1.数据管理</h3><p>（1）定义：对数据进行收集、分类、组织、编码、存储、检索和维护一系列活动的总和；</p><p>（2）发展过程：人工管理阶段 -&gt; 文件系统阶段 -&gt; 数据库系统阶段</p><h3 id="2-人工管理阶段">2.人工管理阶段</h3><ul><li>数据的管理者: 应用程序，数据不保存</li><li>数据面向的对象: 某一应用程序</li><li>数据的共享程度: 无共享、冗余度极大</li><li>数据的独立性: 不独立，完全依赖于程序</li><li>数据的结构化: 无结构</li><li>数据控制能力: 应用程序自己控制</li></ul><h3 id="3-文件系统阶段">3.文件系统阶段</h3><ul><li>数据的管理者: 文件系统，数据可长期保存</li><li>数据面向的对象: 某一应用程序</li><li>数据的共享程度: 共享性差、冗余度大</li><li>数据的结构化: 记录内有结构，整体无结构</li><li>数据的独立性: 独立性差，数据逻辑结构改变必须修改应用程序</li><li>数据控制能力: 应用程序自己控制</li></ul><h3 id="4-数据库系统阶段">4.数据库系统阶段</h3><p>（DBMS，独立的软件，位于操作系统之上）</p><ul><li>数据结构化</li><li>数据的共享性高，冗余度低且易扩充</li><li>数据独立性高（应用程序和数据库分离）</li><li>数据由 DBMS 统一管理和控制</li></ul><h2 id="（二）数据库">（二）数据库</h2><h3 id="1-数据-Data">1.数据(Data)</h3><ul><li>数据(Data)是数据库中存储的基本对象</li><li>数据的定义:描述事物的符号记录</li><li>数据的种类:文本、图形、图像、音频、视频、学生的档案记录、货物的运输情况等</li><li>数据的特点:数据与其语义是不可分的</li></ul><h3 id="2-数据库-Database">2.数据库(Database)</h3><ul><li>数据库(Database,简称DB)是长期储存在<u>计算机内</u>、<u>有组织</u>的、<u>可共享</u>的<u>大量数据</u>的集合</li></ul><h3 id="3-数据库管理系统-DBMS">3.数据库管理系统(DBMS)</h3><ul><li>定义:位于用户和操作系统之间的一层数据管理软件，是数据库和用户之间的一个接口</li><li>属性:数据库管理系统和操作系统一样都属于计算机的基础软件，也是一个大型复杂的软件系统。</li><li>作用:在数据库建立、运用和维护时对数据库进行统一控制，以保证数据的完整性、安全性，并在多用户同时使用数据库时进行并发控制，在发生故障后对数据库进行恢复。</li></ul><h3 id="4-数据库系统-DBS">4.数据库系统(DBS)</h3><p>​数据库系统的构成</p><ul><li>数据库</li><li>数据库管理系统(及其应用开发工具)</li><li>应用程序</li><li>数据库管理员</li></ul><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F.png" alt="数据库系统"></p><h2 id="（三）MySQL-安装与配置">（三）MySQL 安装与配置</h2><h3 id="1-安装">1.安装</h3><p>（1）macOS</p><ul><li>macOS 安装 MySQL <a href="https://blog.csdn.net/weixin_42148729/article/details/115056646?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168532550116800222872851%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168532550116800222872851&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-115056646-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=Mac%20mysql&amp;spm=1018.2226.3001.4187">教程</a></li></ul><p>（2）Windows</p><ul><li>Windows 安装 MySQL <a href="https://blog.csdn.net/xhmico/article/details/125029286">教程</a></li></ul><h3 id="2-连接">2.连接</h3><p>（1）终端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">Enter password: 123456</span><br></pre></td></tr></table></figure><p>（2）Navicat</p><p>（3）DataGrip</p><p>（4）VSCode</p><h1>二、 MySQL 基础</h1><h2 id="（一）概念">（一）概念</h2><p>DBMS 数据库管理系统</p><ul><li>关系型数据库 SQL</li><li>非关系型数据库 noSQL</li></ul><p>SQL: Structured Query Language 结构化查询语言</p><ol><li>设定为 主键 的属性可以唯一地表示每一条记录，即用 主键 可以区分不同的记录</li><li>可以通过 外键 将两张表格的记录关联起来，<ul><li>两张表间关联：表 A 中的 外键 对应到表 B 的 主键</li><li>一张表内关联：表A 中的 外键 也可以对应到自己的 主键 ，e.g 主管 id</li></ul></li><li>主键可以有多个，无论几个，其目的都是通过 一个/组 主键 ，区分不同的记录</li><li>可以同时将某一个属性设置为 主键 和 外键，表示从 A 可以查到 B 的某一条记录，从 B 也可以反过来找到 A 中的对应记录</li></ol><h2 id="（二）MySQL-数据类型">（二）MySQL 数据类型</h2><ol><li><p>数值</p><p>（1）整数</p><table><thead><tr><th style="text-align:left">数据类型</th><th style="text-align:left">字节数</th></tr></thead><tbody><tr><td style="text-align:left">TINYINT</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">SMALLINT</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">MEDIUMINT</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">INT</td><td style="text-align:left">4</td></tr><tr><td style="text-align:left">BIGINT</td><td style="text-align:left">8</td></tr></tbody></table><p>（2）浮点数</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>字节数</strong></th></tr></thead><tbody><tr><td>FLOAT</td><td>4</td></tr><tr><td>DOUBLE</td><td>8</td></tr></tbody></table><blockquote><p>注：float / double(m, n) 带有小数点的数</p><p>m 表示该数字总共有几位数n 表示小数部分所占的位数</p><p>e.g. float(3, 2) -&gt; 2.33 就是总共有 3 位数，其中小数占了 2 位</p></blockquote><p>（3）定点数 DECIMAL</p><blockquote><p>注：DECIMAL(m, n) 带有小数点的数</p><p>m 表示该数字总共有几位数n 表示小数部分所占的位数</p><p>e.g. DECIMAL(3, 2) -&gt; 2.33</p></blockquote><blockquote><p>注：浮点数和定点数的区别</p><ul><li>float / double 在 db 中存储的是近似值，而 decimal 则是以字符串形式进行保存的。因此，浮点数可能会存在精度丢失的问题，而定点数则不会丢失精度。</li><li>decimal(m,n) 的规则和 float / double 相同，但区别在 float / double 在不指定 m/n 时默认按照实际精度来处理，而 decimal 在不指定时默认为 decimal(10, 0)。</li></ul></blockquote></li><li><p>日期时间</p><table><thead><tr><th>数据类型</th><th>字节数</th><th>格式</th><th>备注</th></tr></thead><tbody><tr><td>date</td><td>3</td><td>yyyy-MM-dd</td><td>存储日期值</td></tr><tr><td>time</td><td>3</td><td>HH:mm:ss</td><td>存储时分秒</td></tr><tr><td>year</td><td>1</td><td>yyyy</td><td>存储年</td></tr><tr><td>datetime</td><td>8</td><td>yyyy-MM-dd HH:mm:ss</td><td>存储日期+时间</td></tr><tr><td>timestamp</td><td>4</td><td>yyyy-MM-dd HH:mm:ss</td><td>存储日期+时间，时间戳</td></tr></tbody></table><blockquote><p>注 1 ：datetime 和 timestamp 的区别：</p><ul><li>datetime 占8个字节，timestamp 占4个字节；</li><li>由于字节数区别，datetime 与 timestamp 能存储的时间范围也不同，datetime 的存储范围为 1000-01-01 00:00:00 — 9999-12-31 23:59:59，timestamp 存储的时间范围为 19700101080001—20380119111407；</li><li>datetime 默认值为空，当插入的值为 null 时，该列的值就是 null；timestamp 默认值不为空，当插入的值为 null 的时候，mysql 会取当前时间；</li><li>datetime 存储的时间与时区无关，timestamp 存储的时间及显示的时间都依赖于当前时区；</li></ul><p>注 2 ：通常表格中记录“创建时间”和“修改时间”字段时，用 timestamp</p></blockquote></li><li><p>字符串</p><p>（1）CHAR(n) 定长字符串</p><p>（2）VARCHAR(n) 变长字符串</p><p>（3）TEXT</p><p>（4）BLOB 二进制对象（图片、视频、档案等）</p><blockquote><p>注：</p><ul><li><p>MySql 单行最大数据量为 64K，为了存储大数据，因此创建了 TEXT 和 BLOB 两种类型；</p></li><li><p>TEXT 和 VARCHAR 比较类似，当 varchar(M) 的 M 大于某些数值时，varchar 会自动转为 text：</p><ul><li><p>M&gt;255 时转为 tinytext</p></li><li><p>M&gt;500 时转为 text</p></li><li><p>M&gt;20000 时转为 mediumtext</p></li></ul></li><li><p>varchar(M) 和 text 的区别：</p><ul><li><p>单行 64K 即 65535 字节的空间，varchar 只能用 63352 /  65533 个字节，text 可以用 65535 个字节；</p></li><li><p>text 可以指定 text(M) ，且 M 无限制</p></li><li><p>text 不允许有默认值，varchar 允许有默认值</p></li></ul></li><li><p>text 和 blob 的区别：text 存储的是字符串而 blob 存储的是二进制字符串。</p></li></ul></blockquote></li><li><p>JSON</p></li><li><p>空间</p></li></ol><h2 id="（三）SQL-语句分类">（三）SQL 语句分类</h2><ol><li><p>DDL (Data Definition Language) 数据定义语言</p><p>CREATE / DROP / ALTER / TRUNCATE</p></li><li><p>DML (Data Manipulation Language) 数据操作语言</p><p>INSERT / UPDATE / DELETE / CALL</p></li><li><p>DQL (Data Query Language) 数据查询语言</p><p>SELECT</p></li><li><p>DCL (Data Control Language) 数据控制语言</p><p>GRANT / REVOKE</p></li></ol><h1>三、常用 SQL 语句</h1><h2 id="（一）数据库和表操作">（一）数据库和表操作</h2><ol><li><p>新建数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `sql_tutorial`;</span><br></pre></td></tr></table></figure></li><li><p>查看所有数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure></li><li><p>删除数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE `sql_tutorial`;</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">drop</span> database test;</span><br><span class="line">ERROR <span class="number">1010</span> (HY000): Error dropping database (can<span class="string">&#x27;t rmdir &#x27;</span>.<span class="operator">/</span>test<span class="operator">/</span><span class="string">&#x27;, errno: 17)</span></span><br></pre></td></tr></table></figure><p>注：如果遇到上述无法删除数据库的情况，是因为 test 目录下存在着MySQL 不知道的文件，即 MySQL 中没有该文件的数据字典信息，需要手动删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/mysql/data/test# 进入 test 所在位置</span><br><span class="line">ls # 查看未知文件</span><br><span class="line">rm -rf xxx # 手动删除</span><br></pre></td></tr></table></figure><p>删除后，再次 DROP 即可。</p></blockquote></li><li><p>选择数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE `sql_tutorial`;</span><br></pre></td></tr></table></figure></li><li><p>创建表格</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `student` ( </span><br><span class="line">`student_id` <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span>, # `属性名` 类型 主键,</span><br><span class="line">`name` <span class="type">VARCHAR</span> ( <span class="number">20</span> ), </span><br><span class="line">`major` <span class="type">VARCHAR</span> ( <span class="number">20</span> ) </span><br><span class="line">  #<span class="keyword">PRIMARY KEY</span>(`student_id`) 主键也可以不在属性后注明，也可以在下面单独写</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>查看表格</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> `student`;</span><br><span class="line"><span class="keyword">DESC</span> `student`;</span><br></pre></td></tr></table></figure></li><li><p>删除表格</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> `student`;</span><br></pre></td></tr></table></figure></li><li><p>新增表 字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> `student` <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> gpa <span class="type">DECIMAL</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p>删除表 字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> `student` <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> gpa;</span><br></pre></td></tr></table></figure></li><li><p>修改表 字段属性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> `student` MODIFY <span class="keyword">COLUMN</span> gpa <span class="type">FLOAT</span>(<span class="number">3</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改表 字段名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER TABLE</span> `student` RENAME <span class="keyword">COLUMN</span> gpa <span class="keyword">to</span> Stu_GPA;</span><br></pre></td></tr></table></figure></li><li><p>导出数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 Shell 中使用</span></span><br><span class="line">mysqldump -u root -p DB (able) &gt; DB.sql</span><br></pre></td></tr></table></figure></li><li><p>导入数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 Shell 中使用</span></span><br><span class="line">mysql -u root -p DB &lt; DB.sql</span><br></pre></td></tr></table></figure></li></ol><h2 id="（二）数据操作">（二）数据操作</h2><ol><li><p>查询所有记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `student`;</span><br></pre></td></tr></table></figure></li><li><p>添加记录</p><ol><li><p>不指定属性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 这种方式添加记录，属性的顺序和数量必须全部匹配</span><br><span class="line"><span class="keyword">INSERT INTO</span> `student` <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;小白&#x27;</span>, <span class="string">&#x27;历史&#x27;</span>); </span><br></pre></td></tr></table></figure></li><li><p>指定属性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 可以在表格后添加属性序列，指定输入的属性，如后续值省略，则自动填入默认值</span><br><span class="line"><span class="keyword">INSERT INTO</span> `student`(`name`, `major`, `student_id`) <span class="keyword">VALUES</span>(<span class="string">&#x27;小蓝&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"># 插入多条数据</span><br><span class="line"><span class="keyword">INSERT INTO</span> `student`(`name`, `student_id`) <span class="keyword">VALUES</span>(<span class="string">&#x27;小红&#x27;</span>, <span class="number">5</span>),(<span class="string">&#x27;小绿&#x27;</span>, <span class="number">6</span>),(<span class="string">&#x27;小黄&#x27;</span>, <span class="number">7</span>);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>常用约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> `student`</span><br><span class="line">(</span><br><span class="line">    `student_id` <span class="type">INT</span> <span class="keyword">PRIMARY KEY</span> AUTO_INCREMENT,</span><br><span class="line">    `name`       <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT NULL</span>, # 非空</span><br><span class="line">    `major`      <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>, # 唯一</span><br><span class="line">    `sex`        <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;男&#x27;</span># 默认值，通常应用在指定输入属性时</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>更新记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `student`</span><br><span class="line"><span class="keyword">SET</span> `major` <span class="operator">=</span> <span class="string">&#x27;English&#x27;</span>, `score` <span class="operator">=</span> <span class="number">98</span></span><br><span class="line"><span class="keyword">WHERE</span> `major` <span class="operator">=</span> <span class="string">&#x27;Math&#x27;</span> <span class="keyword">OR</span> `major` <span class="operator">=</span> <span class="string">&#x27;Chinese&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `student`</span><br><span class="line"><span class="keyword">WHERE</span> `student_id` <span class="operator">=</span> <span class="number">4</span>; # 不加条件，则删除所有记录</span><br></pre></td></tr></table></figure></li><li><p>查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">1</span>, 属性<span class="number">2</span></span><br><span class="line"><span class="keyword">FROM</span> 表</span><br><span class="line"><span class="keyword">WHERE</span> 属性<span class="number">1</span> <span class="operator">=</span> <span class="string">&#x27;特定值&#x27;</span> <span class="keyword">AND</span> <span class="operator">/</span> <span class="keyword">OR</span> 属性<span class="number">2</span> <span class="operator">&lt;&gt;</span> <span class="string">&#x27;特定值&#x27;</span></span><br><span class="line"># 链接符优先级 <span class="keyword">NOT</span> <span class="operator">&gt;</span> <span class="keyword">AND</span> <span class="operator">&gt;</span> <span class="keyword">OR</span>，可以用括号改变优先级顺序</span><br><span class="line"># 增加筛选条件（ <span class="operator">&lt;&gt;</span> 不等于 ）</span><br><span class="line"># 同一属性 a 判断多个条件并使用 <span class="keyword">OR</span> 连接时，可以用: 属性 <span class="keyword">IN</span> (<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"># 属性在某个区间内取值时，可以用: <span class="keyword">BETWEEN</span> a <span class="keyword">AND</span> b</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组依据</span><br><span class="line"><span class="keyword">HAVING</span> 分组后过滤的依据</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序依据<span class="number">1</span>, 排序依据<span class="number">2</span> <span class="keyword">DESC</span> </span><br><span class="line"># 默认升序 <span class="keyword">ASC</span> ，添加 <span class="keyword">DESC</span> 变为降序</span><br><span class="line"># 先按照依据<span class="number">1</span>排序，有相同的再按照依据<span class="number">2</span>排序</span><br><span class="line">LIMIT n <span class="operator">/</span> a,b </span><br><span class="line"># 如果只写一个数字 n 则返回前 n 条记录</span><br><span class="line"># 如果写 a,b 则返回 从 a<span class="operator">+</span><span class="number">1</span> 条记录开始的 b 条记录</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注：</p><ol><li>判断是否为空用 <code>IS NULL / IS NOT NULL</code>；</li><li>计算字符串中字符数的最佳函数是 <code>CHAR_LENGTH(str)</code>，它返回字符串 <code>str</code> 的长度；而函数 <code>LENGTH(str)</code> 返回字符串 <code>str</code> 的字节数，某些字符包含多于 1 个字节，可能导致返回结果错误。</li><li>DISTINCT + 属性 可用于去重；</li></ol></blockquote><h2 id="（三）进阶操作">（三）进阶操作</h2><ol><li><p>聚合函数</p><p>聚合函数用于对某些列进行一些计算，包括求和、计数、求平均等。</p><ul><li><p>COUNT( ) 返回集合中的项目数；</p></li><li><p>AVG( ) 返回集合的平均数；</p></li><li><p>SUM( ) 求和；</p></li><li><p>ROUND( 对象, 小数位数 ) 四舍五入保留小数；</p></li><li><p>MIN( ) 最小值；</p></li><li><p>MAX( ) 最大值；</p></li></ul></li><li><p>通配符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">属性 (<span class="keyword">NOT</span>) <span class="keyword">LIKE</span> <span class="string">&#x27;通配符&#x27;</span>;</span><br><span class="line"># <span class="operator">%</span> 表示任意长度的字符串</span><br><span class="line"># _ 表示任意单个字符</span><br></pre></td></tr></table></figure></li><li><p>正则表达式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">属性 REGEXP <span class="string">&#x27;正则表达式&#x27;</span>;</span><br><span class="line"># <span class="operator">^</span> 开头 $ 结尾</span><br><span class="line"># . 任意一个字符</span><br><span class="line"># [abc] 其中任意一个字符</span><br><span class="line"># [a<span class="operator">-</span>z] 范围内任意一个字符</span><br><span class="line"># A<span class="operator">|</span>B A 或 B</span><br></pre></td></tr></table></figure></li><li><p>集合运算</p><ul><li><p>UNION 并集</p><p>将两个结果合并为一个结果返回，后者直接接在前者最后；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">1</span> <span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">2</span> <span class="keyword">FROM</span> 表<span class="number">2</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>UNION 默认会去除两条 select 中得到的重复记录；如果要求不去重，则可以使用 UNION ALL。</p></blockquote></li><li><p>INTERSECT 交集</p><p>将两个结果取交集后返回；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">1</span> <span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">2</span> <span class="keyword">FROM</span> 表<span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>EXCEPT 差集</p><p>将两个结果取差集后返回，查找满足第一条语句但不满足第二条语句的记录；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">1</span> <span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">2</span> <span class="keyword">FROM</span> 表<span class="number">2</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>连接查询 JOIN</p><p>连接查询，将后者拼接在前者表的右边</p><p>（1）外连接</p><ul><li>LEFT JOIN（左连接）以左表为主，右表中没有的数据用 NULL 填充；</li><li>RIGHT JOIN（右连接）以右表为主，左表中没有的数据用 NULL填充；</li><li>FULL (OUTER) JOIN（全连接）两边连接，没有的都用 FULL 填充 <em><strong><u>并集</u></strong></em>。</li></ul><p>（2）内连接</p><ul><li>INNER JOIN （内连接）只返回两个表中都有的数据 <em><strong><u>交集</u></strong></em></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">1</span>, 属性<span class="number">2</span>, 属性<span class="number">3</span> <span class="keyword">FROM</span> 表<span class="number">1</span> </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span></span><br><span class="line"><span class="keyword">ON</span> 表<span class="number">1.</span>属性a <span class="operator">=</span> 表<span class="number">2.</span>属性b;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 内连接 也可以用 <span class="keyword">WHERE</span> 的方式实现</span><br><span class="line"># <span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">join</span> equip</span><br><span class="line"><span class="keyword">on</span> player.id <span class="operator">=</span> equip.player_id;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> player, equip</span><br><span class="line"><span class="keyword">where</span> player.id <span class="operator">=</span> equip.player_id;</span><br></pre></td></tr></table></figure><p>（3）交叉连接</p><ul><li><p>(CROSS) JOIN （交叉连接）相当于取两个表的***<u>笛卡尔积</u>***</p><blockquote><p>注：在 MySQL 中，如果不指定 ON 条件，则 CROSS JOIN 与 INNER JOIN 的结果是一样的，都是两张表的笛卡尔积。</p></blockquote></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">1</span>, 属性<span class="number">2</span>, 属性<span class="number">3</span> <span class="keyword">FROM</span> 表<span class="number">1</span> </span><br><span class="line">(<span class="keyword">CROSS</span>) <span class="keyword">JOIN</span> 表<span class="number">2</span></span><br><span class="line"><span class="keyword">ON</span> 表<span class="number">1.</span>属性a <span class="operator">=</span> 表<span class="number">2.</span>属性b;</span><br></pre></td></tr></table></figure></li><li><p>子查询 / 嵌套查询</p><p>（1）一个查询嵌套在另一个查询中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查询对一位客户销售金额超过 <span class="number">50000</span> 的员工姓名</span><br><span class="line"><span class="keyword">SELECT</span> Employee.name, Works_with.total_sales</span><br><span class="line"><span class="keyword">FROM</span> Employee <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Works_with</span><br><span class="line"><span class="keyword">ON</span> Employee.emp_id <span class="operator">=</span> Works_with.emp_id</span><br><span class="line"><span class="keyword">WHERE</span> Employee.emp_id <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">SELECT</span> Works_with.emp_id </span><br><span class="line">  <span class="keyword">FROM</span> Works_with </span><br><span class="line">  <span class="keyword">WHERE</span> Works_with.total_sales <span class="operator">&gt;=</span> <span class="number">50000</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 注: 这里内层的查询结果不止一个，所以不能用 <span class="operator">=</span> 连接内外查询，要用 <span class="keyword">IN</span> 连接内外查询</span><br></pre></td></tr></table></figure><p>（2）用子查询结果创建新表格</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查询所有等级小于 <span class="number">5</span> 级的玩家，并将结果保存到新的表格中</span><br><span class="line"><span class="keyword">CREATE TABLE</span> new_player <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> level <span class="operator">&lt;</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"># 查询所有等级在 <span class="number">6</span><span class="number">-10</span> 级的玩家，并将结果插入到 new_player 中</span><br><span class="line"><span class="keyword">INSERT INTO</span> new_player <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> level <span class="keyword">BETWEEN</span> <span class="number">6</span> <span class="keyword">AND</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>索引 INDEX</p><p>通常对一张表格的主键字段或常用字段创建索引，从而提高后续的查询效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 在指定表（的某些字段）上创建 唯一<span class="operator">/</span>全文<span class="operator">/</span>空间 索引</span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT<span class="operator">|</span>SPATIAL] INDEX 索引名称</span><br><span class="line"><span class="keyword">ON</span> 表名 (字段名称, ...);</span><br><span class="line"></span><br><span class="line"># 查看索引</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> 表名;</span><br><span class="line"></span><br><span class="line"># 删除索引</span><br><span class="line"><span class="keyword">DROP</span> INDEX 索引名称</span><br><span class="line"><span class="keyword">ON</span> 表;</span><br></pre></td></tr></table></figure></li></ol><h2 id="（四）窗口函数">（四）窗口函数</h2><ol><li><p>概念</p><p>窗口函数是一种特殊类型的 SQL 函数，它在查询结果集中的一定窗口（或称为窗口框架）上执行计算操作。</p><p>这个窗口是通过使用 OVER 子句定义的，它指定了在进行聚合、排序或分析等操作时应考虑的行集合。</p><p>窗口函数通常与聚合函数一起使用，但与普通的聚合函数不同，它不会将整个结果集作为输入，而是基于定义的窗口框架对子集进行计算。这使得在不引入子查询或自连接的情况下，能够在每一行上执行对整个结果集的聚合或分析操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  column1,</span><br><span class="line">  column2,</span><br><span class="line">  <span class="built_in">SUM</span>(column3) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> column1 # 按 column1 分组</span><br><span class="line">                     <span class="keyword">ORDER</span> <span class="keyword">BY</span> column2 # 按 column2 排序</span><br><span class="line">                     <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="number">1</span> PRECEDING <span class="keyword">AND</span> <span class="number">1</span> FOLLOWING # 当前行及其前后各一行</span><br><span class="line">                    ) <span class="keyword">AS</span> running_total</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  your_table;</span><br><span class="line"></span><br><span class="line"># SUM 是一个聚合函数，但它通过<span class="keyword">OVER</span>子句指定了一个窗口框架。</span><br><span class="line"># 在这个例子中，窗口由 <span class="keyword">PARTITION</span> <span class="keyword">BY</span> column1 定义，然后使用 <span class="keyword">ORDER</span> <span class="keyword">BY</span> column2 排序。</span><br><span class="line"># <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="number">1</span> PRECEDING <span class="keyword">AND</span> <span class="number">1</span> FOLLOWING指定了窗口的范围，表示当前行及其前后各一行。</span><br><span class="line"># 这样，SUM函数将在每个窗口内计算列column3的累计和。</span><br></pre></td></tr></table></figure></li><li><p>聚合函数</p><blockquote><p>示例数据</p><p>![截屏2023-12-20 21.15.22](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.15.22.png)</p></blockquote><ul><li><p><code>SUM</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line">       <span class="built_in">SUM</span>(Salary) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> GroupName) <span class="keyword">AS</span> 部门工资总和, # 按照部门分组，计算部门工资总和</span><br><span class="line">       <span class="built_in">SUM</span>(Salary) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> GroupName <span class="keyword">ORDER</span> <span class="keyword">BY</span> ID) <span class="keyword">AS</span> 累加_部门工资总和, # 按照部门分组，再按组内 ID 依次累加部门工资总和</span><br><span class="line">       <span class="built_in">SUM</span>(Salary) <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> ID) <span class="keyword">AS</span> 累加_全体工资总和, # 按所有人的 ID 依次累加工资总和</span><br><span class="line">       <span class="built_in">SUM</span>(Salary) <span class="keyword">OVER</span>() <span class="keyword">AS</span> 全体工资总和 # 窗口为空，直接计算所有员工工资总和 等同于 <span class="built_in">SUM</span>()</span><br><span class="line"><span class="keyword">FROM</span> Emp;</span><br></pre></td></tr></table></figure><p>![截屏2023-12-20 21.13.50](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.13.50.png)</p></li><li><p><code>MAX</code></p></li><li><p><code>MIN</code></p></li><li><p><code>COUNT</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> GroupName) <span class="keyword">AS</span> 部门人数,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> GroupName <span class="keyword">ORDER</span> <span class="keyword">BY</span> ID) <span class="keyword">AS</span> 累加_部门人数,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> ID) <span class="keyword">AS</span> 累加_全体人数,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">OVER</span>() <span class="keyword">AS</span> 总人数</span><br><span class="line"><span class="keyword">FROM</span> Emp;</span><br></pre></td></tr></table></figure><p>![截屏2023-12-20 21.14.46](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.14.46.png)</p></li><li><p><code>AVG</code></p></li></ul></li><li><p>排序函数</p><blockquote><p>示例数据</p><p>![截屏2023-12-20 21.16.26](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.16.26.png)</p></blockquote><ul><li><p><code>ROW_NUMBER</code> 将 SELECT 得到的数据进行排序，必须与 ORDER BY 连用，常用于分页查询；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line">       <span class="built_in">ROW_NUMBER</span>() <span class="keyword">over</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> ClassName <span class="keyword">ORDER</span> <span class="keyword">BY</span> Score <span class="keyword">DESC</span>) <span class="keyword">AS</span> 班内排名, # 按照班级分组，再按照分数降序排列，给每行一个排名</span><br><span class="line">       <span class="built_in">ROW_NUMBER</span>() <span class="keyword">over</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> Score <span class="keyword">DESC</span>) <span class="keyword">AS</span> 全体排名 # 按照分数降序排列，给每行一个排名</span><br><span class="line"><span class="keyword">FROM</span> SCO;</span><br></pre></td></tr></table></figure><p>![截屏2023-12-20 21.16.59](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.16.59.png)</p></li><li><p><code>RANK</code> 与 ROW_NUMBER 类似，但是允许并列排名，即分数相同时，排名也相同，后续跳过被占用的名次；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ROW_NUMBER</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>, <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> SCO.Score <span class="keyword">DESC</span>) <span class="keyword">AS</span> 总排名</span><br><span class="line"><span class="keyword">FROM</span> SCO; # 不能并列排名</span><br></pre></td></tr></table></figure><p>![截屏2023-12-20 21.18.28](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.18.28.png)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># RANK</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>, <span class="built_in">RANK</span>() <span class="keyword">over</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> SCO.Score <span class="keyword">DESC</span>) <span class="keyword">AS</span> 总排名</span><br><span class="line"><span class="keyword">FROM</span> SCO; # 可以并列，且后续跳过被占用的排名</span><br></pre></td></tr></table></figure><p>![截屏2023-12-20 21.18.40](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.18.40.png)</p></li><li><p><code>DENSE_RANK</code> 与 RANK 类似，允许并列排名，但后续不会跳过被占用的名次。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># DENSE_RANK</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>, <span class="built_in">DENSE_RANK</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> SCO.Score <span class="keyword">DESC</span> ) <span class="keyword">AS</span> 总排名</span><br><span class="line"><span class="keyword">FROM</span> SCO; # 可以并列，且后续不跳过被占用的排名</span><br></pre></td></tr></table></figure><p>![截屏2023-12-20 21.19.55](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.19.55.png)</p></li></ul></li><li><p>取值函数</p><p>（1）向前向后取数</p><ul><li><code>lag( )</code> 返回窗口内当前行之前的第 N 行数据</li><li><code>lead( )</code> 返回窗口内当前行之后的第 N 行数据</li></ul><p>（2）First_value &amp; Last_value</p><ul><li><code>First_value</code> 返回窗口内第一行数据，可以用 Min 聚合函数替代</li><li><code>Last_value</code> 返回窗口内最后一行数据，可以用 Max 聚合函数替代</li></ul></li></ol><h2 id="（五）函数">（五）函数</h2><ol><li><code>substr( 属性 a, begin, n )</code> 截取属性 a 从 begin 位置开始的 n 个字符，e.g. 查找姓氏 substr(name, 1, 1)；</li><li><code>datediff( 日期 1, 日期 2 )</code> 前减后，得到的结果是日期 1 与日期 2 相差的天数。如果日期 1 比日期 2 大，结果为正；如果日期 1 比日期 2 小，结果为负。</li><li><code>timestampdiff(时间类型, 日期1, 日期2)</code> 后减前在“时间类型”的参数位置，通过添加“day”, “hour”, “second”等关键词，来规定计算天数差、小时数差、还是分钟数差。日期 1 大于日期 2 ，结果为负，日期 1 小于日期 2 ，结果为正。</li><li><code>IFNULL( 判断对象 A, 替换值 N )</code> 如果判断对象 A 的值为 NULL，则返回替换值 N。</li><li><code>mod( 操作对象 A, 取模数 n ) = x</code> 判断操作对象 A 对 n 取模的结果是否为 x，等价于 A % n = x。</li><li></li></ol><h2 id="（六）视图">（六）视图</h2><ol><li>创建视图的目的是将查询结果保存为一张虚拟的表，当后续需要使用该查询结果时，就可以直接从视图中调用，做进一步的查询。</li><li>视图是动态变化的，随着原表的修改而修改。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 创建视图</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名;</span><br><span class="line"></span><br><span class="line"># 修改视图</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名称</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名;</span><br><span class="line"></span><br><span class="line"># 删除视图</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> 视图名称;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">MySQL 学习笔记</summary>
    
    
    
    <category term="技术" scheme="https://www.angfff.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="MySQL" scheme="https://www.angfff.top/categories/%E6%8A%80%E6%9C%AF/MySQL/"/>
    
    
    <category term="技术" scheme="https://www.angfff.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="MySQL" scheme="https://www.angfff.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Sklearn 导入随机逻辑回归函数 RLR 失败原因及解决</title>
    <link href="https://www.angfff.top/posts/5fd458f7.html"/>
    <id>https://www.angfff.top/posts/5fd458f7.html</id>
    <published>2023-12-09T08:05:10.000Z</published>
    <updated>2025-03-06T04:40:56.795Z</updated>
    
    <content type="html"><![CDATA[<h1>一、问题描述</h1><ol><li><p>描述：在进行分类任务时，导入随机逻辑回归模型 RandomizedLogisticRegression 时会提示无法找到该模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> RandomizedLogisticRegression <span class="keyword">as</span> RLR</span><br></pre></td></tr></table></figure></li><li><p>分析：自 sklearn 0.19.2 版本后，随机逻辑回归模型已经被移除</p></li><li><p>当前软件版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn</span><br><span class="line">sklearn.show_versions()</span><br></pre></td></tr></table></figure><blockquote><p>System:<br>python: 3.9.16</p><p>Python dependencies:</p><p>​sklearn: 1.3.2</p><p>​numpy: 1.26.2</p><p>​scipy: 1.10.1</p><p>​pandas: 2.1.3</p><p>​matplotlib: 3.7.1</p><p>​joblib: 1.3.2</p></blockquote></li></ol><h1>二、解决办法</h1><h2 id="（一）手动安装随机逻辑回归模型">（一）手动安装随机逻辑回归模型</h2><ol><li><p>模型仓库：<a href="https://github.com/scikit-learn-contrib/stability-selection">https://github.com/scikit-learn-contrib/stability-selection</a></p></li><li><p>安装参考：<a href="https://github.com/scikit-learn-contrib/stability-selection/issues/38">https://github.com/scikit-learn-contrib/stability-selection/issues/38</a></p><blockquote><p>注：</p><p>​安装随机逻辑回归模型后，能够解决模型导入时的报错问题，并能够正确拟合训练模型。</p><p>​但是在后续查看特征筛选结果和 Score 分数时，会无法调用 rlr.get_support() 和 rlr.scores_ 方法，可能是因为高版本在移除随机逻辑回归模型时，也对 sklearn_base 中的方法做了修改，无法再按旧版本方法调用。</p></blockquote></li></ol><h2 id="（二）采用低版本-Scikit-Learn">（二）采用低版本 Scikit-Learn</h2><ol><li><p>低版本 Scikit-Learn 所需的环境</p><blockquote><p>Python 3.8 及以下（建议 Python 3.6）</p><p>Numpy 1.23.5 及以下（建议 Numpy 1.20.0）</p><p>Scikit-Learn 0.19.2</p><p>注：</p><ol><li>所建议版本是较为久远的版本，可能会出现无法找到对应源、无法安装的情况，需根据自己的电脑情况调整；</li><li>M 系列 Mac 由于架构不同，不支持 3.8 版本以下的 Python，请使用 Python 3.8；</li><li>Scikit-Learn 最好使用 0.19.2 版本。</li></ol></blockquote></li><li><p>安装过程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">conda 创建虚拟环境 Python 3.8</span></span><br><span class="line">conda create -n py38 python=3.8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">激活 py38 环境</span></span><br><span class="line">conda activate py38</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装相关库</span></span><br><span class="line">pip install numpy==1.23.5</span><br><span class="line">pip install scipy</span><br><span class="line">pip install pandas</span><br><span class="line">pip install xlrd</span><br><span class="line">pip install scikit-learn==0.19.2</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><ol><li>以上过程均在终端 shell 中安装；</li><li>或者选用 Anaconda 图形化界面安装。</li></ol></blockquote></li><li><p>安装完毕后，在 Pycharm 右下角添加并使用新的 Python 解释器即可。</p></li></ol>]]></content>
    
    
    <summary type="html">Python Sklearn 导入随机逻辑回归函数 RLR 失败原因及解决</summary>
    
    
    
    <category term="环境配置" scheme="https://www.angfff.top/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    <category term="Sklearn" scheme="https://www.angfff.top/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Sklearn/"/>
    
    
    <category term="环境配置" scheme="https://www.angfff.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    <category term="Sklearn" scheme="https://www.angfff.top/tags/Sklearn/"/>
    
  </entry>
  
  <entry>
    <title>CIFAR100 多模型训练结果及分析</title>
    <link href="https://www.angfff.top/posts/2fb8888f.html"/>
    <id>https://www.angfff.top/posts/2fb8888f.html</id>
    <published>2023-12-09T02:50:31.000Z</published>
    <updated>2025-03-06T04:40:56.795Z</updated>
    
    <content type="html"><![CDATA[<h1>一、自建网络</h1><h2 id="两层-CNN-网络">两层 CNN 网络</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: Adam</li></ul></blockquote></li><li><p>思路</p><blockquote><p>CNN：Conv2d -&gt; BatchNorm2d -&gt; ReLu -&gt; MaxPool2d</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-2CNN.png" alt="Arch_2CNN"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-2CNN.png" alt="Loss_2CNN"></p><blockquote><ul><li>Time: 0:01:11.308311</li><li>Min Loss: 1.4500</li><li>Final Loss: 1.9618</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：39.75 %</li></ul></blockquote></li></ol><h2 id="三层-CNN-网络">三层 CNN 网络</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: Adam</li></ul></blockquote></li><li><p>思路</p><blockquote><p>CNN：Conv2d -&gt; BatchNorm2d -&gt; ReLu -&gt; MaxPool2d</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-3CNN.png" alt="Arch_3CNN"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-3CNN.png" alt="Loss_3CNN"></p><blockquote><ul><li>Time: 0:01:10.645922</li><li>Min Loss: 1.5404</li><li>Final Loss: 1.9817</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：44.14 %</li></ul></blockquote></li></ol><h2 id="五层-CNN-网络">五层 CNN 网络</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: Adam</li></ul></blockquote></li><li><p>思路</p><blockquote><p>CNN：Conv2d -&gt; BatchNorm2d -&gt; ReLu -&gt; MaxPool2d</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-5CNN.png" alt="Arch_5CNN"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-5CNN.png" alt="Loss_5CNN"></p><blockquote><ul><li>Time: 0:02:12.387121</li><li>Min Loss: 1.3080</li><li>Final Loss: 1.5872</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：44.20 %</li></ul></blockquote></li></ol><h1>二、经典 CNN 网络</h1><h2 id="VGG-19">VGG 19</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: SGD</li></ul></blockquote></li><li><p>思路</p><blockquote><p>VGG 19 -&gt; Transforms ( Resize + ToTensor + Normalize) -&gt; Model Arch ( fc out 100 ) -&gt; Fine Tune</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-VGG.png" alt="Arch_VGG"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-VGG.png" alt="Loss_VGG"></p><blockquote><ul><li>Time: 0:24:17.983430</li><li>Min Loss: 0.3057</li><li>Final Loss: 0.7126</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：71.61 %</li></ul></blockquote></li></ol><h2 id="ResNet-101">ResNet 101</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: SGD</li></ul></blockquote></li><li><p>思路</p><blockquote><p>ResNet 101 -&gt; Transforms ( Resize + ToTensor + Normalize) -&gt; Model Arch ( fc out 100 ) -&gt; Fine Tune</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-ResNet.png" alt="Arch_ResNet"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-ResNet.png" alt="Loss_ResNet"></p><blockquote><ul><li>Time: 0:26:58.626524</li><li>Min Loss: 0.0667</li><li>Final Loss: 0.0942</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：83.92 %</li></ul></blockquote></li></ol><h1>三、 Vision Transformer 网络</h1><h2 id="ViT-b-32">ViT_b_32</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: SGD</li></ul></blockquote></li><li><p>思路</p><blockquote><p>ViT_b_32 -&gt; Transforms ( Resize + ToTensor + Normalize) -&gt; Model Arch ( fc out 100 ) -&gt; Fine Tune</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-ViT.png" alt="Arch_ViT"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-ViT.png" alt="Loss_ViT"></p><blockquote><ul><li>Time: 0:11:34.681656</li><li>Min Loss: 0.1308</li><li>Final Loss: 0.1308</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：84.34 %</li></ul></blockquote></li></ol><h2 id="Swin-b">Swin_b</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: SGD</li></ul></blockquote></li><li><p>思路</p><blockquote><p>Swim_b -&gt; Transforms ( Resize + ToTensor + Normalize) -&gt; Model Arch ( fc out 100 ) -&gt; Fine Tune</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-Swin.png" alt="Arch_Swin"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-Swin.png" alt="Loss_Swin"></p><blockquote><ul><li>Time: 0:40:31.978593</li><li>Min Loss: 0.2692</li><li>Final Loss: 0.5661</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：83.53 %</li></ul></blockquote></li></ol><h1>四、对比分析</h1><table><thead><tr><th>Model</th><th>Total Params</th><th>Total Size</th><th>Min loss</th><th>Final Loss</th><th>Accuracy</th></tr></thead><tbody><tr><td>CNN_2</td><td>219,044</td><td>40.63</td><td>1.4500</td><td>1.9618</td><td>39.75 %</td></tr><tr><td>CNN_3</td><td>168,036</td><td>46.94</td><td>1.5404</td><td>1.9817</td><td>44.14 %</td></tr><tr><td>CNN_5</td><td>1,116,388</td><td>55.43</td><td>1.3080</td><td>1.5872</td><td>44.20 %</td></tr><tr><td>VGG19</td><td>139,979,940</td><td>773.24</td><td>0.3057</td><td>0.7126</td><td>71.61 %</td></tr><tr><td>ResNet101</td><td>42,705,060</td><td>593.20</td><td>0.0667</td><td>0.0942</td><td>83.92 %</td></tr><tr><td>ViT_b_32</td><td>87,532,132</td><td>263.59</td><td>0.1308</td><td>0.1308</td><td>84.34 %</td></tr><tr><td>Swin_b</td><td>86,845,724</td><td>425.33</td><td>0.2692</td><td>0.5661</td><td>83.53 %</td></tr></tbody></table><ol><li>对比自建 CNN 网络<ul><li>从 2 层 CNN 到 3 层 CNN 模型的总参数量有所下降，主要原因是 FC 层 Linear 函数的输入参数减少，导致了总参数量的下降。</li><li>从 2 层 CNN 到 3 层 CNN 模型准确率提升了约 4.39%；从 3 层 CNN 到 5 层 CNN 模型准确率几乎没有提升。虽然从 3 层到 5 层模型的总参数量扩大了约 6.64 倍，但是模型的性能没有显著提升，推测是因为此时模型深度的增加已经无法帮助模型学到更多有用的特征，且深度的增加也可能会导致模型出现过拟合现象，致使准确率无法得到进一步提升。</li></ul></li><li>对比经典 CNN 网络<ul><li>VGG19 模型拥有近 1.4 亿的参数量，其规模也是本次测试中最大的模型。 VGG19 的测试结果（71.61%），也证明了使用更小的卷积核（3 * 3）并且增加卷积神经网络的深度，可以有效地提升模型的性能。</li><li>ResNet101 通过引入残差块在网络内部跳跃连接，缓解了深度增加所导致的梯度消失的问题。从模型结果来看（83.92%），在增加模型深度，缓解梯度消失问题的同时也减少了参数量，相比于 VGG19 模型取得了更好的效果。</li></ul></li><li>对比 Transformer 网络<ul><li>本次所选用的 Transformer 网络都是该系列下的基础模型。ViT_b_32 模型 和 Swin_b 模型参数量相当，最后测试结果也较为接近，都具有较好的性能。</li><li>值得一提的是，在实际训练和测试时，Swin_b 模型对显存的占用非常高，训练时大约需要 15G 左右的显存空间，而测试时大概需要 30G 左右的显存空间，对硬件设备的要求很高。</li></ul></li></ol><h1>五、总结与优化</h1><h2 id="总结">总结</h2><ul><li>从自建 CNN 网络到 VGG 模型，可以看出增加网络的宽度和深度可以很好的提高模型的性能；但如果一直简单地增加深度，可能会遇到梯度爆炸或梯度消失的问题，对于前者可以尝试使用正则化的方式解决，但对于梯度消失的问题，就需要引入残差网络，在不增加额外参数的情况下，尽可能让深层次的模型得到充分训练，进而继续提升模型的性能，上述过程也在本次实验中得到了充分的验证。</li><li>转向 Transformer 架构，在 ViT 模型的思路下，用自注意力机制来捕捉全局图像信息，从而得到全连接的网络结构，能够很好的捕捉数据的特征；Swin 模型进一步采用分层的窗口化注意力机制和分层的网络结构，在降低计算复杂度的同时，也通过层级嵌套捕捉了多尺度的特征，使得模型在处理不同尺度的信息时更加灵活。</li><li>但是在本次实验中，ResNet 和 ViT 以及 Swin 的模型性能（测试集准确率）相近，没能很好的展现出 Transformer 架构在 CV 领域的巨大潜力。推测其中的原因，一是 ResNet 残差网络的性能确实很好，能够非常显著的降低梯度消失风险、提升 CNN 网络的性能；二是本次实验所选用的 CIFAR100 数据集相对原本的 ImageNet 而言更简单，用 ResNet 模型就足以捕捉其中的关键特征，能够较好的完成分类任务，ViT 和 Swin 的潜力没能得到充分发挥；三是模型的选用及训练策略的不足，本次实验选用的 ResNet 模型为 101 层，而 ViT 和 Swin 都只选用了 Base 模型，同时训练的 Epoch 较少，损失函数和优化器的选用没有做进一步的比对分析，学习率也没有做进一步的尝试。</li></ul><h2 id="优化">优化</h2><ul><li>宏观层面，下一步将继续尝试不同的模型，结合模型结构和实验结果分析每种模型的特点、改进点。</li><li>微观层面，下一步将尝试调整训练策略，增加 Epoch 的同时引入验证集，根据验证集准确率等指标提前停止训练防止模型过拟合现象的产生，同时将尝试不同的损失函数和优化器，以及综合使用 Warm up、余弦退火等技巧逐步改善学习率，进一步提升模型的性能。</li></ul>]]></content>
    
    
    <summary type="html">CIFAR100 经典 CNN 与 ViT 模型对比</summary>
    
    
    
    <category term="AI" scheme="https://www.angfff.top/categories/AI/"/>
    
    <category term="CV" scheme="https://www.angfff.top/categories/AI/CV/"/>
    
    
    <category term="DL" scheme="https://www.angfff.top/tags/DL/"/>
    
    <category term="CV" scheme="https://www.angfff.top/tags/CV/"/>
    
    <category term="CNN" scheme="https://www.angfff.top/tags/CNN/"/>
    
    <category term="ViT" scheme="https://www.angfff.top/tags/ViT/"/>
    
    <category term="Transformer" scheme="https://www.angfff.top/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>每日LeetCode_230903</title>
    <link href="https://www.angfff.top/posts/4d3cdec0.html"/>
    <id>https://www.angfff.top/posts/4d3cdec0.html</id>
    <published>2023-09-03T14:26:37.000Z</published>
    <updated>2025-03-06T04:40:56.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-寻找两个正序数组的中位数">4.寻找两个正序数组的中位数</h2><h3 id="（1）题目">（1）题目</h3><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li></ul><h3 id="（2）题解">（2）题解</h3><blockquote><p>给定两个有序数组，要求找到两个有序数组的中位数，最直观的思路有以下两种：</p><ol><li>使用归并的方式，合并两个有序数组，得到一个大的有序数组。大的有序数组的中间位置的元素，即为中位数。第一种思路的时间复杂度是 O(m+n) ，空间复杂度是 O(m+n) ；</li><li>不需要合并两个有序数组，只要找到中位数的位置即可。由于两个数组的长度已知，因此中位数对应的两个数组的下标之和也是已知的。维护两个指针，初始时分别指向两个数组的下标 0 的位置，每次将指向较小值的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到到达中位数的位置。空间复杂度降到 O(1) ，时间复杂度仍是 O(m+n) ；</li></ol></blockquote><ul><li><p>不合并数组，依次取数，直至中位数位置</p><p>中位数的位置一定在 (m+n)/2 附近：</p><ul><li>如果是偶数，中位数就是最后取的两个数的平均数；</li><li>如果是奇数，中位数就是最后取的那个数。</li></ul><p>取数阶段，循环 (m + n) / 2.0 + 1 次即可；判断中位数时，关键是奇数情况，可能有指针溢出，需要判断一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 nums1 和 nums2 中每次取一个数，直到取出的数的个数 &lt;= (m+n)/2 + 1</span></span><br><span class="line"><span class="type">int</span> m = nums<span class="number">1.</span><span class="built_in">size</span>(), n = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>; <span class="comment">// x, y 分别是 nums1 和 nums2 的下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (m + n) / <span class="number">2.0</span> + <span class="number">1</span>; ++i)&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; m &amp;&amp; y &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1[x] &lt; nums2[y]) ++x;</span><br><span class="line">    <span class="keyword">else</span> ++y;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (x &lt; m) ++x;</span><br><span class="line">  <span class="keyword">else</span> ++y;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> (nums1[x - <span class="number">1</span>] + nums2[y - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt;= m)&#123;</span><br><span class="line">    <span class="keyword">return</span> nums1[x - <span class="number">1</span>];</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (y &gt;= n)&#123;</span><br><span class="line">    <span class="keyword">return</span> nums2[y - <span class="number">1</span>];</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(nums1[x - <span class="number">1</span>], nums2[y - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法测试用例可行，但 LeetCode 无法通过，可能是指针溢出形成空指针不被允许。</p></li><li><p>改进</p><p>我们首先计算出两个数组的长度，然后将它们的长度相加，得到总长度。接下来，我们使用一个循环来遍历这两个数组，直到到达中位数的位置。在循环中，我们维护两个指针 <code>aStart</code> 和 <code>bStart</code>，它们分别指向两个数组的下标 0 的位置。我们还维护两个变量 <code>left</code> 和 <code>right</code>，它们分别表示当前的中位数和前一个元素。在每次循环中，我们将 <code>left</code> 的值更新为 <code>right</code>，然后将指向较小值的指针后移一位。最后，如果总长度是偶数，则中位数是 <code>left</code> 和 <code>right</code> 的平均值，否则中位数是 <code>right</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m = nums<span class="number">1.</span><span class="built_in">size</span>(), n = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> len = m + n;</span><br><span class="line"><span class="type">int</span> left = <span class="number">-1</span>, right = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> aStart = <span class="number">0</span>, bStart = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len / <span class="number">2</span>; i++)&#123;</span><br><span class="line">left = right;</span><br><span class="line">  <span class="keyword">if</span> (aStart &lt; m &amp;&amp; (bStart &gt;= n || nums1[aStart] &lt; nums2[bStart]))&#123;</span><br><span class="line">    right = nums1[aStart++];</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    right = nums2[bStart++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> (left + right) / <span class="number">2.0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二分查找</p><p>如果对时间复杂度的要求有 log⁡ ，通常都需要用到二分查找：</p><p>根据中位数的定义，当 m+n 是奇数时，中位数是两个有序数组中的第 (m+n)/2 个元素，当 m+n 是偶数时，中位数是两个有序数组中的第 (m+n)/2 个元素和第 (m+n)/2+1 个元素的平均值。因此，这道题可以转化成寻找两个有序数组中的第 k 小的数，其中 k 为 (m+n)/2 或 (m+n)/2+1 。</p><p>假设两个有序数组分别是 A 和 B。要找到第 k 个元素，我们可以比较 A[k/2−1] 和 B[k/2−1] ，其中 / 表示整数除法。由于 A 和 B 的前面分别有  k/2−1 个元素，对于 A[k/2−1] 和 B[k/2−1] 中的较小值，最多只会有 (k/2−1)+(k/2−1)≤k−2 个元素比它小，那么它就不能是第 k 小的数了。</p><p>因此我们可以归纳出三种情况：</p><ol><li>如果 A[k/2−1]&lt;B[k/2−1] ，则比 A[k/2−1] 小的数最多只有 A 的前 k/2−1 个数和 B 的前 k/2−1 个数，即比 A[k/2−1] 小的数最多只有 k−2 个，因此 A[k/2−1] 不可能是第 k 个数，A[0] 到 A[k/2−1] 也都不可能是第 k 个数，可以全部排除。</li><li>如果 A[k/2−1]&gt;B[k/2−1] ，则可以排除 B[0] 到 B[k/2−1] 。</li><li>如果 A[k/2−1]=B[k/2−1] ，则可以归入第一种情况处理。</li></ol><p><img src="https://assets.leetcode-cn.com/solution-static/4/4_fig1.png" alt=""></p><p>可以看到，比较 A[k/2−1] 和 B[k/2−1] 之后，可以排除 k/2 个不可能是第 k 小的数，查找范围缩小了一半。同时，我们将在排除后的新数组上继续进行二分查找，并且根据我们排除数的个数，减少 k 的值，这是因为我们排除的数都不大于第 k 小的数。</p><p>有以下三种情况需要特殊处理：</p><ol><li>如果 A[k/2−1] 或者 B[k/2−1] 越界，那么我们可以选取对应数组中的最后一个元素。在这种情况下，我们必须根据排除数的个数减少 k 的值，而不能直接将 k 减去 k/2。</li><li>如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第 k 小的元素。</li><li>如果 k=1 ，我们只要返回两个数组首元素的最小值即可。</li></ol><p>用一个例子说明上述算法。假设两个有序数组如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: 1 3 4 9</span><br><span class="line">B: 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>两个有序数组的长度分别是 4 和 9，长度之和是 13，中位数是两个有序数组中的第 7 个元素，因此需要找到第 k=7 个元素。</p><p>比较两个有序数组中下标为 k/2−1=2 的数，即 A[2]=4 和 B[2]=3 ，如下面所示：<br>由于 A[2]&gt;B[2] ，因此排除 B[0] 到 B[2] ，即数组 B 的下标偏移（offset）变为 3，同时更新 k 的值：k=k−k/2=4。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: 1 3 4 9</span><br><span class="line">B: [1 2 3] 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>下一步寻找，比较两个有序数组中下标为 k/2−1=1 的数，即 A[1]=3 和 B[4]=5 ，如下面所示，其中方括号部分表示已经被排除的数。<br>由于 A[1]&lt;B[4]，因此排除 A[0] 到 A[1]，即数组 A 的下标偏移变为 2，同时更新 k 的值：k=k−k/2=2。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: [1 3] 4 9</span><br><span class="line">B: [1 2 3] 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>下一步寻找，比较两个有序数组中下标为 k/2−1=0 的数，即比较 A[2]=4 和 B[3]=4 ，如下面所示，其中方括号部分表示已经被排除的数。<br>由于 A[2]=B[3]，根据之前的规则，排除 A 中的元素，因此排除 A[2] ，即数组 A 的下标偏移变为 3 ，同时更新 k 的值： k=k−k/2=1 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: [1 3 4] 9</span><br><span class="line">B: [1 2 3] 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>由于 k 的值变成 1，因此比较两个有序数组中的未排除下标范围内的第一个数，其中较小的数即为第 k 个数，由于 A[3]=9&gt;B[3]=4 ，因此第 k 个数是 B[3]=4。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthElement</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class="line"><span class="comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> m = nums<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (index1 == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="type">int</span> newIndex1 = <span class="built_in">min</span>(index1 + k / <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> newIndex2 = <span class="built_in">min</span>(index2 + k / <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> pivot1 = nums1[newIndex1];</span><br><span class="line">            <span class="type">int</span> pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= newIndex1 - index1 + <span class="number">1</span>;</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= newIndex2 - index2 + <span class="number">1</span>;</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> totalLength = nums<span class="number">1.</span><span class="built_in">size</span>() + nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKthElement</span>(nums1, nums2, (totalLength + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span>) + <span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="（3）知识点">（3）知识点</h3><ul><li><a href="https://suanfa8.com/binary-search">二分查找总结</a></li><li><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/39941/jiang-qi-zhuan-wei-zhao-liang-ge-you-xu-shu-zu-de-/">本题思路 1</a></li><li><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/6098/4-xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu/">本题思路 2</a></li></ul>]]></content>
    
    
    <summary type="html">每日LeetCode 寻找两个正序数组的中位数</summary>
    
    
    
    <category term="算法" scheme="https://www.angfff.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://www.angfff.top/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://www.angfff.top/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://www.angfff.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>每日LeetCode_230902</title>
    <link href="https://www.angfff.top/posts/3a3bee56.html"/>
    <id>https://www.angfff.top/posts/3a3bee56.html</id>
    <published>2023-09-02T14:20:44.000Z</published>
    <updated>2025-03-06T04:40:56.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-无重复字符的最长子串">3. 无重复字符的最长子串</h2><h3 id="（1）题目">（1）题目</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 </span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h3 id="（2）题解">（2）题解</h3><ul><li><p>暴力循环</p><p>两层循环，外层循环从左侧开始，依次移动；内层循环从外层循环的下一个位置开始移动，每移动一次检测是否有重复，若有重复，则找到当前起始位置的最长子串，停止内层循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表，用于检测是否有重复字符</span></span><br><span class="line">unordered_set&lt;<span class="type">char</span>&gt; HashTable;</span><br><span class="line"><span class="comment">// 最长子串长度</span></span><br><span class="line"><span class="type">int</span> maxlength = <span class="number">0</span>;       </span><br><span class="line"><span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 外层循环从左向右遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">  HashTable.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">  <span class="comment">// 内层循环从 i + 1 开始向右遍历</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">    <span class="comment">// 如果 j 到达边界，或者出现重复字符</span></span><br><span class="line">    <span class="keyword">if</span>(j == n || HashTable.<span class="built_in">find</span>(s[j]) != HashTable.<span class="built_in">end</span>())&#123;</span><br><span class="line">      <span class="comment">// 更新最长子串长度</span></span><br><span class="line">      maxlength = <span class="built_in">max</span>(maxlength, j - i);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，将 s[j] 加入哈希表</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      HashTable.<span class="built_in">insert</span>(s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清空哈希表</span></span><br><span class="line">  HashTable.<span class="built_in">clear</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxlength;</span><br></pre></td></tr></table></figure><p>该方法在每次外层循环时都要重建哈希表，对于内存的占用过高；同时，因为有两层循环，且每次都是逐个字母检测，耗时过长，并不推荐使用。</p></li><li><p>滑动窗口</p><p>假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 rk 。 那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 rk 的字符显然是不重复的，并且由于少了原本的第 k 个字符，可以尝试继续增大 rk ，直到右侧出现了重复字符为止。</p><ul><li><p>使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表「枚举子串的起始位置」，右指针代表窗口的结束位置 rk ；</p></li><li><p>在每一步的操作中，将左指针向右移动一格，表示开始枚举下一个字符作为起始位置，然后不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着<em><strong>以左指针开始的，不包含重复字符的最长子串</strong></em>；</p></li><li><p>判断重复字符：哈希表（即 C++ 中的 std::unordered_set，Java 中的 HashSet，Python 中的 set, JavaScript 中的 Set）。在左指针向右移动的时候，从哈希集合中移除一个字符，在右指针向右移动的时候，往哈希集合中添加一个字符。</p><p><strong>注意：这里所使用的哈希表只是为了确认每次加入的新字母是否与已有序列重复，因此加入后，统计表中的新字母的个数即可。</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">      unordered_set&lt;<span class="type">char</span>&gt; occ;</span><br><span class="line">      <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">      <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">      <span class="type">int</span> rk = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 枚举左指针的位置，初始值隐性地表示为 -1</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">          occ.<span class="built_in">erase</span>(s[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.<span class="built_in">count</span>(s[rk + <span class="number">1</span>]))&#123;</span><br><span class="line">          <span class="comment">// 不断地移动右指针</span></span><br><span class="line">          occ.<span class="built_in">insert</span>(s[rk + <span class="number">1</span>]);</span><br><span class="line">          ++rk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>进一步改进，出现重复字符就缩小窗口</p><p>外层循环改进为 右指针到达字符串末尾就停止循环，这样可以减少一定的循环次数；</p><p>循环内，仅用了 c 和 d 两个临时变量用于存储窗口的边界字符，并利用此检测是否有重复字符以及增减出现次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 记录最长集合</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>; <span class="comment">// 窗口左指针</span></span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>; <span class="comment">// 窗口右指针</span></span><br><span class="line">        <span class="comment">// 哈希表，记录每个字符是否出现过</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line">        <span class="comment">// 外层循环，扩张窗口</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[right]; <span class="comment">// 记录右指针字符</span></span><br><span class="line">            right++;</span><br><span class="line">            window[c]++; <span class="comment">// 将 c 在哈希表中出现的次数+1</span></span><br><span class="line">            <span class="comment">// 如果出现重复字符，就缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span> (window[c] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">char</span> d = s[left]; <span class="comment">// 记录左指针字符</span></span><br><span class="line">                left++;</span><br><span class="line">                window[d]--; <span class="comment">// 减少 d 的出现次数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最长集合</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>window[c]++</code> 这一句代码的意思是将字符 <code>c</code> 在 <code>window</code> 映射中的出现次数加 1。如果 <code>c</code> 在 <code>window</code> 映射中不存在，则会自动插入一个键值对 <code>(c, 0)</code>，然后将出现次数加 1。这个操作可以用来维护当前窗口中每个字符的出现次数。</p></blockquote></li></ul><h3 id="（3）知识点">（3）知识点</h3><ol><li>滑动窗口算法：该算法是一种常用的解决字符串子串问题的方法。它通过维护一个窗口，来遍历字符串中的所有子串。在每次移动窗口时，可以通过一些技巧来避免重复计算，从而达到线性时间复杂度的目的。</li><li>哈希表：哈希表是一种常用的数据结构，可以用来快速地查找和插入元素。在本题中，我们可以使用哈希表来维护当前窗口中每个字符的出现次数。</li><li>双指针：双指针是一种常用的技巧，可以使用两个指针 <code>i</code> 和 <code>j</code> 来维护当前窗口的左右边界。</li></ol>]]></content>
    
    
    <summary type="html">每日LeetCode 无重复字符的最长子串</summary>
    
    
    
    <category term="算法" scheme="https://www.angfff.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://www.angfff.top/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://www.angfff.top/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://www.angfff.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门</title>
    <link href="https://www.angfff.top/posts/89826705.html"/>
    <id>https://www.angfff.top/posts/89826705.html</id>
    <published>2023-08-31T15:14:57.000Z</published>
    <updated>2025-03-06T04:40:56.794Z</updated>
    
    <content type="html"><![CDATA[<h1>Docker 入门</h1><h2 id="一、-Docker-介绍">一、 Docker 介绍</h2><p>Docker 是一个用于 构建(build)、运行(run)、传送(share) 应用程序的平台。</p><p>通过 Docker 我们可以将应用程序及其运行时所依赖的环境、第三方软件库、配置文件等打包在一起，行成一个个“集装箱”，运送至其他平台，以便于在任何环境中正确地运行。</p><h2 id="二、-Docker-应用场景">二、 Docker 应用场景</h2><blockquote><p>应用隔离、环境配置、 安装部署、持续集成、持续发布、DevOps</p></blockquote><p>例如，我们利用目前较为主流的前后端分离架构写了一个网站，前端使用 Vue 来构建网站的界面，后端使用 Java 的 SpringBoot 微服务架构来提供各种服务和接口，使用 MySQL 数据库来存储数据。</p><p>如果不使用 Docker，我们需要先安装 NodeJs 环境、安装各种 npm 依赖包，配置 Java 运行环境，安装 SpringBoot 微服务的各种第三方依赖包，安装 MySQL 数据库，以及配置各种环境变量、启动服务等。与此同时，如果要把该网站部署在测试环境和生产环境上，还需要将上述步骤再重复一遍。</p><p>相反，如果我们使用 Docker，只要我们在开发环境中配置好了所有环境并将其打包成一个“集装箱”，那么就可以直接在其他环境中直接运行。</p><h2 id="三、容器和虚拟机的区别">三、容器和虚拟机的区别</h2><h3 id="（一）传统虚拟机">（一）传统虚拟机</h3><p>传统虚拟机软件包括：VMware 、 Virtalbox、 Parallels Desktop 、 WSL 、 Hyper-V 等</p><p>虚拟机是完整的操作系统，可以在该操作系统中运行各种支持的应用程序。虚拟机实际上是利用 虚拟化技术(Hypervisor) 将物理资源虚拟化为多个逻辑资源，它可以将一个物理服务器虚拟为多个逻辑服务器，每个逻辑服务器都有自己的操作系统、 CPU 、内存、硬盘和网络接口等。逻辑服务器之间是完全隔离的，可以独立运行。</p><p>虚拟机在一定程度上实现了资源的整合，可以将一台服务器的计算能力、存储能力、网络资源分配给多台虚拟服务器，实现多台服务器的功能。但虚拟机也存在一定的缺点，每台虚拟服务器都将占用非常多的资源，且启动速度慢。</p><p>实际上我们并不需要让每台服务器都运行多个虚拟机。通常情况下，每台物理服务器都有其特定的用途，如 Web 服务器只需提供收发数据包的功能即可，并不需要一个完整的操作系统，因此没有必要在该服务器上使用虚拟机来收发数据包。</p><h3 id="（二）容器">（二）容器</h3><p>容器是一个虚拟化技术，一定程度上类似虚拟机，是一个独立的环境。Docker 是容器的一种实现方式，是一个容器话的解决方案和平台。</p><p>与虚拟机不同的是，容器中并不需要运行一个完整的操作系统便可以运行应用程序，因此其占用的资源更少、启动速度更快。</p><h2 id="四、基本原理">四、基本原理</h2><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Docker%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.jpeg" alt="Docker基本概念"></p><h3 id="（一）镜像-images">（一）镜像 images</h3><p>镜像是一个只读模版，可以用来创建容器。（类）</p><h3 id="（二）容器-containers">（二）容器 containers</h3><p>容器是 Docker 的运行实例，提供了一个独立的可移植的环境，可以在该环境中运行应用程序。（对象）</p><h3 id="（三）仓库-registry">（三）仓库 registry</h3><p>用于存储 Docker 镜像。</p><h2 id="五、安装配置">五、安装配置</h2><h3 id="（一）安装">（一）安装</h3><ul><li><p>macOS 安装</p><p>下载安装即可。安装后运行 Docker，便可以在终端中使用 Docker 命令。</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Docker%E5%AE%89%E8%A3%85.png" alt="Docker安装"></p></li><li><p>Windows 安装</p><p>下载安装完毕后，需要在系统设置-Windows 功能中开启 Hyper-V 功能，才能正常启用 Docker 。</p></li></ul><h3 id="（二）容器化">（二）容器化</h3><ol><li>将应用程序打包成容器，然后在容器中运行应用程序的过程。</li><li>容器化步骤：<ol><li>创建一个 Dockerfile ；</li><li>使用 Dockerfile 构建镜像；</li><li>使用镜像创建和运行容器。</li></ol></li><li>Dockerfile：文本文件，包含了多条指令，用于指导 Docker 构建镜像。通常包括精简版的操作系统、应用程序的运行环境、应用程序本体、第三方依赖包或库、应用程序的配置文件、环境变量等。</li></ol><h2 id="六、常用命令">六、常用命令</h2><p><a href="https://www.runoob.com/docker/docker-command-manual.html">Docker 常用命令</a></p><h2 id="七、构建镜像并启动容器">七、构建镜像并启动容器</h2><h3 id="（一）创建-Dockerfile-文件">（一）创建 Dockerfile 文件</h3><ol><li><p>创建 HelloDocker 文件夹；</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/1-1%20%E5%88%9B%E5%BB%BA%20HelloDocker%20%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt=""></p></li><li><p>在项目文件夹中创建 index.js 文件并键入简单 JS 命令，使之在控制台输出语句；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在控制台输出语句</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/1-2%20%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F.png" alt=""></p><p>现在，在开发环境中已经可以输出语句了；</p><p>但是，如果我们需要在其他环境也运行该程序，就需要安装兼容的操作系统、JS 运行环境 NodeJS，并将该程序及其依赖包和配置文件一并复制到新的环境中，才能正常运行；</p><p>此时，就可以利用 Docker，将这些步骤打包起来，写入 Dockerfile 文件中。</p></li><li><p>在项目文件夹中创建 Dockerfile 文件并写入相关命令；</p><ol><li><p>设置镜像</p><p>镜像是按层次结构来构建的，每一层都是基于上一层的，因此需要先指定一个基础镜像；然后在该镜像的基础上添加应用程序。</p><p>这里使用到了 NodeJS ，因此需要添加其对应的基础镜像，本来应该从 Linux 的基础镜像（操作系统）开始，例如 alpine ，但 NodeJS 的镜像实际上已经是基于 Alpine 镜像构建的了，所以我们可以直接使用 NodeJS 的镜像作为我们的基础镜像。</p></li><li><p>将应用程序复制到 Docker 中</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> 源文件路径 目标路径</span></span><br></pre></td></tr></table></figure></li><li><p>在镜像中运行应用程序</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;可执行程序名&quot;</span>, <span class="string">&quot;可执行程序接受的参数&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/1-3%20%E7%BC%96%E5%86%99%20Dockerfile%20%E6%96%87%E4%BB%B6.png" alt=""></p></li></ol></li></ol><h3 id="（二）创建镜像">（二）创建镜像</h3><ol><li><p>在终端中创建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t 镜像名称[:版本号] 目录</span><br><span class="line">// 版本号可省略，不指定版本默认使用最新版本</span><br><span class="line">// . 表示当前目录</span><br></pre></td></tr></table></figure><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/2-1%20%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F.png" alt=""></p></li><li><p>查看镜像是否创建成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">// docker image ls</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/2-2%20%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F.png" alt=""></p><h3 id="（三）运行镜像">（三）运行镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run 镜像名称</span><br></pre></td></tr></table></figure><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/2-3%20%E8%BF%90%E8%A1%8C%E9%95%9C%E5%83%8F.png" alt=""></p><h3 id="（四）在其他环境中运行镜像">（四）在其他环境中运行镜像</h3><ul><li><p>将镜像复制到当前环境中，运行即可；</p></li><li><p>将镜像上传至 Dockerhub 中，在任意环境中 pull 拉取再运行即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 用户名/镜像名称</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">容器是将操作系统层虚拟化，虚拟机则是虚拟化硬件。借助 Docker 可以更便捷地实现应用的开发、交付和运行。</summary>
    
    
    
    <category term="必备工具" scheme="https://www.angfff.top/categories/%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Docker" scheme="https://www.angfff.top/categories/%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/Docker/"/>
    
    
    <category term="必备工具" scheme="https://www.angfff.top/tags/%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Docker" scheme="https://www.angfff.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>每日LeetCode_230831</title>
    <link href="https://www.angfff.top/posts/89dd8618.html"/>
    <id>https://www.angfff.top/posts/89dd8618.html</id>
    <published>2023-08-31T05:16:06.000Z</published>
    <updated>2025-03-06T04:40:56.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-两数相加">2. 两数相加</h2><h3 id="（1）题目">（1）题目</h3><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="题目示例"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h3 id="（2）题解">（2）题解</h3><ul><li><p>循环对位相加</p><p>对应位依次相加，利用额外变量追踪进位情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">//记录当前位的和</span></span><br><span class="line"><span class="type">int</span> carry = <span class="number">0</span>; <span class="comment">//记录下一位的进位情况</span></span><br><span class="line"></span><br><span class="line">ListNode* result =<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">ListNode* cur = result; <span class="comment">//result 固定在头结点，current 移动</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">//该循环用于计算 l1 和 l2 有相同的位数的部分</span></span><br><span class="line"><span class="keyword">while</span> (l1 != <span class="literal">NULL</span> <span class="keyword">and</span> l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">sum = l1-&gt;val + l2-&gt;val + carry;</span><br><span class="line">cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>); <span class="comment">//取余</span></span><br><span class="line">carry = sum / <span class="number">10</span>; <span class="comment">//取整，有进位是 1，否则是 0</span></span><br><span class="line"><span class="comment">//向后移动</span></span><br><span class="line">l1 = l1-&gt;next;</span><br><span class="line">l2 = l2-&gt;next;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环结束后，判断是否还有余下的位数</span></span><br><span class="line"><span class="keyword">while</span> (l1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">sum = l1-&gt;val + carry;</span><br><span class="line">cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">carry = sum / <span class="number">10</span>;</span><br><span class="line">l1 = l1-&gt;next;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">sum = l2-&gt;val + carry;</span><br><span class="line">cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">carry = sum / <span class="number">10</span>;</span><br><span class="line">l2 = l2-&gt;next;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述循环都结束后，所有位数均已遍历，最后检查是否还有进位</span></span><br><span class="line"><span class="keyword">if</span> (carry != <span class="number">0</span>)&#123;</span><br><span class="line">cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="keyword">return</span> result-&gt;next;</span><br></pre></td></tr></table></figure></li><li><p>改进</p><p>简化了循环的过程，一次循环即可遍历两个链表的所有位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ListNode* head=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);<span class="comment">//存放结果的链表</span></span><br><span class="line">ListNode* h=head;<span class="comment">//移动指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;<span class="comment">//每个位的加和结果</span></span><br><span class="line"><span class="type">bool</span> carry=<span class="literal">false</span>;<span class="comment">//进位标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该循环用于将 l1 和 l2 的每一位都遍历</span></span><br><span class="line"><span class="keyword">while</span>(l1!=<span class="literal">NULL</span>||l2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">  sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(l1!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    sum+=l1-&gt;val;</span><br><span class="line">    l1=l1-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(l2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    sum+=l2-&gt;val;</span><br><span class="line">    l2=l2-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(carry)</span><br><span class="line">    sum++;</span><br><span class="line">  h-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">  h=h-&gt;next;</span><br><span class="line">  carry=sum&gt;=<span class="number">10</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后判断是否有进位</span></span><br><span class="line"><span class="keyword">if</span>(carry)&#123;</span><br><span class="line">  h-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head-&gt;next;</span><br></pre></td></tr></table></figure></li><li><p>递归法</p><p>将两个链表从头开始相加，每次将两个链表的当前节点以及上一次相加的进位相加，得到一个新的节点，并将这个节点的 next 指针指向下一次递归的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">addTwoNumbersHelper</span>(l1, l2, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 递归函数 参数包括两个链表以及上一次相加的进位，返回值是相加后的链表</span></span><br><span class="line">  <span class="function">ListNode* <span class="title">addTwoNumbersHelper</span><span class="params">(ListNode* l1, ListNode* l2, <span class="type">int</span> carry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先判断递归结束的条件，即两个链表都为空且进位为 0</span></span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span> &amp;&amp; l2 == <span class="literal">nullptr</span> &amp;&amp; carry == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算当前节点的值</span></span><br><span class="line">    <span class="type">int</span> sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + carry;</span><br><span class="line">    <span class="comment">// 创建一个新的节点 并取余赋值</span></span><br><span class="line">    ListNode* node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 递归，将这个节点的 next 指针指向下一次递归的结果</span></span><br><span class="line">    node-&gt;next = <span class="built_in">addTwoNumbersHelper</span>(l1 ? l1-&gt;next : <span class="literal">nullptr</span>, l2 ? l2-&gt;next : <span class="literal">nullptr</span>, sum / <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 返回该节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="（3）知识点">（3）知识点</h3><ul><li><p>错误 1：示例 3 最高位没有进位 1</p><p>错误原因：最后检查 carry 是否为 0 时，应该是 <code>cur-&gt;next = new ListNode(carry);</code> 而不是 <code>cur-&gt;next = new ListNode(sum%10);</code></p></li></ul>]]></content>
    
    
    <summary type="html">每日LeetCode 两数相加</summary>
    
    
    
    <category term="算法" scheme="https://www.angfff.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://www.angfff.top/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://www.angfff.top/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://www.angfff.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>每日LeetCode_230830</title>
    <link href="https://www.angfff.top/posts/fedab68e.html"/>
    <id>https://www.angfff.top/posts/fedab68e.html</id>
    <published>2023-08-30T15:48:32.000Z</published>
    <updated>2025-03-06T04:40:56.794Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-两数之和">1. 两数之和</h2><h3 id="（1）题目">（1）题目</h3><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p><strong>进阶：</strong> 你可以想出一个时间复杂度小于 <code>O(n²)</code> 的算法吗？</p><h3 id="（2）题解">（2）题解</h3><ul><li><p>暴力法  <strong>O(n²)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>哈希表 <strong>O(n)</strong></p><p>将每一个元素作为 key ，将其索引值作为 value 。每次查询一个元素，并与 target 做差（ target - key），如果差在表中可查，则找到并输出当前元素和查到的元素的 value ；否则检查下一个元素。</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/LeetCode-1-%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="LeetCode-1"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 构建哈希表</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">  map.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 逐一检查</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">  <span class="type">int</span> diff = target - nums[j];</span><br><span class="line">  <span class="keyword">if</span> (map.<span class="built_in">find</span>(diff) != map.<span class="built_in">end</span>() <span class="keyword">and</span> map[diff] != j)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;j, map[diff]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>哈希表进一步改进</p><p>先查询 target - nums[i] 值是否存在，如果不存在才将 nums[i] 插入哈希表，等待后面的数字做差后与之比较；如果存在，则说明找到了，不必再验证后续的值，直接输出即可。</p><p>该方法可以减少省去构建哈希表时的循环，时间复杂度相同，但可节省内存空间的占用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">  <span class="keyword">auto</span> it = hashtable.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">  <span class="keyword">if</span> (it != hashtable.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;it-&gt;second, i&#125;; <span class="comment">//有则输出</span></span><br><span class="line">  &#125;</span><br><span class="line">  hashtable[nums[i]] = i; <span class="comment">//无则插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="（3）知识点">（3）知识点</h3><ul><li><p>C++ 中 Hash 表的使用：unordered_map 容器</p><p><a href="https://blog.csdn.net/zou_albert/article/details/106983268">https://blog.csdn.net/zou_albert/article/details/106983268</a></p></li><li><p>unordered_map 的插入</p><p><a href="https://blog.csdn.net/YourClerk/article/details/123967991">https://blog.csdn.net/YourClerk/article/details/123967991</a></p></li><li><p>map 容器中的取值方式 -&gt; first / second</p><p><a href="https://blog.csdn.net/qq_38860340/article/details/121640219">https://blog.csdn.net/qq_38860340/article/details/121640219</a></p></li></ul>]]></content>
    
    
    <summary type="html">每日LeetCode 两数之和</summary>
    
    
    
    <category term="算法" scheme="https://www.angfff.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://www.angfff.top/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://www.angfff.top/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://www.angfff.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>M系列 Mac CLion 环境配置问题(一)</title>
    <link href="https://www.angfff.top/posts/65843a24.html"/>
    <id>https://www.angfff.top/posts/65843a24.html</id>
    <published>2023-08-10T05:52:52.000Z</published>
    <updated>2025-03-06T04:40:56.794Z</updated>
    
    <content type="html"><![CDATA[<h1>关于 M1 Mac 中 CLion 添加头文件情况下仍无法调用 __gcd 函数的解决办法</h1><h2 id="一、问题描述">一、问题描述</h2><p>近期在学习 C++ 的过程中发现，正常调用 __gcd 函数（最大公因数函数），CLion 报错无法调用。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; __gcd(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误如下：</p><blockquote><p>error: use of undeclared identifier ‘__gcd’</p></blockquote><h2 id="二、问题处理">二、问题处理</h2><p>尝试各种方式后，最终发现是编译器的问题，在此记录处理过程，有相同问题的同学可以参考。</p><h3 id="（一）系统及软件版本">（一）系统及软件版本</h3><p>系统：macOS Ventura 13.2</p><p>软件：CLion 2022.3.2</p><h3 id="（二）解决流程">（二）解决流程</h3><p>之前在安装 CLion 时我直接按照 CLion 的提示安装了 Command Line Tools ，并直接使用了 CLion 的默认编译器配置，这样就有可能导致编译过程中出现错误，需要重新配一下环境。</p><ol><li>打开终端，确认Command Line Tools是否安装成功。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Xcode-<span class="keyword">select</span> -install</span><br></pre></td></tr></table></figure><ol start="2"><li>利用 Homebrew 安装 gcc</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install gcc</span><br></pre></td></tr></table></figure><p>​注：安装 gcc 编译器时可能出现问题，解决方法可参照 <a href="https://blog.csdn.net/weixin_45571585/article/details/126977413?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-6-126977413-blog-116170561.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-6-126977413-blog-116170561.pc_relevant_aa&amp;utm_relevant_index=11">gcc 安装教程</a>。</p><ol start="3"><li>利用 Homebrew 安装 cmake</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install cmake</span><br></pre></td></tr></table></figure><ol start="4"><li>重新配置 CLion</li></ol><p>进入 CLion <code>设置 -- 构建、执行、部署 -- 工具链</code> 修改构建工具、 C 编译器以及 C++ 编译器，如下：</p><ul><li>原配置：</li></ul><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%80%20CLion%E5%8E%9F%E9%85%8D%E7%BD%AE.png" alt="CLion原配置"></p><ul><li>修改为：</li></ul><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%80%20CLion%E9%85%8D%E7%BD%AE%E4%BF%AE%E6%94%B9.png" alt="CLion配置修改"></p><p><strong>注1：可能版本有点区别，只要在文件中选取 ctest 、 gcc-xx 、 g+±xx 即可；</strong></p><p><strong>注2：如果点开文件后找不到文件夹，按下 <code>commond + shift + .</code> 即可显示隐藏文件夹，选好后再按一次即可隐藏</strong></p><ol start="5"><li>重启一下 CLion 即可调用 __gcc 函数</li></ol>]]></content>
    
    
    <summary type="html">记录关于 M1 Mac 中 CLion 添加头文件情况下仍无法调用 __gcd 函数的解决办法</summary>
    
    
    
    <category term="环境配置" scheme="https://www.angfff.top/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    <category term="CLion" scheme="https://www.angfff.top/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/CLion/"/>
    
    
    <category term="Mac环境配置" scheme="https://www.angfff.top/tags/Mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    <category term="CLion" scheme="https://www.angfff.top/tags/CLion/"/>
    
  </entry>
  
  <entry>
    <title>Git基础</title>
    <link href="https://www.angfff.top/posts/1a60696b.html"/>
    <id>https://www.angfff.top/posts/1a60696b.html</id>
    <published>2023-07-23T16:13:26.000Z</published>
    <updated>2025-03-06T04:40:56.794Z</updated>
    
    <content type="html"><![CDATA[<h1>Git版本控制</h1><h2 id="一、版本控制">一、版本控制</h2><h3 id="（一）什么是版本控制？">（一）什么是版本控制？</h3><p>版本控制是一种记录和管理计算机文件或项目的变化历史的系统。它允许开发人员或团队跟踪文件的每次修改、查看更改内容、比较不同版本之间的差异，并在需要时还原到之前的特定状态。版本控制对于软件开发和其他类似项目的管理非常重要，因为它提供了许多优势和便利。</p><p>主要的版本控制系统有两种类型：集中式版本控制系统（Centralized Version Control System，CVCS）和分布式版本控制系统（Distributed Version Control System，DVCS）。</p><ol><li><p>集中式版本控制系统（CVCS）：<br>在CVCS中，所有文件的版本历史都保存在中央服务器上。开发人员通过连接到中央服务器来检出最新版本的文件，并将自己的更改提交到中央服务器。CVCS的缺点是，如果中央服务器出现故障或网络连接问题，那么开发人员将无法提交更改或获取最新的代码。此外，对于较大的团队，由于所有开发人员都使用中央服务器，可能会造成服务器性能瓶颈。</p></li><li><p>分布式版本控制系统（DVCS）：<br>在DVCS中，每个开发人员都有一个完整的代码仓库，包含完整的项目历史。开发人员可以在本地进行提交、回滚、创建分支等操作，而不需要实时连接到中央服务器。这使得团队成员可以在离线状态下工作，并且可以更加灵活地协作。当开发人员准备好时，他们可以将他们的更改推送（push）到中央服务器，或者从中央服务器拉取（pull）其他人的更改。</p></li></ol><p>版本控制系统的主要优势包括：</p><ul><li>更好的协作：团队成员可以同时在同一个项目上工作，不会干扰彼此的进度，也能更容易地合并不同人员的修改。</li><li>历史记录：每个版本都被记录下来，可以查看文件的完整修改历史，包括何时做了哪些更改。</li><li>版本回退：如果某次修改引入了问题，可以轻松回退到之前的稳定版本。</li><li>分支管理：可以创建多个分支，每个分支可用于不同的功能开发或问题修复，而不会相互干扰。</li><li>远程备份：中央服务器提供了对代码的远程备份，减少了数据丢失的风险。</li></ul><p>版本控制系统的使用不仅局限于软件开发，它还可以在各种其他场景中应用，如文档管理、项目管理、设计文件等。</p><h3 id="（二）为什么需要版本控制？">（二）为什么需要版本控制？</h3><p>以论文写作为例，在没有版本控制工具前，我们往往是通过每次修改版本都保留一个文件的方式来管理论文。通过多个文件来确定各个版本，不仅会占用更多的空间，而且也不利于我们对比版本间的差异。此外，我们也无法和他人协作。</p><p>使用版本控制工具，我们在论文写作中可以实现：</p><ol><li><p><strong>版本历史记录：</strong> 版本控制工具记录了每次对论文进行的修改和更新，包括添加、删除、编辑等。这使得作者可以随时查看论文的历史版本，了解每个修改的内容和时间，方便跟踪研究进展和撰写过程。</p></li><li><p><strong>版本回退和比较：</strong> 作者可以轻松地回退到之前的版本，如果当前的修改出现问题或需要恢复之前的内容，这在不丢失任何数据的情况下进行。此外，版本控制工具允许作者比较不同版本之间的差异，帮助他们了解具体修改的细节和影响。</p></li><li><p><strong>分支管理：</strong> 版本控制工具允许作者创建多个分支，每个分支可以用于不同的实验、讨论或章节撰写。这样可以在不影响主线论文的情况下进行尝试和修改，保持主线内容的稳定性。</p></li><li><p><strong>协作与审阅：</strong> 版本控制工具使得多位作者可以并行地对论文进行编辑和审阅。每位作者都可以在自己的本地副本上工作，然后将更改推送到共享的远程仓库。这样，团队成员可以实时了解其他人的修改，并且可以更好地合并和处理冲突。</p></li><li><p><strong>备份和安全性：</strong> 版本控制工具提供了对论文内容的远程备份，减少了数据丢失的风险。即使本地计算机出现故障，作者的论文仍然安全存储在远程服务器上。</p></li><li><p><strong>跨平台支持：</strong> 大多数版本控制工具都支持跨平台，这意味着作者可以在不同的操作系统上（如Windows、Mac、Linux）使用同一个版本控制系统，并轻松地共享和访问论文内容。</p></li><li><p><strong>注释和讨论：</strong> 版本控制工具通常支持注释和讨论功能，团队成员可以在特定的修改或提交上留下评论，以便进行讨论、提供反馈或交流想法。</p></li></ol><p>总体而言，版本控制工具为论文写作带来了更好的协作、追踪和管理的能力，提高了论文写作的效率，并保障了论文内容的安全性和稳定性。这对于研究团队、学生、教师以及其他合作写作项目的人员来说，都是非常有价值的工具。</p><h3 id="（三）常用版本控制工具？">（三）常用版本控制工具？</h3><p>常用的版本控制方法和工具主要有以下几种：</p><ol><li><p><strong>集中式版本控制系统（CVCS）：</strong></p><ul><li>CVS (Concurrent Versions System)：是最早流行的集中式版本控制系统之一，但目前已逐渐被更先进的版本控制系统所取代。</li><li>Subversion (SVN)：一种更现代和流行的集中式版本控制系统，提供了更多功能和改进，仍然在一些项目中广泛使用。</li></ul></li><li><p><strong>分布式版本控制系统（DVCS）：</strong></p><ul><li>Git：目前最流行和广泛使用的分布式版本控制系统。Git 是由 Linus Torvalds 创造的，它非常快速、强大，并得到了全球开发者社区的支持。</li><li>Mercurial：另一种流行的分布式版本控制系统，与 Git 类似，但在一些特定场景下可能具有不同的优势。</li></ul></li><li><p><strong>集成开发环境（IDE）内置版本控制：</strong></p><ul><li>一些集成开发环境（如Visual Studio、Eclipse、IntelliJ IDEA等）具有内置的版本控制集成，通常支持 Git 和 SVN 等常见的版本控制工具。</li></ul></li><li><p><strong>在线托管平台的版本控制：</strong></p><ul><li>GitHub：一个基于 Git 的在线代码托管平台，广泛用于开源项目、团队协作以及个人项目管理。</li><li>GitLab：类似于 GitHub 的另一个在线代码托管平台，提供类似的功能，并且可以自行搭建在私有服务器上。</li><li>Bitbucket：提供 Git 和 Mercurial 支持的在线代码托管平台，通常用于私有项目。</li></ul></li></ol><p>这些版本控制方法和工具在软件开发、文档管理、论文写作、项目协作等领域广泛使用。选择哪种版本控制方法和工具取决于项目的需求、团队的喜好和技术要求。Git 是目前最受欢迎和推荐的版本控制系统，它为开发者提供了强大的功能和灵活性，并在开源社区中得到广泛支持。</p><h2 id="二、-Git">二、 Git</h2><h3 id="（一）什么是-Git？">（一）什么是 Git？</h3><p>Git是一种分布式版本控制系统，它用于跟踪计算机文件的变化和协调多人在同一个项目上的协作。版本控制是在软件开发和其他类似项目中非常重要的概念，因为它允许开发人员或团队记录每个文件的更改历史并管理不同版本之间的差异。</p><p>Git由Linus Torvalds于2005年创造，最初是为了更好地管理Linux内核的开发而设计的。现在，Git已经成为世界上最流行和广泛使用的版本控制系统之一，被广泛应用于软件开发和其他项目管理中。</p><p>Git的主要特点包括：</p><ol><li><p>分布式：与传统的集中式版本控制系统不同，Git是一种分布式系统，每个开发人员都有一个完整的代码仓库，包含完整的历史记录。这使得团队成员可以在离线状态下工作，并可以更容易地进行协作。</p></li><li><p>分支管理：Git非常擅长管理分支，开发人员可以轻松地创建、合并和删除分支，这为同时处理多个功能或修复不同问题提供了便利。</p></li><li><p>快速和高效：Git被设计成非常快速和高效，使开发人员可以迅速完成各种操作，如提交、分支切换和合并等。</p></li><li><p>完整的历史记录：Git记录每个文件的完整历史记录，开发人员可以查看文件的每个版本、每次修改和对应的作者信息。</p></li><li><p>数据完整性：Git使用哈希值来保证数据的完整性，这意味着一旦数据被提交，就会被永久地记录和保留。</p></li><li><p>开放源代码：Git是开源软件，任何人都可以查看其源代码，并可以根据需要进行自定义修改。</p></li></ol><p>使用Git，开发人员可以更加灵活地协作，管理项目，并追踪代码变化，从而帮助团队更加高效地进行软件开发或其他类型的项目管理。</p><h3 id="（二）Git-工作原理">（二）Git 工作原理</h3><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F932856%2F202004%2F932856-20200423143251346-796113044.jpg&amp;refer=http%3A%2F%2Fimg2020.cnblogs.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1644374894&amp;t=7c2044128f7851ecd92de3c01f0187ca" alt="点击查看源网页"></p><p>Git 大致分为4个板块：</p><ul><li>工作目录：存放我们正在写的代码（当我们新版本开发完成之后，就可以进行新版本的提交）</li><li>暂存区：暂时保存待提交的内容（新版本提交后会存放到本地仓库）</li><li>本地仓库：位于我们电脑上的一个版本控制仓库（存放的就是当前项目各个版本代码的增删信息）</li><li>远程仓库：位于服务器上的版本控制仓库（服务器上的版本信息可以由本地仓库推送上去，也可以从服务器抓取到本地仓库）</li></ul><p>它是一个分布式的控制系统，因此一般情况下我们每个人的电脑上都有一个本地仓库，由大家共同向远程仓库去推送版本迭代信息。</p><p>通过这一系列操作，我们就可以实现每开发完一个版本或是一个功能，就提交一次新版本，这样，我们就可以很好地控制项目的版本迭代，想回退到之前的版本随时都可以回退，想查看新版本添加或是删除了什么代码，随时都可以查看。</p><h3 id="（三）安装-Git">（三）安装 Git</h3><p>首先请前往 Git 官网去下载最新的安装包：<a href="https://git-scm.com/">https://git-scm.com/</a></p><p>安装完成后，需要设定用户名和邮箱来区分不同的用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Ang Lee&quot;</span><br><span class="line">git config --global user.email &quot;18416841@qq.com&quot;</span><br></pre></td></tr></table></figure><h3 id="（四）基本命令介绍">（四）基本命令介绍</h3><ol><li>创建本地仓库</li></ol><p>我们可以将任意一个文件夹作为一个本地仓库，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>输入后，会自动生成一个<code>.git</code>目录，注意这个目录是一个隐藏目录，而当前目录就是我们的工作目录。</p><p>创建成功后，我们可以查看一下当前的一个状态，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>如果已经成功配置为Git本地仓库，那么输入后可以看到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br></pre></td></tr></table></figure><p>这表示我们还没有向仓库中提交任何内容，也就是一个空的状态。</p><ol start="2"><li>添加和提交</li></ol><p>接着我们来看看，如何使用git来管理我们文档的版本，我们创建一个文本文档，随便写入一点内容，接着输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>我们会得到如下提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">hello.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p>其中Untracked files是未追踪文件的意思，也就是说，如果一个文件处于未追踪状态，那么git不会记录它的变化，始终将其当做一个新创建的文件，这里我们将其添加到暂存区，那么它会自动变为被追踪状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add hello.txt #也可以 add . 一次性添加目录下所有的</span><br></pre></td></tr></table></figure><p>再次查看当前状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">new file:   hello.txt</span><br></pre></td></tr></table></figure><p>现在文件名称的颜色变成了绿色，并且是处于Changes to be committed下面，因此，我们的hello.txt现在已经被添加到暂存区了。</p><p>接着我们来尝试将其提交到Git本地仓库中，注意需要输入提交的描述以便后续查看，比如你这次提交修改了或是新增了哪些内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;Hello World&#x27;</span></span><br></pre></td></tr></table></figure><p>注：如果是修改了文件的内容（不是增删文件），可以用以下一行命令完成添加到暂存区以及提交到本地仓库中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m <span class="string">&#x27;Modify x&#x27;</span></span><br></pre></td></tr></table></figure><p>接着我们可以查看我们的提交记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line">git <span class="built_in">log</span> --graph</span><br><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure><p>我们还可以查看最近一次变更的详细内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show [也可以加上commit ID查看指定的提交记录]</span><br></pre></td></tr></table></figure><p>再次查看当前状态，已经是清空状态了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>接着我们可以尝试修改一下我们的文本文档，由于当前文件已经是被追踪状态，那么git会去跟踪它的变化，如果说文件发生了修改，那么我们再次查看状态会得到下面的结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">modified:   hello.txt</span><br></pre></td></tr></table></figure><p>也就是说现在此文件是处于已修改状态，我们如果修改好了，就可以提交我们的新版本到本地仓库中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;Modify Text&#x27;</span></span><br></pre></td></tr></table></figure><p>接着我们来查询一下提交记录，可以看到一共有两次提交记录。</p><p>我们可以创建一个<code>.gitignore</code>文件来确定一个文件忽略列表，如果忽略列表中的文件存在且不是被追踪状态，那么git不会对其进行任何检查：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这样就会匹配所有以txt结尾的文件</span></span><br><span class="line"><span class="string">*.txt</span></span><br><span class="line"><span class="comment"># 虽然上面排除了所有txt结尾的文件，但是这个不排除</span></span><br><span class="line"><span class="type">!666.txt</span></span><br><span class="line"><span class="comment"># 也可以直接指定一个文件夹，文件夹下的所有文件将全部忽略</span></span><br><span class="line"><span class="string">test/</span></span><br><span class="line"><span class="comment"># 目录中所有以txt结尾的文件，但不包括子目录</span></span><br><span class="line"><span class="string">xxx/*.txt</span></span><br><span class="line"><span class="comment"># 目录中所有以txt结尾的文件，包括子目录</span></span><br><span class="line"><span class="string">xxx/**/*.txt</span></span><br></pre></td></tr></table></figure><p>创建后，我们来看看是否还会检测到我们忽略的文件。</p><ol start="3"><li>回滚</li></ol><p>当我们想要回退到过去的版本时，就可以执行回滚操作，执行后，可以将工作空间的内容恢复到指定提交的状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commitID</span><br></pre></td></tr></table></figure><p>执行后，会直接重置为那个时候的状态。再次查看提交日志，我们发现之后的日志全部消失了。</p><p>那么要是现在我又想回去呢？我们可以通过查看所有分支的所有操作记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p>这样就能找到之前的commitID，再次重置即可。</p><ol start="4"><li>分支</li></ol><p>分支就像我们树上的一个树枝一样，它们可能一开始的时候是同一根树枝，但是长着长着就开始分道扬镳了，这就是分支。我们的代码也是这样，可能一开始写基础功能的时候使用的是单个分支，但是某一天我们希望基于这些基础的功能，把我们的项目做成两个不同方向的项目，比如一个方向做Web网站，另一个方向做游戏服务端。</p><p>因此，我们可以在一个主干上分出N个分支，分别对多个分支的代码进行维护。</p><ul><li>创建分支</li></ul><p>我们可以通过以下命令来查看当前仓库中存在的分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>我们发现，默认情况下是有一个master分支的，并且我们使用的也是master分支，一般情况下master分支都是正式版本的更新，而其他分支一般是开发中才频繁更新的。我们接着来基于当前分支创建一个新的分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 对应的删除分支是</span></span><br><span class="line">git branch -d <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>现在我们修改一下文件，提交，再查看一下提交日志：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m <span class="string">&#x27;branch master commit&#x27;</span></span><br></pre></td></tr></table></figure><p>通过添加-a来自动将未放入暂存区的已修改文件放入暂存区并执行提交操作。查看日志，我们发现现在我们的提交只生效于master分支，而新创建的分支并没有发生修改。</p><p>我们将分支切换到另一个分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>我们会发现，文件变成了此分支创建的时的状态，也就是说，在不同分支下我们的文件内容是相互隔离的。</p><p>我们现在再来提交一次变更，会发现它只生效在test分支上。我们可以看看当前的分支状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --all --graph</span><br></pre></td></tr></table></figure><ul><li>合并分支</li></ul><p>我们也可以将两个分支更新的内容最终合并到同一个分支上，我们先切换回主分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>接着使用分支合并命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>会得到如下提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Auto-merging hello.txt</span><br><span class="line">CONFLICT (content): Merge conflict in hello.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>在合并过程中产生了冲突，因为两个分支都对hello.txt文件进行了修改，那么现在要合并在一起，到底保留谁的hello文件呢？</p><p>我们可以查看一下是哪里发生了冲突：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>因此，现在我们将master分支的版本回退到修改hello.txt之前或是直接修改为最新版本的内容，这样就不会有冲突了，接着再执行一次合并操作，现在两个分支成功合并为同一个分支。</p><ul><li>变基分支</li></ul><p>除了直接合并分支以外，我们还可以进行变基操作，它跟合并不同，合并是分支回到主干的过程，而变基是直接修改分支开始的位置，比如我们希望将yyds变基到master上，那么yyds会将分支起点移动到master最后一次提交位置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase master</span><br></pre></td></tr></table></figure><p>变基后，yyds分支相当于同步了此前master分支的全部提交。</p><ul><li>优选</li></ul><p>我们还可以选择其将他分支上的提交作用于当前分支上，这种操作称为cherrypick：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;commit <span class="built_in">id</span>&gt;:单独合并一个提交</span><br></pre></td></tr></table></figure><p>这里我们在master分支上创建一个新的文件，提交此次更新，接着通过cherry-pick的方式将此次更新作用于test分支上。</p><h2 id="三、使用IDEA版本控制">三、使用IDEA版本控制</h2><p>虽然前面我们基本讲解了git的命令行使用方法，但是没有一个图形化界面，始终会感觉到很抽象，所以这里我们使用IDEA来演示，IDEA内部集成了git模块，它可以让我们的git版本管理图形化显示，当然除了IDEA也有一些独立的软件比如：SourceTree（挺好用）</p><p>打开IDEA后，找到版本控模块，我们直接点击创建本地仓库，它会自动将当前项目的根目录作为我们的本地仓库，而我们编写的所有代码和项目目录下其他的文件都可以进行版本控制。</p><p>我们发现所有项目中正在编写的类文件全部变红了，也就是处于未追踪状态，接着我们进行第一次初始化提交，提交之后我们可以在下方看到所有的本地仓库提交记录。</p><p>接着我们来整合一下Web环境，创建新的类之后，IDEA会提示我们是否将文件添加到Git，也就是是否放入暂存区并开启追踪，我们可以直接对比两次代码的相同和不同之处。</p><p>接着我们来演示一下分支创建和分支管理。</p><h2 id="四、远程仓库">四、远程仓库</h2><p>远程仓库实际上就是位于服务器上的仓库，它能在远端保存我们的版本历史，并且可以实现多人同时合作编写项目，每个人都能够同步他人的版本，能够看到他人的版本提交，相当于将我们的代码放在服务器上进行托管。</p><p>远程仓库有公有和私有的，公有的远程仓库有GitHub、码云、Coding等，他们都是对外开放的，我们注册账号之后就可以使用远程仓库进行版本控制，其中最大的就是GitHub，但是它服务器在国外，我们国内连接可能会有一点卡。私有的一般是GitLab这种自主搭建的远程仓库私服，在公司中比较常用，它只对公司内部开放，不对外开放。</p><p>这里我们以GitHub做讲解，官网：<a href="https://github.com">https://github.com</a>，首先完成用户注册。</p><p>接下来在 GitHub 中创建一个项目远程仓库(New Repository)，依次填写仓库名称、仓库介绍以及私有/公有仓库，创建后便可以得到远程仓库的地址(Https)。</p><h3 id="（一）远程账户认证和推送">（一）远程账户认证和推送</h3><p>创建仓库后，我们可以通过推送来将本地仓库中的内容推送到远程仓库。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add 名称 远程仓库地址</span><br><span class="line">git push 远程仓库名称 本地分支名称[:远端分支名称]</span><br></pre></td></tr></table></figure><p>注意<code>push</code>后面两个参数，一个是远端名称，还有一个就是本地分支名称，但是如果本地分支名称和远端分支名称一致，那么不用指定远端分支名称，但是如果我们希望推送的分支在远端没有同名的，那么需要额外指定。推送前需要登陆账户，GitHub现在不允许使用用户名密码验证，只允许使用个人AccessToken来验证身份，所以我们需要先去生成一个Token才可以。</p><p>注：创建Token时，勾选 repo、gist、user 选项。在终端中push时，账号为GitHub账号名称，密码为Token值。</p><p>推送后，我们发现远程仓库中的内容已经与我们本地仓库中的内容保持一致了，注意，远程仓库也可以有很多个分支。</p><hr><p>以下部分为SSH配置方式，目前GitHub已支持终端记住Token凭证，因此可忽略该方式。</p><p>但是这样比较麻烦，我们每次都需要去输入用户名和密码，有没有一劳永逸的方法呢？当然，我们也可以使用SSH来实现一次性校验，我们可以在本地生成一个rsa公钥：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/github.pub</span><br></pre></td></tr></table></figure><p>接着我们需要在GitHub上上传我们的公钥，当我们再次去访问GitHub时，会自动验证，就无需进行登录了，之后在Linux部分我们会详细讲解SSH的原理。</p><hr><p>接着我们修改一下工作区的内容，提交到本地仓库后，再推送到远程仓库，提交的过程中我们注意观察提交记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m <span class="string">&#x27;Modify files&#x27;</span></span><br><span class="line">git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">git push origin master </span><br><span class="line">git <span class="built_in">log</span> --all --oneline --graph</span><br></pre></td></tr></table></figure><p>我们可以将远端和本地的分支进行绑定，绑定后就不需要指定分支名称了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin master:master</span><br><span class="line">git push origin</span><br></pre></td></tr></table></figure><p>在一个本地仓库对应一个远程仓库的情况下，远程仓库基本上就是纯粹的代码托管了（云盘那种感觉，就纯粹是存你代码的）</p><h3 id="（二）克隆项目">（二）克隆项目</h3><p>如果我们已经存在一个远程仓库的情况下，我们需要在远程仓库的代码上继续编写代码，这个时候怎么办呢？</p><p>我们可以使用克隆操作来将远端仓库的内容全部复制到本地：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 远程仓库地址</span><br></pre></td></tr></table></figure><p>这样本地就能够直接与远程保持同步。</p><h3 id="（三）抓取、拉取和冲突解决">（三）抓取、拉取和冲突解决</h3><p>我们接着来看，如果这个时候，出现多个本地仓库对应一个远程仓库的情况下，比如一个团队里面，N个人都在使用同一个远程仓库，但是他们各自只负责编写和推送自己业务部分的代码，也就是我们常说的协同工作，那么这个时候，我们就需要协调。</p><p>比如程序员A完成了他的模块，那么他就可以提交代码并推送到远程仓库，这时程序员B也要开始写代码了，由于远程仓库有其他程序员的提交记录，因此程序员B的本地仓库和远程仓库不一致，这时就需要有先进行pull操作，获取远程仓库中最新的提交：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch 远程仓库 <span class="comment">#抓取：只获取但不合并远端分支，后面需要我们手动合并才能提交</span></span><br><span class="line">git pull 远程仓库 <span class="comment">#拉取：获取+合并</span></span><br></pre></td></tr></table></figure><p>在程序员B拉取了最新的版本后，再编写自己的代码然后提交就可以实现多人合作编写项目了，并且在拉取过程中就能将别人提交的内容同步到本地，开发效率大大提升。</p><p>如果工作中存在不协调的地方，比如现在我们本地有两个仓库，一个仓库去修改hello.txt并直接提交，另一个仓库也修改hello.txt并直接提交，会得到如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">To https://github.com/xx/xxx.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to &#x27;https://github.com/xx/xxx.git&#x27;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &#x27;git pull ...&#x27;) before pushing again.</span><br><span class="line">hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br></pre></td></tr></table></figure><p>一旦一个本地仓库推送了代码，那么另一个本地仓库的推送会被拒绝，原因是当前文件已经被其他的推送给修改了，我们这边相当于是另一个版本，和之前两个分支合并一样，产生了冲突，因此我们只能去解决冲突问题。</p><p>如果远程仓库中的提交和本地仓库中的提交没有去编写同一个文件，那么就可以直接拉取：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull 远程仓库</span><br></pre></td></tr></table></figure><p>拉取后会自动进行合并，合并完成之后我们再提交即可。</p><p>但是如果两次提交都修改了同一个文件，那么就会遇到和多分支合并一样的情况，在合并时会产生冲突，这时就需要我们自己去解决冲突了。</p>]]></content>
    
    
    <summary type="html">Git是一种分布式版本控制系统，用于跟踪计算机文件的变化和协调多人在同一个项目上的协作。</summary>
    
    
    
    <category term="必备工具" scheme="https://www.angfff.top/categories/%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Git" scheme="https://www.angfff.top/categories/%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/Git/"/>
    
    
    <category term="必备工具" scheme="https://www.angfff.top/tags/%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Git" scheme="https://www.angfff.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>个人博客搭建（一）</title>
    <link href="https://www.angfff.top/posts/ad52d94.html"/>
    <id>https://www.angfff.top/posts/ad52d94.html</id>
    <published>2023-07-18T12:30:44.000Z</published>
    <updated>2025-03-06T04:40:56.794Z</updated>
    
    <content type="html"><![CDATA[<h1>个人博客搭建（一）</h1><div class="note red icon-padding flat"><i class="note-icon fas fa-fan fa-spin"></i><p>本文是搭建个人博客系列的第一篇文章，主要包括本地环境搭建、远程仓库搭建两个部分。</p></div><h2 id="一、技术栈">一、技术栈</h2><ul><li>语言：HTML、CSS、JavaScript、MarkDown</li><li>框架：Hexo</li><li>主题：ButterFly</li><li>仓库：GitHub</li><li>第三方托管：Vercel</li><li>域名：阿里云</li></ul><h2 id="二、本地环境搭建">二、本地环境搭建</h2><h3 id="1-安装Node-js">1. 安装Node.js</h3><ul><li>下载地址：<a href="https://nodejs.org/zh-cn/download/">https://nodejs.org/zh-cn/download/</a></li><li>安装完成后，打开命令行，输入<code>node -v</code>和<code>npm -v</code>，查看是否安装成功</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">（一）本地环境及远程仓库搭建</summary>
    
    
    
    <category term="实战项目" scheme="https://www.angfff.top/categories/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="个人博客" scheme="https://www.angfff.top/categories/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客搭建" scheme="https://www.angfff.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    <category term="Hexo" scheme="https://www.angfff.top/tags/Hexo/"/>
    
    <category term="ButterFly" scheme="https://www.angfff.top/tags/ButterFly/"/>
    
  </entry>
  
</feed>
