<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AngFff&#39;s Blog</title>
  
  
  <link href="https://www.angfff.top/atom.xml" rel="self"/>
  
  <link href="https://www.angfff.top/"/>
  <updated>2025-02-09T03:33:56.699Z</updated>
  <id>https://www.angfff.top/</id>
  
  <author>
    <name>AngFff</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MLX-学习笔记</title>
    <link href="https://www.angfff.top/posts/d37068c6.html"/>
    <id>https://www.angfff.top/posts/d37068c6.html</id>
    <published>2025-02-09T03:23:37.000Z</published>
    <updated>2025-02-09T03:33:56.699Z</updated>
    
    <content type="html"><![CDATA[<h1>一、框架文档 <a href="https://ml-explore.github.io/mlx/build/html/index.html">MLX</a></h1><hr><h1>二、框架安装</h1><h2 id="（一）创建并使用环境">（一）创建并使用环境</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">% python &gt;= 3.10 %%</span></span><br><span class="line">conda create -n mlx python=3.10</span><br><span class="line"></span><br><span class="line">conda activate mlx</span><br></pre></td></tr></table></figure><h2 id="（二）安装框架">（二）安装框架</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mlx</span><br></pre></td></tr></table></figure><hr><h1>三、LLM</h1><h2 id="（一）相关链接">（一）相关链接</h2><ul><li><a href="https://github.com/ml-explore/mlx-examples">mlx-examples</a></li><li><a href="https://github.com/ml-explore/mlx-examples/tree/main/llms">mlx-llms</a></li><li><a href="https://huggingface.co/mlx-community?message=You've%20joined%20MLX%20Community!">mlx-community</a></li></ul><h2 id="（二）安装-mlx-lm-库">（二）安装 mlx_lm 库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mlx-lm</span><br></pre></td></tr></table></figure><h2 id="（三）拉取-mlx-examples">（三）拉取 mlx-examples</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">% 官方示例库，方便学习参考 %%</span></span><br><span class="line">git clone https://github.com/ml-explore/mlx-examples.git</span><br></pre></td></tr></table></figure><h2 id="（四）Hugging-Face-模型下载">（四）Hugging Face 模型下载</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">%</span><span class="language-bash">% 安装 git-lfs 方便拉取大文件 %%</span></span><br><span class="line">brew install git-lfs</span><br><span class="line">git lfs install</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">% 拉取模型文件 %%</span></span><br><span class="line">git clone https://huggingface.co/Qwen/Qwen2.5-0.5B-Instruct</span><br></pre></td></tr></table></figure><h2 id="（五）模型推理-Generate">（五）模型推理 Generate</h2><h3 id="5-1-Generate-from-a-model">5.1 Generate from a model</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mlx_lm.generate \</span><br><span class="line">--model &lt;path&gt; \</span><br><span class="line">--prompt &quot;&lt;prompt&gt;&quot;</span><br></pre></td></tr></table></figure><h3 id="5-2-Generate-from-a-model-after-finetuning-with-adapter">5.2 Generate from a model after finetuning with adapter</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mlx_lm.generate \</span><br><span class="line">--model &lt;path&gt; \</span><br><span class="line">--adapter-path &lt;path&gt; \</span><br><span class="line">--prompt &quot;&lt;prompt&gt;&quot;</span><br></pre></td></tr></table></figure><h2 id="（六）模型微调">（六）模型微调</h2><h3 id="6-1-Finetune-Lora">6.1 Finetune --Lora</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mlx_lm.lora \</span><br><span class="line">--model &lt;path&gt; \</span><br><span class="line">--train \</span><br><span class="line">--data &lt;path&gt; \</span><br><span class="line">--iters 600</span><br></pre></td></tr></table></figure><h3 id="6-2-Fuse-整合">6.2 Fuse 整合</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mlx_lm.fuse \</span><br><span class="line">--model &lt;path&gt; \</span><br><span class="line">--adapter-path &lt;path&gt; \</span><br><span class="line">--save-path &lt;path&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">MLX 学习笔记</summary>
    
    
    
    <category term="AI" scheme="https://www.angfff.top/categories/AI/"/>
    
    <category term="MLX" scheme="https://www.angfff.top/categories/AI/MLX/"/>
    
    
    <category term="MLX" scheme="https://www.angfff.top/tags/MLX/"/>
    
    <category term="AI" scheme="https://www.angfff.top/tags/AI/"/>
    
    <category term="LLM" scheme="https://www.angfff.top/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>实战项目——股票分析系统</title>
    <link href="https://www.angfff.top/posts/82f46f22.html"/>
    <id>https://www.angfff.top/posts/82f46f22.html</id>
    <published>2025-01-03T06:55:23.000Z</published>
    <updated>2025-02-09T03:33:56.699Z</updated>
    
    
    <summary type="html">基于 Flask 和 Vuetify 框架的股票分析系统，结合 LLM 与 LSTM 模型，实现股票基本面、技术面及市场情绪分析等功能。</summary>
    
    
    
    <category term="实战项目" scheme="https://www.angfff.top/categories/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="股票分析系统" scheme="https://www.angfff.top/categories/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/%E8%82%A1%E7%A5%A8%E5%88%86%E6%9E%90%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Python" scheme="https://www.angfff.top/tags/Python/"/>
    
    <category term="实战项目" scheme="https://www.angfff.top/tags/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="Flask" scheme="https://www.angfff.top/tags/Flask/"/>
    
    <category term="Node.js" scheme="https://www.angfff.top/tags/Node-js/"/>
    
    <category term="Vuetify" scheme="https://www.angfff.top/tags/Vuetify/"/>
    
    <category term="前后端分离" scheme="https://www.angfff.top/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>Python 学习笔记</title>
    <link href="https://www.angfff.top/posts/7db8c537.html"/>
    <id>https://www.angfff.top/posts/7db8c537.html</id>
    <published>2024-09-29T11:37:59.000Z</published>
    <updated>2025-02-09T03:33:56.699Z</updated>
    
    <content type="html"><![CDATA[<h1>1. 基础</h1><h2 id="1-1-编码-标识符-保留字">1.1 编码 / 标识符 / 保留字</h2><ol><li>默认情况下，Python 3 源码文件以 <strong>UTF-8</strong> 编码，所有字符串都是 unicode 字符串；</li><li>标识符<ul><li>第一个字符必须是字母表中字母或下划线_</li><li>标识符的其他的部分由字母、数字和下划线组成</li><li>标识符对大小写敏感</li></ul></li><li>保留字即关键字，不能把它们用作任何标识符名称。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line"><span class="built_in">print</span>(keyword.kwlist)</span><br></pre></td></tr></table></figure></li></ol><h2 id="1-2-注释">1.2 注释</h2><ol><li>单行注释以 <strong>#</strong> 开头</li><li>多行注释可以用多个#号，或者三个单 / 双引号 ‘’’ 和 “”&quot;</li><li>多行注释中不能再嵌套多行注释，但可以使用单行注释 #</li><li>输出函数的注释<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">a</span>():</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;函数注释&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.__doc__)</span><br></pre></td></tr></table></figure></li></ol><h2 id="1-3-多行语句">1.3 多行语句</h2><ol><li>Python 通常是一行写完一条语句，但如果语句很长，可以使用反斜杠来实现多行语句<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure></li><li>在 [], {}, 或 () 中的多行语句，不需要使用反斜杠 \<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total = [<span class="string">&#x27;item_one&#x27;</span>, <span class="string">&#x27;item_two&#x27;</span>, <span class="string">&#x27;item_three&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;item_four&#x27;</span>, <span class="string">&#x27;item_five&#x27;</span>]</span><br></pre></td></tr></table></figure></li></ol><h2 id="1-4-输出">1.4 输出</h2><h3 id="1-4-1-基本输出">1.4.1 基本输出</h3><ol><li>Python 使用 print 输出内容，默认输出是换行的；</li><li>要实现不换行，则需要在变量末尾加上 <code>end=&quot;&quot;</code>；<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 换行输出 </span></span><br><span class="line"><span class="built_in">print</span>( x ) </span><br><span class="line"><span class="comment"># 不换行输出 </span></span><br><span class="line"><span class="built_in">print</span>( x, end=<span class="string">&quot;&quot;</span> )</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-4-2-输出格式调整">1.4.2 输出格式调整</h3><ol><li><p>转为字符串</p><ul><li>str()：函数返回一个用户易读的表达形式；</li><li>repr()：产生一个解释器易读的表达形式；</li></ul></li><li><p>zfill( )</p><ul><li>该函数会在数字的左边填充 0；</li></ul></li><li><p>str.format()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 参数替换</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125;网址： &quot;&#123;&#125;!&quot;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;AngFff&#x27;</span>, <span class="string">&#x27;www.angfff.top&#x27;</span>)) </span><br><span class="line"><span class="comment"># 输出： AngFff网址： &quot;www.angfff.top!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 数字标明位置</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125; 和 &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>))  </span><br><span class="line"><span class="comment"># 输出：Google 和 Apple</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 关键字指定参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#123;name&#125;网址：&#123;site&#125;&#x27;</span>.<span class="built_in">format</span>(name=<span class="string">&#x27;AngFff&#x27;</span>, site=<span class="string">&#x27;123&#x27;</span>))  </span><br><span class="line"><span class="comment"># AngFff网址：123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 可选项，进一步控制格式</span></span><br><span class="line"><span class="comment"># 将 Pi 保留到小数点后三位</span></span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;常量 PI 的值近似为 &#123;0:.3f&#125;。&#x27;</span>.<span class="built_in">format</span>(math.pi)) </span><br><span class="line"><span class="comment"># 输出：常量 PI 的值近似为 3.142。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 控制宽度</span></span><br><span class="line">table = &#123;<span class="string">&#x27;Google&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;Runoob&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;Taobao&#x27;</span>: <span class="number">3</span>&#125;  </span><br><span class="line"><span class="keyword">for</span> name, number <span class="keyword">in</span> table.items():  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;0:10&#125; ==&gt; &#123;1:10d&#125;&#x27;</span>.<span class="built_in">format</span>(name, number))  </span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># Google     ==&gt;          1  </span></span><br><span class="line"><span class="comment"># Runoob     ==&gt;          2  </span></span><br><span class="line"><span class="comment"># Taobao     ==&gt;          3  </span></span><br></pre></td></tr></table></figure><ul><li>括号及其里面的字符 (称作格式化字段) 将会被 format() 中的参数替换；</li><li>在括号中的数字用于指向传入对象在 format() 中的位置；</li><li>如果在 format() 中使用了关键字参数, 那么它们的值会指向使用该名字的参数，位置及关键字参数可以任意的结合；</li><li>!a (使用 <strong>ascii()</strong>),  !s (使用 <strong>str()</strong>) 和  !r (使用 <strong>repr()</strong>) 可以用于在格式化某个值之前对其进行转化；</li><li>可选项 : 和格式标识符可以跟着字段名，允许对值进行更好的格式化；</li><li>在 : 后传入一个整数, 可以保证该域至少有这么多的宽度；</li></ul></li></ol><h2 id="1-5-输入">1.5 输入</h2><h3 id="1-5-1-标准输入">1.5.1 标准输入</h3><ol><li><p>input( ) 内置函数 从标准输入读入一行文本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;请输入：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;输入内容为：&quot;</span>, <span class="built_in">str</span>)</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-5-2-文件读写">1.5.2 文件读写</h3><ol><li><p>创建文件对象</p><ul><li>open() 将会返回一个 file 对象 <code>open(filename, mode)</code></li><li>filename：要打开的文件名</li><li>mode：决定了打开文件的模式，只读 ‘r’，写入 ‘w’，追加 ‘a’ 等。该参数是非强制的，默认文件访问模式为只读 ‘r’</li><li>每次打开文件后，都需要关闭文件对象，调用 <code>f.close()</code></li></ul><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Python%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E6%A8%A1%E5%BC%8F.png" alt="Python文件读写模式.png"></p></li><li><p>针对文件对象进行读取</p><ul><li>在已创建 文件对象 的情况下 f = open()</li><li>f.read()<ul><li>调用 f.read(size)，将读取一定数目的数据，然后作为字符串或字节对象返回</li><li>size 是一个可选的数字类型的参数，当 size 为空或者负，则该文件的所有内容都将被读取并且返回</li></ul></li><li>f.readline()<ul><li>f.readline() 会从文件中读取单独的一行，换行符为 ‘\n’</li><li>如果返回一个空字符串，说明已经已经读取到最后一行</li></ul></li><li>f.readlines()<ul><li>f.readlines() 将返回该文件中包含的所有行</li><li>如果设置可选参数 sizehint，则读取指定长度的字节，并且将这些字节按行分割</li></ul></li></ul></li><li><p>针对文件对象进行写入</p><ul><li>在已创建 文件对象 的情况下 f = open()</li><li>f.write()<ul><li>f.write(string) 将 string 写入到文件中，然后返回写入的字符数</li></ul></li><li>f.tell()<ul><li>f.tell() 用于返回文件当前的读/写位置（即文件指针的位置）</li><li>文件指针表示从文件开头开始的字节数偏移量</li></ul></li><li>f.seek()<ul><li>要改变文件指针的位置，可以用 f.seek(offset, whence)</li><li>offset 表示相对于 whence 参数的偏移量，whence 如果是 0 表示开头，如果是 1 表示当前位置, 2 表示文件的结尾<ul><li>seek(x,0)：从起始位置即文件首行首字符开始移动 x 个字</li><li>seek(x,1)：表示从当前位置往后移动 x 个字符</li><li>seek(-x,2)：表示从文件的结尾往前移动 x 个字符</li></ul></li></ul></li></ul></li><li><p>关闭文件</p><ul><li>在已创建 文件对象 的情况下 f = open()</li><li>f.close()<ul><li>调用 f.close() 来关闭文件并释放系统的资源</li></ul></li><li>with 关键字用于简化文件操作并确保文件在使用完后自动关闭，避免手动调用 close() 方法。它会在代码块执行结束后自动管理资源的释放，即使代码中发生异常，也能保证文件被正确关闭<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/test.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    read_data = f.read()</span><br><span class="line"><span class="comment"># 运行结束后，会自动关闭 f 对象，释放资源</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="1-6-运算符">1.6 运算符</h2><ol><li><p>算数运算符</p><blockquote><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>加 - 两个对象相加</td></tr><tr><td>-</td><td>减 - 得到负数或是一个数减去另一个数</td></tr><tr><td>*</td><td>乘 - 两个数相乘或是返回一个被重复若干次的字符串</td></tr><tr><td>/</td><td>除 - x 除以 y</td></tr><tr><td>%</td><td>取模 - 返回除法的余数</td></tr><tr><td>**</td><td>幂 - 返回x的y次幂</td></tr><tr><td>//</td><td>取整除 - 向下 / 左取整</td></tr></tbody></table></blockquote></li><li><p>比较（关系）运算符</p><blockquote><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>==</td><td>等于 - 比较对象是否相等</td></tr><tr><td>!=</td><td>不等于 - 比较两个对象是否不相等</td></tr><tr><td>&gt;</td><td>大于 - 返回x是否大于y</td></tr><tr><td>&lt;</td><td>小于 - 返回x是否小于y</td></tr><tr><td>&gt;=</td><td>大于等于 - 返回x是否大于等于y</td></tr><tr><td>&lt;=</td><td>小于等于 - 返回x是否小于等于y</td></tr></tbody></table></blockquote></li><li><p>赋值运算符</p><blockquote><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符</td></tr><tr><td>+=</td><td>加法赋值运算符</td></tr><tr><td>-=</td><td>减法赋值运算符</td></tr><tr><td>*=</td><td>乘法赋值运算符</td></tr><tr><td>/=</td><td>除法赋值运算符</td></tr><tr><td>%=</td><td>取模赋值运算符</td></tr><tr><td>**=</td><td>幂赋值运算符</td></tr><tr><td>//=</td><td>取整除赋值运算符</td></tr><tr><td>:=</td><td>海象运算符，这个运算符的主要目的是在表达式中同时进行赋值和返回赋值的值。<strong>Python3.8 版本新增运算符</strong></td></tr></tbody></table></blockquote></li><li><p>位运算符</p><blockquote><table><thead><tr><th>运算符</th><th>描述</th><th>实例(a=12 / b=13)</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与运算符：参与运算的两个值,如果两个相应位都为1,则该位的结果为1,否则为0</td><td>(a &amp; b) 输出结果 12 ，二进制解释： 0000 1100</td></tr><tr><td>|</td><td>按位或运算符：只要对应的二个二进位有一个为1时，结果位就为1。</td><td>(a | b) 输出结果 61 ，二进制解释： 0011 1101</td></tr><tr><td>^</td><td>按位异或运算符：当两对应的二进位相异时，结果为1</td><td>(a ^ b) 输出结果 49 ，二进制解释： 0011 0001</td></tr><tr><td>~</td><td>按位取反运算符：对数据的每个二进制位取反,即把1变为0,把0变为1。~x 类似于 -x-1</td><td>(~a ) 输出结果 -61 ，二进制解释： 1100 0011， 在一个有符号二进制数的补码形式。</td></tr><tr><td>&lt;&lt;</td><td>左移动运算符：运算数的各二进位全部左移若干位，由&quot;&lt;&lt;&quot;右边的数指定移动的位数，高位丢弃，低位补0。</td><td>a &lt;&lt; 2 输出结果 240 ，二进制解释： 1111 0000</td></tr><tr><td>&gt;&gt;</td><td>右移动运算符：把&quot;&gt;&gt;“左边的运算数的各二进位全部右移若干位，”&gt;&gt;&quot;右边的数指定移动的位数</td><td>a &gt;&gt; 2 输出结果 15 ，二进制解释： 0000 1111</td></tr></tbody></table></blockquote></li><li><p>逻辑运算符</p><blockquote><table><thead><tr><th>运算符</th><th>逻辑表达式</th><th>描述</th></tr></thead><tbody><tr><td>and</td><td>x and y</td><td>布尔&quot;与&quot; - 如果 x 为 False，x and y 返回 x 的值，否则返回 y 的计算值。</td></tr><tr><td>or</td><td>x or y</td><td>布尔&quot;或&quot; - 如果 x 是 True，它返回 x 的值，否则它返回 y 的计算值。</td></tr><tr><td>not</td><td>not x</td><td>布尔&quot;非&quot; - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td></tr></tbody></table></blockquote></li><li><p>成员运算符</p><blockquote><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>in</td><td>如果在指定的序列中找到值返回 True，否则返回 False。</td></tr><tr><td>not in</td><td>如果在指定的序列中没有找到值返回 True，否则返回 False。</td></tr></tbody></table></blockquote></li><li><p>身份运算符</p><blockquote><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>is</td><td>is 是判断两个标识符是不是引用自一个对象</td></tr><tr><td>is not</td><td>is not 是判断两个标识符是不是引用自不同对象</td></tr></tbody></table></blockquote></li></ol><h1>2. 基本数据类型</h1><h2 id="2-1-数字-Number">2.1 数字(Number)</h2><ol><li><strong>int</strong> (整数)<ul><li>只有一种整数类型 int，表示为长整型，没有 Long</li></ul></li><li><strong>bool</strong> (布尔)<ul><li>bool 是 int 的子类，True / 1 和 False / 0 可以和数字相加</li></ul></li><li><strong>float</strong> (浮点数)<ul><li>如 1.23、3E-2</li></ul></li><li><strong>complex</strong> (复数)<ul><li>如 1 + 2j、 1.1 + 2.2j</li></ul></li></ol><blockquote><table><thead><tr><th>函数</th><th>返回值 ( 描述 )</th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/python3/python3-func-number-abs.html">abs(x)</a></td><td>返回数字的绝对值，如abs(-10) 返回 10</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-ceil.html">ceil(x)</a></td><td>返回数字的上入整数，如math.ceil(4.1) 返回 5</td></tr><tr><td>cmp(x, y)</td><td>如果 x &lt; y 返回 -1, 如果 x == y 返回 0, 如果 x &gt; y 返回 1。 <strong>Python 3 已废弃，使用 (x&gt;y)-(x&lt;y) 替换</strong>。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-exp.html">exp(x)</a></td><td>返回e的x次幂(ex),如math.exp(1) 返回2.718281828459045</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-fabs.html">fabs(x)</a></td><td>以浮点数形式返回数字的绝对值，如math.fabs(-10) 返回10.0</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-floor.html">floor(x)</a></td><td>返回数字的下舍整数，如math.floor(4.9)返回 4</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-log.html">log(x)</a></td><td>如math.log(math.e)返回1.0,math.log(100,10)返回2.0</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-log10.html">log10(x)</a></td><td>返回以10为基数的x的对数，如math.log10(100)返回 2.0</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-max.html">max(x1, x2,…)</a></td><td>返回给定参数的最大值，参数可以为序列。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-min.html">min(x1, x2,…)</a></td><td>返回给定参数的最小值，参数可以为序列。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-modf.html">modf(x)</a></td><td>返回x的整数部分与小数部分，两部分的数值符号与x相同，整数部分以浮点型表示。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-pow.html">pow(x, y)</a></td><td>x**y 运算后的值。</td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-round.html">round(x [,n])</a></td><td>返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数。<br><br><strong>其实准确的说是保留值将保留到离上一位更近的一端。</strong></td></tr><tr><td><a href="https://www.runoob.com/python3/python3-func-number-sqrt.html">sqrt(x)</a></td><td>返回数字x的平方根。</td></tr></tbody></table></blockquote><h2 id="2-2-字符串-String">2.2 字符串(String)</h2><ol><li>字符串用单引号 ’ 或双引号 &quot; 括起来，单引号 ’ 和双引号 &quot; 的使用完全相同，使用三引号(‘’’ 或 “”&quot;)可以指定一个多行字符串；</li><li>使用反斜杠 \ 转义特殊字符，使用 r 可以让反斜杠不发生转义。 如 <strong>r&quot;this is a line with \n&quot;</strong> 则 \n 会显示，并不是换行；</li><li>字符串的截取 / 切片<ul><li><code>字符串[start:end:step]</code>，左含右不含、步长参数 step，step 为负数时表示逆向；</li><li>索引值以 0 为开始值，-1 为从末尾的开始位置；</li><li>加号 + 是字符串的连接符， 星号 * 表示复制当前字符串；</li></ul></li><li>Python 没有单独的字符类型，一个字符就是长度为 1 的字符串；</li><li>字符串不能通过索引赋值、修改元素值；</li></ol><h2 id="2-3-布尔-Bool">2.3 布尔(Bool)</h2><ol><li>布尔类型只有两个值：True 和 False，等价于 1 和 0；</li><li>布尔类型可以转换成其他数据类型；</li><li>使用 <code>bool()</code> 函数将其他类型的值转换为布尔值；</li><li>布尔类型可以和逻辑运算符一起使用，包括 and、or 和 not；</li></ol><h2 id="2-4-列表-List">2.4 列表(List)</h2><ol><li>列表写在方括号 [] 之间、用逗号分隔元素；</li><li>列表中的元素类型可以互不相同；</li><li>列表可以通过索引赋值、修改元素值；</li><li>列表的截取 / 切片<ul><li><code>列表[start:end:step]</code>，左含右不含、步长参数 step，step 为负数时表示逆向；</li><li>索引值以 0 为开始值，-1 为从末尾的开始位置；</li><li>加号 + 是列表的连接符， 星号 * 表示复制当前列表；</li></ul></li></ol><h2 id="2-5-元组-Tuple">2.5 元组(Tuple)</h2><ol><li>元组写在小括号 () 之间、用逗号分隔元素；</li><li>元组中的元素类型可以互不相同；</li><li>元组不能通过索引赋值、修改元素值；</li><li>元组的截取 / 切片<ul><li><code>元组[start:end:step]</code>，左含右不含、步长参数 step，step 为负数时表示逆向；</li><li>索引值以 0 为开始值，-1 为从末尾的开始位置；</li><li>加号 + 是元组的连接符， 星号 * 表示复制当前元组；</li></ul></li><li>构造包含 0 个或 1 个元素的元组比较特殊<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup1 = () <span class="comment"># 空元组</span></span><br><span class="line">tup2 = (<span class="number">20</span>,) <span class="comment"># 一个元素，需要在元素后添加逗号</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="2-6-集合-Set">2.6 集合(Set)</h2><ol><li>集合写在大括号 {} 之间、用逗号分隔元素，另外也可以使用 <code>set()</code> 函数创建集合；</li><li>创建一个空集合必须用 <code>set()</code> 而不是 <code>&#123; &#125;</code>， <code>&#123; &#125;</code> 用于创建空字典；</li><li>集合是一种无序、可变的数据类型，其中的元素不会重复；</li><li>集合运算<ul><li>交集 &amp;</li><li>并集 |</li><li>差集 -</li><li>两集合中不同时存在的元素 ^</li></ul></li></ol><h2 id="2-7-字典-Dictionary">2.7 字典(Dictionary)</h2><ol><li>字典是一种映射类型，字典用 <code>&#123; &#125;</code> 标识，它是一个无序的 <strong>键(key) : 值(value)</strong> 的集合；</li><li>在同一个字典中，键必须是唯一的，且键必须使用不可变类型；</li><li>字典的创建<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dict1 = &#123;&#125;</span><br><span class="line">dict1[<span class="string">&#x27;one&#x27;</span>] = <span class="string">&quot;1 A&quot;</span></span><br><span class="line">dict1[<span class="number">2</span>] = <span class="string">&quot;2 F&quot;</span></span><br><span class="line"></span><br><span class="line">dict2 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Ang&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="string">&#x27;18&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典推导式</span></span><br><span class="line">dict3 = &#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)&#125;</span><br><span class="line"></span><br><span class="line">x = [<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;D&#x27;</span>]</span><br><span class="line">y = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">dict4 = &#123;i:j <span class="keyword">for</span> i,j <span class="keyword">in</span> <span class="built_in">zip</span>(x,y)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># dict 函数</span></span><br><span class="line">dict5 = <span class="built_in">dict</span>(Runoob=<span class="number">1</span>, Google=<span class="number">2</span>, Taobao=<span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li>键值对输出<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dic1 = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="keyword">for</span> k,v. <span class="keyword">in</span> dict1.items():</span><br><span class="line">    <span class="built_in">print</span>(k, <span class="string">&#x27;:&#x27;</span>, v)</span><br></pre></td></tr></table></figure></li></ol><h1>3. 基本数据类型的转换</h1><h2 id="3-1-隐式类型转换">3.1 隐式类型转换</h2><ol><li>对两种不同类型的数据进行运算时，较低数据类型会转换为较高数据类型以避免数据丢失；<ul><li>当整数与浮点数进行运算时，整数会被自动转换为浮点数；</li><li>布尔值在与数字进行运算时会被自动转换为整数，<code>True</code> 被视为 <code>1</code>，<code>False</code> 被视为 <code>0</code>；</li></ul></li><li>数据类型的高低：bool &lt; int &lt; float &lt; complex</li></ol><h2 id="3-2-显式类型转换">3.2 显式类型转换</h2><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>int(x [,base])</td><td>将x转换为一个整数</td></tr><tr><td>float(x)</td><td>将x转换到一个浮点数</td></tr><tr><td>complex(real [,imag])</td><td>创建一个复数</td></tr><tr><td>str(x)</td><td>将对象 x 转换为字符串</td></tr><tr><td>repr(x)</td><td>将对象 x 转换为表达式字符串</td></tr><tr><td>eval(str)</td><td>用来计算在字符串中的有效Python表达式,并返回一个对象</td></tr><tr><td>tuple(s)</td><td>将序列 s 转换为一个元组</td></tr><tr><td>list(s)</td><td>将序列 s 转换为一个列表</td></tr><tr><td>set(s)</td><td>转换为可变集合</td></tr><tr><td>dict(d)</td><td>创建一个字典。d 必须是一个 (key, value)元组序列。</td></tr><tr><td>frozenset(s)</td><td>转换为不可变集合</td></tr><tr><td>chr(x)</td><td>将一个整数转换为一个字符</td></tr><tr><td>ord(x)</td><td>将一个字符转换为它的整数值</td></tr><tr><td>hex(x)</td><td>将一个整数转换为一个十六进制字符串</td></tr><tr><td>oct(x)</td><td>将一个整数转换为一个八进制字符串</td></tr></tbody></table><h1>4. 条件控制</h1><h2 id="4-1-if-elif-else">4.1 if-elif-else</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> condition_1:</span><br><span class="line">    statement_block_1</span><br><span class="line"><span class="keyword">elif</span> condition_2:</span><br><span class="line">    statement_block_2</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    statement_block_3</span><br></pre></td></tr></table></figure><ul><li>每个条件后面要使用冒号，表示接下来是满足条件后要执行的语句块。</li><li>如果 if 的执行语句只有一句，可以写在 if 的同一行。</li></ul><h2 id="4-2-match-case">4.2 match-case</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> subject:</span><br><span class="line">    <span class="keyword">case</span> &lt;pattern_1&gt;:</span><br><span class="line">        &lt;action_1&gt;</span><br><span class="line">    <span class="keyword">case</span> &lt;pattern_2&gt;:</span><br><span class="line">        &lt;action_2&gt;</span><br><span class="line">    <span class="keyword">case</span> &lt;pattern_3&gt;:</span><br><span class="line">        &lt;action_3&gt;</span><br><span class="line">    <span class="keyword">case</span> _:</span><br><span class="line">        &lt;action_wildcard&gt;</span><br></pre></td></tr></table></figure><ul><li>case _: 类似于 C 和 Java 中的 <strong>default:</strong>，当其他 case 都无法匹配时，匹配这条，保证永远会匹配成功。</li></ul><h1>5. 循环语句</h1><h2 id="5-1-while">5.1 while</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> &lt;expr&gt;:</span><br><span class="line">    &lt;statement(s)&gt;</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    &lt;additional_statement(s)&gt;</span><br></pre></td></tr></table></figure><ul><li>如果 while 的执行语句只有一句，可以写在 while 的同一行。</li></ul><h2 id="5-2-for">5.2 for</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> iterable:</span><br><span class="line">    <span class="comment"># 循环主体</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 循环结束后执行的代码</span></span><br></pre></td></tr></table></figure><h2 id="5-3-break-continue-pass">5.3 break &amp; continue &amp; pass</h2><ul><li><strong>break</strong> 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。</li><li><strong>continue</strong> 语句被用来告诉 Python 跳过当前循环块中的剩余语句，然后继续进行下一轮循环。</li><li><strong>pass</strong> 不做任何事情，一般用做占位语句。</li></ul><h1>6. 推导式</h1><h2 id="6-1-列表推导式">6.1 列表推导式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表]</span><br><span class="line"></span><br><span class="line">或者 </span><br><span class="line"></span><br><span class="line">[表达式 <span class="keyword">for</span> 变量 <span class="keyword">in</span> 列表 <span class="keyword">if</span> 条件]</span><br></pre></td></tr></table></figure><p>e.g. 过滤掉长度小于或等于3的字符串列表，并将剩下的转换成大写字母</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">names = [<span class="string">&#x27;Bob&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;alice&#x27;</span>,<span class="string">&#x27;Jerry&#x27;</span>,<span class="string">&#x27;Wendy&#x27;</span>,<span class="string">&#x27;Smith&#x27;</span>]</span><br><span class="line">new_names = [name.upper()<span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> <span class="built_in">len</span>(name)&gt;<span class="number">3</span>]</span><br><span class="line"><span class="built_in">print</span>(new_names)</span><br></pre></td></tr></table></figure><h2 id="6-2-字典推导式">6.2 字典推导式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection &#125;</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">&#123; key_expr: value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition &#125;</span><br></pre></td></tr></table></figure><p>e.g. 将列表中各字符串值为键，各字符串的长度为值，组成键值对</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">listdemo = [<span class="string">&#x27;Google&#x27;</span>,<span class="string">&#x27;Runoob&#x27;</span>, <span class="string">&#x27;Taobao&#x27;</span>]</span><br><span class="line">newdict = &#123;key:<span class="built_in">len</span>(key) <span class="keyword">for</span> key <span class="keyword">in</span> listdemo&#125;</span><br><span class="line"><span class="built_in">print</span>(newdict)</span><br></pre></td></tr></table></figure><h2 id="6-3-集合推导式">6.3 集合推导式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> &#125;</span><br><span class="line">或</span><br><span class="line">&#123; expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional &#125;</span><br></pre></td></tr></table></figure><p>e.g. 判断不是 abc 的字母并输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="string">&#x27;abracadabra&#x27;</span> <span class="keyword">if</span> x <span class="keyword">not</span> <span class="keyword">in</span> <span class="string">&#x27;abc&#x27;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><h2 id="6-4-元组推导式">6.4 元组推导式</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> )</span><br><span class="line">或</span><br><span class="line">(expression <span class="keyword">for</span> item <span class="keyword">in</span> <span class="type">Sequence</span> <span class="keyword">if</span> conditional )</span><br></pre></td></tr></table></figure><ul><li>元组推导式返回的结果是一个生成器对象，使用 tuple() 函数，可以直接将生成器对象转换成元组；</li></ul><p>e.g. 生成一个包含数字 1~9 的元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">t = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>))</span><br><span class="line"><span class="built_in">print</span>(t) <span class="comment"># 输出 &lt;generator object &lt;genexpr&gt; at 0x104b0e890&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(t)) <span class="comment"># 输出 (1, 2, 3, 4, 5, 6, 7, 8, 9)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># range() 返回的是一个可迭代对象，而不是一个列表</span></span><br><span class="line"><span class="comment"># 如果需要列表，可以使用 list() 函数将其转换</span></span><br></pre></td></tr></table></figure><h1>7. 迭代器 &amp; 生成器</h1><h2 id="7-1-迭代器">7.1 迭代器</h2><h3 id="（1）概念">（1）概念</h3><blockquote><p>在 Python 中，迭代器（Iterator）是一种用于遍历集合（如列表、元组、字典等）元素的对象。迭代器遵循迭代协议，主要包括两个方法：<code>__iter__()</code> 和 <code>__next__()</code>。下面是对迭代器的详细解释：</p><ol><li>迭代器的基本概念</li></ol><ul><li><strong>迭代器对象</strong>：实现了 <code>__iter__()</code> 和 <code>__next__()</code> 方法的对象。</li><li><strong>可迭代对象</strong>：实现了 <code>__iter__()</code> 方法的对象，可以返回一个迭代器。</li></ul><ol start="2"><li>迭代器的工作原理</li></ol><ul><li><strong><code>__iter__()</code> 方法</strong>：返回迭代器对象本身。通常在可迭代对象上调用时会返回一个迭代器。</li><li><strong><code>__next__()</code> 方法</strong>：返回序列中的下一个值。如果没有更多的值可返回，应该抛出 <code>StopIteration</code> 异常。</li></ul></blockquote><h3 id="（2）从集合生成迭代器">（2）从集合生成迭代器</h3><ul><li>可迭代对象：可以使用 <code>for</code> 循环遍历的对象，如列表、元组、字典、集合等。可迭代对象实现了 <code>__iter__()</code> 方法。</li><li>基本方法：iter()；next()</li></ul><p>e.g. 从列表生成迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原列表</span></span><br><span class="line">list_a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代器对象</span></span><br><span class="line">it = <span class="built_in">iter</span>(list_a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出单个元素，使用 next() 方法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环输出剩余元素，使用 for/while 循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> it:</span><br><span class="line"><span class="built_in">print</span>(i, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># while 循环注意结束条件</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(it))</span><br><span class="line"><span class="keyword">except</span> StopIteration:</span><br><span class="line">sys.exit()</span><br></pre></td></tr></table></figure><h3 id="（3）创建自定义迭代器">（3）创建自定义迭代器</h3><ul><li>通过定义一个类并实现 _<em>iter</em>_\ 和 _<em>next</em>_\ 两个方法来创建自定义迭代器。例如：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建迭代器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyIterator</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, <span class="built_in">max</span></span>):</span><br><span class="line">        self.<span class="built_in">max</span> = <span class="built_in">max</span></span><br><span class="line">        self.current = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__iter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__next__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> self.current &lt; self.<span class="built_in">max</span>:</span><br><span class="line">            result = self.current</span><br><span class="line">            self.current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用自定义迭代器</span></span><br><span class="line">my_iter = MyIterator(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> my_iter:</span><br><span class="line">    <span class="built_in">print</span>(num) <span class="comment"># 输出 0 1 2 3 4</span></span><br></pre></td></tr></table></figure><h3 id="（4）迭代器与可迭代对象的区别">（4）迭代器与可迭代对象的区别</h3><ul><li><strong>可迭代对象</strong>：可以使用 <code>for</code> 循环遍历的对象，如列表、元组、字典、集合等。可迭代对象实现了 <code>__iter__()</code> 方法。</li><li><strong>迭代器</strong>：是可迭代对象的一个实现，具有 <code>__iter__()</code> 和 <code>__next__()</code> 方法。迭代器可以在遍历时保持状态。</li></ul><h2 id="7-2-生成器">7.2 生成器</h2><h3 id="（1）概念-2">（1）概念</h3><blockquote><p>在 Python 中，生成器（Generator）是一种特殊类型的迭代器，用于创建可迭代的序列。生成器的主要特点是它们使用 <code>yield</code> 语句来返回值，而不是使用 <code>return</code> 语句。生成器在每次调用时会记住上一次的状态，从而实现惰性求值。</p><ul><li><strong>生成器函数</strong>：使用 <code>yield</code> 语句定义的函数。调用生成器函数不会立即执行，而是返回一个生成器对象。</li><li><strong>生成器对象</strong>：可以被迭代的对象，支持 <code>__iter__()</code> 和 <code>__next__()</code> 方法。</li></ul></blockquote><h3 id="（2）创建生成器">（2）创建生成器</h3><ul><li>生成器函数的定义与普通函数类似，但使用 <code>yield</code> 语句来返回值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">n</span>):</span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a  <span class="comment"># 当运行到这里时，就会停止，直到再次调用 next，会接着从这里继续生成 a</span></span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出值</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(f), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure><h3 id="（3）生成器的工作原理">（3）生成器的工作原理</h3><ul><li>当调用生成器函数时，函数体不会立即执行，而是返回一个生成器对象。</li><li>每次调用生成器对象的 <code>__next__()</code> 方法时，函数会从上次 <code>yield</code> 语句停止的地方继续执行，直到遇到下一个 <code>yield</code> 语句。</li><li>当没有更多的 <code>yield</code> 语句可执行时，生成器会抛出 <code>StopIteration</code> 异常，表示迭代结束。</li></ul><h1>8. 函数</h1><h2 id="8-1-定义-调用函数">8.1 定义 / 调用函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>（参数列表）:</span><br><span class="line"><span class="comment"># 函数说明</span></span><br><span class="line">    函数体</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">返回值 = 函数名(参数)</span><br></pre></td></tr></table></figure><p>python 函数的参数传递：</p><ul><li><p><strong>不可变类型</strong>：类似 C++ 的值传递，不可变类型对象包括 整数、字符串、元组。对于不可变类型对象 a，调用 fun(a) 时，传递的只是 a 的值，没有影响 a 对象本身。如果在 fun(a) 内部修改 a 的值，则是新生成一个 a 的对象，函数外部的 a 不会受影响。</p></li><li><p><strong>可变类型</strong>：类似 C++ 的引用传递，可变类型对象包括 列表，字典。对于可变类型对象 b，调用 fun(b) 时，则是将 b 真正的传过去，修改后 fun 外部的 b 也会受影响。</p></li></ul><h2 id="8-2-函数参数">8.2 函数参数</h2><h3 id="（1）必需参数">（1）必需参数</h3><ul><li>必需参数须以正确的顺序传入函数。调用时的数量必须和声明时的一样，否则会因缺少参数而报错。</li></ul><h3 id="（2）关键字参数">（2）关键字参数</h3><ul><li>关键字参数和函数调用关系紧密，函数调用使用关键字参数来确定传入的参数值。</li><li>使用关键字参数允许函数调用时参数的顺序与声明时不一致，因为 Python 解释器能够用参数名匹配参数值。</li></ul><p>e.g.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可写函数说明</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> name, age </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的字符串&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;名字: &quot;</span>, name)</span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;年龄: &quot;</span>, age)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 调用printinfo函数</span></span><br><span class="line">printinfo( age=<span class="number">50</span>, name=<span class="string">&quot;runoob&quot;</span> )</span><br></pre></td></tr></table></figure><h3 id="（3）默认参数">（3）默认参数</h3><ul><li>调用函数时，如果没有传递参数，则会使用默认参数</li></ul><h3 id="（4）不定长参数">（4）不定长参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个 * 的参数会以元组形式导入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">functionname</span>(<span class="params">[formal_args,] *var_args_tuple </span>):</span><br><span class="line">   <span class="string">&quot;函数_文档字符串&quot;</span></span><br><span class="line">   function_suite</span><br><span class="line">   <span class="keyword">return</span> [expression]</span><br><span class="line">   </span><br><span class="line"><span class="comment"># 两个 * 的参数会以字典形式导入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printinfo</span>(<span class="params"> arg1, **vardict </span>):</span><br><span class="line">   <span class="string">&quot;打印任何传入的参数&quot;</span></span><br><span class="line">   <span class="built_in">print</span> (<span class="string">&quot;输出: &quot;</span>)</span><br><span class="line">   <span class="built_in">print</span> (arg1)</span><br><span class="line">   <span class="built_in">print</span> (vardict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单独出现 *，则 * 以后的所有参数都需要带上参数名称再传入</span></span><br><span class="line"><span class="comment"># 函数定义</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a,b,*,c</span>):</span><br><span class="line"><span class="keyword">return</span> a+b+c</span><br><span class="line"><span class="comment"># 函数调用</span></span><br><span class="line">f(<span class="number">1</span>,<span class="number">2</span>,c=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制位置参数 /</span></span><br><span class="line"><span class="comment"># 函数定义</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a, b, /, c, d, *, e, f</span>):</span><br><span class="line"><span class="built_in">print</span>(a, b, c, d, e, f)</span><br><span class="line"><span class="comment"># 函数调用</span></span><br><span class="line">f(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, d=<span class="number">40</span>, e=<span class="number">50</span>, f=<span class="number">60</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 形参 a 和 b 必须使用指定位置参数，c 或 d 可以是位置形参或关键字形参，而 e 和 f 要求为关键字形参</span></span><br></pre></td></tr></table></figure><ul><li>加了星号 * 的参数会以元组(tuple)的形式导入，存放所有未命名的变量参数</li><li>可以不向函数传递未命名的变量，如果在函数调用时没有指定参数，它就是一个空元组</li><li>加了两个星号 ** 的参数会以字典的形式导入</li><li>如果单独出现星号 * ，则星号 * 后的参数必须用关键字传入</li><li>强制位置参数：Python3.8 新增了一个函数形参语法 / 用来指明函数形参必须使用指定位置参数，不能使用关键字参数的形式。</li></ul><h2 id="8-3-lambda-匿名函数">8.3 lambda 匿名函数</h2><h3 id="（1）概念-3">（1）概念</h3><p>在 Python 中，<code>lambda</code> 函数是一种小型、匿名的、内联函数，它可以具有任意数量的参数，但只能有一个表达式。与常规的函数定义（使用 <code>def</code> 关键字）相比，<code>lambda</code> 函数通常用于需要快速定义简单函数的场景。</p><p>① <code>lambda</code> 函数的基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> arguments: expression</span><br></pre></td></tr></table></figure><ul><li><strong>arguments</strong>: 输入参数，可以是多个，用逗号分隔。</li><li><strong>expression</strong>: 一个表达式，返回值是这个表达式的计算结果。</li></ul><p>② 示例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个简单的 lambda 函数</span></span><br><span class="line">add = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 lambda 函数</span></span><br><span class="line">result = add(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: 8</span></span><br></pre></td></tr></table></figure><h3 id="（2）应用（使用-lambda-函数作为参数）">（2）应用（使用 <code>lambda</code> 函数作为参数）</h3><p><code>lambda</code> 函数常用于需要函数作为参数的场景，例如在 <code>map()</code>, <code>filter()</code>, 和 <code>sorted()</code> 函数中。<br>① <code>map()</code></p><ul><li><code>map()</code> 函数用于将指定函数应用于给定可迭代对象的每个元素，并返回一个迭代器<ul><li><code>map(function, iterable)</code></li><li>function: 要应用的函数（可以是 <code>lambda</code> 函数）</li><li>iterable: 要处理的可迭代对象（如列表、元组等）</li></ul></li><li>示例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, numbers)) <span class="comment"># map 会遍历 numbers 中的每个元素，并将每个元素传递给 lambda 函数，计算完成后作为 map 迭代器的结果，需要时输出</span></span><br><span class="line"><span class="built_in">print</span>(squared)  <span class="comment"># 输出: [1, 4, 9, 16, 25]</span></span><br></pre></td></tr></table></figure><p>② <code>filter()</code></p><ul><li><code>filter()</code> 函数用于过滤可迭代对象中的元素，返回满足条件的元素<ul><li><code>filter(function, iterable)</code></li><li>遍历每个元素，如果满足 function 中的条件(返回 True)，则保留该元素；否则，丢弃该元素</li></ul></li><li>示例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">even_numbers = <span class="built_in">list</span>(<span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, numbers)) <span class="comment"># filter 会遍历 numbers 中的每个元素，并将每个元素传递给 lambda 函数，判断元素是否为偶数，是偶数则保留，否则丢弃该元素</span></span><br><span class="line"><span class="built_in">print</span>(even_numbers)  <span class="comment"># 输出: [2, 4]</span></span><br></pre></td></tr></table></figure><p>③ <code>sorted()</code></p><ul><li><code>sorted()</code> 函数用于对可迭代对象进行排序，可以使用 <code>lambda</code> 函数自定义排序规则。<ul><li><code>sorted(iterable, key=None, reverse=False)</code></li><li>key 是一个函数，用于从每个元素中提取比较键</li><li>默认升序排列，reverse=True，则调整为降序</li></ul></li><li>示例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">points = [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">5</span>, <span class="number">0</span>), (<span class="number">0</span>, <span class="number">3</span>)]</span><br><span class="line">sorted_points = <span class="built_in">sorted</span>(points, key=<span class="keyword">lambda</span> point: point[<span class="number">1</span>])  <span class="comment"># sorted 会遍历 points 中的每个元组，并将每个元组传递给 lambda 函数，lambda 会提取每个元组的第二个元素（y 坐标）作为排序的依据，最终按 key（y坐标）排序</span></span><br><span class="line"><span class="built_in">print</span>(sorted_points)  <span class="comment"># 输出: [(5, 0), (3, 1), (1, 2), (0, 3)]</span></span><br></pre></td></tr></table></figure><h3 id="（3）注意">（3）注意</h3><ul><li><strong>单行表达式</strong>：<code>lambda</code> 函数只能包含一个表达式，不能包含多个语句或复杂的逻辑。</li><li><strong>可读性</strong>：虽然 <code>lambda</code> 函数可以使代码更简洁，但在复杂的情况下，使用常规的 <code>def</code> 函数可能会提高代码的可读性。</li><li><strong>命名</strong>：<code>lambda</code> 函数是匿名的，但可以赋值给变量以便后续使用。</li></ul><h1>9. 装饰器</h1><h2 id="9-1-概念">9.1 概念</h2><h3 id="（1）定义">（1）定义</h3><p>在 Python 中，装饰器（decorator）是一种用于修改或增强函数或方法行为的设计模式。装饰器本质上是一个函数，它接受另一个函数作为参数，并返回一个新的函数。通过使用装饰器，可以在不修改原始函数代码的情况下，添加额外的功能或行为。</p><h3 id="（2）常见用途">（2）常见用途</h3><ul><li><strong>日志记录</strong>：记录函数的调用信息。</li><li><strong>权限检查</strong>：在执行函数之前检查用户权限。</li><li><strong>缓存</strong>：缓存函数的返回值以提高性能。</li><li><strong>输入验证</strong>：验证函数参数的有效性。</li></ul><h2 id="9-2-装饰器的基本语法">9.2 装饰器的基本语法</h2><ul><li>装饰器通常使用 <code>@decorator_name</code> 语法来应用，放在被装饰函数的定义上方</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义 装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something is happening before the function is called.&quot;</span>)</span><br><span class="line">        func()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Something is happening after the function is called.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用 装饰器</span></span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"></span><br><span class="line">say_hello() <span class="comment"># 输出三行句子</span></span><br></pre></td></tr></table></figure><h2 id="9-3-带参数的装饰器">9.3 带参数的装饰器</h2><ul><li>装饰器也可以接受参数。为了实现这一点，通常需要在最外层再嵌套一层函数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义 含参数的装饰器</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">repeat</span>(<span class="params">num_times</span>):</span><br><span class="line"><span class="comment"># 最外层用于定义参数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decorator_repeat</span>(<span class="params">func</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(num_times):</span><br><span class="line">                func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator_repeat</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用 装饰器</span></span><br><span class="line"><span class="meta">@repeat(<span class="params">num_times=<span class="number">3</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">greet(<span class="string">&quot;Alice&quot;</span>) <span class="comment"># 重复输出三次 Hello, Alice!</span></span><br></pre></td></tr></table></figure><h1>10. 数据结构</h1><h2 id="10-1-将列表当作栈使用">10.1 将列表当作栈使用</h2><ul><li>在 Python 中，可以使用列表（list）来实现栈的功能。栈是一种后进先出（LIFO, Last-In-First-Out）数据结构，意味着最后添加的元素最先被移除。</li><li>用 append() 方法可以把一个元素添加到栈顶，用不指定索引的 pop() 方法可以把一个元素从栈顶释放出来。</li></ul><blockquote><ul><li><strong>压入（Push）</strong>: 将一个元素添加到栈的顶端。</li><li><strong>弹出（Pop）</strong>: 移除并返回栈顶元素。</li><li><strong>查看栈顶元素（Peek/Top）</strong>: 返回栈顶元素而不移除它。</li><li><strong>检查是否为空（IsEmpty）</strong>: 检查栈是否为空。</li><li><strong>获取栈的大小（Size）</strong>: 获取栈中元素的数量。</li></ul><p>1、创建一个空栈</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack = []  </span><br></pre></td></tr></table></figure><p>2、压入（Push）操作</p><ul><li>使用 append() 方法将元素添加到栈的顶端</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack.append(<span class="number">1</span>)  </span><br><span class="line">stack.append(<span class="number">2</span>)  </span><br><span class="line">stack.append(<span class="number">3</span>)  </span><br><span class="line"><span class="built_in">print</span>(stack)  <span class="comment"># 输出: [1, 2, 3]  </span></span><br></pre></td></tr></table></figure><p>3、弹出（Pop）操作</p><ul><li>使用 pop() 方法移除并返回栈顶元素</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">top_element = stack.pop()  </span><br><span class="line"><span class="built_in">print</span>(top_element)  <span class="comment"># 输出: 3  </span></span><br><span class="line"><span class="built_in">print</span>(stack)        <span class="comment"># 输出: [1, 2]  </span></span><br></pre></td></tr></table></figure><p>4、查看栈顶元素（Peek/Top）</p><ul><li>直接访问列表的最后一个元素（不移除）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">top_element = stack[-<span class="number">1</span>]  </span><br><span class="line"><span class="built_in">print</span>(top_element)  <span class="comment"># 输出: 2  </span></span><br></pre></td></tr></table></figure><p>5、检查是否为空（IsEmpty）</p><ul><li>检查列表是否为空</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">is_empty = <span class="built_in">len</span>(stack) == <span class="number">0</span>  </span><br><span class="line"><span class="built_in">print</span>(is_empty)  <span class="comment"># 输出: False  </span></span><br></pre></td></tr></table></figure><p>6、获取栈的大小（Size）</p><ul><li>使用 len() 函数获取栈中元素的数量</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size = <span class="built_in">len</span>(stack)  </span><br><span class="line"><span class="built_in">print</span>(size)  <span class="comment"># 输出: 2</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="10-2-将列表当作队列使用">10.2 将列表当作队列使用</h2><ul><li>在 Python 中，列表（list）可以用作队列（queue），但由于列表的特点，直接使用列表来实现队列并不是最优的选择。</li><li>队列是一种先进先出（FIFO, First-In-First-Out）的数据结构，意味着最早添加的元素最先被移除。</li><li>使用列表时，如果频繁地在列表的开头插入或删除元素，性能会受到影响，因为这些操作的时间复杂度是 O(n)。为了解决这个问题，Python 提供了 collections.deque，它是双端队列，可以在两端高效地添加和删除元素。</li></ul><blockquote><ul><li>collections.deque 是 Python 标准库的一部分，非常适合用于实现队列。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 创建一个空队列  </span></span><br><span class="line">queue = deque()  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 向队尾添加元素  </span></span><br><span class="line">queue.append(<span class="string">&#x27;a&#x27;</span>)  </span><br><span class="line">queue.append(<span class="string">&#x27;b&#x27;</span>)  </span><br><span class="line">queue.append(<span class="string">&#x27;c&#x27;</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列状态:&quot;</span>, queue)  <span class="comment"># 输出: 队列状态: deque([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 从队首移除元素  </span></span><br><span class="line">first_element = queue.popleft()  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;移除的元素:&quot;</span>, first_element)  <span class="comment"># 输出: 移除的元素: a  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列状态:&quot;</span>, queue)            <span class="comment"># 输出: 队列状态: deque([&#x27;b&#x27;, &#x27;c&#x27;])  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 查看队首元素（不移除）  </span></span><br><span class="line">front_element = queue[<span class="number">0</span>]  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队首元素:&quot;</span>, front_element)    <span class="comment"># 输出: 队首元素: b  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 检查队列是否为空  </span></span><br><span class="line">is_empty = <span class="built_in">len</span>(queue) == <span class="number">0</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列是否为空:&quot;</span>, is_empty)     <span class="comment"># 输出: 队列是否为空: False  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 获取队列大小  </span></span><br><span class="line">size = <span class="built_in">len</span>(queue)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列大小:&quot;</span>, size)            <span class="comment"># 输出: 队列大小: 2  </span></span><br></pre></td></tr></table></figure></blockquote><blockquote><ul><li>虽然 deque更高效，但如果坚持使用列表来实现队列，也可以这么做。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 创建队列</span></span><br><span class="line">queue = []  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 向队尾添加元素，使用 append() 方法将元素添加到队尾</span></span><br><span class="line">queue.append(<span class="string">&#x27;a&#x27;</span>)  </span><br><span class="line">queue.append(<span class="string">&#x27;b&#x27;</span>)  </span><br><span class="line">queue.append(<span class="string">&#x27;c&#x27;</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列状态:&quot;</span>, queue)  <span class="comment"># 输出: 队列状态: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 从队首移除元素，使用 pop(0) 方法从队首移除元素</span></span><br><span class="line">first_element = queue.pop(<span class="number">0</span>)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;移除的元素:&quot;</span>, first_element)  <span class="comment"># 输出: 移除的元素: a  </span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列状态:&quot;</span>, queue)            <span class="comment"># 输出: 队列状态: [&#x27;b&#x27;, &#x27;c&#x27;]  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 查看队首元素，直接访问列表的第一个元素</span></span><br><span class="line">front_element = queue[<span class="number">0</span>]  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队首元素:&quot;</span>, front_element)    <span class="comment"># 输出: 队首元素: b  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 检查队列是否为空</span></span><br><span class="line">is_empty = <span class="built_in">len</span>(queue) == <span class="number">0</span>  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列是否为空:&quot;</span>, is_empty)     <span class="comment"># 输出: 队列是否为空: False  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 获取队列大小，使用 len() 函数获取队列的大小</span></span><br><span class="line">size = <span class="built_in">len</span>(queue)  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;队列大小:&quot;</span>, size)            <span class="comment"># 输出: 队列大小: 2  </span></span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <summary type="html">Python 学习笔记</summary>
    
    
    
    <category term="开发" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Python" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/Python/"/>
    
    
    <category term="开发" scheme="https://www.angfff.top/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Python" scheme="https://www.angfff.top/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Java SE 学习笔记 2️⃣</title>
    <link href="https://www.angfff.top/posts/c3baad0f.html"/>
    <id>https://www.angfff.top/posts/c3baad0f.html</id>
    <published>2024-02-02T03:55:17.000Z</published>
    <updated>2025-02-09T03:33:56.699Z</updated>
    
    <content type="html"><![CDATA[<h1>Java SE</h1>]]></content>
    
    
    <summary type="html">Java SE 2️⃣ 类和对象</summary>
    
    
    
    <category term="开发" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Java SE" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/Java-SE/"/>
    
    
    <category term="开发" scheme="https://www.angfff.top/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Java" scheme="https://www.angfff.top/tags/Java/"/>
    
    <category term="Java SE" scheme="https://www.angfff.top/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>Java SE 学习笔记 1️⃣</title>
    <link href="https://www.angfff.top/posts/6b4fa997.html"/>
    <id>https://www.angfff.top/posts/6b4fa997.html</id>
    <published>2024-02-02T03:42:47.000Z</published>
    <updated>2025-02-09T03:33:56.699Z</updated>
    
    <content type="html"><![CDATA[<h1>Java SE</h1><h2 id="一、入门介绍">一、入门介绍</h2><ol><li><p>回顾：</p><ul><li><p>C 语言通过编译，将高级语言代码翻译为计算机能够直接执行的指令；</p></li><li><p>Python 并不会先进行编译，而是直接交给解释器解释执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/09/16/xAe9TspMDtlz8SE.png" alt="image-20220916150119407"></p></li></ul></li><li><p>一般来说，编程语言分为两大类：</p><ul><li><p>**编译型语言：**需要先编译为计算机可以直接执行的命令才可以运行。优点是计算机直接运行，性能高；缺点是与平台密切相关，在一种操作系统上编译的程序，无法在其他非同类操作系统上运行，比如 Windows 下的 exe 程序在 Mac 上就无法运行。</p></li><li><p>**解释型语言：**只需要通过解释器代为执行即可，不需要进行编译。优点是可以跨平台，因为解释是解释器的事情，只需要在各个平台上安装对应的解释器，代码不需要任何修改就可以直接运行；缺点是需要依靠解释器解释执行，效率肯定没直接编译成机器指令运行的快，并且会产生额外的资源占用。</p></li></ul></li><li><p>Java语言（Java之父：James Gosling，詹姆斯·高斯林）</p><blockquote><p>Write Once, Run Anywhere.</p></blockquote><p>这是Java语言的标语，它的目标很明确：一次编写，到处运行，它旨在打破平台的限制，让Java语言可以运行在任何平台上，并且不需要重新编译，实现跨平台运行。</p><p>Java自1995年正式推出以来，已经度过了快28个春秋，而基于Java语言，我们的生活中也有了各种各样的应用：</p><p><img src="https://s2.loli.net/2022/09/16/8SWeCjp6M4ufBk2.png" alt="image-20220916151604563"></p><ul><li><p>诺基亚手机上的很多游戏都是使用Java编写的。</p></li><li><p>安卓系统中的各种应用程序也是使用Java编写的。</p></li><li><p>著名沙盒游戏《Minecraft》也有对应的Java版本，得益于Java跨平台特性，无论在什么操作系统上都可以玩到这款游戏。</p></li><li><p>…</p></li></ul></li><li><p>Java 运行机制</p><p>实际上，Java程序也是需要进行编译才可以运行的，这一点与C语言是一样的，Java程序编译之后会变成 <code>.class</code> 结尾的二进制文件：</p><p><img src="https://s2.loli.net/2022/09/16/5z2OWQb3B9AhwSZ.png" alt="image-20220916153102763"></p><p>不过不同的是，这种二进制文件计算机并不能直接运行，而是需要交给JVM（Java虚拟机）执行。</p><p><img src="https://s2.loli.net/2022/09/16/6HnkcSIfPdVZEpM.png" alt="image-20220916152514450"></p><p>JVM 类似于 Python 解释器，将编译完成的 <code>.class</code> 文件交给 JVM 运行，程序中要做的事情，都由 JVM 告诉计算机该如何去执行。</p><p>在不同的操作系统下，都有对应的 JVM 实现，程序员只需要将 Java 程序编译为 <code>.class</code> 文件就可以直接交给 JVM 运行，无论是什么操作系统，JVM 都采用的同一套标准读取和执行 <code>.class</code> 文件，所以编译之后，在任何平台都可以运行，从而实现跨平台。</p><p>由于 Java 又需要编译同时还需要依靠 JVM 解释执行，所以说 Java <strong>既是编译型语言，也是解释型语言。</strong></p></li><li><p>Java 版本</p><ul><li><p>**JavaSE：**标准版 Java</p></li><li><p>**JavaME：**微缩版 Java，已经基本没人用了。</p></li><li><p>**JavaEE：**企业级 Java，比如网站开发。</p></li></ul></li></ol><h2 id="二、环境安装">二、环境安装</h2><h3 id="（一）JDK-安装">（一）JDK 安装</h3><ol><li><p>JRE 和 JDK 区别</p><ul><li><p><strong>JRE（Java Runtime Environment）</strong>：Java 的运行环境，安装了运行环境之后，Java 程序才可以运行，一般不做开发，只是需要运行 Java 程序直接按照 JRE 即可。</p></li><li><p><strong>JDK（Java Development Kit）</strong>：包含 JRE，并且还附带了大量开发者工具。</p><p><img src="https://s2.loli.net/2022/09/16/MpGWrh5xZdI3bCJ.png" alt="image-20220916154906732"></p></li></ul></li><li><p>JDK 安装</p><ul><li><a href="https://blog.csdn.net/m0_43395703/article/details/119685247?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-119685247-blog-134803032.235%5Ev43%5Epc_blog_bottom_relevance_base3&amp;spm=1001.2101.3001.4242.2&amp;utm_relevant_index=2">ARM Mac JDK 安装教程</a></li><li><a href="https://www.azul.com/downloads">Zulu JDK 下载</a></li></ul></li><li><p>jenv 安装</p><ul><li><a href="https://blog.csdn.net/weixin_52911459/article/details/128063285">jenv 安装</a></li></ul></li></ol><h3 id="（二）Java-版本管理">（二）Java 版本管理</h3><blockquote><p>查看当前 Java 版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java --version</span><br></pre></td></tr></table></figure><p>查看已安装的所有版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jenv versions</span><br></pre></td></tr></table></figure><p>切换不同版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jenv global 1.8</span><br></pre></td></tr></table></figure><p>添加新安装版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jenv add /Library/Java/JavaVirtualMachines/zulu-8.jdk/Contents/Home</span><br></pre></td></tr></table></figure><p>删除已安装版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jenv remove xxx</span><br></pre></td></tr></table></figure></blockquote><h2 id="三、Java-基础">三、Java 基础</h2><h3 id="（一）基础语法">（一）基础语法</h3><ol><li><p>main 主方法，是整个程序的入口点，执行过程从 main 主方法内开始从下往下依次执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>⚠️</p><ul><li>Java 中严格区分大小写；</li><li>每行代码写完后需要添加分号；</li></ul></blockquote></li><li><p>注释的使用</p><ul><li>单行注释 //</li><li>多行注释 /* xxx */</li><li>说明文档 /** xxx */</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> angfff</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>); <span class="comment">//输出语句</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      多行注释</span></span><br><span class="line"><span class="comment">      Test</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>变量</p><ul><li><p>变量声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[数据类型] [变量名称];</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="comment">// 方法一</span></span><br><span class="line">          <span class="type">int</span> X; <span class="comment">// 定义整数类型变量 X</span></span><br><span class="line">          X = <span class="number">10</span>; <span class="comment">// 为 X 赋值为 10</span></span><br><span class="line">          <span class="comment">// 方法二</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">Y</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// 定义变量 Y 并赋值为 20</span></span><br><span class="line">          <span class="comment">// 方法三</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">Z</span> <span class="operator">=</span> Y; <span class="comment">// 定义变量 Z 并赋值为 Y 的值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>关键字 final : 在变量前添加 final 关键字，可以将变量定义为不可变变量（常量），也即只能进行一次赋值，后续不能对其进行修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> x; <span class="comment">// 常量 x</span></span><br><span class="line">        x = <span class="number">10</span>;</span><br><span class="line">        x = <span class="number">20</span>; <span class="comment">// 报错，无法进行修改</span></span><br><span class="line">        System.out.println(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="（二）基本数据类型">（二）基本数据类型</h3><ol><li><p>整数类型</p><ul><li>byte 字节型 （8 个 bit，也就是 1 个字节）范围：-128 ~ +127</li><li>short 短整形（16 个 bit，也就是 2 个字节 / 一个字）范围：-32768 ~ +32767</li><li>int 整形（32 个 bit，也就是 4 个字节 / 双字）最常用的类型，范围：-2147483648 ~ +2147483647</li><li>long 长整形（64 个 bit，也就是 8 个字节 / 四字）范围：-9223372036854775808 ~ +9223372036854775807</li></ul><blockquote><p>补充：隐式类型转换</p><ul><li>从存储范围小的类型到存储范围大的类型，会发生隐式类型转换，自动将某种类型的值，转换为另一种类型。</li><li>实际上我们在为变量赋一个常量数值时，也发生了隐式类型转换，比如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;    <span class="comment">//这里的整数常量10，实际上默认情况下是int类型，但是由于正好在对应类型可以表示的范围内，所以说直接转换为了byte类型的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>由于直接编写的整数常量值默认为<code>int</code>，这里需要特别注意一下，比如下面这种情况：</p><p><img src="https://s2.loli.net/2022/09/16/76GgjWYz4DPBy1p.png" alt="image-20220916232420547"></p><p>按照 <code>long</code> 类型的规定，实际上是可以表示这么大的数字的，但是为什么这里报错了呢？这是因为我们直接在代码中写的常量数字，默认情况下就是 <code>int</code> 类型，这么大肯定是表示不下的，如果需要将其表示为一个 long 类型的常量数字，那么需要在后面添加大写或是小写的 <code>L</code> 才可以。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">922337203685477580L</span>;   <span class="comment">//这样就可以正常编译通过了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>针对于这种很长的数字，为了提升辨识度，我们可以使用下划线分割每一位：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1_000_000</span>;    <span class="comment">//当然这里依然表示的是1000000，没什么区别，但是辨识度会更高</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们也可以以8进制或是16进制表示一个常量值：<ul><li>**十六进制：**以 <code>0x</code> 开头的都是十六进制表示法</li><li>**八进制：**以 0 开头的都是八进制表示法</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="number">0xA</span>);</span><br><span class="line">    System.out.println(<span class="number">012</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>浮点类型</p><ul><li>float 单精度浮点数（32bit，4 字节）</li><li>double 双精度浮点数（64bit，8 字节）</li></ul><blockquote><p><img src="https://s2.loli.net/2022/09/17/CpI5jaWgR9nqTbc.png" alt="image-20220917102209246"></p><p>根据国际标准 IEEE 754，任意一个二进制浮点数 V 可以表示成下面的形式：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>V</mi><mo>=</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>S</mi></msup><mo>×</mo><mi>M</mi><mo>×</mo><msup><mn>2</mn><mi>E</mi></msup></mrow><annotation encoding="application/x-tex">V = (-1)^S \times M \times 2^E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1413em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span></span></span></span></span></span></span></span></p><ul><li>(-1)^S 表示符号位，当 S=0，V 为正数；当 S=1，V 为负数。</li><li>M 表示有效数字，大于等于 1，小于 2，但整数部分的 1 不变，因此可以省略。（例如尾数为 1111010，那么 M 实际上就是1.111010，尾数首位必须是 1，1 后面紧跟小数点，如果出现0001111 这样的情况，去掉前面的 0，移动 1 到首位；题外话：随着时间的发展，IEEE 754标准默认第一位为 1，故为了能够存放更多数据，就舍去了第一位，比如保存 1.0101 的时候， 只保存 0101，这样能够多存储一位数据）</li><li>2^E 表示指数位。（用于移动小数点，所以说才称为浮点型）</li></ul><p>浮点类型的大致取值范围：</p><ul><li>单精度：±3.40282347*10^38</li><li>双精度：±1.79769313486231570 *10^308</li></ul></blockquote><blockquote><p>⚠️ 跟整数类型常量一样，小数类型常量默认都是<code>double</code>类型，所以说如果我们直接给一个float类型赋值：</p><p><img src="https://s2.loli.net/2022/09/17/x7bOzyIacpDowKk.png" alt="image-20220917105141288"></p><p>由于<code>float</code>类型的精度不如<code>double</code>，如果直接给其赋一个double类型的值，会直接出现错误。</p><p>同样的，我们可以给常量后面添加大写或小写的 F 来表示这是一个<code>float</code>类型的常量值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">9.9F</span>;   <span class="comment">//这样就可以正常编译通过了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>⚠️ 隐式类型转换规则总结：</p><p>byte → short(char) → int → long → float → double</p></blockquote></li><li><p>字符类型</p><ul><li>char 字符型（16个bit，2字节，不带符号）范围 0 ~ 65535</li></ul><p><img src="https://s2.loli.net/2022/09/17/Z7AiBPNO6ylML4z.png" alt="img"></p><ul><li>String 字符串类型</li></ul><blockquote><p>⚠️ ’ ’ 单引号用于 char 字符类型；&quot; &quot; 双引号用于 String 字符串类型</p></blockquote></li><li><p>布尔类型</p><ul><li>true  -  真</li><li>false  -  假</li></ul><p>布尔类型（boolean）只有<code>true</code>和<code>false</code>两种值，也就是要么为真，要么为假，布尔类型的变量通常用作流程控制判断语句（不同于C语言，C语言中一般使用0表示false，除0以外的所有数都表示true）布尔类型占据的空间大小并未明确定义，而是根据不同的JVM会有不同的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> <span class="literal">true</span>;   <span class="comment">//值只能是 true 或 false</span></span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="（三）运算符">（三）运算符</h3><ol><li><p>赋值运算符</p><p>赋值运算符可以直接给某个变量赋值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">666</span>;   <span class="comment">//使用等号进行赋值运算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**使用规则为：**赋值运算符的左边必须是一个可以赋值的目标，比如变量，右边可以是任意满足要求的值，包括变量。</p></li><li><p>算术运算符</p><ul><li><p>&quot; + &quot; 加法运算，除了支持算数运算外，还可以对字符串进行拼接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span> + <span class="string">&quot;abc&quot;</span>; </span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span> + <span class="literal">true</span> + <span class="number">1.5</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol><ul><li><p>&quot; - &quot; 减法运算</p></li><li><p>&quot; * &quot; 乘法运算</p></li><li><p>&quot; / &quot; 除法运算</p><p>两个整数在进行除法运算时，得到的结果也是整数（会直接砍掉小数部分，注意不是四舍五入）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>, b = <span class="number">5</span>;</span><br><span class="line">    System.out.println(a / b); <span class="comment">// 结果为 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>&quot; % &quot; 取模（取余数）运算</p></li></ul><blockquote><p>⚠️ 不同类型之间可以进行运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line"> <span class="type">short</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"> <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;   </span><br><span class="line"><span class="comment">//不同类型的整数一起运算，小类型需要转换为大类型；</span></span><br><span class="line"> <span class="comment">//其中 short、byte、char 一律转换为 int 再进行计算（无论算式中有无 int，都需要转换），结果也是 int ；</span></span><br><span class="line"><span class="comment">//如果算式中出现了long类型，那么全部都需要转换到long类型再进行计算，结果也是long，反正就是依大的来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><ol start="3"><li><p>括号运算符</p><ul><li><p>提升优先级</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (a = <span class="number">8</span>) * (-a + <span class="number">10</span>);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1. 括号的优先级是最高的，需要先计算括号中的内容，如果存在多个括号，就从左往右计算</span></span><br><span class="line"><span class="comment">        2. 首先是 a = 8，计算完成之后a变成8，并且运算结果也为8</span></span><br><span class="line"><span class="comment">        3. 然后是后面的加法，-a就是-8，加上10就是2</span></span><br><span class="line"><span class="comment">        4. 最后才是乘法，左边此时是8，右边是2，最后结果为16</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>强制类型转换</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">short</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">short</span>) a;   <span class="comment">//在括号中填写上强制转换的类型，就可以强制转换到对应的类型了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>自增自减运算符</p><ul><li>&quot; ++ &quot; 自增运算符</li><li>&quot; – &quot; 自减运算符</li><li>“+=”、“-=”、“*=”、“/=”、“%=”</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a++;   <span class="comment">//先出结果，再自增</span></span><br><span class="line">    System.out.println(b);  <span class="comment">//b得到的是a自增前的值 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> ++a;   <span class="comment">//先自增，再出结果</span></span><br><span class="line">    System.out.println(b);   <span class="comment">//b得到的是a自增之后的结果 9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>⚠️ 自增运算符放在前面，是先自增再得到结果；而自增运算符放到后面，是先出结果再自增（自减同理）</p><p>⚠️ 自增自减运算符的优先级与正负号等价比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line"> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> -a++ + ++a; </span><br><span class="line"><span class="comment">//我们首先来看前面的a，因为正负号和自增是同一个优先级，结合性是从右往左，所以说先计算a++</span></span><br><span class="line"><span class="comment">//a++的结果还是8，然后是负号，得到-8</span></span><br><span class="line"><span class="comment">//接着是后面的a，因为此时a已经经过前面变成9了，所以说++a就是先自增，再得到10</span></span><br><span class="line"><span class="comment">//最后得到的结果为 -8 + 10 = 2</span></span><br><span class="line"> System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li><li><p>位运算符</p><ul><li><p>&quot; &amp; &quot; 按位与 运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a &amp; b;    <span class="comment">//进行按位与运算</span></span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>按位与，就是让这两个数每一位都进行比较，如果这一位两个数都是 1，那么结果就是 1，否则就是 0：</p><ul><li>a = 9 = 1001</li><li>b = 3 = 0011</li><li>c = 1 = 0001（因为只有最后一位，两个数都是1，所以说结果最后一位是1，其他都是0）</li></ul></blockquote></li><li><p>&quot; | &quot; 按位或 运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a | b;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>按位或，就是只要任意一个为1（不能同时为0）那么结果就是1：</p><ul><li>a = 9 = 1001</li><li>b = 3 = 0011</li><li>c =11= 1011（只要上下有一个是1或者都是1，那结果就是1）</li></ul></blockquote></li><li><p>&quot; ^ &quot; 按位异或 运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">9</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a ^ b;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Java 中并没有乘方运算符，<code>^</code> 是按位异或运算符</p><p>异或，就是只有两边不相同的情况下，结果才是1，也就是说一边是1一边是0的情况：</p><ul><li>a = 9 = 1001</li><li>b = 3 = 0011</li><li>c =10= 1010（从左往右第二位、第四位要么两个都是0，要么两个都是1，所以说结果为0）</li></ul></blockquote></li><li><p>&quot; ~ &quot; 按位取反 运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">c</span> <span class="operator">=</span> ~<span class="number">127</span>;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>按位取反，跟前面的正负号一样，只操作一个数，最好理解，如果这一位上是1，变成0，如果是0，变成1：</p><ul><li>127 = 01111111</li><li>-128 = 10000000</li></ul></blockquote></li><li><p>&quot; &lt;&lt; &quot; 左移；&quot; &lt;&lt; &quot; 右移</p><blockquote><ul><li>**左移操作 &lt;&lt;：**高位直接丢弃，低位补0</li><li>**右移操作 &gt;&gt;：**低位直接丢弃，符号位是什么高位补什么</li></ul></blockquote></li><li><p>&quot; &gt;&gt;&gt; &quot; 无符号右移</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> -<span class="number">1</span> &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    System.out.println(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>-1    =   11111111 11111111 11111111 11111111</li><li>右移：  01111111 11111111 11111111 11111111（无符号右移使用0填充高位）</li></ul><p>此时得到的结果就是正数的最大值</p><p>⚠️ 不存在无符号左移。</p></blockquote></li></ul></li><li><p>关系和逻辑运算符</p><ul><li>关系判断的结果只可能是真或是假，所以说得到的结果是一个<code>boolean</code>类型的值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;   大于</span><br><span class="line">&lt;   小于</span><br><span class="line">==  等于（注意是两个等号连在一起，不是一个等号，使用时不要搞混了）</span><br><span class="line">!=  不等于</span><br><span class="line">&gt;=  大于等于</span><br><span class="line">&lt;=  小于等于</span><br></pre></td></tr></table></figure><ul><li>逻辑运算符</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;&amp;     与运算，要求两边同时为<span class="literal">true</span>才能返回<span class="literal">true</span></span><br><span class="line">||     或运算，要求两边至少要有一个为<span class="literal">true</span>才能返回<span class="literal">true</span></span><br><span class="line">!      非运算，一般放在表达式最前面，表达式用括号扩起来，表示对表达式的结果进行反转</span><br></pre></td></tr></table></figure></li><li><p>三元运算符</p><p>三元运算符可以根据判断条件，返回不同的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span> <span class="variable">b</span> <span class="operator">=</span> a &gt; <span class="number">10</span> ? <span class="string">&#x27;A&#x27;</span> : <span class="string">&#x27;B&#x27;</span>;   <span class="comment">//三元运算符需要三个内容，第一个是判断语句，第二个是满足判断语句的值，第三个是不满足判断语句的值</span></span><br><span class="line">    System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三元运算符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断语句 ? 结果<span class="number">1</span> : 结果<span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>运算符优先级总结</p><table><thead><tr><th style="text-align:center">优先级</th><th style="text-align:center">运算符</th><th style="text-align:center">结合性</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">( )</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">~   -   +  (强制类型转换)  ++   –</td><td style="text-align:center">从右向左</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">*   /  %</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">+   -</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">&lt;&lt;   &gt;&gt;   &gt;&gt;&gt;</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">&gt;   &lt;   &gt;=   &gt;=</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">==     !=</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">&amp;</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">^</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">|</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">&amp;&amp;</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">||</td><td style="text-align:center">从左向右</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">? :</td><td style="text-align:center">从右向左</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">=  +=  -=  *=   /=   %=   &amp;=   |=   ^=   &lt;&lt;=  &gt;&gt;=  &gt;&gt;&gt;=</td><td style="text-align:center">从右向左</td></tr></tbody></table></li></ol><h3 id="（四）流程控制">（四）流程控制</h3><ol><li><p>代码块与作用域</p><p>作用域：在代码块内定义的变量无法在代码块之外使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;   <span class="comment">//此时变量在代码块内定义</span></span><br><span class="line">        System.out.println(a);   <span class="comment">//处于其作用域内部的代码可以调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(a);   <span class="comment">//作用域外的代码无法调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>条件判断</p><ul><li>IF 语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件判断) &#123;</span><br><span class="line">  判断成功执行的代码 <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> () &#123;</span><br><span class="line">  判断成功执行的代码 <span class="number">2</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">  判断成功执行的代码 <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span>  <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(score &gt;= <span class="number">90</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;优秀&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">70</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;良好&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (score &gt;= <span class="number">60</span>)</span><br><span class="line">        System.out.println(<span class="string">&quot;及格&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        System.out.println(<span class="string">&quot;不及格&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Switch 语句</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (目标) &#123;   <span class="comment">//目标变量 或 计算表达式</span></span><br><span class="line">  <span class="keyword">case</span> 匹配值:    <span class="comment">//如目标值等于给定匹配值，执行case的代码</span></span><br><span class="line">    代码...</span><br><span class="line">    <span class="keyword">break</span>;    <span class="comment">//代码执行结束后需要使用break来结束，否则会溜到下一个case继续执行代码</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">case</span> 匹配值:</span><br><span class="line">    代码...</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    代码...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>循环语句</p><ul><li>for 循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (表达式<span class="number">1</span>;表达式<span class="number">2</span>;表达式<span class="number">3</span>) &#123;</span><br><span class="line">  循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>while 循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(循环条件) &#123;</span><br><span class="line">  循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>do……while 循环</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//比如现在我们想看看i不断除以2得到的结果会是什么，但是循环次数我们并不明确</span></span><br><span class="line">    <span class="keyword">do</span> &#123;  <span class="comment">//无论满不满足循环条件，先执行循环体里面的内容</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125; <span class="keyword">while</span> (i &lt; <span class="number">10</span>);   <span class="comment">//再做判断，如果判断成功，开启下一轮循环，否则结束</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>continue 和 break</p><p>⚠️ 就近原则，也可以利用标签指定跳转位置</p><p>a. <code>continue + (标签)</code> 跳过本轮循环进入下一轮</p><p>b. <code>break + (标签)</code> 跳出 / 结束循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">outer: <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">4</span>; ++i) &#123;   <span class="comment">//在循环语句前，添加 标签: 来进行标记</span></span><br><span class="line">    inner: <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j) <span class="keyword">break</span> outer;    <span class="comment">//break后紧跟要结束的循环标记，当i == j时终止外层循环</span></span><br><span class="line">        System.out.println(i+<span class="string">&quot;, &quot;</span>+j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
    
    
    <summary type="html">Java SE 1️⃣ 环境搭建 与 基础语法</summary>
    
    
    
    <category term="开发" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Java SE" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/Java-SE/"/>
    
    
    <category term="开发" scheme="https://www.angfff.top/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="Java" scheme="https://www.angfff.top/tags/Java/"/>
    
    <category term="Java SE" scheme="https://www.angfff.top/tags/Java-SE/"/>
    
  </entry>
  
  <entry>
    <title>软件测试笔记</title>
    <link href="https://www.angfff.top/posts/83eeafe1.html"/>
    <id>https://www.angfff.top/posts/83eeafe1.html</id>
    <published>2024-01-24T13:04:43.000Z</published>
    <updated>2025-02-09T03:33:56.699Z</updated>
    
    <content type="html"><![CDATA[<h1>软件测试</h1><h2 id="一、概述">一、概述</h2><h3 id="（一）基本概念">（一）基本概念</h3><ol><li><p>概念</p><blockquote><p>软件测试是指对软件系统进行验证和评估的过程。它包括通过运行软件系统来检测错误、缺陷和问题，并确保软件能够按照预期的要求和功能正常工作。软件测试的目标是提高软件质量和可靠性，以确保用户能够获得高质量的软件产品。测试人员通常使用各种测试技术和方法，如功能测试、性能测试、安全测试等，来发现并报告潜在的问题。软件测试在软件开发生命周期的不同阶段进行，以确保在发布软件之前发现和修复问题。</p></blockquote></li><li><p>分类：</p><ul><li>功能测试</li><li>性能测试</li><li>安全测试</li></ul></li></ol><h3 id="（二）软件测试重要性">（二）软件测试重要性</h3><blockquote><p>软件测试在软件项目中扮演着至关重要的角色，其重要性体现在以下几个方面：</p><ol><li><p>发现和修复问题：软件测试的主要目标是发现软件系统中的错误、缺陷和问题。通过有效的测试，可以及早发现并修复这些问题，从而提高软件的质量和可靠性。</p></li><li><p>提高用户满意度：通过软件测试，可以确保软件系统按照预期的要求和功能正常工作。这有助于提高用户满意度，满足用户的需求和期望。</p></li><li><p>节约成本和资源：通过在早期发现和修复问题，可以避免将错误和缺陷传递到后续开发阶段，从而节约了修复这些问题所需的成本和资源。</p></li><li><p>降低风险：软件测试有助于降低软件项目的风险。通过检测和修复问题，可以减少软件系统引发故障、数据丢失或安全漏洞等风险的概率。</p></li><li><p>提高软件质量和可靠性：软件测试是提高软件质量和可靠性的关键步骤。通过不断优化和完善测试流程，可以确保软件系统具有较高的质量和可靠性，满足用户的需求。</p></li></ol><p>总之，软件测试在软件项目中的重要性不可忽视。它有助于发现问题、提高用户满意度、节约成本和资源、降低风险，并提高软件质量和可靠性。通过有效的测试，可以确保软件系统交付给用户之前经过充分验证，从而提供高质量的软件产品。</p></blockquote><h2 id="二、功能测试">二、功能测试</h2><h3 id="（一）基本概念-2">（一）基本概念</h3><blockquote><p>功能测试是对软件系统的功能进行验证的测试过程。它主要测试软件是否按照规格说明书或需求文档中所定义的功能进行操作和输出。</p><p>在功能测试中，测试人员通常会使用黑盒测试技术，即仅关注软件的输入和输出，不考虑内部实现细节。常用的功能测试技术包括边界值分析、等价类划分、决策表等。</p></blockquote><h3 id="（二）黑盒测试">（二）黑盒测试</h3><ol><li><p>概念：黑盒测试，它是通过测试来检测每个功能是否都能正常使用。在测试中，把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。</p></li><li><p>作用：</p><blockquote><p>是否有功能错误，是否有功能遗漏。</p><p>是否能够正确地接收输入数据并产生正确的输出结果。</p><p>是否有数据结构错误或外部信息访问错误。</p><p>是否有程序初始化和终止方面的错误。</p></blockquote></li><li><p>测试方法：</p><ol><li><p><strong><u>等价类划分法</u></strong></p><blockquote><p>等价类划分法是一种常用的测试技术，用于减少测试用例的数量，从而提高测试效率。它基于一个假设，即在一个等价类中的测试用例具有相同的测试结果。</p><p>等价类划分法将输入值划分为多个等价类，然后选择代表性的测试用例来代表每个等价类进行测试。</p><p>等价类划分法的步骤如下：</p><ol><li>确定输入值的合法和非法范围。</li><li>将输入值划分为多个等价类，每个等价类包含具有相同测试结果的输入值。</li><li>选择代表性的测试用例来代表每个等价类进行测试。</li></ol><p>例如，假设有一个登录功能，用户名只能包含字母和数字，且长度在6到12个字符之间。根据等价类划分法，可以将输入值划分为以下等价类：</p><ul><li>合法的用户名：包含字母和数字，长度在6到12个字符之间。</li><li>非法的用户名：包含除字母和数字以外的字符。</li><li>非法的用户名：长度小于6个字符或大于12个字符。</li></ul><p>然后，从每个等价类中选择一个或多个代表性的测试用例进行测试，例如选择一个合法的用户名和一个非法的用户名进行测试。</p><p>等价类划分法可以帮助测试人员在覆盖各种输入情况的同时，减少测试用例的数量，提高测试效率。</p></blockquote></li><li><p><strong><u>边界值分析法</u></strong></p><blockquote><p>边界值分析法是一种测试技术，用于确定测试用例的边界条件。它基于一个假设，即在边界上的输入值往往容易引发错误和异常情况。</p><p>边界值分析法通过选择接近边界的测试用例来测试系统的稳定性和准确性。</p><p>边界值分析法的步骤如下：</p><ol><li>确定输入值的合法范围和边界条件。例如，一个输入范围是1到100的整数，边界条件是1和100。</li><li>选择接近边界的测试用例进行测试。通常会选择边界值、边界值的前一个值和边界值的后一个值作为测试用例。</li><li>测试边界值本身的情况以及边界值周围的情况，以确保系统在边界条件下的正确性。</li></ol><p>例如，假设有一个年龄输入框，要求输入的年龄在18到65岁之间。根据边界值分析法，可以选择以下测试用例：</p><ul><li>边界值测试用例：18、65</li><li>边界前一个值测试用例：17（测试小于最小边界的情况）</li><li>边界后一个值测试用例：66（测试大于最大边界的情况）</li></ul><p>边界值分析法可以帮助测试人员发现在边界条件下可能存在的问题和错误，并确保系统在边界条件下的正确性。它也有助于减少测试用例的数量，提高测试效率。</p></blockquote></li><li><p><strong><u>错误推测法</u></strong></p><blockquote><p>错误推测法是基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性的设计测试用例的方法。</p><p>错误推测方法的基本思想： 列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据他们选择测试用例。</p><p>例如，输入数据和输出数据为 0的情况。 输入表格为空格或输入表格只有一行。</p></blockquote></li><li><p><strong><u>决策表</u></strong></p><blockquote><p>决策表法是一种测试技术，用于设计和执行测试用例，以覆盖多个条件组合和对应的行为。它通过创建一个决策表来描述系统的各种条件和相应的行为，并根据不同的条件组合选择相应的测试用例。</p><p>决策表通常由以下几个部分组成：</p><ol><li>条件列：列出所有可能的条件，每个条件通常有两个状态，例如&quot;是&quot;和&quot;否&quot;。</li><li>动作列：列出系统可能的行为或操作。</li><li>规则：将条件和动作组合起来形成规则，描述系统的行为。</li></ol><p>决策表法的步骤如下：</p><ol><li>确定系统的条件和动作。</li><li>创建决策表，列出所有可能的条件和相应的动作。</li><li>根据系统需求和测试目标，选择测试用例。</li><li>根据选择的测试用例，执行测试并记录结果。</li></ol><p>决策表法的优势在于能够覆盖多个条件组合，并根据不同的条件组合选择相应的测试用例。它可以帮助测试人员在较少的测试用例数量下覆盖更多的情况，从而提高测试效率。同时，决策表法也有助于可读性和可维护性，使得测试用例的设计更加系统化和规范化。</p></blockquote></li></ol></li></ol><h3 id="（三）白盒测试">（三）白盒测试</h3><ol><li>概念：白盒测试是一种软件测试方法，它基于对软件系统的内部结构和逻辑进行测试。在白盒测试中，测试人员具有对源代码、算法和系统内部的详细了解，以便设计和执行测试用例。白盒测试的主要目标是验证软件系统的内部逻辑、路径覆盖和代码执行的正确性。</li><li>测试方法：<ol><li><p><strong><u>语句覆盖</u></strong>（Statement Coverage）：测试人员通过执行测试用例，确保每个源代码语句都被执行到。</p></li><li><p><strong><u>分支覆盖</u></strong>（Branch Coverage）：测试人员通过执行测试用例，确保每个分支和决策点都被覆盖到。</p></li><li><p><strong><u>条件覆盖</u></strong>（Condition Coverage）：测试人员通过执行测试用例，确保每个条件语句的真值和假值都被覆盖到。</p></li><li><p><strong><u>路径覆盖</u></strong>（Path Coverage）：测试人员通过执行测试用例，确保覆盖所有可能的代码路径。</p></li></ol></li></ol><h2 id="三、性能测试">三、性能测试</h2><h3 id="（一）基本概念-3">（一）基本概念</h3><blockquote><p>性能测试是评估软件系统性能和响应能力的测试过程。它主要测试软件在不同负载和压力条件下的性能表现，如响应时间、并发用户数、吞吐量等。</p></blockquote><h3 id="（二）测试方式">（二）测试方式</h3><p>在性能测试中，测试人员通常会使用负载测试、压力测试、性能剖析等技术来模拟不同负载和压力条件，并测量软件的性能指标。</p><h2 id="四、安全测试">四、安全测试</h2><h3 id="（一）基本概念-4">（一）基本概念</h3><blockquote><p>安全测试是评估软件系统安全性和防护能力的测试过程。它主要测试软件系统是否存在安全漏洞和弱点，以及是否能够抵御恶意攻击和未授权访问。</p></blockquote><h3 id="（二）测试方式-2">（二）测试方式</h3><p>在安全测试中，测试人员通常会使用渗透测试、漏洞扫描、安全代码审查等技术来发现软件系统中的安全漏洞和弱点，并提出相应的修复建议。</p><h2 id="参考书目">参考书目</h2><ul><li>软件测试 [美] Ron Patton 机械工业出版社</li><li>Google 软件测试之道：像 Google 一样进行软件测试 [美] James A. Whittaker 等 人民邮电出版社</li><li>软件性能测试、分析与调优实践之路 [中] 张永清 清华大学出版社</li></ul>]]></content>
    
    
    <summary type="html">软件测试笔记</summary>
    
    
    
    <category term="开发" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/"/>
    
    <category term="软件测试" scheme="https://www.angfff.top/categories/%E5%BC%80%E5%8F%91/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
    
    <category term="开发" scheme="https://www.angfff.top/tags/%E5%BC%80%E5%8F%91/"/>
    
    <category term="软件测试" scheme="https://www.angfff.top/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 笔记</title>
    <link href="https://www.angfff.top/posts/65316ea.html"/>
    <id>https://www.angfff.top/posts/65316ea.html</id>
    <published>2023-12-17T09:49:58.000Z</published>
    <updated>2025-02-09T03:33:56.699Z</updated>
    
    <content type="html"><![CDATA[<h1>一、概述</h1><h2 id="（一）数据管理技术发展过程">（一）数据管理技术发展过程</h2><h3 id="1-数据管理">1.数据管理</h3><p>（1）定义：对数据进行收集、分类、组织、编码、存储、检索和维护一系列活动的总和；</p><p>（2）发展过程：人工管理阶段 -&gt; 文件系统阶段 -&gt; 数据库系统阶段</p><h3 id="2-人工管理阶段">2.人工管理阶段</h3><ul><li>数据的管理者: 应用程序，数据不保存</li><li>数据面向的对象: 某一应用程序</li><li>数据的共享程度: 无共享、冗余度极大</li><li>数据的独立性: 不独立，完全依赖于程序</li><li>数据的结构化: 无结构</li><li>数据控制能力: 应用程序自己控制</li></ul><h3 id="3-文件系统阶段">3.文件系统阶段</h3><ul><li>数据的管理者: 文件系统，数据可长期保存</li><li>数据面向的对象: 某一应用程序</li><li>数据的共享程度: 共享性差、冗余度大</li><li>数据的结构化: 记录内有结构，整体无结构</li><li>数据的独立性: 独立性差，数据逻辑结构改变必须修改应用程序</li><li>数据控制能力: 应用程序自己控制</li></ul><h3 id="4-数据库系统阶段">4.数据库系统阶段</h3><p>（DBMS，独立的软件，位于操作系统之上）</p><ul><li>数据结构化</li><li>数据的共享性高，冗余度低且易扩充</li><li>数据独立性高（应用程序和数据库分离）</li><li>数据由 DBMS 统一管理和控制</li></ul><h2 id="（二）数据库">（二）数据库</h2><h3 id="1-数据-Data">1.数据(Data)</h3><ul><li>数据(Data)是数据库中存储的基本对象</li><li>数据的定义:描述事物的符号记录</li><li>数据的种类:文本、图形、图像、音频、视频、学生的档案记录、货物的运输情况等</li><li>数据的特点:数据与其语义是不可分的</li></ul><h3 id="2-数据库-Database">2.数据库(Database)</h3><ul><li>数据库(Database,简称DB)是长期储存在<u>计算机内</u>、<u>有组织</u>的、<u>可共享</u>的<u>大量数据</u>的集合</li></ul><h3 id="3-数据库管理系统-DBMS">3.数据库管理系统(DBMS)</h3><ul><li>定义:位于用户和操作系统之间的一层数据管理软件，是数据库和用户之间的一个接口</li><li>属性:数据库管理系统和操作系统一样都属于计算机的基础软件，也是一个大型复杂的软件系统。</li><li>作用:在数据库建立、运用和维护时对数据库进行统一控制，以保证数据的完整性、安全性，并在多用户同时使用数据库时进行并发控制，在发生故障后对数据库进行恢复。</li></ul><h3 id="4-数据库系统-DBS">4.数据库系统(DBS)</h3><p>​数据库系统的构成</p><ul><li>数据库</li><li>数据库管理系统(及其应用开发工具)</li><li>应用程序</li><li>数据库管理员</li></ul><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F.png" alt="数据库系统"></p><h2 id="（三）MySQL-安装与配置">（三）MySQL 安装与配置</h2><h3 id="1-安装">1.安装</h3><p>（1）macOS</p><ul><li>macOS 安装 MySQL <a href="https://blog.csdn.net/weixin_42148729/article/details/115056646?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168532550116800222872851%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=168532550116800222872851&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-115056646-null-null.142%5Ev88%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=Mac%20mysql&amp;spm=1018.2226.3001.4187">教程</a></li></ul><p>（2）Windows</p><ul><li>Windows 安装 MySQL <a href="https://blog.csdn.net/xhmico/article/details/125029286">教程</a></li></ul><h3 id="2-连接">2.连接</h3><p>（1）终端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">Enter password: 123456</span><br></pre></td></tr></table></figure><p>（2）Navicat</p><p>（3）DataGrip</p><p>（4）VSCode</p><h1>二、 MySQL 基础</h1><h2 id="（一）概念">（一）概念</h2><p>DBMS 数据库管理系统</p><ul><li>关系型数据库 SQL</li><li>非关系型数据库 noSQL</li></ul><p>SQL: Structured Query Language 结构化查询语言</p><ol><li>设定为 主键 的属性可以唯一地表示每一条记录，即用 主键 可以区分不同的记录</li><li>可以通过 外键 将两张表格的记录关联起来，<ul><li>两张表间关联：表 A 中的 外键 对应到表 B 的 主键</li><li>一张表内关联：表A 中的 外键 也可以对应到自己的 主键 ，e.g 主管 id</li></ul></li><li>主键可以有多个，无论几个，其目的都是通过 一个/组 主键 ，区分不同的记录</li><li>可以同时将某一个属性设置为 主键 和 外键，表示从 A 可以查到 B 的某一条记录，从 B 也可以反过来找到 A 中的对应记录</li></ol><h2 id="（二）MySQL-数据类型">（二）MySQL 数据类型</h2><ol><li><p>数值</p><p>（1）整数</p><table><thead><tr><th style="text-align:left">数据类型</th><th style="text-align:left">字节数</th></tr></thead><tbody><tr><td style="text-align:left">TINYINT</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">SMALLINT</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">MEDIUMINT</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">INT</td><td style="text-align:left">4</td></tr><tr><td style="text-align:left">BIGINT</td><td style="text-align:left">8</td></tr></tbody></table><p>（2）浮点数</p><table><thead><tr><th><strong>数据类型</strong></th><th><strong>字节数</strong></th></tr></thead><tbody><tr><td>FLOAT</td><td>4</td></tr><tr><td>DOUBLE</td><td>8</td></tr></tbody></table><blockquote><p>注：float / double(m, n) 带有小数点的数</p><p>m 表示该数字总共有几位数n 表示小数部分所占的位数</p><p>e.g. float(3, 2) -&gt; 2.33 就是总共有 3 位数，其中小数占了 2 位</p></blockquote><p>（3）定点数 DECIMAL</p><blockquote><p>注：DECIMAL(m, n) 带有小数点的数</p><p>m 表示该数字总共有几位数n 表示小数部分所占的位数</p><p>e.g. DECIMAL(3, 2) -&gt; 2.33</p></blockquote><blockquote><p>注：浮点数和定点数的区别</p><ul><li>float / double 在 db 中存储的是近似值，而 decimal 则是以字符串形式进行保存的。因此，浮点数可能会存在精度丢失的问题，而定点数则不会丢失精度。</li><li>decimal(m,n) 的规则和 float / double 相同，但区别在 float / double 在不指定 m/n 时默认按照实际精度来处理，而 decimal 在不指定时默认为 decimal(10, 0)。</li></ul></blockquote></li><li><p>日期时间</p><table><thead><tr><th>数据类型</th><th>字节数</th><th>格式</th><th>备注</th></tr></thead><tbody><tr><td>date</td><td>3</td><td>yyyy-MM-dd</td><td>存储日期值</td></tr><tr><td>time</td><td>3</td><td>HH:mm:ss</td><td>存储时分秒</td></tr><tr><td>year</td><td>1</td><td>yyyy</td><td>存储年</td></tr><tr><td>datetime</td><td>8</td><td>yyyy-MM-dd HH:mm:ss</td><td>存储日期+时间</td></tr><tr><td>timestamp</td><td>4</td><td>yyyy-MM-dd HH:mm:ss</td><td>存储日期+时间，时间戳</td></tr></tbody></table><blockquote><p>注 1 ：datetime 和 timestamp 的区别：</p><ul><li>datetime 占8个字节，timestamp 占4个字节；</li><li>由于字节数区别，datetime 与 timestamp 能存储的时间范围也不同，datetime 的存储范围为 1000-01-01 00:00:00 — 9999-12-31 23:59:59，timestamp 存储的时间范围为 19700101080001—20380119111407；</li><li>datetime 默认值为空，当插入的值为 null 时，该列的值就是 null；timestamp 默认值不为空，当插入的值为 null 的时候，mysql 会取当前时间；</li><li>datetime 存储的时间与时区无关，timestamp 存储的时间及显示的时间都依赖于当前时区；</li></ul><p>注 2 ：通常表格中记录“创建时间”和“修改时间”字段时，用 timestamp</p></blockquote></li><li><p>字符串</p><p>（1）CHAR(n) 定长字符串</p><p>（2）VARCHAR(n) 变长字符串</p><p>（3）TEXT</p><p>（4）BLOB 二进制对象（图片、视频、档案等）</p><blockquote><p>注：</p><ul><li><p>MySql 单行最大数据量为 64K，为了存储大数据，因此创建了 TEXT 和 BLOB 两种类型；</p></li><li><p>TEXT 和 VARCHAR 比较类似，当 varchar(M) 的 M 大于某些数值时，varchar 会自动转为 text：</p><ul><li><p>M&gt;255 时转为 tinytext</p></li><li><p>M&gt;500 时转为 text</p></li><li><p>M&gt;20000 时转为 mediumtext</p></li></ul></li><li><p>varchar(M) 和 text 的区别：</p><ul><li><p>单行 64K 即 65535 字节的空间，varchar 只能用 63352 /  65533 个字节，text 可以用 65535 个字节；</p></li><li><p>text 可以指定 text(M) ，且 M 无限制</p></li><li><p>text 不允许有默认值，varchar 允许有默认值</p></li></ul></li><li><p>text 和 blob 的区别：text 存储的是字符串而 blob 存储的是二进制字符串。</p></li></ul></blockquote></li><li><p>JSON</p></li><li><p>空间</p></li></ol><h2 id="（三）SQL-语句分类">（三）SQL 语句分类</h2><ol><li><p>DDL (Data Definition Language) 数据定义语言</p><p>CREATE / DROP / ALTER / TRUNCATE</p></li><li><p>DML (Data Manipulation Language) 数据操作语言</p><p>INSERT / UPDATE / DELETE / CALL</p></li><li><p>DQL (Data Query Language) 数据查询语言</p><p>SELECT</p></li><li><p>DCL (Data Control Language) 数据控制语言</p><p>GRANT / REVOKE</p></li></ol><h1>三、常用 SQL 语句</h1><h2 id="（一）数据库和表操作">（一）数据库和表操作</h2><ol><li><p>新建数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `sql_tutorial`;</span><br></pre></td></tr></table></figure></li><li><p>查看所有数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES;</span><br></pre></td></tr></table></figure></li><li><p>删除数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> DATABASE `sql_tutorial`;</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">drop</span> database test;</span><br><span class="line">ERROR <span class="number">1010</span> (HY000): Error dropping database (can<span class="string">&#x27;t rmdir &#x27;</span>.<span class="operator">/</span>test<span class="operator">/</span><span class="string">&#x27;, errno: 17)</span></span><br></pre></td></tr></table></figure><p>注：如果遇到上述无法删除数据库的情况，是因为 test 目录下存在着MySQL 不知道的文件，即 MySQL 中没有该文件的数据字典信息，需要手动删除。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/mysql/data/test# 进入 test 所在位置</span><br><span class="line">ls # 查看未知文件</span><br><span class="line">rm -rf xxx # 手动删除</span><br></pre></td></tr></table></figure><p>删除后，再次 DROP 即可。</p></blockquote></li><li><p>选择数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USE `sql_tutorial`;</span><br></pre></td></tr></table></figure></li><li><p>创建表格</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student` ( </span><br><span class="line">`student_id` <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY, # `属性名` 类型 主键,</span><br><span class="line">`name` <span class="type">VARCHAR</span> ( <span class="number">20</span> ), </span><br><span class="line">`major` <span class="type">VARCHAR</span> ( <span class="number">20</span> ) </span><br><span class="line">  #<span class="keyword">PRIMARY</span> KEY(`student_id`) 主键也可以不在属性后注明，也可以在下面单独写</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>查看表格</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> `student`;</span><br><span class="line"><span class="keyword">DESC</span> `student`;</span><br></pre></td></tr></table></figure></li><li><p>删除表格</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> `student`;</span><br></pre></td></tr></table></figure></li><li><p>新增表 字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `student` <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> gpa <span class="type">DECIMAL</span>(<span class="number">3</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li><li><p>删除表 字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `student` <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> gpa;</span><br></pre></td></tr></table></figure></li><li><p>修改表 字段属性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `student` MODIFY <span class="keyword">COLUMN</span> gpa <span class="type">FLOAT</span>(<span class="number">3</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li><li><p>修改表 字段名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `student` RENAME <span class="keyword">COLUMN</span> gpa <span class="keyword">to</span> Stu_GPA;</span><br></pre></td></tr></table></figure></li><li><p>导出数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 Shell 中使用</span></span><br><span class="line">mysqldump -u root -p DB (able) &gt; DB.sql</span><br></pre></td></tr></table></figure></li><li><p>导入数据库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 Shell 中使用</span></span><br><span class="line">mysql -u root -p DB &lt; DB.sql</span><br></pre></td></tr></table></figure></li></ol><h2 id="（二）数据操作">（二）数据操作</h2><ol><li><p>查询所有记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> `student`;</span><br></pre></td></tr></table></figure></li><li><p>添加记录</p><ol><li><p>不指定属性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 这种方式添加记录，属性的顺序和数量必须全部匹配</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student` <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">&#x27;小白&#x27;</span>, <span class="string">&#x27;历史&#x27;</span>); </span><br></pre></td></tr></table></figure></li><li><p>指定属性</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 可以在表格后添加属性序列，指定输入的属性，如后续值省略，则自动填入默认值</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student`(`name`, `major`, `student_id`) <span class="keyword">VALUES</span>(<span class="string">&#x27;小蓝&#x27;</span>, <span class="string">&#x27;英语&#x27;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"># 插入多条数据</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `student`(`name`, `student_id`) <span class="keyword">VALUES</span>(<span class="string">&#x27;小红&#x27;</span>, <span class="number">5</span>),(<span class="string">&#x27;小绿&#x27;</span>, <span class="number">6</span>),(<span class="string">&#x27;小黄&#x27;</span>, <span class="number">7</span>);</span><br></pre></td></tr></table></figure></li></ol></li><li><p>常用约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `student`</span><br><span class="line">(</span><br><span class="line">    `student_id` <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">    `name`       <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, # 非空</span><br><span class="line">    `major`      <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">UNIQUE</span>, # 唯一</span><br><span class="line">    `sex`        <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;男&#x27;</span># 默认值，通常应用在指定输入属性时</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>更新记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> `student`</span><br><span class="line"><span class="keyword">SET</span> `major` <span class="operator">=</span> <span class="string">&#x27;English&#x27;</span>, `score` <span class="operator">=</span> <span class="number">98</span></span><br><span class="line"><span class="keyword">WHERE</span> `major` <span class="operator">=</span> <span class="string">&#x27;Math&#x27;</span> <span class="keyword">OR</span> `major` <span class="operator">=</span> <span class="string">&#x27;Chinese&#x27;</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除记录</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> `student`</span><br><span class="line"><span class="keyword">WHERE</span> `student_id` <span class="operator">=</span> <span class="number">4</span>; # 不加条件，则删除所有记录</span><br></pre></td></tr></table></figure></li><li><p>查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">1</span>, 属性<span class="number">2</span></span><br><span class="line"><span class="keyword">FROM</span> 表</span><br><span class="line"><span class="keyword">WHERE</span> 属性<span class="number">1</span> <span class="operator">=</span> <span class="string">&#x27;特定值&#x27;</span> <span class="keyword">AND</span> <span class="operator">/</span> <span class="keyword">OR</span> 属性<span class="number">2</span> <span class="operator">&lt;&gt;</span> <span class="string">&#x27;特定值&#x27;</span></span><br><span class="line"># 链接符优先级 <span class="keyword">NOT</span> <span class="operator">&gt;</span> <span class="keyword">AND</span> <span class="operator">&gt;</span> <span class="keyword">OR</span>，可以用括号改变优先级顺序</span><br><span class="line"># 增加筛选条件（ <span class="operator">&lt;&gt;</span> 不等于 ）</span><br><span class="line"># 同一属性 a 判断多个条件并使用 <span class="keyword">OR</span> 连接时，可以用: 属性 <span class="keyword">IN</span> (<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line"># 属性在某个区间内取值时，可以用: <span class="keyword">BETWEEN</span> a <span class="keyword">AND</span> b</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> 分组依据</span><br><span class="line"><span class="keyword">HAVING</span> 分组后过滤的依据</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> 排序依据<span class="number">1</span>, 排序依据<span class="number">2</span> <span class="keyword">DESC</span> </span><br><span class="line"># 默认升序 <span class="keyword">ASC</span> ，添加 <span class="keyword">DESC</span> 变为降序</span><br><span class="line"># 先按照依据<span class="number">1</span>排序，有相同的再按照依据<span class="number">2</span>排序</span><br><span class="line">LIMIT n <span class="operator">/</span> a,b </span><br><span class="line"># 如果只写一个数字 n 则返回前 n 条记录</span><br><span class="line"># 如果写 a,b 则返回 从 a<span class="operator">+</span><span class="number">1</span> 条记录开始的 b 条记录</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注：</p><ol><li>判断是否为空用 <code>IS NULL / IS NOT NULL</code>；</li><li>计算字符串中字符数的最佳函数是 <code>CHAR_LENGTH(str)</code>，它返回字符串 <code>str</code> 的长度；而函数 <code>LENGTH(str)</code> 返回字符串 <code>str</code> 的字节数，某些字符包含多于 1 个字节，可能导致返回结果错误。</li><li>DISTINCT + 属性 可用于去重；</li></ol></blockquote><h2 id="（三）进阶操作">（三）进阶操作</h2><ol><li><p>聚合函数</p><p>聚合函数用于对某些列进行一些计算，包括求和、计数、求平均等。</p><ul><li><p>COUNT( ) 返回集合中的项目数；</p></li><li><p>AVG( ) 返回集合的平均数；</p></li><li><p>SUM( ) 求和；</p></li><li><p>ROUND( 对象, 小数位数 ) 四舍五入保留小数；</p></li><li><p>MIN( ) 最小值；</p></li><li><p>MAX( ) 最大值；</p></li></ul></li><li><p>通配符</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">属性 (<span class="keyword">NOT</span>) <span class="keyword">LIKE</span> <span class="string">&#x27;通配符&#x27;</span>;</span><br><span class="line"># <span class="operator">%</span> 表示任意长度的字符串</span><br><span class="line"># _ 表示任意单个字符</span><br></pre></td></tr></table></figure></li><li><p>正则表达式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">属性 REGEXP <span class="string">&#x27;正则表达式&#x27;</span>;</span><br><span class="line"># <span class="operator">^</span> 开头 $ 结尾</span><br><span class="line"># . 任意一个字符</span><br><span class="line"># [abc] 其中任意一个字符</span><br><span class="line"># [a<span class="operator">-</span>z] 范围内任意一个字符</span><br><span class="line"># A<span class="operator">|</span>B A 或 B</span><br></pre></td></tr></table></figure></li><li><p>集合运算</p><ul><li><p>UNION 并集</p><p>将两个结果合并为一个结果返回，后者直接接在前者最后；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">1</span> <span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">2</span> <span class="keyword">FROM</span> 表<span class="number">2</span>;</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><p>UNION 默认会去除两条 select 中得到的重复记录；如果要求不去重，则可以使用 UNION ALL。</p></blockquote></li><li><p>INTERSECT 交集</p><p>将两个结果取交集后返回；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">1</span> <span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">INTERSECT</span></span><br><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">2</span> <span class="keyword">FROM</span> 表<span class="number">2</span>;</span><br></pre></td></tr></table></figure></li><li><p>EXCEPT 差集</p><p>将两个结果取差集后返回，查找满足第一条语句但不满足第二条语句的记录；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">1</span> <span class="keyword">FROM</span> 表<span class="number">1</span></span><br><span class="line"><span class="keyword">EXCEPT</span></span><br><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">2</span> <span class="keyword">FROM</span> 表<span class="number">2</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>连接查询 JOIN</p><p>连接查询，将后者拼接在前者表的右边</p><p>（1）外连接</p><ul><li>LEFT JOIN（左连接）以左表为主，右表中没有的数据用 NULL 填充；</li><li>RIGHT JOIN（右连接）以右表为主，左表中没有的数据用 NULL填充；</li><li>FULL (OUTER) JOIN（全连接）两边连接，没有的都用 FULL 填充 <em><strong><u>并集</u></strong></em>。</li></ul><p>（2）内连接</p><ul><li>INNER JOIN （内连接）只返回两个表中都有的数据 <em><strong><u>交集</u></strong></em></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">1</span>, 属性<span class="number">2</span>, 属性<span class="number">3</span> <span class="keyword">FROM</span> 表<span class="number">1</span> </span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> 表<span class="number">2</span></span><br><span class="line"><span class="keyword">ON</span> 表<span class="number">1.</span>属性a <span class="operator">=</span> 表<span class="number">2.</span>属性b;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">INNER</span> <span class="keyword">JOIN</span> 内连接 也可以用 <span class="keyword">WHERE</span> 的方式实现</span><br><span class="line"># <span class="keyword">INNER</span> <span class="keyword">JOIN</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">join</span> equip</span><br><span class="line"><span class="keyword">on</span> player.id <span class="operator">=</span> equip.player_id;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> player, equip</span><br><span class="line"><span class="keyword">where</span> player.id <span class="operator">=</span> equip.player_id;</span><br></pre></td></tr></table></figure><p>（3）交叉连接</p><ul><li><p>(CROSS) JOIN （交叉连接）相当于取两个表的***<u>笛卡尔积</u>***</p><blockquote><p>注：在 MySQL 中，如果不指定 ON 条件，则 CROSS JOIN 与 INNER JOIN 的结果是一样的，都是两张表的笛卡尔积。</p></blockquote></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 属性<span class="number">1</span>, 属性<span class="number">2</span>, 属性<span class="number">3</span> <span class="keyword">FROM</span> 表<span class="number">1</span> </span><br><span class="line">(<span class="keyword">CROSS</span>) <span class="keyword">JOIN</span> 表<span class="number">2</span></span><br><span class="line"><span class="keyword">ON</span> 表<span class="number">1.</span>属性a <span class="operator">=</span> 表<span class="number">2.</span>属性b;</span><br></pre></td></tr></table></figure></li><li><p>子查询 / 嵌套查询</p><p>（1）一个查询嵌套在另一个查询中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查询对一位客户销售金额超过 <span class="number">50000</span> 的员工姓名</span><br><span class="line"><span class="keyword">SELECT</span> Employee.name, Works_with.total_sales</span><br><span class="line"><span class="keyword">FROM</span> Employee <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Works_with</span><br><span class="line"><span class="keyword">ON</span> Employee.emp_id <span class="operator">=</span> Works_with.emp_id</span><br><span class="line"><span class="keyword">WHERE</span> Employee.emp_id <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line">  <span class="keyword">SELECT</span> Works_with.emp_id </span><br><span class="line">  <span class="keyword">FROM</span> Works_with </span><br><span class="line">  <span class="keyword">WHERE</span> Works_with.total_sales <span class="operator">&gt;=</span> <span class="number">50000</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 注: 这里内层的查询结果不止一个，所以不能用 <span class="operator">=</span> 连接内外查询，要用 <span class="keyword">IN</span> 连接内外查询</span><br></pre></td></tr></table></figure><p>（2）用子查询结果创建新表格</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查询所有等级小于 <span class="number">5</span> 级的玩家，并将结果保存到新的表格中</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> new_player <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> level <span class="operator">&lt;</span> <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"># 查询所有等级在 <span class="number">6</span><span class="number">-10</span> 级的玩家，并将结果插入到 new_player 中</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> new_player <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> player <span class="keyword">WHERE</span> level <span class="keyword">BETWEEN</span> <span class="number">6</span> <span class="keyword">AND</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p>索引 INDEX</p><p>通常对一张表格的主键字段或常用字段创建索引，从而提高后续的查询效率。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 在指定表（的某些字段）上创建 唯一<span class="operator">/</span>全文<span class="operator">/</span>空间 索引</span><br><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span><span class="operator">|</span>FULLTEXT<span class="operator">|</span>SPATIAL] INDEX 索引名称</span><br><span class="line"><span class="keyword">ON</span> 表名 (字段名称, ...);</span><br><span class="line"></span><br><span class="line"># 查看索引</span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> 表名;</span><br><span class="line"></span><br><span class="line"># 删除索引</span><br><span class="line"><span class="keyword">DROP</span> INDEX 索引名称</span><br><span class="line"><span class="keyword">ON</span> 表;</span><br></pre></td></tr></table></figure></li></ol><h2 id="（四）窗口函数">（四）窗口函数</h2><ol><li><p>概念</p><p>窗口函数是一种特殊类型的 SQL 函数，它在查询结果集中的一定窗口（或称为窗口框架）上执行计算操作。</p><p>这个窗口是通过使用 OVER 子句定义的，它指定了在进行聚合、排序或分析等操作时应考虑的行集合。</p><p>窗口函数通常与聚合函数一起使用，但与普通的聚合函数不同，它不会将整个结果集作为输入，而是基于定义的窗口框架对子集进行计算。这使得在不引入子查询或自连接的情况下，能够在每一行上执行对整个结果集的聚合或分析操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  column1,</span><br><span class="line">  column2,</span><br><span class="line">  <span class="built_in">SUM</span>(column3) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> column1 # 按 column1 分组</span><br><span class="line">                     <span class="keyword">ORDER</span> <span class="keyword">BY</span> column2 # 按 column2 排序</span><br><span class="line">                     <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="number">1</span> PRECEDING <span class="keyword">AND</span> <span class="number">1</span> FOLLOWING # 当前行及其前后各一行</span><br><span class="line">                    ) <span class="keyword">AS</span> running_total</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  your_table;</span><br><span class="line"></span><br><span class="line"># SUM 是一个聚合函数，但它通过<span class="keyword">OVER</span>子句指定了一个窗口框架。</span><br><span class="line"># 在这个例子中，窗口由 <span class="keyword">PARTITION</span> <span class="keyword">BY</span> column1 定义，然后使用 <span class="keyword">ORDER</span> <span class="keyword">BY</span> column2 排序。</span><br><span class="line"># <span class="keyword">ROWS</span> <span class="keyword">BETWEEN</span> <span class="number">1</span> PRECEDING <span class="keyword">AND</span> <span class="number">1</span> FOLLOWING指定了窗口的范围，表示当前行及其前后各一行。</span><br><span class="line"># 这样，SUM函数将在每个窗口内计算列column3的累计和。</span><br></pre></td></tr></table></figure></li><li><p>聚合函数</p><blockquote><p>示例数据</p><p>![截屏2023-12-20 21.15.22](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.15.22.png)</p></blockquote><ul><li><p><code>SUM</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line">       <span class="built_in">SUM</span>(Salary) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> GroupName) <span class="keyword">AS</span> 部门工资总和, # 按照部门分组，计算部门工资总和</span><br><span class="line">       <span class="built_in">SUM</span>(Salary) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> GroupName <span class="keyword">ORDER</span> <span class="keyword">BY</span> ID) <span class="keyword">AS</span> 累加_部门工资总和, # 按照部门分组，再按组内 ID 依次累加部门工资总和</span><br><span class="line">       <span class="built_in">SUM</span>(Salary) <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> ID) <span class="keyword">AS</span> 累加_全体工资总和, # 按所有人的 ID 依次累加工资总和</span><br><span class="line">       <span class="built_in">SUM</span>(Salary) <span class="keyword">OVER</span>() <span class="keyword">AS</span> 全体工资总和 # 窗口为空，直接计算所有员工工资总和 等同于 <span class="built_in">SUM</span>()</span><br><span class="line"><span class="keyword">FROM</span> Emp;</span><br></pre></td></tr></table></figure><p>![截屏2023-12-20 21.13.50](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.13.50.png)</p></li><li><p><code>MAX</code></p></li><li><p><code>MIN</code></p></li><li><p><code>COUNT</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> GroupName) <span class="keyword">AS</span> 部门人数,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> GroupName <span class="keyword">ORDER</span> <span class="keyword">BY</span> ID) <span class="keyword">AS</span> 累加_部门人数,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">OVER</span>(<span class="keyword">ORDER</span> <span class="keyword">BY</span> ID) <span class="keyword">AS</span> 累加_全体人数,</span><br><span class="line">       <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">OVER</span>() <span class="keyword">AS</span> 总人数</span><br><span class="line"><span class="keyword">FROM</span> Emp;</span><br></pre></td></tr></table></figure><p>![截屏2023-12-20 21.14.46](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.14.46.png)</p></li><li><p><code>AVG</code></p></li></ul></li><li><p>排序函数</p><blockquote><p>示例数据</p><p>![截屏2023-12-20 21.16.26](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.16.26.png)</p></blockquote><ul><li><p><code>ROW_NUMBER</code> 将 SELECT 得到的数据进行排序，必须与 ORDER BY 连用，常用于分页查询；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>,</span><br><span class="line">       <span class="built_in">ROW_NUMBER</span>() <span class="keyword">over</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> ClassName <span class="keyword">ORDER</span> <span class="keyword">BY</span> Score <span class="keyword">DESC</span>) <span class="keyword">AS</span> 班内排名, # 按照班级分组，再按照分数降序排列，给每行一个排名</span><br><span class="line">       <span class="built_in">ROW_NUMBER</span>() <span class="keyword">over</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> Score <span class="keyword">DESC</span>) <span class="keyword">AS</span> 全体排名 # 按照分数降序排列，给每行一个排名</span><br><span class="line"><span class="keyword">FROM</span> SCO;</span><br></pre></td></tr></table></figure><p>![截屏2023-12-20 21.16.59](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.16.59.png)</p></li><li><p><code>RANK</code> 与 ROW_NUMBER 类似，但是允许并列排名，即分数相同时，排名也相同，后续跳过被占用的名次；</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ROW_NUMBER</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>, <span class="built_in">ROW_NUMBER</span>() <span class="keyword">OVER</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> SCO.Score <span class="keyword">DESC</span>) <span class="keyword">AS</span> 总排名</span><br><span class="line"><span class="keyword">FROM</span> SCO; # 不能并列排名</span><br></pre></td></tr></table></figure><p>![截屏2023-12-20 21.18.28](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.18.28.png)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># RANK</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>, <span class="built_in">RANK</span>() <span class="keyword">over</span> (<span class="keyword">ORDER</span> <span class="keyword">BY</span> SCO.Score <span class="keyword">DESC</span>) <span class="keyword">AS</span> 总排名</span><br><span class="line"><span class="keyword">FROM</span> SCO; # 可以并列，且后续跳过被占用的排名</span><br></pre></td></tr></table></figure><p>![截屏2023-12-20 21.18.40](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.18.40.png)</p></li><li><p><code>DENSE_RANK</code> 与 RANK 类似，允许并列排名，但后续不会跳过被占用的名次。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># DENSE_RANK</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span>, <span class="built_in">DENSE_RANK</span>() <span class="keyword">over</span> (<span class="keyword">order</span> <span class="keyword">by</span> SCO.Score <span class="keyword">DESC</span> ) <span class="keyword">AS</span> 总排名</span><br><span class="line"><span class="keyword">FROM</span> SCO; # 可以并列，且后续不跳过被占用的排名</span><br></pre></td></tr></table></figure><p>![截屏2023-12-20 21.19.55](/Users/angfff/Library/Application Support/typora-user-images/截屏2023-12-20 21.19.55.png)</p></li></ul></li><li><p>取值函数</p><p>（1）向前向后取数</p><ul><li><code>lag( )</code> 返回窗口内当前行之前的第 N 行数据</li><li><code>lead( )</code> 返回窗口内当前行之后的第 N 行数据</li></ul><p>（2）First_value &amp; Last_value</p><ul><li><code>First_value</code> 返回窗口内第一行数据，可以用 Min 聚合函数替代</li><li><code>Last_value</code> 返回窗口内最后一行数据，可以用 Max 聚合函数替代</li></ul></li></ol><h2 id="（五）函数">（五）函数</h2><ol><li><code>substr( 属性 a, begin, n )</code> 截取属性 a 从 begin 位置开始的 n 个字符，e.g. 查找姓氏 substr(name, 1, 1)；</li><li><code>datediff( 日期 1, 日期 2 )</code> 前减后，得到的结果是日期 1 与日期 2 相差的天数。如果日期 1 比日期 2 大，结果为正；如果日期 1 比日期 2 小，结果为负。</li><li><code>timestampdiff(时间类型, 日期1, 日期2)</code> 后减前在“时间类型”的参数位置，通过添加“day”, “hour”, “second”等关键词，来规定计算天数差、小时数差、还是分钟数差。日期 1 大于日期 2 ，结果为负，日期 1 小于日期 2 ，结果为正。</li><li><code>IFNULL( 判断对象 A, 替换值 N )</code> 如果判断对象 A 的值为 NULL，则返回替换值 N。</li><li><code>mod( 操作对象 A, 取模数 n ) = x</code> 判断操作对象 A 对 n 取模的结果是否为 x，等价于 A % n = x。</li><li></li></ol><h2 id="（六）视图">（六）视图</h2><ol><li>创建视图的目的是将查询结果保存为一张虚拟的表，当后续需要使用该查询结果时，就可以直接从视图中调用，做进一步的查询。</li><li>视图是动态变化的，随着原表的修改而修改。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 创建视图</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> 视图名称</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名;</span><br><span class="line"></span><br><span class="line"># 修改视图</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">VIEW</span> 视图名称</span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> 表名;</span><br><span class="line"></span><br><span class="line"># 删除视图</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">VIEW</span> 视图名称;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">MySQL 学习笔记</summary>
    
    
    
    <category term="技术" scheme="https://www.angfff.top/categories/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="MySQL" scheme="https://www.angfff.top/categories/%E6%8A%80%E6%9C%AF/MySQL/"/>
    
    
    <category term="技术" scheme="https://www.angfff.top/tags/%E6%8A%80%E6%9C%AF/"/>
    
    <category term="MySQL" scheme="https://www.angfff.top/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Sklearn 导入随机逻辑回归函数 RLR 失败原因及解决</title>
    <link href="https://www.angfff.top/posts/5fd458f7.html"/>
    <id>https://www.angfff.top/posts/5fd458f7.html</id>
    <published>2023-12-09T08:05:10.000Z</published>
    <updated>2025-02-09T03:33:56.698Z</updated>
    
    <content type="html"><![CDATA[<h1>一、问题描述</h1><ol><li><p>描述：在进行分类任务时，导入随机逻辑回归模型 RandomizedLogisticRegression 时会提示无法找到该模型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> RandomizedLogisticRegression <span class="keyword">as</span> RLR</span><br></pre></td></tr></table></figure></li><li><p>分析：自 sklearn 0.19.2 版本后，随机逻辑回归模型已经被移除</p></li><li><p>当前软件版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sklearn</span><br><span class="line">sklearn.show_versions()</span><br></pre></td></tr></table></figure><blockquote><p>System:<br>python: 3.9.16</p><p>Python dependencies:</p><p>​sklearn: 1.3.2</p><p>​numpy: 1.26.2</p><p>​scipy: 1.10.1</p><p>​pandas: 2.1.3</p><p>​matplotlib: 3.7.1</p><p>​joblib: 1.3.2</p></blockquote></li></ol><h1>二、解决办法</h1><h2 id="（一）手动安装随机逻辑回归模型">（一）手动安装随机逻辑回归模型</h2><ol><li><p>模型仓库：<a href="https://github.com/scikit-learn-contrib/stability-selection">https://github.com/scikit-learn-contrib/stability-selection</a></p></li><li><p>安装参考：<a href="https://github.com/scikit-learn-contrib/stability-selection/issues/38">https://github.com/scikit-learn-contrib/stability-selection/issues/38</a></p><blockquote><p>注：</p><p>​安装随机逻辑回归模型后，能够解决模型导入时的报错问题，并能够正确拟合训练模型。</p><p>​但是在后续查看特征筛选结果和 Score 分数时，会无法调用 rlr.get_support() 和 rlr.scores_ 方法，可能是因为高版本在移除随机逻辑回归模型时，也对 sklearn_base 中的方法做了修改，无法再按旧版本方法调用。</p></blockquote></li></ol><h2 id="（二）采用低版本-Scikit-Learn">（二）采用低版本 Scikit-Learn</h2><ol><li><p>低版本 Scikit-Learn 所需的环境</p><blockquote><p>Python 3.8 及以下（建议 Python 3.6）</p><p>Numpy 1.23.5 及以下（建议 Numpy 1.20.0）</p><p>Scikit-Learn 0.19.2</p><p>注：</p><ol><li>所建议版本是较为久远的版本，可能会出现无法找到对应源、无法安装的情况，需根据自己的电脑情况调整；</li><li>M 系列 Mac 由于架构不同，不支持 3.8 版本以下的 Python，请使用 Python 3.8；</li><li>Scikit-Learn 最好使用 0.19.2 版本。</li></ol></blockquote></li><li><p>安装过程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">conda 创建虚拟环境 Python 3.8</span></span><br><span class="line">conda create -n py38 python=3.8</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">激活 py38 环境</span></span><br><span class="line">conda activate py38</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装相关库</span></span><br><span class="line">pip install numpy==1.23.5</span><br><span class="line">pip install scipy</span><br><span class="line">pip install pandas</span><br><span class="line">pip install xlrd</span><br><span class="line">pip install scikit-learn==0.19.2</span><br></pre></td></tr></table></figure><blockquote><p>注：</p><ol><li>以上过程均在终端 shell 中安装；</li><li>或者选用 Anaconda 图形化界面安装。</li></ol></blockquote></li><li><p>安装完毕后，在 Pycharm 右下角添加并使用新的 Python 解释器即可。</p></li></ol>]]></content>
    
    
    <summary type="html">Python Sklearn 导入随机逻辑回归函数 RLR 失败原因及解决</summary>
    
    
    
    <category term="环境配置" scheme="https://www.angfff.top/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    <category term="Sklearn" scheme="https://www.angfff.top/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Sklearn/"/>
    
    
    <category term="环境配置" scheme="https://www.angfff.top/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    <category term="Sklearn" scheme="https://www.angfff.top/tags/Sklearn/"/>
    
  </entry>
  
  <entry>
    <title>CIFAR100 多模型训练结果及分析</title>
    <link href="https://www.angfff.top/posts/2fb8888f.html"/>
    <id>https://www.angfff.top/posts/2fb8888f.html</id>
    <published>2023-12-09T02:50:31.000Z</published>
    <updated>2025-02-09T03:33:56.698Z</updated>
    
    <content type="html"><![CDATA[<h1>一、自建网络</h1><h2 id="两层-CNN-网络">两层 CNN 网络</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: Adam</li></ul></blockquote></li><li><p>思路</p><blockquote><p>CNN：Conv2d -&gt; BatchNorm2d -&gt; ReLu -&gt; MaxPool2d</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-2CNN.png" alt="Arch_2CNN"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-2CNN.png" alt="Loss_2CNN"></p><blockquote><ul><li>Time: 0:01:11.308311</li><li>Min Loss: 1.4500</li><li>Final Loss: 1.9618</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：39.75 %</li></ul></blockquote></li></ol><h2 id="三层-CNN-网络">三层 CNN 网络</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: Adam</li></ul></blockquote></li><li><p>思路</p><blockquote><p>CNN：Conv2d -&gt; BatchNorm2d -&gt; ReLu -&gt; MaxPool2d</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-3CNN.png" alt="Arch_3CNN"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-3CNN.png" alt="Loss_3CNN"></p><blockquote><ul><li>Time: 0:01:10.645922</li><li>Min Loss: 1.5404</li><li>Final Loss: 1.9817</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：44.14 %</li></ul></blockquote></li></ol><h2 id="五层-CNN-网络">五层 CNN 网络</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: Adam</li></ul></blockquote></li><li><p>思路</p><blockquote><p>CNN：Conv2d -&gt; BatchNorm2d -&gt; ReLu -&gt; MaxPool2d</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-5CNN.png" alt="Arch_5CNN"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-5CNN.png" alt="Loss_5CNN"></p><blockquote><ul><li>Time: 0:02:12.387121</li><li>Min Loss: 1.3080</li><li>Final Loss: 1.5872</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：44.20 %</li></ul></blockquote></li></ol><h1>二、经典 CNN 网络</h1><h2 id="VGG-19">VGG 19</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: SGD</li></ul></blockquote></li><li><p>思路</p><blockquote><p>VGG 19 -&gt; Transforms ( Resize + ToTensor + Normalize) -&gt; Model Arch ( fc out 100 ) -&gt; Fine Tune</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-VGG.png" alt="Arch_VGG"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-VGG.png" alt="Loss_VGG"></p><blockquote><ul><li>Time: 0:24:17.983430</li><li>Min Loss: 0.3057</li><li>Final Loss: 0.7126</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：71.61 %</li></ul></blockquote></li></ol><h2 id="ResNet-101">ResNet 101</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: SGD</li></ul></blockquote></li><li><p>思路</p><blockquote><p>ResNet 101 -&gt; Transforms ( Resize + ToTensor + Normalize) -&gt; Model Arch ( fc out 100 ) -&gt; Fine Tune</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-ResNet.png" alt="Arch_ResNet"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-ResNet.png" alt="Loss_ResNet"></p><blockquote><ul><li>Time: 0:26:58.626524</li><li>Min Loss: 0.0667</li><li>Final Loss: 0.0942</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：83.92 %</li></ul></blockquote></li></ol><h1>三、 Vision Transformer 网络</h1><h2 id="ViT-b-32">ViT_b_32</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: SGD</li></ul></blockquote></li><li><p>思路</p><blockquote><p>ViT_b_32 -&gt; Transforms ( Resize + ToTensor + Normalize) -&gt; Model Arch ( fc out 100 ) -&gt; Fine Tune</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-ViT.png" alt="Arch_ViT"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-ViT.png" alt="Loss_ViT"></p><blockquote><ul><li>Time: 0:11:34.681656</li><li>Min Loss: 0.1308</li><li>Final Loss: 0.1308</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：84.34 %</li></ul></blockquote></li></ol><h2 id="Swin-b">Swin_b</h2><ol><li><p>超参数</p><blockquote><ul><li>batch_size = 64 (5000 / 64 = 782)</li><li>epochs = 5</li><li>learning_rate = 1e-3</li><li>Loss: CrossEntropyLoss</li><li>Optimizer: SGD</li></ul></blockquote></li><li><p>思路</p><blockquote><p>Swim_b -&gt; Transforms ( Resize + ToTensor + Normalize) -&gt; Model Arch ( fc out 100 ) -&gt; Fine Tune</p></blockquote></li><li><p>结构</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Arch-Swin.png" alt="Arch_Swin"></p></li><li><p>loss 曲线</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Loss-Swin.png" alt="Loss_Swin"></p><blockquote><ul><li>Time: 0:40:31.978593</li><li>Min Loss: 0.2692</li><li>Final Loss: 0.5661</li></ul></blockquote></li><li><p>测试集精准度</p><blockquote><ul><li>测试集精准度：83.53 %</li></ul></blockquote></li></ol><h1>四、对比分析</h1><table><thead><tr><th>Model</th><th>Total Params</th><th>Total Size</th><th>Min loss</th><th>Final Loss</th><th>Accuracy</th></tr></thead><tbody><tr><td>CNN_2</td><td>219,044</td><td>40.63</td><td>1.4500</td><td>1.9618</td><td>39.75 %</td></tr><tr><td>CNN_3</td><td>168,036</td><td>46.94</td><td>1.5404</td><td>1.9817</td><td>44.14 %</td></tr><tr><td>CNN_5</td><td>1,116,388</td><td>55.43</td><td>1.3080</td><td>1.5872</td><td>44.20 %</td></tr><tr><td>VGG19</td><td>139,979,940</td><td>773.24</td><td>0.3057</td><td>0.7126</td><td>71.61 %</td></tr><tr><td>ResNet101</td><td>42,705,060</td><td>593.20</td><td>0.0667</td><td>0.0942</td><td>83.92 %</td></tr><tr><td>ViT_b_32</td><td>87,532,132</td><td>263.59</td><td>0.1308</td><td>0.1308</td><td>84.34 %</td></tr><tr><td>Swin_b</td><td>86,845,724</td><td>425.33</td><td>0.2692</td><td>0.5661</td><td>83.53 %</td></tr></tbody></table><ol><li>对比自建 CNN 网络<ul><li>从 2 层 CNN 到 3 层 CNN 模型的总参数量有所下降，主要原因是 FC 层 Linear 函数的输入参数减少，导致了总参数量的下降。</li><li>从 2 层 CNN 到 3 层 CNN 模型准确率提升了约 4.39%；从 3 层 CNN 到 5 层 CNN 模型准确率几乎没有提升。虽然从 3 层到 5 层模型的总参数量扩大了约 6.64 倍，但是模型的性能没有显著提升，推测是因为此时模型深度的增加已经无法帮助模型学到更多有用的特征，且深度的增加也可能会导致模型出现过拟合现象，致使准确率无法得到进一步提升。</li></ul></li><li>对比经典 CNN 网络<ul><li>VGG19 模型拥有近 1.4 亿的参数量，其规模也是本次测试中最大的模型。 VGG19 的测试结果（71.61%），也证明了使用更小的卷积核（3 * 3）并且增加卷积神经网络的深度，可以有效地提升模型的性能。</li><li>ResNet101 通过引入残差块在网络内部跳跃连接，缓解了深度增加所导致的梯度消失的问题。从模型结果来看（83.92%），在增加模型深度，缓解梯度消失问题的同时也减少了参数量，相比于 VGG19 模型取得了更好的效果。</li></ul></li><li>对比 Transformer 网络<ul><li>本次所选用的 Transformer 网络都是该系列下的基础模型。ViT_b_32 模型 和 Swin_b 模型参数量相当，最后测试结果也较为接近，都具有较好的性能。</li><li>值得一提的是，在实际训练和测试时，Swin_b 模型对显存的占用非常高，训练时大约需要 15G 左右的显存空间，而测试时大概需要 30G 左右的显存空间，对硬件设备的要求很高。</li></ul></li></ol><h1>五、总结与优化</h1><h2 id="总结">总结</h2><ul><li>从自建 CNN 网络到 VGG 模型，可以看出增加网络的宽度和深度可以很好的提高模型的性能；但如果一直简单地增加深度，可能会遇到梯度爆炸或梯度消失的问题，对于前者可以尝试使用正则化的方式解决，但对于梯度消失的问题，就需要引入残差网络，在不增加额外参数的情况下，尽可能让深层次的模型得到充分训练，进而继续提升模型的性能，上述过程也在本次实验中得到了充分的验证。</li><li>转向 Transformer 架构，在 ViT 模型的思路下，用自注意力机制来捕捉全局图像信息，从而得到全连接的网络结构，能够很好的捕捉数据的特征；Swin 模型进一步采用分层的窗口化注意力机制和分层的网络结构，在降低计算复杂度的同时，也通过层级嵌套捕捉了多尺度的特征，使得模型在处理不同尺度的信息时更加灵活。</li><li>但是在本次实验中，ResNet 和 ViT 以及 Swin 的模型性能（测试集准确率）相近，没能很好的展现出 Transformer 架构在 CV 领域的巨大潜力。推测其中的原因，一是 ResNet 残差网络的性能确实很好，能够非常显著的降低梯度消失风险、提升 CNN 网络的性能；二是本次实验所选用的 CIFAR100 数据集相对原本的 ImageNet 而言更简单，用 ResNet 模型就足以捕捉其中的关键特征，能够较好的完成分类任务，ViT 和 Swin 的潜力没能得到充分发挥；三是模型的选用及训练策略的不足，本次实验选用的 ResNet 模型为 101 层，而 ViT 和 Swin 都只选用了 Base 模型，同时训练的 Epoch 较少，损失函数和优化器的选用没有做进一步的比对分析，学习率也没有做进一步的尝试。</li></ul><h2 id="优化">优化</h2><ul><li>宏观层面，下一步将继续尝试不同的模型，结合模型结构和实验结果分析每种模型的特点、改进点。</li><li>微观层面，下一步将尝试调整训练策略，增加 Epoch 的同时引入验证集，根据验证集准确率等指标提前停止训练防止模型过拟合现象的产生，同时将尝试不同的损失函数和优化器，以及综合使用 Warm up、余弦退火等技巧逐步改善学习率，进一步提升模型的性能。</li></ul>]]></content>
    
    
    <summary type="html">CIFAR100 经典 CNN 与 ViT 模型对比</summary>
    
    
    
    <category term="CV" scheme="https://www.angfff.top/categories/CV/"/>
    
    <category term="CNN" scheme="https://www.angfff.top/categories/CV/CNN/"/>
    
    <category term="ViT" scheme="https://www.angfff.top/categories/CV/ViT/"/>
    
    
    <category term="DL" scheme="https://www.angfff.top/tags/DL/"/>
    
    <category term="CV" scheme="https://www.angfff.top/tags/CV/"/>
    
    <category term="CNN" scheme="https://www.angfff.top/tags/CNN/"/>
    
    <category term="ViT" scheme="https://www.angfff.top/tags/ViT/"/>
    
    <category term="Transformer" scheme="https://www.angfff.top/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>每日LeetCode_230903</title>
    <link href="https://www.angfff.top/posts/4d3cdec0.html"/>
    <id>https://www.angfff.top/posts/4d3cdec0.html</id>
    <published>2023-09-03T14:26:37.000Z</published>
    <updated>2025-02-09T03:33:56.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-寻找两个正序数组的中位数">4.寻找两个正序数组的中位数</h2><h3 id="（1）题目">（1）题目</h3><p>给定两个大小分别为 <code>m</code> 和 <code>n</code> 的正序（从小到大）数组 <code>nums1</code> 和 <code>nums2</code>。请你找出并返回这两个正序数组的 <strong>中位数</strong> 。</p><p>算法的时间复杂度应该为 <code>O(log (m+n))</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,3], nums2 = [2]</span><br><span class="line">输出：2.00000</span><br><span class="line">解释：合并数组 = [1,2,3] ，中位数 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 = [1,2], nums2 = [3,4]</span><br><span class="line">输出：2.50000</span><br><span class="line">解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>nums1.length == m</code></li><li><code>nums2.length == n</code></li><li><code>0 &lt;= m &lt;= 1000</code></li><li><code>0 &lt;= n &lt;= 1000</code></li><li><code>1 &lt;= m + n &lt;= 2000</code></li><li><code>-106 &lt;= nums1[i], nums2[i] &lt;= 106</code></li></ul><h3 id="（2）题解">（2）题解</h3><blockquote><p>给定两个有序数组，要求找到两个有序数组的中位数，最直观的思路有以下两种：</p><ol><li>使用归并的方式，合并两个有序数组，得到一个大的有序数组。大的有序数组的中间位置的元素，即为中位数。第一种思路的时间复杂度是 O(m+n) ，空间复杂度是 O(m+n) ；</li><li>不需要合并两个有序数组，只要找到中位数的位置即可。由于两个数组的长度已知，因此中位数对应的两个数组的下标之和也是已知的。维护两个指针，初始时分别指向两个数组的下标 0 的位置，每次将指向较小值的指针后移一位（如果一个指针已经到达数组末尾，则只需要移动另一个数组的指针），直到到达中位数的位置。空间复杂度降到 O(1) ，时间复杂度仍是 O(m+n) ；</li></ol></blockquote><ul><li><p>不合并数组，依次取数，直至中位数位置</p><p>中位数的位置一定在 (m+n)/2 附近：</p><ul><li>如果是偶数，中位数就是最后取的两个数的平均数；</li><li>如果是奇数，中位数就是最后取的那个数。</li></ul><p>取数阶段，循环 (m + n) / 2.0 + 1 次即可；判断中位数时，关键是奇数情况，可能有指针溢出，需要判断一下。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 nums1 和 nums2 中每次取一个数，直到取出的数的个数 &lt;= (m+n)/2 + 1</span></span><br><span class="line"><span class="type">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>, y = <span class="number">0</span>; <span class="comment">// x, y 分别是 nums1 和 nums2 的下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= (m + n) / <span class="number">2.0</span> + <span class="number">1</span>; ++i)&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt; m &amp;&amp; y &lt; n)&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums1[x] &lt; nums2[y]) ++x;</span><br><span class="line">    <span class="keyword">else</span> ++y;</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (x &lt; m) ++x;</span><br><span class="line">  <span class="keyword">else</span> ++y;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> ((m + n) % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> (nums1[x - <span class="number">1</span>] + nums2[y - <span class="number">1</span>]) / <span class="number">2.0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt;= m)&#123;</span><br><span class="line">    <span class="keyword">return</span> nums1[x - <span class="number">1</span>];</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span> (y &gt;= n)&#123;</span><br><span class="line">    <span class="keyword">return</span> nums2[y - <span class="number">1</span>];</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(nums1[x - <span class="number">1</span>], nums2[y - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法测试用例可行，但 LeetCode 无法通过，可能是指针溢出形成空指针不被允许。</p></li><li><p>改进</p><p>我们首先计算出两个数组的长度，然后将它们的长度相加，得到总长度。接下来，我们使用一个循环来遍历这两个数组，直到到达中位数的位置。在循环中，我们维护两个指针 <code>aStart</code> 和 <code>bStart</code>，它们分别指向两个数组的下标 0 的位置。我们还维护两个变量 <code>left</code> 和 <code>right</code>，它们分别表示当前的中位数和前一个元素。在每次循环中，我们将 <code>left</code> 的值更新为 <code>right</code>，然后将指向较小值的指针后移一位。最后，如果总长度是偶数，则中位数是 <code>left</code> 和 <code>right</code> 的平均值，否则中位数是 <code>right</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> m = nums1.<span class="built_in">size</span>(), n = nums2.<span class="built_in">size</span>();</span><br><span class="line"><span class="type">int</span> len = m + n;</span><br><span class="line"><span class="type">int</span> left = <span class="number">-1</span>, right = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> aStart = <span class="number">0</span>, bStart = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len / <span class="number">2</span>; i++)&#123;</span><br><span class="line">left = right;</span><br><span class="line">  <span class="keyword">if</span> (aStart &lt; m &amp;&amp; (bStart &gt;= n || nums1[aStart] &lt; nums2[bStart]))&#123;</span><br><span class="line">    right = nums1[aStart++];</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    right = nums2[bStart++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (len % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> (left + right) / <span class="number">2.0</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二分查找</p><p>如果对时间复杂度的要求有 log⁡ ，通常都需要用到二分查找：</p><p>根据中位数的定义，当 m+n 是奇数时，中位数是两个有序数组中的第 (m+n)/2 个元素，当 m+n 是偶数时，中位数是两个有序数组中的第 (m+n)/2 个元素和第 (m+n)/2+1 个元素的平均值。因此，这道题可以转化成寻找两个有序数组中的第 k 小的数，其中 k 为 (m+n)/2 或 (m+n)/2+1 。</p><p>假设两个有序数组分别是 A 和 B。要找到第 k 个元素，我们可以比较 A[k/2−1] 和 B[k/2−1] ，其中 / 表示整数除法。由于 A 和 B 的前面分别有  k/2−1 个元素，对于 A[k/2−1] 和 B[k/2−1] 中的较小值，最多只会有 (k/2−1)+(k/2−1)≤k−2 个元素比它小，那么它就不能是第 k 小的数了。</p><p>因此我们可以归纳出三种情况：</p><ol><li>如果 A[k/2−1]&lt;B[k/2−1] ，则比 A[k/2−1] 小的数最多只有 A 的前 k/2−1 个数和 B 的前 k/2−1 个数，即比 A[k/2−1] 小的数最多只有 k−2 个，因此 A[k/2−1] 不可能是第 k 个数，A[0] 到 A[k/2−1] 也都不可能是第 k 个数，可以全部排除。</li><li>如果 A[k/2−1]&gt;B[k/2−1] ，则可以排除 B[0] 到 B[k/2−1] 。</li><li>如果 A[k/2−1]=B[k/2−1] ，则可以归入第一种情况处理。</li></ol><p><img src="https://assets.leetcode-cn.com/solution-static/4/4_fig1.png" alt=""></p><p>可以看到，比较 A[k/2−1] 和 B[k/2−1] 之后，可以排除 k/2 个不可能是第 k 小的数，查找范围缩小了一半。同时，我们将在排除后的新数组上继续进行二分查找，并且根据我们排除数的个数，减少 k 的值，这是因为我们排除的数都不大于第 k 小的数。</p><p>有以下三种情况需要特殊处理：</p><ol><li>如果 A[k/2−1] 或者 B[k/2−1] 越界，那么我们可以选取对应数组中的最后一个元素。在这种情况下，我们必须根据排除数的个数减少 k 的值，而不能直接将 k 减去 k/2。</li><li>如果一个数组为空，说明该数组中的所有元素都被排除，我们可以直接返回另一个数组中第 k 小的元素。</li><li>如果 k=1 ，我们只要返回两个数组首元素的最小值即可。</li></ol><p>用一个例子说明上述算法。假设两个有序数组如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: 1 3 4 9</span><br><span class="line">B: 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>两个有序数组的长度分别是 4 和 9，长度之和是 13，中位数是两个有序数组中的第 7 个元素，因此需要找到第 k=7 个元素。</p><p>比较两个有序数组中下标为 k/2−1=2 的数，即 A[2]=4 和 B[2]=3 ，如下面所示：<br>由于 A[2]&gt;B[2] ，因此排除 B[0] 到 B[2] ，即数组 B 的下标偏移（offset）变为 3，同时更新 k 的值：k=k−k/2=4。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: 1 3 4 9</span><br><span class="line">B: [1 2 3] 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>下一步寻找，比较两个有序数组中下标为 k/2−1=1 的数，即 A[1]=3 和 B[4]=5 ，如下面所示，其中方括号部分表示已经被排除的数。<br>由于 A[1]&lt;B[4]，因此排除 A[0] 到 A[1]，即数组 A 的下标偏移变为 2，同时更新 k 的值：k=k−k/2=2。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: [1 3] 4 9</span><br><span class="line">B: [1 2 3] 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>下一步寻找，比较两个有序数组中下标为 k/2−1=0 的数，即比较 A[2]=4 和 B[3]=4 ，如下面所示，其中方括号部分表示已经被排除的数。<br>由于 A[2]=B[3]，根据之前的规则，排除 A 中的元素，因此排除 A[2] ，即数组 A 的下标偏移变为 3 ，同时更新 k 的值： k=k−k/2=1 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A: [1 3 4] 9</span><br><span class="line">B: [1 2 3] 4 5 6 7 8 9</span><br></pre></td></tr></table></figure><p>由于 k 的值变成 1，因此比较两个有序数组中的未排除下标范围内的第一个数，其中较小的数即为第 k 个数，由于 A[3]=9&gt;B[3]=4 ，因此第 k 个数是 B[3]=4。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getKthElement</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span></span><br><span class="line"><span class="comment">         * 这里的 &quot;/&quot; 表示整除</span></span><br><span class="line"><span class="comment">         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span></span><br><span class="line"><span class="comment">         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span></span><br><span class="line"><span class="comment">         * 这样 pivot 本身最大也只能是第 k-1 小的元素</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span></span><br><span class="line"><span class="comment">         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span></span><br><span class="line"><span class="comment">         * 由于我们 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> m = nums1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> index1 = <span class="number">0</span>, index2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 边界情况</span></span><br><span class="line">            <span class="keyword">if</span> (index1 == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums2[index2 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (index2 == n) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums1[index1 + k - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">min</span>(nums1[index1], nums2[index2]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 正常情况</span></span><br><span class="line">            <span class="type">int</span> newIndex1 = <span class="built_in">min</span>(index1 + k / <span class="number">2</span> - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> newIndex2 = <span class="built_in">min</span>(index2 + k / <span class="number">2</span> - <span class="number">1</span>, n - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> pivot1 = nums1[newIndex1];</span><br><span class="line">            <span class="type">int</span> pivot2 = nums2[newIndex2];</span><br><span class="line">            <span class="keyword">if</span> (pivot1 &lt;= pivot2) &#123;</span><br><span class="line">                k -= newIndex1 - index1 + <span class="number">1</span>;</span><br><span class="line">                index1 = newIndex1 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                k -= newIndex2 - index2 + <span class="number">1</span>;</span><br><span class="line">                index2 = newIndex2 + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> totalLength = nums1.<span class="built_in">size</span>() + nums2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (totalLength % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">getKthElement</span>(nums1, nums2, (totalLength + <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">return</span> (<span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span>) + <span class="built_in">getKthElement</span>(nums1, nums2, totalLength / <span class="number">2</span> + <span class="number">1</span>)) / <span class="number">2.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="（3）知识点">（3）知识点</h3><ul><li><a href="https://suanfa8.com/binary-search">二分查找总结</a></li><li><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/39941/jiang-qi-zhuan-wei-zhao-liang-ge-you-xu-shu-zu-de-/">本题思路 1</a></li><li><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/solutions/6098/4-xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-shu/">本题思路 2</a></li></ul>]]></content>
    
    
    <summary type="html">每日LeetCode 寻找两个正序数组的中位数</summary>
    
    
    
    <category term="算法" scheme="https://www.angfff.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://www.angfff.top/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://www.angfff.top/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://www.angfff.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>每日LeetCode_230902</title>
    <link href="https://www.angfff.top/posts/3a3bee56.html"/>
    <id>https://www.angfff.top/posts/3a3bee56.html</id>
    <published>2023-09-02T14:20:44.000Z</published>
    <updated>2025-02-09T03:33:56.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="3-无重复字符的最长子串">3. 无重复字符的最长子串</h2><h3 id="（1）题目">（1）题目</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 </span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h3 id="（2）题解">（2）题解</h3><ul><li><p>暴力循环</p><p>两层循环，外层循环从左侧开始，依次移动；内层循环从外层循环的下一个位置开始移动，每移动一次检测是否有重复，若有重复，则找到当前起始位置的最长子串，停止内层循环。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 哈希表，用于检测是否有重复字符</span></span><br><span class="line">unordered_set&lt;<span class="type">char</span>&gt; HashTable;</span><br><span class="line"><span class="comment">// 最长子串长度</span></span><br><span class="line"><span class="type">int</span> maxlength = <span class="number">0</span>;       </span><br><span class="line"><span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line"><span class="comment">// 外层循环从左向右遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">  HashTable.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">  <span class="comment">// 内层循环从 i + 1 开始向右遍历</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)&#123;</span><br><span class="line">    <span class="comment">// 如果 j 到达边界，或者出现重复字符</span></span><br><span class="line">    <span class="keyword">if</span>(j == n || HashTable.<span class="built_in">find</span>(s[j]) != HashTable.<span class="built_in">end</span>())&#123;</span><br><span class="line">      <span class="comment">// 更新最长子串长度</span></span><br><span class="line">      maxlength = <span class="built_in">max</span>(maxlength, j - i);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，将 s[j] 加入哈希表</span></span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      HashTable.<span class="built_in">insert</span>(s[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 清空哈希表</span></span><br><span class="line">  HashTable.<span class="built_in">clear</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxlength;</span><br></pre></td></tr></table></figure><p>该方法在每次外层循环时都要重建哈希表，对于内存的占用过高；同时，因为有两层循环，且每次都是逐个字母检测，耗时过长，并不推荐使用。</p></li><li><p>滑动窗口</p><p>假设我们选择字符串中的第 k 个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为 rk 。 那么当我们选择第 k+1 个字符作为起始位置时，首先从 k+1 到 rk 的字符显然是不重复的，并且由于少了原本的第 k 个字符，可以尝试继续增大 rk ，直到右侧出现了重复字符为止。</p><ul><li><p>使用两个指针表示字符串中的某个子串（或窗口）的左右边界，其中左指针代表「枚举子串的起始位置」，右指针代表窗口的结束位置 rk ；</p></li><li><p>在每一步的操作中，将左指针向右移动一格，表示开始枚举下一个字符作为起始位置，然后不断地向右移动右指针，但需要保证这两个指针对应的子串中没有重复的字符。在移动结束后，这个子串就对应着<em><strong>以左指针开始的，不包含重复字符的最长子串</strong></em>；</p></li><li><p>判断重复字符：哈希表（即 C++ 中的 std::unordered_set，Java 中的 HashSet，Python 中的 set, JavaScript 中的 Set）。在左指针向右移动的时候，从哈希集合中移除一个字符，在右指针向右移动的时候，往哈希集合中添加一个字符。</p><p><strong>注意：这里所使用的哈希表只是为了确认每次加入的新字母是否与已有序列重复，因此加入后，统计表中的新字母的个数即可。</strong></p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 哈希集合，记录每个字符是否出现过</span></span><br><span class="line">      unordered_set&lt;<span class="type">char</span>&gt; occ;</span><br><span class="line">      <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">      <span class="comment">// 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动</span></span><br><span class="line">      <span class="type">int</span> rk = <span class="number">-1</span>, ans = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 枚举左指针的位置，初始值隐性地表示为 -1</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="comment">// 左指针向右移动一格，移除一个字符</span></span><br><span class="line">          occ.<span class="built_in">erase</span>(s[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rk + <span class="number">1</span> &lt; n &amp;&amp; !occ.<span class="built_in">count</span>(s[rk + <span class="number">1</span>]))&#123;</span><br><span class="line">          <span class="comment">// 不断地移动右指针</span></span><br><span class="line">          occ.<span class="built_in">insert</span>(s[rk + <span class="number">1</span>]);</span><br><span class="line">          ++rk;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第 i 到 rk 个字符是一个极长的无重复字符子串</span></span><br><span class="line">        ans = <span class="built_in">max</span>(ans, rk - i + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>进一步改进，出现重复字符就缩小窗口</p><p>外层循环改进为 右指针到达字符串末尾就停止循环，这样可以减少一定的循环次数；</p><p>循环内，仅用了 c 和 d 两个临时变量用于存储窗口的边界字符，并利用此检测是否有重复字符以及增减出现次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>; <span class="comment">// 记录最长集合</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>; <span class="comment">// 窗口左指针</span></span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>; <span class="comment">// 窗口右指针</span></span><br><span class="line">        <span class="comment">// 哈希表，记录每个字符是否出现过</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; window;</span><br><span class="line">        <span class="comment">// 外层循环，扩张窗口</span></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[right]; <span class="comment">// 记录右指针字符</span></span><br><span class="line">            right++;</span><br><span class="line">            window[c]++; <span class="comment">// 将 c 在哈希表中出现的次数+1</span></span><br><span class="line">            <span class="comment">// 如果出现重复字符，就缩小窗口</span></span><br><span class="line">            <span class="keyword">while</span> (window[c] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="type">char</span> d = s[left]; <span class="comment">// 记录左指针字符</span></span><br><span class="line">                left++;</span><br><span class="line">                window[d]--; <span class="comment">// 减少 d 的出现次数</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最长集合</span></span><br><span class="line">            res = <span class="built_in">max</span>(res, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><code>window[c]++</code> 这一句代码的意思是将字符 <code>c</code> 在 <code>window</code> 映射中的出现次数加 1。如果 <code>c</code> 在 <code>window</code> 映射中不存在，则会自动插入一个键值对 <code>(c, 0)</code>，然后将出现次数加 1。这个操作可以用来维护当前窗口中每个字符的出现次数。</p></blockquote></li></ul><h3 id="（3）知识点">（3）知识点</h3><ol><li>滑动窗口算法：该算法是一种常用的解决字符串子串问题的方法。它通过维护一个窗口，来遍历字符串中的所有子串。在每次移动窗口时，可以通过一些技巧来避免重复计算，从而达到线性时间复杂度的目的。</li><li>哈希表：哈希表是一种常用的数据结构，可以用来快速地查找和插入元素。在本题中，我们可以使用哈希表来维护当前窗口中每个字符的出现次数。</li><li>双指针：双指针是一种常用的技巧，可以使用两个指针 <code>i</code> 和 <code>j</code> 来维护当前窗口的左右边界。</li></ol>]]></content>
    
    
    <summary type="html">每日LeetCode 无重复字符的最长子串</summary>
    
    
    
    <category term="算法" scheme="https://www.angfff.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://www.angfff.top/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://www.angfff.top/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://www.angfff.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Docker入门</title>
    <link href="https://www.angfff.top/posts/89826705.html"/>
    <id>https://www.angfff.top/posts/89826705.html</id>
    <published>2023-08-31T15:14:57.000Z</published>
    <updated>2025-02-09T03:33:56.698Z</updated>
    
    <content type="html"><![CDATA[<h1>Docker 入门</h1><h2 id="一、-Docker-介绍">一、 Docker 介绍</h2><p>Docker 是一个用于 构建(build)、运行(run)、传送(share) 应用程序的平台。</p><p>通过 Docker 我们可以将应用程序及其运行时所依赖的环境、第三方软件库、配置文件等打包在一起，行成一个个“集装箱”，运送至其他平台，以便于在任何环境中正确地运行。</p><h2 id="二、-Docker-应用场景">二、 Docker 应用场景</h2><blockquote><p>应用隔离、环境配置、 安装部署、持续集成、持续发布、DevOps</p></blockquote><p>例如，我们利用目前较为主流的前后端分离架构写了一个网站，前端使用 Vue 来构建网站的界面，后端使用 Java 的 SpringBoot 微服务架构来提供各种服务和接口，使用 MySQL 数据库来存储数据。</p><p>如果不使用 Docker，我们需要先安装 NodeJs 环境、安装各种 npm 依赖包，配置 Java 运行环境，安装 SpringBoot 微服务的各种第三方依赖包，安装 MySQL 数据库，以及配置各种环境变量、启动服务等。与此同时，如果要把该网站部署在测试环境和生产环境上，还需要将上述步骤再重复一遍。</p><p>相反，如果我们使用 Docker，只要我们在开发环境中配置好了所有环境并将其打包成一个“集装箱”，那么就可以直接在其他环境中直接运行。</p><h2 id="三、容器和虚拟机的区别">三、容器和虚拟机的区别</h2><h3 id="（一）传统虚拟机">（一）传统虚拟机</h3><p>传统虚拟机软件包括：VMware 、 Virtalbox、 Parallels Desktop 、 WSL 、 Hyper-V 等</p><p>虚拟机是完整的操作系统，可以在该操作系统中运行各种支持的应用程序。虚拟机实际上是利用 虚拟化技术(Hypervisor) 将物理资源虚拟化为多个逻辑资源，它可以将一个物理服务器虚拟为多个逻辑服务器，每个逻辑服务器都有自己的操作系统、 CPU 、内存、硬盘和网络接口等。逻辑服务器之间是完全隔离的，可以独立运行。</p><p>虚拟机在一定程度上实现了资源的整合，可以将一台服务器的计算能力、存储能力、网络资源分配给多台虚拟服务器，实现多台服务器的功能。但虚拟机也存在一定的缺点，每台虚拟服务器都将占用非常多的资源，且启动速度慢。</p><p>实际上我们并不需要让每台服务器都运行多个虚拟机。通常情况下，每台物理服务器都有其特定的用途，如 Web 服务器只需提供收发数据包的功能即可，并不需要一个完整的操作系统，因此没有必要在该服务器上使用虚拟机来收发数据包。</p><h3 id="（二）容器">（二）容器</h3><p>容器是一个虚拟化技术，一定程度上类似虚拟机，是一个独立的环境。Docker 是容器的一种实现方式，是一个容器话的解决方案和平台。</p><p>与虚拟机不同的是，容器中并不需要运行一个完整的操作系统便可以运行应用程序，因此其占用的资源更少、启动速度更快。</p><h2 id="四、基本原理">四、基本原理</h2><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Docker%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.jpeg" alt="Docker基本概念"></p><h3 id="（一）镜像-images">（一）镜像 images</h3><p>镜像是一个只读模版，可以用来创建容器。（类）</p><h3 id="（二）容器-containers">（二）容器 containers</h3><p>容器是 Docker 的运行实例，提供了一个独立的可移植的环境，可以在该环境中运行应用程序。（对象）</p><h3 id="（三）仓库-registry">（三）仓库 registry</h3><p>用于存储 Docker 镜像。</p><h2 id="五、安装配置">五、安装配置</h2><h3 id="（一）安装">（一）安装</h3><ul><li><p>macOS 安装</p><p>下载安装即可。安装后运行 Docker，便可以在终端中使用 Docker 命令。</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/Docker%E5%AE%89%E8%A3%85.png" alt="Docker安装"></p></li><li><p>Windows 安装</p><p>下载安装完毕后，需要在系统设置-Windows 功能中开启 Hyper-V 功能，才能正常启用 Docker 。</p></li></ul><h3 id="（二）容器化">（二）容器化</h3><ol><li>将应用程序打包成容器，然后在容器中运行应用程序的过程。</li><li>容器化步骤：<ol><li>创建一个 Dockerfile ；</li><li>使用 Dockerfile 构建镜像；</li><li>使用镜像创建和运行容器。</li></ol></li><li>Dockerfile：文本文件，包含了多条指令，用于指导 Docker 构建镜像。通常包括精简版的操作系统、应用程序的运行环境、应用程序本体、第三方依赖包或库、应用程序的配置文件、环境变量等。</li></ol><h2 id="六、常用命令">六、常用命令</h2><p><a href="https://www.runoob.com/docker/docker-command-manual.html">Docker 常用命令</a></p><h2 id="七、构建镜像并启动容器">七、构建镜像并启动容器</h2><h3 id="（一）创建-Dockerfile-文件">（一）创建 Dockerfile 文件</h3><ol><li><p>创建 HelloDocker 文件夹；</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/1-1%20%E5%88%9B%E5%BB%BA%20HelloDocker%20%E6%96%87%E4%BB%B6%E5%A4%B9.png" alt=""></p></li><li><p>在项目文件夹中创建 index.js 文件并键入简单 JS 命令，使之在控制台输出语句；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在控制台输出语句</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/1-2%20%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F.png" alt=""></p><p>现在，在开发环境中已经可以输出语句了；</p><p>但是，如果我们需要在其他环境也运行该程序，就需要安装兼容的操作系统、JS 运行环境 NodeJS，并将该程序及其依赖包和配置文件一并复制到新的环境中，才能正常运行；</p><p>此时，就可以利用 Docker，将这些步骤打包起来，写入 Dockerfile 文件中。</p></li><li><p>在项目文件夹中创建 Dockerfile 文件并写入相关命令；</p><ol><li><p>设置镜像</p><p>镜像是按层次结构来构建的，每一层都是基于上一层的，因此需要先指定一个基础镜像；然后在该镜像的基础上添加应用程序。</p><p>这里使用到了 NodeJS ，因此需要添加其对应的基础镜像，本来应该从 Linux 的基础镜像（操作系统）开始，例如 alpine ，但 NodeJS 的镜像实际上已经是基于 Alpine 镜像构建的了，所以我们可以直接使用 NodeJS 的镜像作为我们的基础镜像。</p></li><li><p>将应用程序复制到 Docker 中</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> 源文件路径 目标路径</span></span><br></pre></td></tr></table></figure></li><li><p>在镜像中运行应用程序</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;可执行程序名&quot;</span>, <span class="string">&quot;可执行程序接受的参数&quot;</span>]</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/1-3%20%E7%BC%96%E5%86%99%20Dockerfile%20%E6%96%87%E4%BB%B6.png" alt=""></p></li></ol></li></ol><h3 id="（二）创建镜像">（二）创建镜像</h3><ol><li><p>在终端中创建镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker build -t 镜像名称[:版本号] 目录</span><br><span class="line">// 版本号可省略，不指定版本默认使用最新版本</span><br><span class="line">// . 表示当前目录</span><br></pre></td></tr></table></figure><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/2-1%20%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F.png" alt=""></p></li><li><p>查看镜像是否创建成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br><span class="line">// docker image ls</span><br></pre></td></tr></table></figure></li></ol><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/2-2%20%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F.png" alt=""></p><h3 id="（三）运行镜像">（三）运行镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run 镜像名称</span><br></pre></td></tr></table></figure><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/2-3%20%E8%BF%90%E8%A1%8C%E9%95%9C%E5%83%8F.png" alt=""></p><h3 id="（四）在其他环境中运行镜像">（四）在其他环境中运行镜像</h3><ul><li><p>将镜像复制到当前环境中，运行即可；</p></li><li><p>将镜像上传至 Dockerhub 中，在任意环境中 pull 拉取再运行即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull 用户名/镜像名称</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">容器是将操作系统层虚拟化，虚拟机则是虚拟化硬件。借助 Docker 可以更便捷地实现应用的开发、交付和运行。</summary>
    
    
    
    <category term="必备工具" scheme="https://www.angfff.top/categories/%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Docker" scheme="https://www.angfff.top/categories/%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/Docker/"/>
    
    
    <category term="必备工具" scheme="https://www.angfff.top/tags/%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Docker" scheme="https://www.angfff.top/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>每日LeetCode_230831</title>
    <link href="https://www.angfff.top/posts/89dd8618.html"/>
    <id>https://www.angfff.top/posts/89dd8618.html</id>
    <published>2023-08-31T05:16:06.000Z</published>
    <updated>2025-02-09T03:33:56.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2-两数相加">2. 两数相加</h2><h3 id="（1）题目">（1）题目</h3><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg" alt="题目示例"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [2,4,3], l2 = [5,6,4]</span><br><span class="line">输出：[7,0,8]</span><br><span class="line">解释：342 + 465 = 807.</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [0], l2 = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><br><span class="line">输出：[8,9,9,9,0,0,0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 9</code></li><li>题目数据保证列表表示的数字不含前导零</li></ul><h3 id="（2）题解">（2）题解</h3><ul><li><p>循环对位相加</p><p>对应位依次相加，利用额外变量追踪进位情况。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">//记录当前位的和</span></span><br><span class="line"><span class="type">int</span> carry = <span class="number">0</span>; <span class="comment">//记录下一位的进位情况</span></span><br><span class="line"></span><br><span class="line">ListNode* result =<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">ListNode* cur = result; <span class="comment">//result 固定在头结点，current 移动</span></span><br><span class="line">      </span><br><span class="line"><span class="comment">//该循环用于计算 l1 和 l2 有相同的位数的部分</span></span><br><span class="line"><span class="keyword">while</span> (l1 != <span class="literal">NULL</span> <span class="keyword">and</span> l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">sum = l1-&gt;val + l2-&gt;val + carry;</span><br><span class="line">cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>); <span class="comment">//取余</span></span><br><span class="line">carry = sum / <span class="number">10</span>; <span class="comment">//取整，有进位是 1，否则是 0</span></span><br><span class="line"><span class="comment">//向后移动</span></span><br><span class="line">l1 = l1-&gt;next;</span><br><span class="line">l2 = l2-&gt;next;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环结束后，判断是否还有余下的位数</span></span><br><span class="line"><span class="keyword">while</span> (l1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">sum = l1-&gt;val + carry;</span><br><span class="line">cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">carry = sum / <span class="number">10</span>;</span><br><span class="line">l1 = l1-&gt;next;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">sum = l2-&gt;val + carry;</span><br><span class="line">cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">carry = sum / <span class="number">10</span>;</span><br><span class="line">l2 = l2-&gt;next;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述循环都结束后，所有位数均已遍历，最后检查是否还有进位</span></span><br><span class="line"><span class="keyword">if</span> (carry != <span class="number">0</span>)&#123;</span><br><span class="line">cur-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="keyword">return</span> result-&gt;next;</span><br></pre></td></tr></table></figure></li><li><p>改进</p><p>简化了循环的过程，一次循环即可遍历两个链表的所有位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">ListNode* head=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);<span class="comment">//存放结果的链表</span></span><br><span class="line">ListNode* h=head;<span class="comment">//移动指针</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum=<span class="number">0</span>;<span class="comment">//每个位的加和结果</span></span><br><span class="line"><span class="type">bool</span> carry=<span class="literal">false</span>;<span class="comment">//进位标志</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该循环用于将 l1 和 l2 的每一位都遍历</span></span><br><span class="line"><span class="keyword">while</span>(l1!=<span class="literal">NULL</span>||l2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">  sum=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span>(l1!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    sum+=l1-&gt;val;</span><br><span class="line">    l1=l1-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(l2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">    sum+=l2-&gt;val;</span><br><span class="line">    l2=l2-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(carry)</span><br><span class="line">    sum++;</span><br><span class="line">  h-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">  h=h-&gt;next;</span><br><span class="line">  carry=sum&gt;=<span class="number">10</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后判断是否有进位</span></span><br><span class="line"><span class="keyword">if</span>(carry)&#123;</span><br><span class="line">  h-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head-&gt;next;</span><br></pre></td></tr></table></figure></li><li><p>递归法</p><p>将两个链表从头开始相加，每次将两个链表的当前节点以及上一次相加的进位相加，得到一个新的节点，并将这个节点的 next 指针指向下一次递归的结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">addTwoNumbersHelper</span>(l1, l2, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 递归函数 参数包括两个链表以及上一次相加的进位，返回值是相加后的链表</span></span><br><span class="line">  <span class="function">ListNode* <span class="title">addTwoNumbersHelper</span><span class="params">(ListNode* l1, ListNode* l2, <span class="type">int</span> carry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先判断递归结束的条件，即两个链表都为空且进位为 0</span></span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span> &amp;&amp; l2 == <span class="literal">nullptr</span> &amp;&amp; carry == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算当前节点的值</span></span><br><span class="line">    <span class="type">int</span> sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + carry;</span><br><span class="line">    <span class="comment">// 创建一个新的节点 并取余赋值</span></span><br><span class="line">    ListNode* node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 递归，将这个节点的 next 指针指向下一次递归的结果</span></span><br><span class="line">    node-&gt;next = <span class="built_in">addTwoNumbersHelper</span>(l1 ? l1-&gt;next : <span class="literal">nullptr</span>, l2 ? l2-&gt;next : <span class="literal">nullptr</span>, sum / <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 返回该节点</span></span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="（3）知识点">（3）知识点</h3><ul><li><p>错误 1：示例 3 最高位没有进位 1</p><p>错误原因：最后检查 carry 是否为 0 时，应该是 <code>cur-&gt;next = new ListNode(carry);</code> 而不是 <code>cur-&gt;next = new ListNode(sum%10);</code></p></li></ul>]]></content>
    
    
    <summary type="html">每日LeetCode 两数相加</summary>
    
    
    
    <category term="算法" scheme="https://www.angfff.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://www.angfff.top/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://www.angfff.top/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://www.angfff.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>每日LeetCode_230830</title>
    <link href="https://www.angfff.top/posts/fedab68e.html"/>
    <id>https://www.angfff.top/posts/fedab68e.html</id>
    <published>2023-08-30T15:48:32.000Z</published>
    <updated>2025-02-09T03:33:56.698Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-两数之和">1. 两数之和</h2><h3 id="（1）题目">（1）题目</h3><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 <strong>和为目标值</strong> <em><code>target</code></em> 的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。你可以按任意顺序返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><p><strong>进阶：</strong> 你可以想出一个时间复杂度小于 <code>O(n²)</code> 的算法吗？</p><h3 id="（2）题解">（2）题解</h3><ul><li><p>暴力法  <strong>O(n²)</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>哈希表 <strong>O(n)</strong></p><p>将每一个元素作为 key ，将其索引值作为 value 。每次查询一个元素，并与 target 做差（ target - key），如果差在表中可查，则找到并输出当前元素和查到的元素的 value ；否则检查下一个元素。</p><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/LeetCode-1-%E5%93%88%E5%B8%8C%E8%A1%A8.png" alt="LeetCode-1"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 构建哈希表</span><br><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">  map.<span class="built_in">emplace</span>(nums[i], i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 逐一检查</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); ++j)&#123;</span><br><span class="line">  <span class="type">int</span> diff = target - nums[j];</span><br><span class="line">  <span class="keyword">if</span> (map.<span class="built_in">find</span>(diff) != map.<span class="built_in">end</span>() <span class="keyword">and</span> map[diff] != j)&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;j, map[diff]&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>哈希表进一步改进</p><p>先查询 target - nums[i] 值是否存在，如果不存在才将 nums[i] 插入哈希表，等待后面的数字做差后与之比较；如果存在，则说明找到了，不必再验证后续的值，直接输出即可。</p><p>该方法可以减少省去构建哈希表时的循环，时间复杂度相同，但可节省内存空间的占用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashtable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">  <span class="keyword">auto</span> it = hashtable.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">  <span class="keyword">if</span> (it != hashtable.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;it-&gt;second, i&#125;; <span class="comment">//有则输出</span></span><br><span class="line">  &#125;</span><br><span class="line">  hashtable[nums[i]] = i; <span class="comment">//无则插入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="（3）知识点">（3）知识点</h3><ul><li><p>C++ 中 Hash 表的使用：unordered_map 容器</p><p><a href="https://blog.csdn.net/zou_albert/article/details/106983268">https://blog.csdn.net/zou_albert/article/details/106983268</a></p></li><li><p>unordered_map 的插入</p><p><a href="https://blog.csdn.net/YourClerk/article/details/123967991">https://blog.csdn.net/YourClerk/article/details/123967991</a></p></li><li><p>map 容器中的取值方式 -&gt; first / second</p><p><a href="https://blog.csdn.net/qq_38860340/article/details/121640219">https://blog.csdn.net/qq_38860340/article/details/121640219</a></p></li></ul>]]></content>
    
    
    <summary type="html">每日LeetCode 两数之和</summary>
    
    
    
    <category term="算法" scheme="https://www.angfff.top/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://www.angfff.top/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://www.angfff.top/tags/LeetCode/"/>
    
    <category term="算法" scheme="https://www.angfff.top/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>M系列 Mac CLion 环境配置问题(一)</title>
    <link href="https://www.angfff.top/posts/65843a24.html"/>
    <id>https://www.angfff.top/posts/65843a24.html</id>
    <published>2023-08-10T05:52:52.000Z</published>
    <updated>2025-02-09T03:33:56.698Z</updated>
    
    <content type="html"><![CDATA[<h1>关于 M1 Mac 中 CLion 添加头文件情况下仍无法调用 __gcd 函数的解决办法</h1><h2 id="一、问题描述">一、问题描述</h2><p>近期在学习 C++ 的过程中发现，正常调用 __gcd 函数（最大公因数函数），CLion 报错无法调用。</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; __gcd(a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误如下：</p><blockquote><p>error: use of undeclared identifier ‘__gcd’</p></blockquote><h2 id="二、问题处理">二、问题处理</h2><p>尝试各种方式后，最终发现是编译器的问题，在此记录处理过程，有相同问题的同学可以参考。</p><h3 id="（一）系统及软件版本">（一）系统及软件版本</h3><p>系统：macOS Ventura 13.2</p><p>软件：CLion 2022.3.2</p><h3 id="（二）解决流程">（二）解决流程</h3><p>之前在安装 CLion 时我直接按照 CLion 的提示安装了 Command Line Tools ，并直接使用了 CLion 的默认编译器配置，这样就有可能导致编译过程中出现错误，需要重新配一下环境。</p><ol><li>打开终端，确认Command Line Tools是否安装成功。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Xcode-<span class="keyword">select</span> -install</span><br></pre></td></tr></table></figure><ol start="2"><li>利用 Homebrew 安装 gcc</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install gcc</span><br></pre></td></tr></table></figure><p>​注：安装 gcc 编译器时可能出现问题，解决方法可参照 <a href="https://blog.csdn.net/weixin_45571585/article/details/126977413?spm=1001.2101.3001.6650.6&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-6-126977413-blog-116170561.pc_relevant_aa&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-6-126977413-blog-116170561.pc_relevant_aa&amp;utm_relevant_index=11">gcc 安装教程</a>。</p><ol start="3"><li>利用 Homebrew 安装 cmake</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install cmake</span><br></pre></td></tr></table></figure><ol start="4"><li>重新配置 CLion</li></ol><p>进入 CLion <code>设置 -- 构建、执行、部署 -- 工具链</code> 修改构建工具、 C 编译器以及 C++ 编译器，如下：</p><ul><li>原配置：</li></ul><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%80%20CLion%E5%8E%9F%E9%85%8D%E7%BD%AE.png" alt="CLion原配置"></p><ul><li>修改为：</li></ul><p><img src="https://cdn.statically.io/gh/AngFff/Blog-Pic@master/img/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E4%B8%80%20CLion%E9%85%8D%E7%BD%AE%E4%BF%AE%E6%94%B9.png" alt="CLion配置修改"></p><p><strong>注1：可能版本有点区别，只要在文件中选取 ctest 、 gcc-xx 、 g+±xx 即可；</strong></p><p><strong>注2：如果点开文件后找不到文件夹，按下 <code>commond + shift + .</code> 即可显示隐藏文件夹，选好后再按一次即可隐藏</strong></p><ol start="5"><li>重启一下 CLion 即可调用 __gcc 函数</li></ol>]]></content>
    
    
    <summary type="html">记录关于 M1 Mac 中 CLion 添加头文件情况下仍无法调用 __gcd 函数的解决办法</summary>
    
    
    
    <category term="环境配置" scheme="https://www.angfff.top/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    <category term="CLion" scheme="https://www.angfff.top/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/CLion/"/>
    
    
    <category term="Mac环境配置" scheme="https://www.angfff.top/tags/Mac%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    
    <category term="CLion" scheme="https://www.angfff.top/tags/CLion/"/>
    
  </entry>
  
  <entry>
    <title>Git基础</title>
    <link href="https://www.angfff.top/posts/1a60696b.html"/>
    <id>https://www.angfff.top/posts/1a60696b.html</id>
    <published>2023-07-23T16:13:26.000Z</published>
    <updated>2025-02-09T03:33:56.698Z</updated>
    
    <content type="html"><![CDATA[<h1>Git版本控制</h1><h2 id="一、版本控制">一、版本控制</h2><h3 id="（一）什么是版本控制？">（一）什么是版本控制？</h3><p>版本控制是一种记录和管理计算机文件或项目的变化历史的系统。它允许开发人员或团队跟踪文件的每次修改、查看更改内容、比较不同版本之间的差异，并在需要时还原到之前的特定状态。版本控制对于软件开发和其他类似项目的管理非常重要，因为它提供了许多优势和便利。</p><p>主要的版本控制系统有两种类型：集中式版本控制系统（Centralized Version Control System，CVCS）和分布式版本控制系统（Distributed Version Control System，DVCS）。</p><ol><li><p>集中式版本控制系统（CVCS）：<br>在CVCS中，所有文件的版本历史都保存在中央服务器上。开发人员通过连接到中央服务器来检出最新版本的文件，并将自己的更改提交到中央服务器。CVCS的缺点是，如果中央服务器出现故障或网络连接问题，那么开发人员将无法提交更改或获取最新的代码。此外，对于较大的团队，由于所有开发人员都使用中央服务器，可能会造成服务器性能瓶颈。</p></li><li><p>分布式版本控制系统（DVCS）：<br>在DVCS中，每个开发人员都有一个完整的代码仓库，包含完整的项目历史。开发人员可以在本地进行提交、回滚、创建分支等操作，而不需要实时连接到中央服务器。这使得团队成员可以在离线状态下工作，并且可以更加灵活地协作。当开发人员准备好时，他们可以将他们的更改推送（push）到中央服务器，或者从中央服务器拉取（pull）其他人的更改。</p></li></ol><p>版本控制系统的主要优势包括：</p><ul><li>更好的协作：团队成员可以同时在同一个项目上工作，不会干扰彼此的进度，也能更容易地合并不同人员的修改。</li><li>历史记录：每个版本都被记录下来，可以查看文件的完整修改历史，包括何时做了哪些更改。</li><li>版本回退：如果某次修改引入了问题，可以轻松回退到之前的稳定版本。</li><li>分支管理：可以创建多个分支，每个分支可用于不同的功能开发或问题修复，而不会相互干扰。</li><li>远程备份：中央服务器提供了对代码的远程备份，减少了数据丢失的风险。</li></ul><p>版本控制系统的使用不仅局限于软件开发，它还可以在各种其他场景中应用，如文档管理、项目管理、设计文件等。</p><h3 id="（二）为什么需要版本控制？">（二）为什么需要版本控制？</h3><p>以论文写作为例，在没有版本控制工具前，我们往往是通过每次修改版本都保留一个文件的方式来管理论文。通过多个文件来确定各个版本，不仅会占用更多的空间，而且也不利于我们对比版本间的差异。此外，我们也无法和他人协作。</p><p>使用版本控制工具，我们在论文写作中可以实现：</p><ol><li><p><strong>版本历史记录：</strong> 版本控制工具记录了每次对论文进行的修改和更新，包括添加、删除、编辑等。这使得作者可以随时查看论文的历史版本，了解每个修改的内容和时间，方便跟踪研究进展和撰写过程。</p></li><li><p><strong>版本回退和比较：</strong> 作者可以轻松地回退到之前的版本，如果当前的修改出现问题或需要恢复之前的内容，这在不丢失任何数据的情况下进行。此外，版本控制工具允许作者比较不同版本之间的差异，帮助他们了解具体修改的细节和影响。</p></li><li><p><strong>分支管理：</strong> 版本控制工具允许作者创建多个分支，每个分支可以用于不同的实验、讨论或章节撰写。这样可以在不影响主线论文的情况下进行尝试和修改，保持主线内容的稳定性。</p></li><li><p><strong>协作与审阅：</strong> 版本控制工具使得多位作者可以并行地对论文进行编辑和审阅。每位作者都可以在自己的本地副本上工作，然后将更改推送到共享的远程仓库。这样，团队成员可以实时了解其他人的修改，并且可以更好地合并和处理冲突。</p></li><li><p><strong>备份和安全性：</strong> 版本控制工具提供了对论文内容的远程备份，减少了数据丢失的风险。即使本地计算机出现故障，作者的论文仍然安全存储在远程服务器上。</p></li><li><p><strong>跨平台支持：</strong> 大多数版本控制工具都支持跨平台，这意味着作者可以在不同的操作系统上（如Windows、Mac、Linux）使用同一个版本控制系统，并轻松地共享和访问论文内容。</p></li><li><p><strong>注释和讨论：</strong> 版本控制工具通常支持注释和讨论功能，团队成员可以在特定的修改或提交上留下评论，以便进行讨论、提供反馈或交流想法。</p></li></ol><p>总体而言，版本控制工具为论文写作带来了更好的协作、追踪和管理的能力，提高了论文写作的效率，并保障了论文内容的安全性和稳定性。这对于研究团队、学生、教师以及其他合作写作项目的人员来说，都是非常有价值的工具。</p><h3 id="（三）常用版本控制工具？">（三）常用版本控制工具？</h3><p>常用的版本控制方法和工具主要有以下几种：</p><ol><li><p><strong>集中式版本控制系统（CVCS）：</strong></p><ul><li>CVS (Concurrent Versions System)：是最早流行的集中式版本控制系统之一，但目前已逐渐被更先进的版本控制系统所取代。</li><li>Subversion (SVN)：一种更现代和流行的集中式版本控制系统，提供了更多功能和改进，仍然在一些项目中广泛使用。</li></ul></li><li><p><strong>分布式版本控制系统（DVCS）：</strong></p><ul><li>Git：目前最流行和广泛使用的分布式版本控制系统。Git 是由 Linus Torvalds 创造的，它非常快速、强大，并得到了全球开发者社区的支持。</li><li>Mercurial：另一种流行的分布式版本控制系统，与 Git 类似，但在一些特定场景下可能具有不同的优势。</li></ul></li><li><p><strong>集成开发环境（IDE）内置版本控制：</strong></p><ul><li>一些集成开发环境（如Visual Studio、Eclipse、IntelliJ IDEA等）具有内置的版本控制集成，通常支持 Git 和 SVN 等常见的版本控制工具。</li></ul></li><li><p><strong>在线托管平台的版本控制：</strong></p><ul><li>GitHub：一个基于 Git 的在线代码托管平台，广泛用于开源项目、团队协作以及个人项目管理。</li><li>GitLab：类似于 GitHub 的另一个在线代码托管平台，提供类似的功能，并且可以自行搭建在私有服务器上。</li><li>Bitbucket：提供 Git 和 Mercurial 支持的在线代码托管平台，通常用于私有项目。</li></ul></li></ol><p>这些版本控制方法和工具在软件开发、文档管理、论文写作、项目协作等领域广泛使用。选择哪种版本控制方法和工具取决于项目的需求、团队的喜好和技术要求。Git 是目前最受欢迎和推荐的版本控制系统，它为开发者提供了强大的功能和灵活性，并在开源社区中得到广泛支持。</p><h2 id="二、-Git">二、 Git</h2><h3 id="（一）什么是-Git？">（一）什么是 Git？</h3><p>Git是一种分布式版本控制系统，它用于跟踪计算机文件的变化和协调多人在同一个项目上的协作。版本控制是在软件开发和其他类似项目中非常重要的概念，因为它允许开发人员或团队记录每个文件的更改历史并管理不同版本之间的差异。</p><p>Git由Linus Torvalds于2005年创造，最初是为了更好地管理Linux内核的开发而设计的。现在，Git已经成为世界上最流行和广泛使用的版本控制系统之一，被广泛应用于软件开发和其他项目管理中。</p><p>Git的主要特点包括：</p><ol><li><p>分布式：与传统的集中式版本控制系统不同，Git是一种分布式系统，每个开发人员都有一个完整的代码仓库，包含完整的历史记录。这使得团队成员可以在离线状态下工作，并可以更容易地进行协作。</p></li><li><p>分支管理：Git非常擅长管理分支，开发人员可以轻松地创建、合并和删除分支，这为同时处理多个功能或修复不同问题提供了便利。</p></li><li><p>快速和高效：Git被设计成非常快速和高效，使开发人员可以迅速完成各种操作，如提交、分支切换和合并等。</p></li><li><p>完整的历史记录：Git记录每个文件的完整历史记录，开发人员可以查看文件的每个版本、每次修改和对应的作者信息。</p></li><li><p>数据完整性：Git使用哈希值来保证数据的完整性，这意味着一旦数据被提交，就会被永久地记录和保留。</p></li><li><p>开放源代码：Git是开源软件，任何人都可以查看其源代码，并可以根据需要进行自定义修改。</p></li></ol><p>使用Git，开发人员可以更加灵活地协作，管理项目，并追踪代码变化，从而帮助团队更加高效地进行软件开发或其他类型的项目管理。</p><h3 id="（二）Git-工作原理">（二）Git 工作原理</h3><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg2020.cnblogs.com%2Fblog%2F932856%2F202004%2F932856-20200423143251346-796113044.jpg&amp;refer=http%3A%2F%2Fimg2020.cnblogs.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=jpeg?sec=1644374894&amp;t=7c2044128f7851ecd92de3c01f0187ca" alt="点击查看源网页"></p><p>Git 大致分为4个板块：</p><ul><li>工作目录：存放我们正在写的代码（当我们新版本开发完成之后，就可以进行新版本的提交）</li><li>暂存区：暂时保存待提交的内容（新版本提交后会存放到本地仓库）</li><li>本地仓库：位于我们电脑上的一个版本控制仓库（存放的就是当前项目各个版本代码的增删信息）</li><li>远程仓库：位于服务器上的版本控制仓库（服务器上的版本信息可以由本地仓库推送上去，也可以从服务器抓取到本地仓库）</li></ul><p>它是一个分布式的控制系统，因此一般情况下我们每个人的电脑上都有一个本地仓库，由大家共同向远程仓库去推送版本迭代信息。</p><p>通过这一系列操作，我们就可以实现每开发完一个版本或是一个功能，就提交一次新版本，这样，我们就可以很好地控制项目的版本迭代，想回退到之前的版本随时都可以回退，想查看新版本添加或是删除了什么代码，随时都可以查看。</p><h3 id="（三）安装-Git">（三）安装 Git</h3><p>首先请前往 Git 官网去下载最新的安装包：<a href="https://git-scm.com/">https://git-scm.com/</a></p><p>安装完成后，需要设定用户名和邮箱来区分不同的用户：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Ang Lee&quot;</span><br><span class="line">git config --global user.email &quot;18416841@qq.com&quot;</span><br></pre></td></tr></table></figure><h3 id="（四）基本命令介绍">（四）基本命令介绍</h3><ol><li>创建本地仓库</li></ol><p>我们可以将任意一个文件夹作为一个本地仓库，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>输入后，会自动生成一个<code>.git</code>目录，注意这个目录是一个隐藏目录，而当前目录就是我们的工作目录。</p><p>创建成功后，我们可以查看一下当前的一个状态，输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>如果已经成功配置为Git本地仓库，那么输入后可以看到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br></pre></td></tr></table></figure><p>这表示我们还没有向仓库中提交任何内容，也就是一个空的状态。</p><ol start="2"><li>添加和提交</li></ol><p>接着我们来看看，如何使用git来管理我们文档的版本，我们创建一个文本文档，随便写入一点内容，接着输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>我们会得到如下提示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">hello.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br></pre></td></tr></table></figure><p>其中Untracked files是未追踪文件的意思，也就是说，如果一个文件处于未追踪状态，那么git不会记录它的变化，始终将其当做一个新创建的文件，这里我们将其添加到暂存区，那么它会自动变为被追踪状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add hello.txt #也可以 add . 一次性添加目录下所有的</span><br></pre></td></tr></table></figure><p>再次查看当前状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">new file:   hello.txt</span><br></pre></td></tr></table></figure><p>现在文件名称的颜色变成了绿色，并且是处于Changes to be committed下面，因此，我们的hello.txt现在已经被添加到暂存区了。</p><p>接着我们来尝试将其提交到Git本地仓库中，注意需要输入提交的描述以便后续查看，比如你这次提交修改了或是新增了哪些内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&#x27;Hello World&#x27;</span></span><br></pre></td></tr></table></figure><p>注：如果是修改了文件的内容（不是增删文件），可以用以下一行命令完成添加到暂存区以及提交到本地仓库中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m <span class="string">&#x27;Modify x&#x27;</span></span><br></pre></td></tr></table></figure><p>接着我们可以查看我们的提交记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line">git <span class="built_in">log</span> --graph</span><br><span class="line">git <span class="built_in">log</span> --oneline</span><br></pre></td></tr></table></figure><p>我们还可以查看最近一次变更的详细内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git show [也可以加上commit ID查看指定的提交记录]</span><br></pre></td></tr></table></figure><p>再次查看当前状态，已经是清空状态了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure><p>接着我们可以尝试修改一下我们的文本文档，由于当前文件已经是被追踪状态，那么git会去跟踪它的变化，如果说文件发生了修改，那么我们再次查看状态会得到下面的结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">modified:   hello.txt</span><br></pre></td></tr></table></figure><p>也就是说现在此文件是处于已修改状态，我们如果修改好了，就可以提交我们的新版本到本地仓库中：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&#x27;Modify Text&#x27;</span></span><br></pre></td></tr></table></figure><p>接着我们来查询一下提交记录，可以看到一共有两次提交记录。</p><p>我们可以创建一个<code>.gitignore</code>文件来确定一个文件忽略列表，如果忽略列表中的文件存在且不是被追踪状态，那么git不会对其进行任何检查：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这样就会匹配所有以txt结尾的文件</span></span><br><span class="line"><span class="string">*.txt</span></span><br><span class="line"><span class="comment"># 虽然上面排除了所有txt结尾的文件，但是这个不排除</span></span><br><span class="line"><span class="type">!666.txt</span></span><br><span class="line"><span class="comment"># 也可以直接指定一个文件夹，文件夹下的所有文件将全部忽略</span></span><br><span class="line"><span class="string">test/</span></span><br><span class="line"><span class="comment"># 目录中所有以txt结尾的文件，但不包括子目录</span></span><br><span class="line"><span class="string">xxx/*.txt</span></span><br><span class="line"><span class="comment"># 目录中所有以txt结尾的文件，包括子目录</span></span><br><span class="line"><span class="string">xxx/**/*.txt</span></span><br></pre></td></tr></table></figure><p>创建后，我们来看看是否还会检测到我们忽略的文件。</p><ol start="3"><li>回滚</li></ol><p>当我们想要回退到过去的版本时，就可以执行回滚操作，执行后，可以将工作空间的内容恢复到指定提交的状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard commitID</span><br></pre></td></tr></table></figure><p>执行后，会直接重置为那个时候的状态。再次查看提交日志，我们发现之后的日志全部消失了。</p><p>那么要是现在我又想回去呢？我们可以通过查看所有分支的所有操作记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure><p>这样就能找到之前的commitID，再次重置即可。</p><ol start="4"><li>分支</li></ol><p>分支就像我们树上的一个树枝一样，它们可能一开始的时候是同一根树枝，但是长着长着就开始分道扬镳了，这就是分支。我们的代码也是这样，可能一开始写基础功能的时候使用的是单个分支，但是某一天我们希望基于这些基础的功能，把我们的项目做成两个不同方向的项目，比如一个方向做Web网站，另一个方向做游戏服务端。</p><p>因此，我们可以在一个主干上分出N个分支，分别对多个分支的代码进行维护。</p><ul><li>创建分支</li></ul><p>我们可以通过以下命令来查看当前仓库中存在的分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure><p>我们发现，默认情况下是有一个master分支的，并且我们使用的也是master分支，一般情况下master分支都是正式版本的更新，而其他分支一般是开发中才频繁更新的。我们接着来基于当前分支创建一个新的分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 对应的删除分支是</span></span><br><span class="line">git branch -d <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>现在我们修改一下文件，提交，再查看一下提交日志：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m <span class="string">&#x27;branch master commit&#x27;</span></span><br></pre></td></tr></table></figure><p>通过添加-a来自动将未放入暂存区的已修改文件放入暂存区并执行提交操作。查看日志，我们发现现在我们的提交只生效于master分支，而新创建的分支并没有发生修改。</p><p>我们将分支切换到另一个分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>我们会发现，文件变成了此分支创建的时的状态，也就是说，在不同分支下我们的文件内容是相互隔离的。</p><p>我们现在再来提交一次变更，会发现它只生效在test分支上。我们可以看看当前的分支状态：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> --all --graph</span><br></pre></td></tr></table></figure><ul><li>合并分支</li></ul><p>我们也可以将两个分支更新的内容最终合并到同一个分支上，我们先切换回主分支：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>接着使用分支合并命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>会得到如下提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Auto-merging hello.txt</span><br><span class="line">CONFLICT (content): Merge conflict in hello.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>在合并过程中产生了冲突，因为两个分支都对hello.txt文件进行了修改，那么现在要合并在一起，到底保留谁的hello文件呢？</p><p>我们可以查看一下是哪里发生了冲突：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff</span><br></pre></td></tr></table></figure><p>因此，现在我们将master分支的版本回退到修改hello.txt之前或是直接修改为最新版本的内容，这样就不会有冲突了，接着再执行一次合并操作，现在两个分支成功合并为同一个分支。</p><ul><li>变基分支</li></ul><p>除了直接合并分支以外，我们还可以进行变基操作，它跟合并不同，合并是分支回到主干的过程，而变基是直接修改分支开始的位置，比如我们希望将yyds变基到master上，那么yyds会将分支起点移动到master最后一次提交位置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase master</span><br></pre></td></tr></table></figure><p>变基后，yyds分支相当于同步了此前master分支的全部提交。</p><ul><li>优选</li></ul><p>我们还可以选择其将他分支上的提交作用于当前分支上，这种操作称为cherrypick：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git cherry-pick &lt;commit <span class="built_in">id</span>&gt;:单独合并一个提交</span><br></pre></td></tr></table></figure><p>这里我们在master分支上创建一个新的文件，提交此次更新，接着通过cherry-pick的方式将此次更新作用于test分支上。</p><h2 id="三、使用IDEA版本控制">三、使用IDEA版本控制</h2><p>虽然前面我们基本讲解了git的命令行使用方法，但是没有一个图形化界面，始终会感觉到很抽象，所以这里我们使用IDEA来演示，IDEA内部集成了git模块，它可以让我们的git版本管理图形化显示，当然除了IDEA也有一些独立的软件比如：SourceTree（挺好用）</p><p>打开IDEA后，找到版本控模块，我们直接点击创建本地仓库，它会自动将当前项目的根目录作为我们的本地仓库，而我们编写的所有代码和项目目录下其他的文件都可以进行版本控制。</p><p>我们发现所有项目中正在编写的类文件全部变红了，也就是处于未追踪状态，接着我们进行第一次初始化提交，提交之后我们可以在下方看到所有的本地仓库提交记录。</p><p>接着我们来整合一下Web环境，创建新的类之后，IDEA会提示我们是否将文件添加到Git，也就是是否放入暂存区并开启追踪，我们可以直接对比两次代码的相同和不同之处。</p><p>接着我们来演示一下分支创建和分支管理。</p><h2 id="四、远程仓库">四、远程仓库</h2><p>远程仓库实际上就是位于服务器上的仓库，它能在远端保存我们的版本历史，并且可以实现多人同时合作编写项目，每个人都能够同步他人的版本，能够看到他人的版本提交，相当于将我们的代码放在服务器上进行托管。</p><p>远程仓库有公有和私有的，公有的远程仓库有GitHub、码云、Coding等，他们都是对外开放的，我们注册账号之后就可以使用远程仓库进行版本控制，其中最大的就是GitHub，但是它服务器在国外，我们国内连接可能会有一点卡。私有的一般是GitLab这种自主搭建的远程仓库私服，在公司中比较常用，它只对公司内部开放，不对外开放。</p><p>这里我们以GitHub做讲解，官网：<a href="https://github.com">https://github.com</a>，首先完成用户注册。</p><p>接下来在 GitHub 中创建一个项目远程仓库(New Repository)，依次填写仓库名称、仓库介绍以及私有/公有仓库，创建后便可以得到远程仓库的地址(Https)。</p><h3 id="（一）远程账户认证和推送">（一）远程账户认证和推送</h3><p>创建仓库后，我们可以通过推送来将本地仓库中的内容推送到远程仓库。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add 名称 远程仓库地址</span><br><span class="line">git push 远程仓库名称 本地分支名称[:远端分支名称]</span><br></pre></td></tr></table></figure><p>注意<code>push</code>后面两个参数，一个是远端名称，还有一个就是本地分支名称，但是如果本地分支名称和远端分支名称一致，那么不用指定远端分支名称，但是如果我们希望推送的分支在远端没有同名的，那么需要额外指定。推送前需要登陆账户，GitHub现在不允许使用用户名密码验证，只允许使用个人AccessToken来验证身份，所以我们需要先去生成一个Token才可以。</p><p>注：创建Token时，勾选 repo、gist、user 选项。在终端中push时，账号为GitHub账号名称，密码为Token值。</p><p>推送后，我们发现远程仓库中的内容已经与我们本地仓库中的内容保持一致了，注意，远程仓库也可以有很多个分支。</p><hr><p>以下部分为SSH配置方式，目前GitHub已支持终端记住Token凭证，因此可忽略该方式。</p><p>但是这样比较麻烦，我们每次都需要去输入用户名和密码，有没有一劳永逸的方法呢？当然，我们也可以使用SSH来实现一次性校验，我们可以在本地生成一个rsa公钥：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/github.pub</span><br></pre></td></tr></table></figure><p>接着我们需要在GitHub上上传我们的公钥，当我们再次去访问GitHub时，会自动验证，就无需进行登录了，之后在Linux部分我们会详细讲解SSH的原理。</p><hr><p>接着我们修改一下工作区的内容，提交到本地仓库后，再推送到远程仓库，提交的过程中我们注意观察提交记录：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git commit -a -m <span class="string">&#x27;Modify files&#x27;</span></span><br><span class="line">git <span class="built_in">log</span> --all --oneline --graph</span><br><span class="line">git push origin master </span><br><span class="line">git <span class="built_in">log</span> --all --oneline --graph</span><br></pre></td></tr></table></figure><p>我们可以将远端和本地的分支进行绑定，绑定后就不需要指定分支名称了：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git push --set-upstream origin master:master</span><br><span class="line">git push origin</span><br></pre></td></tr></table></figure><p>在一个本地仓库对应一个远程仓库的情况下，远程仓库基本上就是纯粹的代码托管了（云盘那种感觉，就纯粹是存你代码的）</p><h3 id="（二）克隆项目">（二）克隆项目</h3><p>如果我们已经存在一个远程仓库的情况下，我们需要在远程仓库的代码上继续编写代码，这个时候怎么办呢？</p><p>我们可以使用克隆操作来将远端仓库的内容全部复制到本地：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 远程仓库地址</span><br></pre></td></tr></table></figure><p>这样本地就能够直接与远程保持同步。</p><h3 id="（三）抓取、拉取和冲突解决">（三）抓取、拉取和冲突解决</h3><p>我们接着来看，如果这个时候，出现多个本地仓库对应一个远程仓库的情况下，比如一个团队里面，N个人都在使用同一个远程仓库，但是他们各自只负责编写和推送自己业务部分的代码，也就是我们常说的协同工作，那么这个时候，我们就需要协调。</p><p>比如程序员A完成了他的模块，那么他就可以提交代码并推送到远程仓库，这时程序员B也要开始写代码了，由于远程仓库有其他程序员的提交记录，因此程序员B的本地仓库和远程仓库不一致，这时就需要有先进行pull操作，获取远程仓库中最新的提交：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch 远程仓库 <span class="comment">#抓取：只获取但不合并远端分支，后面需要我们手动合并才能提交</span></span><br><span class="line">git pull 远程仓库 <span class="comment">#拉取：获取+合并</span></span><br></pre></td></tr></table></figure><p>在程序员B拉取了最新的版本后，再编写自己的代码然后提交就可以实现多人合作编写项目了，并且在拉取过程中就能将别人提交的内容同步到本地，开发效率大大提升。</p><p>如果工作中存在不协调的地方，比如现在我们本地有两个仓库，一个仓库去修改hello.txt并直接提交，另一个仓库也修改hello.txt并直接提交，会得到如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">To https://github.com/xx/xxx.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to &#x27;https://github.com/xx/xxx.git&#x27;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &#x27;git pull ...&#x27;) before pushing again.</span><br><span class="line">hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br></pre></td></tr></table></figure><p>一旦一个本地仓库推送了代码，那么另一个本地仓库的推送会被拒绝，原因是当前文件已经被其他的推送给修改了，我们这边相当于是另一个版本，和之前两个分支合并一样，产生了冲突，因此我们只能去解决冲突问题。</p><p>如果远程仓库中的提交和本地仓库中的提交没有去编写同一个文件，那么就可以直接拉取：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull 远程仓库</span><br></pre></td></tr></table></figure><p>拉取后会自动进行合并，合并完成之后我们再提交即可。</p><p>但是如果两次提交都修改了同一个文件，那么就会遇到和多分支合并一样的情况，在合并时会产生冲突，这时就需要我们自己去解决冲突了。</p>]]></content>
    
    
    <summary type="html">Git是一种分布式版本控制系统，用于跟踪计算机文件的变化和协调多人在同一个项目上的协作。</summary>
    
    
    
    <category term="必备工具" scheme="https://www.angfff.top/categories/%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Git" scheme="https://www.angfff.top/categories/%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/Git/"/>
    
    
    <category term="必备工具" scheme="https://www.angfff.top/tags/%E5%BF%85%E5%A4%87%E5%B7%A5%E5%85%B7/"/>
    
    <category term="Git" scheme="https://www.angfff.top/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>个人博客搭建（一）</title>
    <link href="https://www.angfff.top/posts/ad52d94.html"/>
    <id>https://www.angfff.top/posts/ad52d94.html</id>
    <published>2023-07-18T12:30:44.000Z</published>
    <updated>2025-02-09T03:33:56.698Z</updated>
    
    <content type="html"><![CDATA[<h1>个人博客搭建（一）</h1><div class="note red icon-padding flat"><i class="note-icon fas fa-fan fa-spin"></i><p>本文是搭建个人博客系列的第一篇文章，主要包括本地环境搭建、远程仓库搭建两个部分。</p></div><h2 id="一、技术栈">一、技术栈</h2><ul><li>语言：HTML、CSS、JavaScript、MarkDown</li><li>框架：Hexo</li><li>主题：ButterFly</li><li>仓库：GitHub</li><li>第三方托管：Vercel</li><li>域名：阿里云</li></ul><h2 id="二、本地环境搭建">二、本地环境搭建</h2><h3 id="1-安装Node-js">1. 安装Node.js</h3><ul><li>下载地址：<a href="https://nodejs.org/zh-cn/download/">https://nodejs.org/zh-cn/download/</a></li><li>安装完成后，打开命令行，输入<code>node -v</code>和<code>npm -v</code>，查看是否安装成功</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">（一）本地环境及远程仓库搭建</summary>
    
    
    
    <category term="实战项目" scheme="https://www.angfff.top/categories/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="个人博客" scheme="https://www.angfff.top/categories/%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客搭建" scheme="https://www.angfff.top/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    
    <category term="Hexo" scheme="https://www.angfff.top/tags/Hexo/"/>
    
    <category term="ButterFly" scheme="https://www.angfff.top/tags/ButterFly/"/>
    
  </entry>
  
</feed>
